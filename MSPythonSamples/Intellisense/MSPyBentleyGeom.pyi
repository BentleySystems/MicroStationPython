from typing import Any, Optional, overload, Type, Sequence, Iterable, Union, Callable
from enum import Enum
import MSPyBentleyGeom

ANY_EDGE: int

class Angle:
    """
    None
    """

    def Acos(*args, **kwargs):
        """
        Acos(arg: float) -> float
        
        Return acos of arg, but cap arg at +- 1
        """
        ...
    
    def AdjustToSweep(*args, **kwargs):
        """
        AdjustToSweep(theta: float, thetaStart: float, sweep: float) -> float
        
        Shift{theta} so it is within one period of{thetaStart} in the
        direction of{sweep}. Return angle in radians
        """
        ...
    
    def ApplyGivensWeights(*args, **kwargs):
        """
        ApplyGivensWeights(a: float, b: float, cos: float, sin: float) -> tuple
        
        Parameter ``[out]``:
        aOut{(a,b) DOT (cos,sin)}
        
        Parameter ``[out]``:
        bOut{(cross,sin) DOT (a,b)}
        
        Parameter ``[in]``:
        a x coordiante
        
        Parameter ``[in]``:
        b y coordinate
        
        Parameter ``[in]``:
        cos cosine term of Givens rotation.
        
        Parameter ``[in]``:
        sin sine term of Givens rotation.
        """
        ...
    
    def Asin(*args, **kwargs):
        """
        Asin(arg: float) -> float
        
        Return asin of arg, but cap arg at +- 1
        """
        ...
    
    def Atan2(*args, **kwargs):
        """
        Atan2(numerator: float, denominator: float) -> float
        
        Return the arctan of numerator/denominator, in full -PI to PI range.
        0,0 returns 0.
        """
        ...
    
    def CircleFractionToRadians(*args, **kwargs):
        """
        CircleFractionToRadians(fraction: float) -> float
        
        Convert radians to degrees
        """
        ...
    
    def ConstructGivensWeights(*args, **kwargs):
        """
        ConstructGivensWeights(a: float, b: float) -> tuple
        
        Construct cosine and sine of vector to (a,b). (Just normalize a and
        b.)
        
        Parameter ``[out]``:
        cosine
        
        Parameter ``[out]``:
        sine
        
        Parameter ``[in]``:
        a
        
        Parameter ``[in]``:
        b
        """
        ...
    
    def Cos(*args, **kwargs):
        """
        Cos(self: MSPyBentleyGeom.Angle) -> float
        
        return the cosine of the angle.
        """
        ...
    
    def Cyclic2dAxis(*args, **kwargs):
        """
        Cyclic2dAxis(i: int) -> int
        
        Returns:
        i adjusted to [0,1] with wraparound.
        """
        ...
    
    def Cyclic3dAxes(*args, **kwargs):
        """
        Cyclic3dAxes(i: int) -> tuple
        
        Parameter ``[out]``:
        i0 i adjusted to [0,1,2] with wraparound
        
        Parameter ``[out]``:
        i1 i+1 adjusted to [0,1,2] with wraparound
        
        Parameter ``[out]``:
        i2 i+2 adjusted to [0,1,2] with wraparound
        
        Parameter ``[in]``:
        i initial axis
        """
        ...
    
    def Cyclic3dAxis(*args, **kwargs):
        """
        Cyclic3dAxis(i: int) -> int
        
        Returns:
        i adjusted to [0,1,2] with wraparound.
        """
        ...
    
    def Degrees(*args, **kwargs):
        """
        Degrees(self: MSPyBentleyGeom.Angle) -> float
        
        Return the angle in degrees
        """
        ...
    
    def DegreesToRadians(*args, **kwargs):
        """
        DegreesToRadians(degrees: float) -> float
        
        Convert degrees to radians
        """
        ...
    
    def EvaluateTrigCombination(*args, **kwargs):
        """
        EvaluateTrigCombination(constCoff: float, cosCoff: float, sinCoff: float, theta: float) -> float
        
        Evaluate{f(theta) = constCoff + cosCoff * cos(theta) + sinCoff *
        sin(theta)}
        
        Parameter ``[in]``:
        constCoff constant coefficient
        
        Parameter ``[in]``:
        cosCoff cosine coefficient
        
        Parameter ``[in]``:
        sinCoff sine coefficient
        
        Parameter ``[in]``:
        theta evaluation angle
        """
        ...
    
    def ForwardComplement(*args, **kwargs):
        """
        ForwardComplement(radians: float) -> float
        
        Angle which sweeps in the same direction to return to sum of 2pi
        Examples
        
        * ForwardComplement of{pi/2}{3pi/2}
        
        * ForwardComplement of{-pi/2}{-3pi/2}
        """
        ...
    
    def FromAtan2(*args, **kwargs):
        """
        FromAtan2(sine: float, cosine: float) -> MSPyBentleyGeom.Angle
        
        Strongly typed " constructor " (static method)
        """
        ...
    
    def FromDegrees(*args, **kwargs):
        """
        FromDegrees(degrees: float) -> MSPyBentleyGeom.Angle
        
        Strongly typed " constructor " (static method)
        """
        ...
    
    def FromFullCircle(*args, **kwargs):
        """
        FromFullCircle() -> MSPyBentleyGeom.Angle
        
        Strongly typed " constructor " (static method) for full circle angle
        """
        ...
    
    def FromRadians(*args, **kwargs):
        """
        FromRadians(radians: float) -> MSPyBentleyGeom.Angle
        
        Strongly typed " constructor " (static method)
        """
        ...
    
    def HalfAngleFuctions(*args, **kwargs):
        """
        HalfAngleFuctions(rCos2A: float, rSin2A: float) -> tuple
        
        Given trig functions (cosine and sine) of some (double) angle 2A, find
        trig functions for the angle A.
        """
        ...
    
    def InExactSweep(*args, **kwargs):
        """
        InExactSweep(theta: float, thetaStart: float, sweep: float) -> bool
        
        Test if angle is in sweep with no tolerance or period shift
        """
        ...
    
    def InSweepAllowPeriodShift(*args, **kwargs):
        """
        InSweepAllowPeriodShift(theta: float, thetaStart: float, sweep: float) -> bool
        
        Test if theta or any shift by multiple of 2pi is in sweep.
        """
        ...
    
    def IsFullCircle(*args, **kwargs):
        """
        IsFullCircle(radians: float) -> bool
        
        Return true if{fabs(radians)} is within{Angle:SmallAngle} of 2PI.
        """
        ...
    
    def IsNearZero(*args, **kwargs):
        """
        IsNearZero(radians: float) -> bool
        
        Test if{radians} is{SmallAngle} or smaller.
        """
        ...
    
    def IsNearZeroAllowPeriodShift(*args, **kwargs):
        """
        IsNearZeroAllowPeriodShift(*args, **kwargs)
        Overloaded function.
        
        1. IsNearZeroAllowPeriodShift(radians: float) -> bool
        
        Test if{radians} is{SmallAngle} or smaller.
        
        2. IsNearZeroAllowPeriodShift(radians: float, radiansTol: float) -> bool
        
        Test if{radians} is{SmallAngle} or smaller.
        """
        ...
    
    def MediumAngle(*args, **kwargs):
        """
        MediumAngle() -> float
        
        Medium angle used in toleranced angle comparisons.
        """
        ...
    
    def NearlyEqual(*args, **kwargs):
        """
        NearlyEqual(radiansA: float, radiansB: float) -> bool
        
        Test if two angles are within{SmallAngle} (NOT allowing 2pi shift!!)
        """
        ...
    
    def NearlyEqualAllowPeriodShift(*args, **kwargs):
        """
        NearlyEqualAllowPeriodShift(radiansA: float, radiansB: float) -> bool
        
        Test if two angles are within{SmallAngle}, allowing 2pi shift.
        """
        ...
    
    def NormalizeToSweep(*args, **kwargs):
        """
        NormalizeToSweep(*args, **kwargs)
        Overloaded function.
        
        1. NormalizeToSweep(theta: float, thetaStart: float, sweep: float) -> float
        
        Shift{theta} so it is within one period of{thetaStart} in the
        direction of{sweep}. Return FRACTIONAL position.
        
        2. NormalizeToSweep(theta: float, thetaStart: float, sweep: float, extend0: bool, extend1: bool) -> float
        
        Shift{theta} so it is within one period of{thetaStart} in the
        direction of{sweep}. Return FRACTIONAL position.
        """
        ...
    
    def PeriodShift(*args, **kwargs):
        """
        PeriodShift(theta: float, periods: float) -> float
        
        Add a multiple of 2PI to theta...
        """
        ...
    
    def Pi(*args, **kwargs):
        """
        Pi() -> float
        
        constant{PI}
        """
        ...
    
    def PiOver2(*args, **kwargs):
        """
        PiOver2() -> float
        
        consant{PI/2}
        """
        ...
    
    def Radians(*args, **kwargs):
        """
        Radians(self: MSPyBentleyGeom.Angle) -> float
        
        Return the angle in radians
        """
        ...
    
    def RadiansToDegrees(*args, **kwargs):
        """
        RadiansToDegrees(radians: float) -> float
        
        Convert radians to degrees
        """
        ...
    
    def ReverseComplement(*args, **kwargs):
        """
        ReverseComplement(radians: float) -> float
        
        Angle which sweeps in the other direction to the same end angle
        (modulo 2pi) as the given sweep.
        """
        ...
    
    def Rotate90UntilSmallAngle(*args, **kwargs):
        """
        Rotate90UntilSmallAngle(x0: float, y0: float) -> tuple
        
        Find a vector that differs from (x0,y0) by a multiple of 90 degrees,
        x1 is positive, and y1 is as small as possible in absolute value, i.e.
        points to the right.
        """
        ...
    
    def Sin(*args, **kwargs):
        """
        Sin(self: MSPyBentleyGeom.Angle) -> float
        
        return the sine of the angle.
        """
        ...
    
    def SmallAngle(*args, **kwargs):
        """
        SmallAngle() -> float
        
        Small angle used in toleranced angle comparisons.
        """
        ...
    
    def TinyAngle(*args, **kwargs):
        """
        TinyAngle() -> float
        
        About 10 times unit roundoff . . .
        """
        ...
    
    def TrigCombinationRange(*args, **kwargs):
        """
        TrigCombinationRange(constCoff: float, cosCoff: float, sinCoff: float) -> tuple
        
        Find the min and max values of{f(theta) = constCoff + cosCoff *
        cos(theta) + sinCoff * sin(theta)} in [-pi,pi]
        
        Parameter ``[in]``:
        constCoff constant coefficient
        
        Parameter ``[in]``:
        cosCoff cosine coefficient
        
        Parameter ``[in]``:
        sinCoff sine coefficient
        
        Parameter ``[in]``:
        thetaMin angle where min occurs
        
        Parameter ``[in]``:
        fMin minimum value
        
        Parameter ``[in]``:
        thetaMax angle where max occurs
        
        Parameter ``[in]``:
        fMax maximum value
        """
        ...
    
    def TrigCombinationRangeInSweep(*args, **kwargs):
        """
        TrigCombinationRangeInSweep(constCoff: float, cosCoff: float, sinCoff: float, thetaA: float, sweep: float) -> Tuple[float, float, float, float]
        
        Find the min and max values of{f(theta) = constCoff + cosCoff *
        cos(theta) + sinCoff * sin(theta)} in [thetaA, thetaB].
        
        Parameter ``[in]``:
        constCoff constant coefficient
        
        Parameter ``[in]``:
        cosCoff cosine coefficient
        
        Parameter ``[in]``:
        sinCoff sine coefficient
        
        Parameter ``[in]``:
        thetaA angle range limit
        
        Parameter ``[in]``:
        sweep sweep angle
        
        Parameter ``[in]``:
        thetaMin angle where min occurs
        
        Parameter ``[in]``:
        fMin minimum value
        
        Parameter ``[in]``:
        thetaMax angle where max occurs
        
        Parameter ``[in]``:
        fMax maximum value
        """
        ...
    
    def TrigIntegrals(*args, **kwargs):
        """
        TrigIntegrals(theta0: float, theta1: float, integrals: Bentley.RotMatrix) -> None
        
        Return integrals of [cc cs c; cs ss s; c s 1] from theta0 to theta1
        
        Parameter ``[in]``:
        theta0 beginning of integration interval
        
        Parameter ``[in]``:
        theta1 end of integration interval
        
        Parameter ``[out]``:
        integrals symmetric matrix of integrals.
        """
        ...
    
    def TwoPi(*args, **kwargs):
        """
        TwoPi() -> float
        
        constant{2*PI}
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.Angle) -> None
        
        2. __init__(self: MSPyBentleyGeom.Angle, arg0: MSPyBentleyGeom.Angle) -> None
        """
        ...
    
class AngleInDegrees:
    """
    None
    """

    def AlmostEqual(*args, **kwargs):
        """
        AlmostEqual(self: MSPyBentleyGeom.AngleInDegrees, other: MSPyBentleyGeom.AngleInDegrees) -> bool
        
        approximate equality test
        """
        ...
    
    def Cos(*args, **kwargs):
        """
        Cos(self: MSPyBentleyGeom.AngleInDegrees) -> float
        
        Return the cosine of the angle
        """
        ...
    
    def Degrees(*args, **kwargs):
        """
        Degrees(self: MSPyBentleyGeom.AngleInDegrees) -> float
        
        Return the angle in degrees as simple double
        """
        ...
    
    def FromAtan2(*args, **kwargs):
        """
        FromAtan2(y: float, x: float) -> MSPyBentleyGeom.AngleInDegrees
        
        Construct from xy vector components (with y first as usual for atan2)
        """
        ...
    
    def FromDegrees(*args, **kwargs):
        """
        FromDegrees(degrees: float) -> MSPyBentleyGeom.AngleInDegrees
        
        Construct angle in degrees from input in degrees.
        """
        ...
    
    def FromRadians(*args, **kwargs):
        """
        FromRadians(radians: float) -> MSPyBentleyGeom.AngleInDegrees
        
        Construct angle in degrees from input in radians
        """
        ...
    
    def Radians(*args, **kwargs):
        """
        Radians(self: MSPyBentleyGeom.AngleInDegrees) -> float
        
        Return the angle in radians as a simple double.
        """
        ...
    
    def Sin(*args, **kwargs):
        """
        Sin(self: MSPyBentleyGeom.AngleInDegrees) -> float
        
        Return the sine of the angle
        """
        ...
    
    def SmallAngleInDegrees(*args, **kwargs):
        """
        SmallAngleInDegrees() -> MSPyBentleyGeom.AngleInDegrees
        
        The degrees form of the system small angle (for radians,
        Angle.SmallAngle ())
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.AngleInDegrees) -> None
        
        2. __init__(self: MSPyBentleyGeom.AngleInDegrees, arg0: MSPyBentleyGeom.AngleInDegrees) -> None
        
        3. __init__(self: MSPyBentleyGeom.AngleInDegrees, arg0: MSPyBentleyGeom.Angle) -> None
        """
        ...
    
class AnnounceDoubleDPoint2d:
    """
    None
    """

    def Announce(*args, **kwargs):
        """
        Announce(self: MSPyBentleyGeom.AnnounceDoubleDPoint2d, fraction: float, xy: Bentley.DVec2d) -> None
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    
class AreaSelect:
    """
    Members:
    
    eAreaSelect_Parity
    
    eAreaSelect_CCWPositiveWindingNumber
    
    eAreaSelect_CCWNonzeroWindingNumber
    
    eAreaSelect_CCWNegativeWindingNumber
    """

    def __init__(self: MSPyBentleyGeom.AreaSelect, value: int) -> None:
        ...
    
    eAreaSelect_CCWNegativeWindingNumber: AreaSelect
    
    eAreaSelect_CCWNonzeroWindingNumber: AreaSelect
    
    eAreaSelect_CCWPositiveWindingNumber: AreaSelect
    
    eAreaSelect_Parity: AreaSelect
    
    @property
    def name(self: handle) -> str:
        ...
    
    @property
    def value(arg0: MSPyBentleyGeom.AreaSelect) -> int:
        ...
    
class BCurveSegment:
    """
    None
    """

    def AddExtrema(*args, **kwargs):
        """
        AddExtrema(self: MSPyBentleyGeom.BCurveSegment, params: MSPyBentley.DoubleArray, range: Bentley.DRange3d = None, mapToKnots: bool = False, firstDimension: int = 0, lastDimension: int = 2, includeStartEnd: bool = True) -> None
        
        Find minmax params (in some or all dimensions)
        
        Parameter ``[in,out]``:
        params receiver vector.
        
        Parameter ``[out]``:
        range (optional) range observed at (a) points in the params and
        (b) endpoints.
        
        Parameter ``[in]``:
        mapToKnots if true convert bezier params to knots.
        
        Parameter ``[in]``:
        firstDimension first dimension (0,1,2) to examine.
        
        Parameter ``[in]``:
        lastDimension last dimension (0,1,2) to examine.
        
        Parameter ``[in]``:
        includeStartEnd true to force params 0 and 1 into the results.
        """
        ...
    
    def AddStrokes(*args, **kwargs):
        """
        AddStrokes(self: MSPyBentleyGeom.BCurveSegment, points: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >, derivatives: Bentley.Bstdcxx.bvector<Bentley.DVec3d,Bentley.BentleyAllocator<Bentley.DVec3d> >, params: MSPyBentley.DoubleArray, options: Bentley.IFacetOptions, fractionA: float = 0.0, fractionB: float = 1.0, useWorkPoles: bool = False, curve: Bentley.MSBsplineCurve = None) -> None
        
        Add strokes to point and param arrays.
        
        Parameter ``[in,out]``:
        points receives points.
        
        Parameter ``[in,out]``:
        params receives parameters.
        
        Parameter ``[in,out]``:
        derivatives receives derivatives
        
        Parameter ``[in]``:
        options stroke controls
        
        Parameter ``[in]``:
        fractionA start fraction
        
        Parameter ``[in]``:
        fractionB end fraction
        
        Parameter ``[in]``:
        useWorkPoles true to stroke from work poles, false for primaries.
        
        Parameter ``[in]``:
        curve curve pointer (for use in parameter mapping, if indicated by
        facet options)
        """
        ...
    
    def BuildWorkPoles(*args, **kwargs):
        """
        BuildWorkPoles(self: MSPyBentleyGeom.BCurveSegment, transform: Bentley.Transform) -> None
        
        Transform primary poles into work poles.
        """
        ...
    
    def CopyFrom(*args, **kwargs):
        """
        CopyFrom(*args, **kwargs)
        Overloaded function.
        
        1. CopyFrom(self: MSPyBentleyGeom.BCurveSegment, source: MSPyBentleyGeom.BCurveSegment, matrix: Bentley.DMatrix4d = None) -> None
        
        Copy from{source} and apply a 4d (perspective) matrix.
        
        2. CopyFrom(self: MSPyBentleyGeom.BCurveSegment, source: MSPyBentleyGeom.BCurveSegment, matrix: Bentley.RotMatrix) -> None
        
        Copy from{source} and apply a 4d (perspective) matrix.
        
        3. CopyFrom(self: MSPyBentleyGeom.BCurveSegment, source: MSPyBentleyGeom.BCurveSegment, matrix: Bentley.Transform) -> None
        
        Copy from{source} and apply a 4d (perspective) matrix.
        """
        ...
    
    def FractionToKnot(*args, **kwargs):
        """
        FractionToKnot(self: MSPyBentleyGeom.BCurveSegment, f: float) -> float
        
        Return the knot value at a fractional parameter
        """
        ...
    
    def FractionToPoint(*args, **kwargs):
        """
        FractionToPoint(*args, **kwargs)
        Overloaded function.
        
        1. FractionToPoint(self: MSPyBentleyGeom.BCurveSegment, xyz: Bentley.DPoint3d, f: float) -> None
        
        Evalute the point at given fraction
        
        2. FractionToPoint(self: MSPyBentleyGeom.BCurveSegment, f: float) -> Bentley.DPoint3d
        
        Evalute the point at given fraction
        
        3. FractionToPoint(self: MSPyBentleyGeom.BCurveSegment, xyz: Bentley.DPoint3d, tangent: Bentley.DVec3d, f: float, applyKnotScale: bool = True) -> None
        
        Evalute the point at given fraction
        """
        ...
    
    def GetKnotP(*args, **kwargs):
        """
        GetKnotP(*args, **kwargs)
        Overloaded function.
        
        1. GetKnotP(self: MSPyBentleyGeom.BCurveSegment, index: int) -> float
        
        Get a pointer to an indexed knot.
        
        2. GetKnotP(self: MSPyBentleyGeom.BCurveSegment) -> float
        
        Get a pointer to an indexed knot.
        """
        ...
    
    def GetNumKnots(*args, **kwargs):
        """
        GetNumKnots(self: MSPyBentleyGeom.BCurveSegment) -> int
        
        Return knot count
        """
        ...
    
    def GetOrder(*args, **kwargs):
        """
        GetOrder(self: MSPyBentleyGeom.BCurveSegment) -> int
        
        Return pole count.
        """
        ...
    
    def GetPoleP(*args, **kwargs):
        """
        GetPoleP(*args, **kwargs)
        Overloaded function.
        
        1. GetPoleP(self: MSPyBentleyGeom.BCurveSegment, index: int) -> Bentley.DPoint4d
        
        Return (interior) pointer to indexed pole.
        
        2. GetPoleP(self: MSPyBentleyGeom.BCurveSegment) -> Bentley.DPoint4d
        
        Return (interior) pointer to indexed pole.
        """
        ...
    
    def GetWorkPoleP(*args, **kwargs):
        """
        GetWorkPoleP(self: MSPyBentleyGeom.BCurveSegment, index: int) -> Bentley.DPoint4d
        
        Return a work pole by index.
        """
        ...
    
    def Index(*args, **kwargs):
        """
        Index(self: MSPyBentleyGeom.BCurveSegment) -> int
        
        Index (from start) in parent bspline
        """
        ...
    
    def IsNullU(*args, **kwargs):
        """
        IsNullU(self: MSPyBentleyGeom.BCurveSegment) -> bool
        
        return true if the bezier (just extracted from bspline) has zero-
        length knot interval.
        """
        ...
    
    def IsRational(*args, **kwargs):
        """
        IsRational(self: MSPyBentleyGeom.BCurveSegment, useWorkPoles: bool = False) -> bool
        
        Query if the bezier has weighted control points. Optionally inspect
        the work poles rather than the primaries.
        """
        ...
    
    def KnotRange(*args, **kwargs):
        """
        KnotRange(self: MSPyBentleyGeom.BCurveSegment) -> Bentley.DRange1d
        
        Return uMin,uMax packaged as DRange1d....
        """
        ...
    
    def Length(*args, **kwargs):
        """
        Length(*args, **kwargs)
        Overloaded function.
        
        1. Length(self: MSPyBentleyGeom.BCurveSegment, fraction0: float, fraction1: float) -> float
        
        Compute length between fractions
        
        2. Length(self: MSPyBentleyGeom.BCurveSegment, worldToLocal: Bentley.RotMatrix, fraction0: float, fraction1: float) -> float
        
        Compute length between fractions
        """
        ...
    
    def Multiply(*args, **kwargs):
        """
        Multiply(self: MSPyBentleyGeom.BCurveSegment, transform: Bentley.Transform) -> None
        
        Transform primary poles
        """
        ...
    
    @property
    def NumKnots(arg0: MSPyBentleyGeom.BCurveSegment) -> int:
        ...
    
    @property
    def Order(arg0: MSPyBentleyGeom.BCurveSegment) -> int:
        ...
    
    def PolygonLength(*args, **kwargs):
        """
        PolygonLength(self: MSPyBentleyGeom.BCurveSegment) -> float
        
        Compute polygon length
        """
        ...
    
    def RefineCloseApproach(*args, **kwargs):
        """
        RefineCloseApproach(curveA: MSPyBentleyGeom.BCurveSegment, fractionAin: float, curveB: MSPyBentleyGeom.BCurveSegment, fractionBin: float, useWorkPoles: bool, xyOnly: bool) -> tuple
        
        Run newton iteration to move frctions to closest approach points.
        return true if iteration succeeeded.
        
        Parameter ``[in]``:
        curveA first curve
        
        Parameter ``[in]``:
        fractionAin initial fraction on curveA
        
        Parameter ``[in]``:
        curveB second curve
        
        Parameter ``[in]``:
        fractionBin initial fraction on curveB
        
        Parameter ``[in]``:
        useWorkPoles true to iterate with the work poles, false for
        primaries
        
        Parameter ``[in]``:
        xyOnly true to iterate on xy parts, false for xyz
        
        Parameter ``[out]``:
        fractionAOut fraction on curveA
        
        Parameter ``[out]``:
        xyzAOut point on curveA
        
        Parameter ``[out]``:
        fractionBOut fraction on curveB
        
        Parameter ``[out]``:
        xyzBOut point on curveB
        """
        ...
    
    def SaturateKnots(*args, **kwargs):
        """
        SaturateKnots(self: MSPyBentleyGeom.BCurveSegment) -> None
        
        On input, knots are arbitrary sorted sequence, with{order-1} leading
        knots. On output, knots are collapsed to bezier.
        """
        ...
    
    def SetUMax(*args, **kwargs):
        """
        SetUMax(self: MSPyBentleyGeom.BCurveSegment, u: float) -> None
        
        Set upper knot in parent bspline
        """
        ...
    
    def SetUMin(*args, **kwargs):
        """
        SetUMin(self: MSPyBentleyGeom.BCurveSegment, u: float) -> None
        
        Set lower knot in parent bspline
        """
        ...
    
    def SubdivideToIntersection(*args, **kwargs):
        """
        SubdivideToIntersection(self: MSPyBentleyGeom.BCurveSegment, interval: Bentley.DRange1d) -> bool
        
        Find the intersection of the segment UMin, UMax and the given
        interval. If empty, return false. If not empty,
        """
        ...
    
    def TryGetPoleXYZ(*args, **kwargs):
        """
        TryGetPoleXYZ(self: MSPyBentleyGeom.BCurveSegment, index: int, xyz: Bentley.DPoint3d) -> bool
        
        derference a pole, and drop to xyz.
        """
        ...
    
    def UMax(*args, **kwargs):
        """
        UMax(self: MSPyBentleyGeom.BCurveSegment) -> float
        
        Upper knot in parent bspline
        """
        ...
    
    def UMin(*args, **kwargs):
        """
        UMin(self: MSPyBentleyGeom.BCurveSegment) -> float
        
        Lower knot in parent bspline
        """
        ...
    
    def WireCentroid(*args, **kwargs):
        """
        WireCentroid(self: MSPyBentleyGeom.BCurveSegment, centroid: Bentley.DPoint3d, fraction0: float, fraction1: float) -> float
        
        Compute length and centroid of curve as wire.
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.BCurveSegment) -> None:
        ...
    
BSCURVE_CIRCLE: int

BSCURVE_CIRCULAR_ARC: int

BSCURVE_ELLIPSE: int

BSCURVE_ELLIPTICAL_ARC: int

BSCURVE_GENERAL: int

BSCURVE_HYPERBOLIC_ARC: int

BSCURVE_LINE: int

BSCURVE_PARABOLIC_ARC: int

class BSIIncrementalVectorIntegrand:
    """
    None
    """

    def AnnounceIntermediateIntegral(*args, **kwargs):
        """
        AnnounceIntermediateIntegral(self: MSPyBentleyGeom.BSIIncrementalVectorIntegrand, t: float, pIntegrals: MSPyBentley.DoubleArray) -> bool
        """
        ...
    
    def EvaluateVectorIntegrand(*args, **kwargs):
        """
        EvaluateVectorIntegrand(self: MSPyBentleyGeom.BSIVectorIntegrand, t: float, pF: MSPyBentley.DoubleArray) -> None
        """
        ...
    
    def VectorIntegrandCount(*args, **kwargs):
        """
        VectorIntegrandCount(self: MSPyBentleyGeom.BSIVectorIntegrand) -> int
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.BSIIncrementalVectorIntegrand) -> None:
        ...
    
class BSIQuadraturePoints:
    """
    None
    """

    def AccumulateWeightedSums(*args, **kwargs):
        """
        AccumulateWeightedSums(self: MSPyBentleyGeom.BSIQuadraturePoints, function: MSPyBentleyGeom.BSIVectorIntegrand, t0: float, t1: float, pSums: MSPyBentley.DoubleArray, numInterval: int) -> None
        
        @description Evaluate and accumulate function values over an interval.
        
        Parameter ``[in]``:
        function function object that can be called as often as needed.
        
        Parameter ``[in]``:
        t0 start of interval.
        
        Parameter ``[in]``:
        t1 end of interval.
        
        Parameter ``[in,out]``:
        pSums accumulating sums.
        
        Parameter ``[in]``:
        numInterval number of intervals to use within t0..t1.
        """
        ...
    
    @property
    def ConvergencePower(arg0: MSPyBentleyGeom.BSIQuadraturePoints) -> float:
        ...
    
    def GetConvergencePower(*args, **kwargs):
        """
        GetConvergencePower(self: MSPyBentleyGeom.BSIQuadraturePoints) -> float
        
        @description Return the exponent for the convergence rate of the rule.
        """
        ...
    
    def GetEval(*args, **kwargs):
        """
        GetEval(self: MSPyBentleyGeom.BSIQuadraturePoints, i: int, a0: float, a1: float) -> tuple
        
        @description Get the coordinate a weight of the i'th quadrature point,
        mapped to interval a0..a1
        
        Parameter ``[in]``:
        i index of evaluation point.
        
        Parameter ``[in]``:
        a0 start of mapped interval.
        
        Parameter ``[in]``:
        a1 end of mapped interval.
        
        Parameter ``[out]``:
        a evaluation coordinate.
        
        Parameter ``[out]``:
        w weight. Both the local quadrature weight and the interval length
        are incorporated in the returned weight.
        
        Returns:
        false if index is out of range.
        """
        ...
    
    def GetNumEval(*args, **kwargs):
        """
        GetNumEval(self: MSPyBentleyGeom.BSIQuadraturePoints) -> int
        
        @description Return the number of points in the quadrature rule.
        """
        ...
    
    def GetXYEval(*args, **kwargs):
        """
        GetXYEval(xRule: MSPyBentleyGeom.BSIQuadraturePoints, ix: int, x0: float, x1: float, yRule: MSPyBentleyGeom.BSIQuadraturePoints, iy: int, y0: float, y1: float) -> tuple
        
        Get the coordinates and weight of quarature point (i,j) in a 2D
        rectangular domain with specified quadrature for each direction.
        
        Parameter ``[in]``:
        xRule x direction quadrature rule
        
        Parameter ``[in]``:
        ix point index in x rule.
        
        Parameter ``[in]``:
        x0 started of x mapped interval
        
        Parameter ``[in]``:
        x1 end of x mapped interval
        
        Parameter ``[in]``:
        yRule y direction quadrature rule.
        
        Parameter ``[in]``:
        iy point index in y rule.
        
        Parameter ``[in]``:
        y0 start of y mapped interval
        
        Parameter ``[in]``:
        y1 end of y mapped interval
        
        Parameter ``[out]``:
        x x coordinate to evaluate.
        
        Parameter ``[out]``:
        y y coordinate to evaluate.
        
        Parameter ``[out]``:
        w weight for sums
        """
        ...
    
    def InitGauss(*args, **kwargs):
        """
        InitGauss(self: MSPyBentleyGeom.BSIQuadraturePoints, numEval: int) -> int
        
        @description Setup for a " Gaussian " quadrature.
        
        Parameter ``[in]``:
        numEval requested number of points.
        
        Returns:
        Number of points actually to be used. max is 5
        """
        ...
    
    def InitGaussKronrod(*args, **kwargs):
        """
        InitGaussKronrod(self: MSPyBentleyGeom.BSIQuadraturePoints, numEval: int, gaussPartner: MSPyBentleyGeom.BSIQuadraturePoints) -> int
        
        @description Setup for a " Kronrod " part of Gauss-Kronrad quadrature.
        The simple Gauss x values appear (in order) at the odd positions of
        the Kronrod rule.
        
        Parameter ``numEval``:
        IN requested number of points. ONLY 7 IS SUPPORTED
        
        Parameter ``gaussPartner``:
        IN corresponding simple Gauss rule.
        
        Returns:
        Number of points actually to be used.
        """
        ...
    
    def InitGaussLobatto(*args, **kwargs):
        """
        InitGaussLobatto(self: MSPyBentleyGeom.BSIQuadraturePoints, numEval: int) -> int
        
        @description Setup for " Gauss - Lobatto " quadrature. This uses endpoints
        plus gauss-like interior points.
        
        Parameter ``[in]``:
        numEval requested number of points.
        
        Remark:
        s numEval may be 3, 4, and 5.
        
        Remark:
        s numEval == 3 is the same as " Simpson "
        """
        ...
    
    def InitUniform(*args, **kwargs):
        """
        InitUniform(self: MSPyBentleyGeom.BSIQuadraturePoints, numEval: int) -> int
        
        @description Setup for a " Newton - Cotes " regularly spaced quadrature.
        
        Remark:
        Gaussian quadrature points are usually more effective. numEval ==
        1 is " rectangle rule " numEval == 2 is " trapezoid rule " numEval ==
        3 is " Simpson s rule "
        
        Parameter ``[in]``:
        numEval requested number of points.
        
        Returns:
        Number of points actually to be used. max is 4
        """
        ...
    
    def IntegrateWithRombergExtrapolation(*args, **kwargs):
        """
        IntegrateWithRombergExtrapolation(self: MSPyBentleyGeom.BSIQuadraturePoints, function: MSPyBentleyGeom.BSIIncrementalVectorIntegrand, t0: float, t1: float, numInterval: int) -> tuple
        
        @description Integrate over an interval.
        
        * In each interval, form gauss sums with one and then two
        subintervals.
        
        * Apply 1 step Romberg (Richardson) extrapolation.
        
        * Accept the extrapolation as that interval's contribution.
        
        * Accumulate the max extrapolation as error bound.
        
        * The ongoing integration at the end of each interval,
        
        * exit if the announcement function returns false
        
        * The caller is can capture sums as announced
        
        Parameter ``[in]``:
        function function object that can be called as often as needed.
        
        Parameter ``[in]``:
        t0 start of interval.
        
        Parameter ``[in]``:
        t1 end of interval.
        
        Parameter ``[in]``:
        numInterval number of intervals to use within t0..t1.
        
        Parameter ``[out]``:
        totalErrorBound
        
        Returns:
        false if function.AnnounceIntermediateIntergral () returned false.
        Bentley Systems +---------------+---------------+---------------+-
        --------------+------
        """
        ...
    
    @property
    def NumEval(arg0: MSPyBentleyGeom.BSIQuadraturePoints) -> int:
        ...
    
    def __init__(self: MSPyBentleyGeom.BSIQuadraturePoints) -> None:
        ...
    
class BSITriangleQuadraturePoints:
    """
    None
    """

    def AccumulateWeightedSums(*args, **kwargs):
        """
        AccumulateWeightedSums(self: MSPyBentleyGeom.BSITriangleQuadraturePoints, arg0: MSPyBentleyGeom.BSIVectorIntegrandXY, arg1: MSPyBentley.DoubleArray) -> None
        """
        ...
    
    def AccumulateWeightedSumsMapped(*args, **kwargs):
        """
        AccumulateWeightedSumsMapped(self: MSPyBentleyGeom.BSITriangleQuadraturePoints, arg0: MSPyBentleyGeom.BSIVectorIntegrandXY, arg1: MSPyBentley.DoubleArray, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float) -> None
        """
        ...
    
    def GetEval(*args, **kwargs):
        """
        GetEval(self: MSPyBentleyGeom.BSITriangleQuadraturePoints, i: int) -> tuple
        
        @description Get the coordinates and weight of the i'th quadrature
        point
        
        Parameter ``[in]``:
        i index of evaluation point.
        
        Parameter ``[out]``:
        u evaluation coordinate.
        
        Parameter ``[out]``:
        v evaluation coordinate.
        
        Parameter ``[out]``:
        w weight.
        
        Returns:
        false if index is out of range.
        """
        ...
    
    def GetNumEval(*args, **kwargs):
        """
        GetNumEval(self: MSPyBentleyGeom.BSITriangleQuadraturePoints) -> int
        
        @description Return the number of points in the quadrature rule.
        """
        ...
    
    def InitStrang(*args, **kwargs):
        """
        InitStrang(self: MSPyBentleyGeom.BSITriangleQuadraturePoints, selector: int) -> int
        
        @description Setup for a " Strang " rule as defined in http://people.sc.
        fsu.edu/~jburkardt/datasets/quadrature_rules_tri/quadrature_rules_tri.
        html
        
        Parameter ``[in]``:
        selector rule selector.
        
        Remark:
        s; Selectors are:(1 --- centroid; exact degree 1) (2 --- 3
        midsides; exact degree 2) (3 --- centroid and one towards each
        vertex; exact degree 3) (4 --- 6 points, vertices and midsides of
        an inset triangle; exact degree 3) (5 --- 6 points, 2 inset from
        each edge; exact degree 4) (6 --- 7 points, centroid and 2 insets
        from each edge -- insets equally weighted; exact degree 4) (7 ---
        7 points, centroid, one towards each vertex, one towards each
        edge; exact degree 5) (8 --- 9 points; exact degree 6) (9 --- 12
        points; exact degree 6) (10 --- 13 points -- negative weight at
        centroid; exact degree 7)
        """
        ...
    
    @property
    def NumEval(arg0: MSPyBentleyGeom.BSITriangleQuadraturePoints) -> int:
        ...
    
    def __init__(self: MSPyBentleyGeom.BSITriangleQuadraturePoints) -> None:
        ...
    
class BSIVectorIntegrand:
    """
    None
    """

    def EvaluateVectorIntegrand(*args, **kwargs):
        """
        EvaluateVectorIntegrand(self: MSPyBentleyGeom.BSIVectorIntegrand, t: float, pF: MSPyBentley.DoubleArray) -> None
        """
        ...
    
    def VectorIntegrandCount(*args, **kwargs):
        """
        VectorIntegrandCount(self: MSPyBentleyGeom.BSIVectorIntegrand) -> int
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.BSIVectorIntegrand) -> None:
        ...
    
class BSIVectorIntegrandXY:
    """
    None
    """

    def EvaluateVectorIntegrand(*args, **kwargs):
        """
        EvaluateVectorIntegrand(self: MSPyBentleyGeom.BSIVectorIntegrandXY, x: float, y: float, pF: MSPyBentley.DoubleArray) -> None
        """
        ...
    
    def VectorIntegrandCount(*args, **kwargs):
        """
        VectorIntegrandCount(self: MSPyBentleyGeom.BSIVectorIntegrandXY) -> int
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.BSIVectorIntegrandXY) -> None:
        ...
    
BSSURF_CONE: int

BSSURF_GENERAL: int

BSSURF_PLANE: int

BSSURF_REVOLUTION: int

BSSURF_RIGHT_CYLINDER: int

BSSURF_RULED_SURFACE: int

BSSURF_SPHERE: int

BSSURF_TAB_CYLINDER: int

BSSURF_TORUS: int

BSSURF_U: int

BSSURF_V: int

class BlendDetail:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    
    @property
    def detailA(self: MSPyBentleyGeom.BlendDetail) -> MSPyBentleyGeom.CurveLocationDetail:
        ...
    @detailA.setter
    def detailA(self: MSPyBentleyGeom.BlendDetail, arg0: MSPyBentleyGeom.CurveLocationDetail) -> None:
        ...
    
    @property
    def detailB(self: MSPyBentleyGeom.BlendDetail) -> MSPyBentleyGeom.CurveLocationDetail:
        ...
    @detailB.setter
    def detailB(self: MSPyBentleyGeom.BlendDetail, arg0: MSPyBentleyGeom.CurveLocationDetail) -> None:
        ...
    
    @property
    def geometry(self: MSPyBentleyGeom.BlendDetail) -> Bentley.ICurvePrimitive:
        ...
    @geometry.setter
    def geometry(self: MSPyBentleyGeom.BlendDetail, arg0: Bentley.ICurvePrimitive) -> None:
        ...
    
class BlendDetailArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.BlendDetailArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.BlendDetailArray, arg0: MSPyBentleyGeom.BlendDetailArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.BlendDetailArray, arg0: Iterable) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.BlendDetailArray, x: MSPyBentleyGeom.BlendDetail) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.BlendDetailArray) -> None
        
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.BlendDetailArray, L: MSPyBentleyGeom.BlendDetailArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.BlendDetailArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.BlendDetailArray, i: int, x: MSPyBentleyGeom.BlendDetail) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.BlendDetailArray) -> MSPyBentleyGeom.BlendDetail
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.BlendDetailArray, i: int) -> MSPyBentleyGeom.BlendDetail
        
        Remove and return the item at index ``i``
        """
        ...
    
class BlendType:
    """
    Members:
    
    eCURVE_CURVE_BLEND_BisectorParabola
    
    eCURVE_CURVE_BLEND_VerticalAxisParabola
    """

    def __init__(self: MSPyBentleyGeom.BlendType, value: int) -> None:
        ...
    
    eCURVE_CURVE_BLEND_BisectorParabola: BlendType
    
    eCURVE_CURVE_BLEND_VerticalAxisParabola: BlendType
    
    @property
    def name(self: handle) -> str:
        ...
    
    @property
    def value(arg0: MSPyBentleyGeom.BlendType) -> int:
        ...
    
class BlockedVectorCurveTopologyId:
    """
    None
    """

    @property
    def Active(arg0: MSPyBentleyGeom.BlockedVectorCurveTopologyId) -> bool:
        ...
    @Active.setter
    def Active(arg0: MSPyBentleyGeom.BlockedVectorCurveTopologyId, arg1: bool) -> None:
        ...
    
    def Append(*args, **kwargs):
        """
        Append(*args, **kwargs)
        Overloaded function.
        
        1. Append(self: MSPyBentleyGeom.BlockedVectorCurveTopologyId, pBuffer: MSPyBentleyGeom.CurveTopologyId, count: int) -> int
        
        2. Append(self: MSPyBentleyGeom.BlockedVectorCurveTopologyId, source: MSPyBentleyGeom.BlockedVectorCurveTopologyId) -> int
        
        3. Append(self: MSPyBentleyGeom.BlockedVectorCurveTopologyId, source: MSPyBentleyGeom.CurveTopologyId) -> int
        """
        ...
    
    def AppendAndReturnIndex(*args, **kwargs):
        """
        AppendAndReturnIndex(self: MSPyBentleyGeom.BlockedVectorCurveTopologyId, source: MSPyBentleyGeom.CurveTopologyId) -> int
        """
        ...
    
    def ClearAndAppend(*args, **kwargs):
        """
        ClearAndAppend(self: MSPyBentleyGeom.BlockedVectorCurveTopologyId, source: MSPyBentleyGeom.CurveTopologyIdArray) -> None
        """
        ...
    
    def ClearAndAppendBlock(*args, **kwargs):
        """
        ClearAndAppendBlock(*args, **kwargs)
        Overloaded function.
        
        1. ClearAndAppendBlock(self: MSPyBentleyGeom.BlockedVectorCurveTopologyId, source: MSPyBentleyGeom.BlockedVectorCurveTopologyId, i0: int, numWrap: int, n: int) -> int
        
        2. ClearAndAppendBlock(self: MSPyBentleyGeom.BlockedVectorCurveTopologyId, source: MSPyBentleyGeom.CurveTopologyId, sourceSize: int, i0: int, numWrap: int, n: int) -> int
        """
        ...
    
    def CopyData(*args, **kwargs):
        """
        CopyData(self: MSPyBentleyGeom.BlockedVectorCurveTopologyId, fromIndex: int, toIndex: int) -> None
        """
        ...
    
    def CopyVectorFrom(*args, **kwargs):
        """
        CopyVectorFrom(self: MSPyBentleyGeom.BlockedVectorCurveTopologyId, source: MSPyBentleyGeom.CurveTopologyIdArray) -> None
        """
        ...
    
    def GetCP(*args, **kwargs):
        """
        GetCP(self: MSPyBentleyGeom.BlockedVectorCurveTopologyId) -> MSPyBentleyGeom.CurveTopologyId
        """
        ...
    
    def GetPtr(*args, **kwargs):
        """
        GetPtr(self: MSPyBentleyGeom.BlockedVectorCurveTopologyId) -> MSPyBentleyGeom.CurveTopologyId
        """
        ...
    
    @property
    def IndexFamily(arg0: MSPyBentleyGeom.BlockedVectorCurveTopologyId) -> int:
        ...
    
    @property
    def IndexedBy(arg0: MSPyBentleyGeom.BlockedVectorCurveTopologyId) -> int:
        ...
    
    def NumCompleteRows(*args, **kwargs):
        """
        NumCompleteRows(self: MSPyBentleyGeom.BlockedVectorCurveTopologyId) -> int
        """
        ...
    
    @property
    def NumPerStruct(arg0: MSPyBentleyGeom.BlockedVectorCurveTopologyId) -> int:
        ...
    
    def ReverseInRange(*args, **kwargs):
        """
        ReverseInRange(self: MSPyBentleyGeom.BlockedVectorCurveTopologyId, iFirst: int, iLast: int) -> None
        """
        ...
    
    def SetTags(*args, **kwargs):
        """
        SetTags(self: MSPyBentleyGeom.BlockedVectorCurveTopologyId, numPeStruct: int, structsPerRow: int, tag: int, IndexFamily: int, IndexedBy: int, active: bool) -> None
        """
        ...
    
    @property
    def StructsPerRow(arg0: MSPyBentleyGeom.BlockedVectorCurveTopologyId) -> int:
        ...
    @StructsPerRow.setter
    def StructsPerRow(arg0: MSPyBentleyGeom.BlockedVectorCurveTopologyId, arg1: int) -> None:
        ...
    
    @property
    def Tag(arg0: MSPyBentleyGeom.BlockedVectorCurveTopologyId) -> int:
        ...
    
    def Trim(*args, **kwargs):
        """
        Trim(self: MSPyBentleyGeom.BlockedVectorCurveTopologyId, index0: int, count: int) -> None
        """
        ...
    
    def TryGet(*args, **kwargs):
        """
        TryGet(self: MSPyBentleyGeom.BlockedVectorCurveTopologyId, index: int, defaultValue: MSPyBentleyGeom.CurveTopologyId) -> Tuple[bool, MSPyBentleyGeom.CurveTopologyId]
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.BlockedVectorCurveTopologyId) -> None
        
        2. __init__(self: MSPyBentleyGeom.BlockedVectorCurveTopologyId, numPerStruct: int, structsPerRow: int = 0, tag: int = 0, indexFamily: int = 0, indexBy: int = 0, active: bool = False) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.CurveTopologyIdArray, x: MSPyBentleyGeom.CurveTopologyId) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.CurveTopologyIdArray) -> None
        
        Clear the contents
        """
        ...
    
    def count(*args, **kwargs):
        """
        count(self: MSPyBentleyGeom.CurveTopologyIdArray, x: MSPyBentleyGeom.CurveTopologyId) -> int
        
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.CurveTopologyIdArray, L: MSPyBentleyGeom.CurveTopologyIdArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.CurveTopologyIdArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.CurveTopologyIdArray, i: int, x: MSPyBentleyGeom.CurveTopologyId) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.CurveTopologyIdArray) -> MSPyBentleyGeom.CurveTopologyId
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.CurveTopologyIdArray, i: int) -> MSPyBentleyGeom.CurveTopologyId
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(*args, **kwargs):
        """
        remove(self: MSPyBentleyGeom.CurveTopologyIdArray, x: MSPyBentleyGeom.CurveTopologyId) -> None
        
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class BlockedVectorDPoint2d:
    """
    None
    """

    @property
    def Active(arg0: MSPyBentleyGeom.BlockedVectorDPoint2d) -> bool:
        ...
    @Active.setter
    def Active(arg0: MSPyBentleyGeom.BlockedVectorDPoint2d, arg1: bool) -> None:
        ...
    
    def Append(*args, **kwargs):
        """
        Append(*args, **kwargs)
        Overloaded function.
        
        1. Append(self: MSPyBentleyGeom.BlockedVectorDPoint2d, pBuffer: MSPyBentleyGeom.DPoint2d, count: int) -> int
        
        2. Append(self: MSPyBentleyGeom.BlockedVectorDPoint2d, source: MSPyBentleyGeom.BlockedVectorDPoint2d) -> int
        
        3. Append(self: MSPyBentleyGeom.BlockedVectorDPoint2d, source: MSPyBentleyGeom.DPoint2d) -> int
        """
        ...
    
    def AppendAndReturnIndex(*args, **kwargs):
        """
        AppendAndReturnIndex(self: MSPyBentleyGeom.BlockedVectorDPoint2d, source: MSPyBentleyGeom.DPoint2d) -> int
        """
        ...
    
    def ClearAndAppend(*args, **kwargs):
        """
        ClearAndAppend(self: MSPyBentleyGeom.BlockedVectorDPoint2d, source: MSPyBentleyGeom.DPoint2dArray) -> None
        """
        ...
    
    def ClearAndAppendBlock(*args, **kwargs):
        """
        ClearAndAppendBlock(*args, **kwargs)
        Overloaded function.
        
        1. ClearAndAppendBlock(self: MSPyBentleyGeom.BlockedVectorDPoint2d, source: MSPyBentleyGeom.BlockedVectorDPoint2d, i0: int, numWrap: int, n: int) -> int
        
        2. ClearAndAppendBlock(self: MSPyBentleyGeom.BlockedVectorDPoint2d, source: MSPyBentleyGeom.DPoint2d, sourceSize: int, i0: int, numWrap: int, n: int) -> int
        """
        ...
    
    def CopyData(*args, **kwargs):
        """
        CopyData(self: MSPyBentleyGeom.BlockedVectorDPoint2d, fromIndex: int, toIndex: int) -> None
        """
        ...
    
    def CopyVectorFrom(*args, **kwargs):
        """
        CopyVectorFrom(self: MSPyBentleyGeom.BlockedVectorDPoint2d, source: MSPyBentleyGeom.DPoint2dArray) -> None
        """
        ...
    
    def GetCP(*args, **kwargs):
        """
        GetCP(self: MSPyBentleyGeom.BlockedVectorDPoint2d) -> MSPyBentleyGeom.DPoint2d
        """
        ...
    
    def GetPtr(*args, **kwargs):
        """
        GetPtr(self: MSPyBentleyGeom.BlockedVectorDPoint2d) -> MSPyBentleyGeom.DPoint2d
        """
        ...
    
    @property
    def IndexFamily(arg0: MSPyBentleyGeom.BlockedVectorDPoint2d) -> int:
        ...
    
    @property
    def IndexedBy(arg0: MSPyBentleyGeom.BlockedVectorDPoint2d) -> int:
        ...
    
    def NumCompleteRows(*args, **kwargs):
        """
        NumCompleteRows(self: MSPyBentleyGeom.BlockedVectorDPoint2d) -> int
        """
        ...
    
    @property
    def NumPerStruct(arg0: MSPyBentleyGeom.BlockedVectorDPoint2d) -> int:
        ...
    
    def ReverseInRange(*args, **kwargs):
        """
        ReverseInRange(self: MSPyBentleyGeom.BlockedVectorDPoint2d, iFirst: int, iLast: int) -> None
        """
        ...
    
    def SetTags(*args, **kwargs):
        """
        SetTags(self: MSPyBentleyGeom.BlockedVectorDPoint2d, numPeStruct: int, structsPerRow: int, tag: int, IndexFamily: int, IndexedBy: int, active: bool) -> None
        """
        ...
    
    @property
    def StructsPerRow(arg0: MSPyBentleyGeom.BlockedVectorDPoint2d) -> int:
        ...
    @StructsPerRow.setter
    def StructsPerRow(arg0: MSPyBentleyGeom.BlockedVectorDPoint2d, arg1: int) -> None:
        ...
    
    @property
    def Tag(arg0: MSPyBentleyGeom.BlockedVectorDPoint2d) -> int:
        ...
    
    def Trim(*args, **kwargs):
        """
        Trim(self: MSPyBentleyGeom.BlockedVectorDPoint2d, index0: int, count: int) -> None
        """
        ...
    
    def TryGet(*args, **kwargs):
        """
        TryGet(self: MSPyBentleyGeom.BlockedVectorDPoint2d, index: int, defaultValue: MSPyBentleyGeom.DPoint2d) -> Tuple[bool, MSPyBentleyGeom.DPoint2d]
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.BlockedVectorDPoint2d) -> None
        
        2. __init__(self: MSPyBentleyGeom.BlockedVectorDPoint2d, numPerStruct: int, structsPerRow: int = 0, tag: int = 0, indexFamily: int = 0, indexBy: int = 0, active: bool = False) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.DPoint2dArray, x: MSPyBentleyGeom.DPoint2d) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.DPoint2dArray) -> None
        
        Clear the contents
        """
        ...
    
    def count(*args, **kwargs):
        """
        count(self: MSPyBentleyGeom.DPoint2dArray, x: MSPyBentleyGeom.DPoint2d) -> int
        
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.DPoint2dArray, L: MSPyBentleyGeom.DPoint2dArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.DPoint2dArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.DPoint2dArray, i: int, x: MSPyBentleyGeom.DPoint2d) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.DPoint2dArray) -> MSPyBentleyGeom.DPoint2d
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.DPoint2dArray, i: int) -> MSPyBentleyGeom.DPoint2d
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(*args, **kwargs):
        """
        remove(self: MSPyBentleyGeom.DPoint2dArray, x: MSPyBentleyGeom.DPoint2d) -> None
        
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class BlockedVectorDPoint3d:
    """
    None
    """

    @property
    def Active(arg0: MSPyBentleyGeom.BlockedVectorDPoint3d) -> bool:
        ...
    @Active.setter
    def Active(arg0: MSPyBentleyGeom.BlockedVectorDPoint3d, arg1: bool) -> None:
        ...
    
    def Append(*args, **kwargs):
        """
        Append(*args, **kwargs)
        Overloaded function.
        
        1. Append(self: MSPyBentleyGeom.BlockedVectorDPoint3d, pBuffer: MSPyBentleyGeom.DPoint3d, count: int) -> int
        
        2. Append(self: MSPyBentleyGeom.BlockedVectorDPoint3d, source: MSPyBentleyGeom.BlockedVectorDPoint3d) -> int
        
        3. Append(self: MSPyBentleyGeom.BlockedVectorDPoint3d, source: MSPyBentleyGeom.DPoint3d) -> int
        """
        ...
    
    def AppendAndReturnIndex(*args, **kwargs):
        """
        AppendAndReturnIndex(self: MSPyBentleyGeom.BlockedVectorDPoint3d, source: MSPyBentleyGeom.DPoint3d) -> int
        """
        ...
    
    def ClearAndAppend(*args, **kwargs):
        """
        ClearAndAppend(self: MSPyBentleyGeom.BlockedVectorDPoint3d, source: MSPyBentleyGeom.DPoint3dArray) -> None
        """
        ...
    
    def ClearAndAppendBlock(*args, **kwargs):
        """
        ClearAndAppendBlock(*args, **kwargs)
        Overloaded function.
        
        1. ClearAndAppendBlock(self: MSPyBentleyGeom.BlockedVectorDPoint3d, source: MSPyBentleyGeom.BlockedVectorDPoint3d, i0: int, numWrap: int, n: int) -> int
        
        2. ClearAndAppendBlock(self: MSPyBentleyGeom.BlockedVectorDPoint3d, source: MSPyBentleyGeom.DPoint3d, sourceSize: int, i0: int, numWrap: int, n: int) -> int
        """
        ...
    
    def CopyData(*args, **kwargs):
        """
        CopyData(self: MSPyBentleyGeom.BlockedVectorDPoint3d, fromIndex: int, toIndex: int) -> None
        """
        ...
    
    def CopyVectorFrom(*args, **kwargs):
        """
        CopyVectorFrom(self: MSPyBentleyGeom.BlockedVectorDPoint3d, source: MSPyBentleyGeom.DPoint3dArray) -> None
        """
        ...
    
    def GetCP(*args, **kwargs):
        """
        GetCP(self: MSPyBentleyGeom.BlockedVectorDPoint3d) -> MSPyBentleyGeom.DPoint3d
        """
        ...
    
    def GetPtr(*args, **kwargs):
        """
        GetPtr(self: MSPyBentleyGeom.BlockedVectorDPoint3d) -> MSPyBentleyGeom.DPoint3d
        """
        ...
    
    @property
    def IndexFamily(arg0: MSPyBentleyGeom.BlockedVectorDPoint3d) -> int:
        ...
    
    @property
    def IndexedBy(arg0: MSPyBentleyGeom.BlockedVectorDPoint3d) -> int:
        ...
    
    def NumCompleteRows(*args, **kwargs):
        """
        NumCompleteRows(self: MSPyBentleyGeom.BlockedVectorDPoint3d) -> int
        """
        ...
    
    @property
    def NumPerStruct(arg0: MSPyBentleyGeom.BlockedVectorDPoint3d) -> int:
        ...
    
    def ReverseInRange(*args, **kwargs):
        """
        ReverseInRange(self: MSPyBentleyGeom.BlockedVectorDPoint3d, iFirst: int, iLast: int) -> None
        """
        ...
    
    def SetTags(*args, **kwargs):
        """
        SetTags(self: MSPyBentleyGeom.BlockedVectorDPoint3d, numPeStruct: int, structsPerRow: int, tag: int, IndexFamily: int, IndexedBy: int, active: bool) -> None
        """
        ...
    
    @property
    def StructsPerRow(arg0: MSPyBentleyGeom.BlockedVectorDPoint3d) -> int:
        ...
    @StructsPerRow.setter
    def StructsPerRow(arg0: MSPyBentleyGeom.BlockedVectorDPoint3d, arg1: int) -> None:
        ...
    
    @property
    def Tag(arg0: MSPyBentleyGeom.BlockedVectorDPoint3d) -> int:
        ...
    
    def Trim(*args, **kwargs):
        """
        Trim(self: MSPyBentleyGeom.BlockedVectorDPoint3d, index0: int, count: int) -> None
        """
        ...
    
    def TryGet(*args, **kwargs):
        """
        TryGet(self: MSPyBentleyGeom.BlockedVectorDPoint3d, index: int, defaultValue: MSPyBentleyGeom.DPoint3d) -> Tuple[bool, MSPyBentleyGeom.DPoint3d]
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.BlockedVectorDPoint3d) -> None
        
        2. __init__(self: MSPyBentleyGeom.BlockedVectorDPoint3d, numPerStruct: int, structsPerRow: int = 0, tag: int = 0, indexFamily: int = 0, indexBy: int = 0, active: bool = False) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.DPoint3dArray, x: MSPyBentleyGeom.DPoint3d) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.DPoint3dArray) -> None
        
        Clear the contents
        """
        ...
    
    def count(*args, **kwargs):
        """
        count(self: MSPyBentleyGeom.DPoint3dArray, x: MSPyBentleyGeom.DPoint3d) -> int
        
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.DPoint3dArray, L: MSPyBentleyGeom.DPoint3dArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.DPoint3dArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.DPoint3dArray, i: int, x: MSPyBentleyGeom.DPoint3d) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.DPoint3dArray) -> MSPyBentleyGeom.DPoint3d
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.DPoint3dArray, i: int) -> MSPyBentleyGeom.DPoint3d
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(*args, **kwargs):
        """
        remove(self: MSPyBentleyGeom.DPoint3dArray, x: MSPyBentleyGeom.DPoint3d) -> None
        
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class BlockedVectorDVec3d:
    """
    None
    """

    @property
    def Active(arg0: MSPyBentleyGeom.BlockedVectorDVec3d) -> bool:
        ...
    @Active.setter
    def Active(arg0: MSPyBentleyGeom.BlockedVectorDVec3d, arg1: bool) -> None:
        ...
    
    def Append(*args, **kwargs):
        """
        Append(*args, **kwargs)
        Overloaded function.
        
        1. Append(self: MSPyBentleyGeom.BlockedVectorDVec3d, pBuffer: MSPyBentleyGeom.DVec3d, count: int) -> int
        
        2. Append(self: MSPyBentleyGeom.BlockedVectorDVec3d, source: MSPyBentleyGeom.BlockedVectorDVec3d) -> int
        
        3. Append(self: MSPyBentleyGeom.BlockedVectorDVec3d, source: MSPyBentleyGeom.DVec3d) -> int
        """
        ...
    
    def AppendAndReturnIndex(*args, **kwargs):
        """
        AppendAndReturnIndex(self: MSPyBentleyGeom.BlockedVectorDVec3d, source: MSPyBentleyGeom.DVec3d) -> int
        """
        ...
    
    def ClearAndAppend(*args, **kwargs):
        """
        ClearAndAppend(self: MSPyBentleyGeom.BlockedVectorDVec3d, source: MSPyBentleyGeom.DVec3dArray) -> None
        """
        ...
    
    def ClearAndAppendBlock(*args, **kwargs):
        """
        ClearAndAppendBlock(*args, **kwargs)
        Overloaded function.
        
        1. ClearAndAppendBlock(self: MSPyBentleyGeom.BlockedVectorDVec3d, source: MSPyBentleyGeom.BlockedVectorDVec3d, i0: int, numWrap: int, n: int) -> int
        
        2. ClearAndAppendBlock(self: MSPyBentleyGeom.BlockedVectorDVec3d, source: MSPyBentleyGeom.DVec3d, sourceSize: int, i0: int, numWrap: int, n: int) -> int
        """
        ...
    
    def CopyData(*args, **kwargs):
        """
        CopyData(self: MSPyBentleyGeom.BlockedVectorDVec3d, fromIndex: int, toIndex: int) -> None
        """
        ...
    
    def CopyVectorFrom(*args, **kwargs):
        """
        CopyVectorFrom(self: MSPyBentleyGeom.BlockedVectorDVec3d, source: MSPyBentleyGeom.DVec3dArray) -> None
        """
        ...
    
    def GetCP(*args, **kwargs):
        """
        GetCP(self: MSPyBentleyGeom.BlockedVectorDVec3d) -> MSPyBentleyGeom.DVec3d
        """
        ...
    
    def GetPtr(*args, **kwargs):
        """
        GetPtr(self: MSPyBentleyGeom.BlockedVectorDVec3d) -> MSPyBentleyGeom.DVec3d
        """
        ...
    
    @property
    def IndexFamily(arg0: MSPyBentleyGeom.BlockedVectorDVec3d) -> int:
        ...
    
    @property
    def IndexedBy(arg0: MSPyBentleyGeom.BlockedVectorDVec3d) -> int:
        ...
    
    def NumCompleteRows(*args, **kwargs):
        """
        NumCompleteRows(self: MSPyBentleyGeom.BlockedVectorDVec3d) -> int
        """
        ...
    
    @property
    def NumPerStruct(arg0: MSPyBentleyGeom.BlockedVectorDVec3d) -> int:
        ...
    
    def ReverseInRange(*args, **kwargs):
        """
        ReverseInRange(self: MSPyBentleyGeom.BlockedVectorDVec3d, iFirst: int, iLast: int) -> None
        """
        ...
    
    def SetTags(*args, **kwargs):
        """
        SetTags(self: MSPyBentleyGeom.BlockedVectorDVec3d, numPeStruct: int, structsPerRow: int, tag: int, IndexFamily: int, IndexedBy: int, active: bool) -> None
        """
        ...
    
    @property
    def StructsPerRow(arg0: MSPyBentleyGeom.BlockedVectorDVec3d) -> int:
        ...
    @StructsPerRow.setter
    def StructsPerRow(arg0: MSPyBentleyGeom.BlockedVectorDVec3d, arg1: int) -> None:
        ...
    
    @property
    def Tag(arg0: MSPyBentleyGeom.BlockedVectorDVec3d) -> int:
        ...
    
    def Trim(*args, **kwargs):
        """
        Trim(self: MSPyBentleyGeom.BlockedVectorDVec3d, index0: int, count: int) -> None
        """
        ...
    
    def TryGet(*args, **kwargs):
        """
        TryGet(self: MSPyBentleyGeom.BlockedVectorDVec3d, index: int, defaultValue: MSPyBentleyGeom.DVec3d) -> Tuple[bool, MSPyBentleyGeom.DVec3d]
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.BlockedVectorDVec3d) -> None
        
        2. __init__(self: MSPyBentleyGeom.BlockedVectorDVec3d, numPerStruct: int, structsPerRow: int = 0, tag: int = 0, indexFamily: int = 0, indexBy: int = 0, active: bool = False) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.DVec3dArray, x: MSPyBentleyGeom.DVec3d) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.DVec3dArray) -> None
        
        Clear the contents
        """
        ...
    
    def count(*args, **kwargs):
        """
        count(self: MSPyBentleyGeom.DVec3dArray, x: MSPyBentleyGeom.DVec3d) -> int
        
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.DVec3dArray, L: MSPyBentleyGeom.DVec3dArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.DVec3dArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.DVec3dArray, i: int, x: MSPyBentleyGeom.DVec3d) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.DVec3dArray) -> MSPyBentleyGeom.DVec3d
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.DVec3dArray, i: int) -> MSPyBentleyGeom.DVec3d
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(*args, **kwargs):
        """
        remove(self: MSPyBentleyGeom.DVec3dArray, x: MSPyBentleyGeom.DVec3d) -> None
        
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class BlockedVectorFacetFaceData:
    """
    None
    """

    @property
    def Active(arg0: MSPyBentleyGeom.BlockedVectorFacetFaceData) -> bool:
        ...
    @Active.setter
    def Active(arg0: MSPyBentleyGeom.BlockedVectorFacetFaceData, arg1: bool) -> None:
        ...
    
    def Append(*args, **kwargs):
        """
        Append(*args, **kwargs)
        Overloaded function.
        
        1. Append(self: MSPyBentleyGeom.BlockedVectorFacetFaceData, pBuffer: MSPyBentleyGeom.FacetFaceData, count: int) -> int
        
        2. Append(self: MSPyBentleyGeom.BlockedVectorFacetFaceData, source: MSPyBentleyGeom.BlockedVectorFacetFaceData) -> int
        
        3. Append(self: MSPyBentleyGeom.BlockedVectorFacetFaceData, source: MSPyBentleyGeom.FacetFaceData) -> int
        """
        ...
    
    def AppendAndReturnIndex(*args, **kwargs):
        """
        AppendAndReturnIndex(self: MSPyBentleyGeom.BlockedVectorFacetFaceData, source: MSPyBentleyGeom.FacetFaceData) -> int
        """
        ...
    
    def ClearAndAppend(*args, **kwargs):
        """
        ClearAndAppend(self: MSPyBentleyGeom.BlockedVectorFacetFaceData, source: MSPyBentleyGeom.FacetFaceDataArray) -> None
        """
        ...
    
    def ClearAndAppendBlock(*args, **kwargs):
        """
        ClearAndAppendBlock(*args, **kwargs)
        Overloaded function.
        
        1. ClearAndAppendBlock(self: MSPyBentleyGeom.BlockedVectorFacetFaceData, source: MSPyBentleyGeom.BlockedVectorFacetFaceData, i0: int, numWrap: int, n: int) -> int
        
        2. ClearAndAppendBlock(self: MSPyBentleyGeom.BlockedVectorFacetFaceData, source: MSPyBentleyGeom.FacetFaceData, sourceSize: int, i0: int, numWrap: int, n: int) -> int
        """
        ...
    
    def CopyData(*args, **kwargs):
        """
        CopyData(self: MSPyBentleyGeom.BlockedVectorFacetFaceData, fromIndex: int, toIndex: int) -> None
        """
        ...
    
    def CopyVectorFrom(*args, **kwargs):
        """
        CopyVectorFrom(self: MSPyBentleyGeom.BlockedVectorFacetFaceData, source: MSPyBentleyGeom.FacetFaceDataArray) -> None
        """
        ...
    
    def GetCP(*args, **kwargs):
        """
        GetCP(self: MSPyBentleyGeom.BlockedVectorFacetFaceData) -> MSPyBentleyGeom.FacetFaceData
        """
        ...
    
    def GetPtr(*args, **kwargs):
        """
        GetPtr(self: MSPyBentleyGeom.BlockedVectorFacetFaceData) -> MSPyBentleyGeom.FacetFaceData
        """
        ...
    
    @property
    def IndexFamily(arg0: MSPyBentleyGeom.BlockedVectorFacetFaceData) -> int:
        ...
    
    @property
    def IndexedBy(arg0: MSPyBentleyGeom.BlockedVectorFacetFaceData) -> int:
        ...
    
    def NumCompleteRows(*args, **kwargs):
        """
        NumCompleteRows(self: MSPyBentleyGeom.BlockedVectorFacetFaceData) -> int
        """
        ...
    
    @property
    def NumPerStruct(arg0: MSPyBentleyGeom.BlockedVectorFacetFaceData) -> int:
        ...
    
    def ReverseInRange(*args, **kwargs):
        """
        ReverseInRange(self: MSPyBentleyGeom.BlockedVectorFacetFaceData, iFirst: int, iLast: int) -> None
        """
        ...
    
    def SetTags(*args, **kwargs):
        """
        SetTags(self: MSPyBentleyGeom.BlockedVectorFacetFaceData, numPeStruct: int, structsPerRow: int, tag: int, IndexFamily: int, IndexedBy: int, active: bool) -> None
        """
        ...
    
    @property
    def StructsPerRow(arg0: MSPyBentleyGeom.BlockedVectorFacetFaceData) -> int:
        ...
    @StructsPerRow.setter
    def StructsPerRow(arg0: MSPyBentleyGeom.BlockedVectorFacetFaceData, arg1: int) -> None:
        ...
    
    @property
    def Tag(arg0: MSPyBentleyGeom.BlockedVectorFacetFaceData) -> int:
        ...
    
    def Trim(*args, **kwargs):
        """
        Trim(self: MSPyBentleyGeom.BlockedVectorFacetFaceData, index0: int, count: int) -> None
        """
        ...
    
    def TryGet(*args, **kwargs):
        """
        TryGet(self: MSPyBentleyGeom.BlockedVectorFacetFaceData, index: int, defaultValue: MSPyBentleyGeom.FacetFaceData) -> Tuple[bool, MSPyBentleyGeom.FacetFaceData]
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.BlockedVectorFacetFaceData) -> None
        
        2. __init__(self: MSPyBentleyGeom.BlockedVectorFacetFaceData, numPerStruct: int, structsPerRow: int = 0, tag: int = 0, indexFamily: int = 0, indexBy: int = 0, active: bool = False) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.FacetFaceDataArray, x: MSPyBentleyGeom.FacetFaceData) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.FacetFaceDataArray) -> None
        
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.FacetFaceDataArray, L: MSPyBentleyGeom.FacetFaceDataArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.FacetFaceDataArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.FacetFaceDataArray, i: int, x: MSPyBentleyGeom.FacetFaceData) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.FacetFaceDataArray) -> MSPyBentleyGeom.FacetFaceData
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.FacetFaceDataArray, i: int) -> MSPyBentleyGeom.FacetFaceData
        
        Remove and return the item at index ``i``
        """
        ...
    
class BlockedVectorFloatRgb:
    """
    None
    """

    @property
    def Active(arg0: MSPyBentleyGeom.BlockedVectorFloatRgb) -> bool:
        ...
    @Active.setter
    def Active(arg0: MSPyBentleyGeom.BlockedVectorFloatRgb, arg1: bool) -> None:
        ...
    
    def Append(*args, **kwargs):
        """
        Append(*args, **kwargs)
        Overloaded function.
        
        1. Append(self: MSPyBentleyGeom.BlockedVectorFloatRgb, pBuffer: MSPyBentleyGeom.FloatRgb, count: int) -> int
        
        2. Append(self: MSPyBentleyGeom.BlockedVectorFloatRgb, source: MSPyBentleyGeom.BlockedVectorFloatRgb) -> int
        
        3. Append(self: MSPyBentleyGeom.BlockedVectorFloatRgb, source: MSPyBentleyGeom.FloatRgb) -> int
        """
        ...
    
    def AppendAndReturnIndex(*args, **kwargs):
        """
        AppendAndReturnIndex(self: MSPyBentleyGeom.BlockedVectorFloatRgb, source: MSPyBentleyGeom.FloatRgb) -> int
        """
        ...
    
    def ClearAndAppend(*args, **kwargs):
        """
        ClearAndAppend(self: MSPyBentleyGeom.BlockedVectorFloatRgb, source: MSPyBentleyGeom.FloatRgbArray) -> None
        """
        ...
    
    def ClearAndAppendBlock(*args, **kwargs):
        """
        ClearAndAppendBlock(*args, **kwargs)
        Overloaded function.
        
        1. ClearAndAppendBlock(self: MSPyBentleyGeom.BlockedVectorFloatRgb, source: MSPyBentleyGeom.BlockedVectorFloatRgb, i0: int, numWrap: int, n: int) -> int
        
        2. ClearAndAppendBlock(self: MSPyBentleyGeom.BlockedVectorFloatRgb, source: MSPyBentleyGeom.FloatRgb, sourceSize: int, i0: int, numWrap: int, n: int) -> int
        """
        ...
    
    def CopyData(*args, **kwargs):
        """
        CopyData(self: MSPyBentleyGeom.BlockedVectorFloatRgb, fromIndex: int, toIndex: int) -> None
        """
        ...
    
    def CopyVectorFrom(*args, **kwargs):
        """
        CopyVectorFrom(self: MSPyBentleyGeom.BlockedVectorFloatRgb, source: MSPyBentleyGeom.FloatRgbArray) -> None
        """
        ...
    
    def GetCP(*args, **kwargs):
        """
        GetCP(self: MSPyBentleyGeom.BlockedVectorFloatRgb) -> MSPyBentleyGeom.FloatRgb
        """
        ...
    
    def GetPtr(*args, **kwargs):
        """
        GetPtr(self: MSPyBentleyGeom.BlockedVectorFloatRgb) -> MSPyBentleyGeom.FloatRgb
        """
        ...
    
    @property
    def IndexFamily(arg0: MSPyBentleyGeom.BlockedVectorFloatRgb) -> int:
        ...
    
    @property
    def IndexedBy(arg0: MSPyBentleyGeom.BlockedVectorFloatRgb) -> int:
        ...
    
    def NumCompleteRows(*args, **kwargs):
        """
        NumCompleteRows(self: MSPyBentleyGeom.BlockedVectorFloatRgb) -> int
        """
        ...
    
    @property
    def NumPerStruct(arg0: MSPyBentleyGeom.BlockedVectorFloatRgb) -> int:
        ...
    
    def ReverseInRange(*args, **kwargs):
        """
        ReverseInRange(self: MSPyBentleyGeom.BlockedVectorFloatRgb, iFirst: int, iLast: int) -> None
        """
        ...
    
    def SetTags(*args, **kwargs):
        """
        SetTags(self: MSPyBentleyGeom.BlockedVectorFloatRgb, numPeStruct: int, structsPerRow: int, tag: int, IndexFamily: int, IndexedBy: int, active: bool) -> None
        """
        ...
    
    @property
    def StructsPerRow(arg0: MSPyBentleyGeom.BlockedVectorFloatRgb) -> int:
        ...
    @StructsPerRow.setter
    def StructsPerRow(arg0: MSPyBentleyGeom.BlockedVectorFloatRgb, arg1: int) -> None:
        ...
    
    @property
    def Tag(arg0: MSPyBentleyGeom.BlockedVectorFloatRgb) -> int:
        ...
    
    def Trim(*args, **kwargs):
        """
        Trim(self: MSPyBentleyGeom.BlockedVectorFloatRgb, index0: int, count: int) -> None
        """
        ...
    
    def TryGet(*args, **kwargs):
        """
        TryGet(self: MSPyBentleyGeom.BlockedVectorFloatRgb, index: int, defaultValue: MSPyBentleyGeom.FloatRgb) -> Tuple[bool, MSPyBentleyGeom.FloatRgb]
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.BlockedVectorFloatRgb) -> None
        
        2. __init__(self: MSPyBentleyGeom.BlockedVectorFloatRgb, numPerStruct: int, structsPerRow: int = 0, tag: int = 0, indexFamily: int = 0, indexBy: int = 0, active: bool = False) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.FloatRgbArray, x: MSPyBentleyGeom.FloatRgb) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.FloatRgbArray) -> None
        
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.FloatRgbArray, L: MSPyBentleyGeom.FloatRgbArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.FloatRgbArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.FloatRgbArray, i: int, x: MSPyBentleyGeom.FloatRgb) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.FloatRgbArray) -> MSPyBentleyGeom.FloatRgb
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.FloatRgbArray, i: int) -> MSPyBentleyGeom.FloatRgb
        
        Remove and return the item at index ``i``
        """
        ...
    
class BlockedVectorInt:
    """
    None
    """

    def Abs(*args, **kwargs):
        """
        Abs(self: MSPyBentleyGeom.BlockedVectorInt) -> None
        
        Set each entry to its absolute value
        """
        ...
    
    def AbsInRange(*args, **kwargs):
        """
        AbsInRange(self: MSPyBentleyGeom.BlockedVectorInt, iFirst: int, iLast: int) -> None
        
        for each k in the inclusive range kFirst<=k<=kLast, set the entry to
        its absolute value.
        """
        ...
    
    @property
    def Active(arg0: MSPyBentleyGeom.BlockedVectorIntT) -> bool:
        ...
    @Active.setter
    def Active(arg0: MSPyBentleyGeom.BlockedVectorIntT, arg1: bool) -> None:
        ...
    
    def AddAndTerminate(*args, **kwargs):
        """
        AddAndTerminate(self: MSPyBentleyGeom.BlockedVectorInt, pValues: int, numValues: int) -> bool
        
        Add one row with terminator or pad.
        """
        ...
    
    def AddSequentialBlock(*args, **kwargs):
        """
        AddSequentialBlock(self: MSPyBentleyGeom.BlockedVectorInt, firstValue: int, numValue: int, numWrap: int, numTrailingZero: int = 0, clearFirst: bool = False) -> None
        
        Add one row with wraparound, optional terminator. NO ACTION if the
        array is not active !!!!
        """
        ...
    
    def AddSteppedBlock(*args, **kwargs):
        """
        AddSteppedBlock(self: MSPyBentleyGeom.BlockedVectorInt, fierstValue: int, valueStep: int, numValue: int, numWrap: int, numTrailingZero: int = 0, clearFirst: bool = False) -> None
        
        Add one row with wraparound, optional terminator. NO ACTION if the
        array is not active !!!!
        """
        ...
    
    def AddTerminatedGridBlocks(*args, **kwargs):
        """
        AddTerminatedGridBlocks(self: MSPyBentleyGeom.BlockedVectorInt, numRow: int, numPerRow: int, rowStep: int, colStep: int, triangulated: bool, clearFirst: bool, firstValue: int, terminator: int) -> None
        
        Create indices for a rectangular grid.
        """
        ...
    
    def AddTerminatedSequentialBlocks(*args, **kwargs):
        """
        AddTerminatedSequentialBlocks(self: MSPyBentleyGeom.BlockedVectorInt, numRow: int, numPerRow: int, clearFirst: bool = False, firstValue: int = 1, terminator: int = 0) -> None
        
        Add numRow blocks of numPerRow sequential values with terminator after
        each row.
        """
        ...
    
    def AllNegativeInRange(*args, **kwargs):
        """
        AllNegativeInRange(self: MSPyBentleyGeom.BlockedVectorInt, iFirst: int, iLast: int) -> bool
        
        return true if all entries in the inclusive range kFirst<=k<=kLast are
        negative.
        """
        ...
    
    def Append(*args, **kwargs):
        """
        Append(*args, **kwargs)
        Overloaded function.
        
        1. Append(self: MSPyBentleyGeom.BlockedVectorIntT, pBuffer: int, count: int) -> int
        
        2. Append(self: MSPyBentleyGeom.BlockedVectorIntT, source: MSPyBentleyGeom.BlockedVectorIntT) -> int
        
        3. Append(self: MSPyBentleyGeom.BlockedVectorIntT, source: int) -> int
        """
        ...
    
    def AppendAndReturnIndex(*args, **kwargs):
        """
        AppendAndReturnIndex(self: MSPyBentleyGeom.BlockedVectorIntT, source: int) -> int
        """
        ...
    
    def AppendShifted(*args, **kwargs):
        """
        AppendShifted(self: MSPyBentleyGeom.BlockedVectorInt, source: MSPyBentleyGeom.BlockedVectorInt, shift: int) -> None
        """
        ...
    
    def ClearAndAppend(*args, **kwargs):
        """
        ClearAndAppend(self: MSPyBentleyGeom.BlockedVectorIntT, source: MSPyBentley.Int32Array) -> None
        """
        ...
    
    def ClearAndAppendBlock(*args, **kwargs):
        """
        ClearAndAppendBlock(*args, **kwargs)
        Overloaded function.
        
        1. ClearAndAppendBlock(self: MSPyBentleyGeom.BlockedVectorIntT, source: MSPyBentleyGeom.BlockedVectorIntT, i0: int, numWrap: int, n: int) -> int
        
        2. ClearAndAppendBlock(self: MSPyBentleyGeom.BlockedVectorIntT, source: int, sourceSize: int, i0: int, numWrap: int, n: int) -> int
        """
        ...
    
    def ConvertBlockedToZeroTerminated(*args, **kwargs):
        """
        ConvertBlockedToZeroTerminated(self: MSPyBentleyGeom.BlockedVectorInt) -> None
        
        If the current array has blocked structsPerRow, expand to variable
        length 0-terminated form. (ASSUMES all zeros in blocked form are
        placeholders.)
        """
        ...
    
    def CopyData(*args, **kwargs):
        """
        CopyData(self: MSPyBentleyGeom.BlockedVectorIntT, fromIndex: int, toIndex: int) -> None
        """
        ...
    
    def CopyVectorFrom(*args, **kwargs):
        """
        CopyVectorFrom(self: MSPyBentleyGeom.BlockedVectorIntT, source: MSPyBentley.Int32Array) -> None
        """
        ...
    
    def CountZeros(*args, **kwargs):
        """
        CountZeros(self: MSPyBentleyGeom.BlockedVectorInt) -> int
        
        Count zeros in the vector.
        """
        ...
    
    def DelimitFace(*args, **kwargs):
        """
        DelimitFace(self: MSPyBentleyGeom.BlockedVectorInt, numPerFace: int, iFirst: int) -> tuple
        
        From given start position, find final (inclusive) position and
        position for next start search. Initialize iFirst to zero before first
        call. Return false if no more faces.
        """
        ...
    
    def GetCP(*args, **kwargs):
        """
        GetCP(self: MSPyBentleyGeom.BlockedVectorIntT) -> int
        """
        ...
    
    def GetPtr(*args, **kwargs):
        """
        GetPtr(self: MSPyBentleyGeom.BlockedVectorIntT) -> int
        """
        ...
    
    class IndexAction:
        """
        Members:
        
        eNone
        
        eForcePositive
        
        eForceNegative
        
        eNegate
        """
    
        def __init__(self: MSPyBentleyGeom.BlockedVectorInt.IndexAction, value: int) -> None:
            ...
        
        eForceNegative: IndexAction
        
        eForcePositive: IndexAction
        
        eNegate: IndexAction
        
        eNone: IndexAction
        
        @property
        def name(self: handle) -> str:
            ...
        
        @property
        def value(arg0: MSPyBentleyGeom.BlockedVectorInt.IndexAction) -> int:
            ...
        
    @property
    def IndexFamily(arg0: MSPyBentleyGeom.BlockedVectorIntT) -> int:
        ...
    
    @property
    def IndexedBy(arg0: MSPyBentleyGeom.BlockedVectorIntT) -> int:
        ...
    
    def MinMax(*args, **kwargs):
        """
        MinMax(self: MSPyBentleyGeom.BlockedVectorInt) -> tuple
        
        Return min and max values in entire vector.
        
        Parameter ``[out]``:
        minValue smallest value, INT_MAX if empty array.
        
        Parameter ``[out]``:
        maxValue largest value, INT_MIN if empty array.
        """
        ...
    
    def NegateInRange(*args, **kwargs):
        """
        NegateInRange(self: MSPyBentleyGeom.BlockedVectorInt, iFirst: int, iLast: int) -> None
        """
        ...
    
    def NegativeAbsInRange(*args, **kwargs):
        """
        NegativeAbsInRange(self: MSPyBentleyGeom.BlockedVectorInt, iFirst: int, iLast: int) -> None
        
        for each k in the inclusive range kFirst<=k<=kLast, set the entry to
        the negative of its absolute value.
        """
        ...
    
    def NumCompleteRows(*args, **kwargs):
        """
        NumCompleteRows(self: MSPyBentleyGeom.BlockedVectorIntT) -> int
        """
        ...
    
    @property
    def NumPerStruct(arg0: MSPyBentleyGeom.BlockedVectorIntT) -> int:
        ...
    
    def ReverseInRange(*args, **kwargs):
        """
        ReverseInRange(self: MSPyBentleyGeom.BlockedVectorIntT, iFirst: int, iLast: int) -> None
        """
        ...
    
    def SetTags(*args, **kwargs):
        """
        SetTags(self: MSPyBentleyGeom.BlockedVectorIntT, numPeStruct: int, structsPerRow: int, tag: int, IndexFamily: int, IndexedBy: int, active: bool) -> None
        """
        ...
    
    def ShiftSignsFromCyclicPredecessorsInRange(*args, **kwargs):
        """
        ShiftSignsFromCyclicPredecessorsInRange(self: MSPyBentleyGeom.BlockedVectorInt, kFirst: int, kLast: int) -> None
        
        for each k in the inclusive range kFirst<=k<=kLast, set the sign to
        the prior value from its
        """
        ...
    
    @property
    def StructsPerRow(arg0: MSPyBentleyGeom.BlockedVectorIntT) -> int:
        ...
    @StructsPerRow.setter
    def StructsPerRow(arg0: MSPyBentleyGeom.BlockedVectorIntT, arg1: int) -> None:
        ...
    
    @property
    def Tag(arg0: MSPyBentleyGeom.BlockedVectorIntT) -> int:
        ...
    
    def Trim(*args, **kwargs):
        """
        Trim(self: MSPyBentleyGeom.BlockedVectorIntT, index0: int, count: int) -> None
        """
        ...
    
    def TryGet(*args, **kwargs):
        """
        TryGet(self: MSPyBentleyGeom.BlockedVectorIntT, index: int, defaultValue: int) -> Tuple[bool, int]
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.BlockedVectorInt) -> None:
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentley.Int32Array, x: int) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentley.Int32Array) -> None
        
        Clear the contents
        """
        ...
    
    def count(*args, **kwargs):
        """
        count(self: MSPyBentley.Int32Array, x: int) -> int
        
        Return the number of times ``x`` appears in the list
        """
        ...
    
    eForceNegative: IndexAction
    
    eForcePositive: IndexAction
    
    eNegate: IndexAction
    
    eNone: IndexAction
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentley.Int32Array, L: MSPyBentley.Int32Array) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentley.Int32Array, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentley.Int32Array, i: int, x: int) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentley.Int32Array) -> int
        
        Remove and return the last item
        
        2. pop(self: MSPyBentley.Int32Array, i: int) -> int
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(*args, **kwargs):
        """
        remove(self: MSPyBentley.Int32Array, x: int) -> None
        
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class BlockedVectorIntT:
    """
    None
    """

    @property
    def Active(arg0: MSPyBentleyGeom.BlockedVectorIntT) -> bool:
        ...
    @Active.setter
    def Active(arg0: MSPyBentleyGeom.BlockedVectorIntT, arg1: bool) -> None:
        ...
    
    def Append(*args, **kwargs):
        """
        Append(*args, **kwargs)
        Overloaded function.
        
        1. Append(self: MSPyBentleyGeom.BlockedVectorIntT, pBuffer: int, count: int) -> int
        
        2. Append(self: MSPyBentleyGeom.BlockedVectorIntT, source: MSPyBentleyGeom.BlockedVectorIntT) -> int
        
        3. Append(self: MSPyBentleyGeom.BlockedVectorIntT, source: int) -> int
        """
        ...
    
    def AppendAndReturnIndex(*args, **kwargs):
        """
        AppendAndReturnIndex(self: MSPyBentleyGeom.BlockedVectorIntT, source: int) -> int
        """
        ...
    
    def ClearAndAppend(*args, **kwargs):
        """
        ClearAndAppend(self: MSPyBentleyGeom.BlockedVectorIntT, source: MSPyBentley.Int32Array) -> None
        """
        ...
    
    def ClearAndAppendBlock(*args, **kwargs):
        """
        ClearAndAppendBlock(*args, **kwargs)
        Overloaded function.
        
        1. ClearAndAppendBlock(self: MSPyBentleyGeom.BlockedVectorIntT, source: MSPyBentleyGeom.BlockedVectorIntT, i0: int, numWrap: int, n: int) -> int
        
        2. ClearAndAppendBlock(self: MSPyBentleyGeom.BlockedVectorIntT, source: int, sourceSize: int, i0: int, numWrap: int, n: int) -> int
        """
        ...
    
    def CopyData(*args, **kwargs):
        """
        CopyData(self: MSPyBentleyGeom.BlockedVectorIntT, fromIndex: int, toIndex: int) -> None
        """
        ...
    
    def CopyVectorFrom(*args, **kwargs):
        """
        CopyVectorFrom(self: MSPyBentleyGeom.BlockedVectorIntT, source: MSPyBentley.Int32Array) -> None
        """
        ...
    
    def GetCP(*args, **kwargs):
        """
        GetCP(self: MSPyBentleyGeom.BlockedVectorIntT) -> int
        """
        ...
    
    def GetPtr(*args, **kwargs):
        """
        GetPtr(self: MSPyBentleyGeom.BlockedVectorIntT) -> int
        """
        ...
    
    @property
    def IndexFamily(arg0: MSPyBentleyGeom.BlockedVectorIntT) -> int:
        ...
    
    @property
    def IndexedBy(arg0: MSPyBentleyGeom.BlockedVectorIntT) -> int:
        ...
    
    def NumCompleteRows(*args, **kwargs):
        """
        NumCompleteRows(self: MSPyBentleyGeom.BlockedVectorIntT) -> int
        """
        ...
    
    @property
    def NumPerStruct(arg0: MSPyBentleyGeom.BlockedVectorIntT) -> int:
        ...
    
    def ReverseInRange(*args, **kwargs):
        """
        ReverseInRange(self: MSPyBentleyGeom.BlockedVectorIntT, iFirst: int, iLast: int) -> None
        """
        ...
    
    def SetTags(*args, **kwargs):
        """
        SetTags(self: MSPyBentleyGeom.BlockedVectorIntT, numPeStruct: int, structsPerRow: int, tag: int, IndexFamily: int, IndexedBy: int, active: bool) -> None
        """
        ...
    
    @property
    def StructsPerRow(arg0: MSPyBentleyGeom.BlockedVectorIntT) -> int:
        ...
    @StructsPerRow.setter
    def StructsPerRow(arg0: MSPyBentleyGeom.BlockedVectorIntT, arg1: int) -> None:
        ...
    
    @property
    def Tag(arg0: MSPyBentleyGeom.BlockedVectorIntT) -> int:
        ...
    
    def Trim(*args, **kwargs):
        """
        Trim(self: MSPyBentleyGeom.BlockedVectorIntT, index0: int, count: int) -> None
        """
        ...
    
    def TryGet(*args, **kwargs):
        """
        TryGet(self: MSPyBentleyGeom.BlockedVectorIntT, index: int, defaultValue: int) -> Tuple[bool, int]
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.BlockedVectorIntT) -> None
        
        2. __init__(self: MSPyBentleyGeom.BlockedVectorIntT, numPerStruct: int, structsPerRow: int = 0, tag: int = 0, indexFamily: int = 0, indexBy: int = 0, active: bool = False) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentley.Int32Array, x: int) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentley.Int32Array) -> None
        
        Clear the contents
        """
        ...
    
    def count(*args, **kwargs):
        """
        count(self: MSPyBentley.Int32Array, x: int) -> int
        
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentley.Int32Array, L: MSPyBentley.Int32Array) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentley.Int32Array, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentley.Int32Array, i: int, x: int) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentley.Int32Array) -> int
        
        Remove and return the last item
        
        2. pop(self: MSPyBentley.Int32Array, i: int) -> int
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(*args, **kwargs):
        """
        remove(self: MSPyBentley.Int32Array, x: int) -> None
        
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class BlockedVectorPolyfaceEdgeChain:
    """
    None
    """

    @property
    def Active(arg0: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain) -> bool:
        ...
    @Active.setter
    def Active(arg0: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain, arg1: bool) -> None:
        ...
    
    def Append(*args, **kwargs):
        """
        Append(*args, **kwargs)
        Overloaded function.
        
        1. Append(self: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain, pBuffer: MSPyBentleyGeom.PolyfaceEdgeChain, count: int) -> int
        
        2. Append(self: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain, source: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain) -> int
        
        3. Append(self: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain, source: MSPyBentleyGeom.PolyfaceEdgeChain) -> int
        """
        ...
    
    def AppendAndReturnIndex(*args, **kwargs):
        """
        AppendAndReturnIndex(self: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain, source: MSPyBentleyGeom.PolyfaceEdgeChain) -> int
        """
        ...
    
    def ClearAndAppend(*args, **kwargs):
        """
        ClearAndAppend(self: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain, source: MSPyBentleyGeom.PolyfaceEdgeChainArray) -> None
        """
        ...
    
    def ClearAndAppendBlock(*args, **kwargs):
        """
        ClearAndAppendBlock(*args, **kwargs)
        Overloaded function.
        
        1. ClearAndAppendBlock(self: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain, source: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain, i0: int, numWrap: int, n: int) -> int
        
        2. ClearAndAppendBlock(self: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain, source: MSPyBentleyGeom.PolyfaceEdgeChain, sourceSize: int, i0: int, numWrap: int, n: int) -> int
        """
        ...
    
    def CopyData(*args, **kwargs):
        """
        CopyData(self: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain, fromIndex: int, toIndex: int) -> None
        """
        ...
    
    def CopyVectorFrom(*args, **kwargs):
        """
        CopyVectorFrom(self: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain, source: MSPyBentleyGeom.PolyfaceEdgeChainArray) -> None
        """
        ...
    
    def GetCP(*args, **kwargs):
        """
        GetCP(self: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain) -> MSPyBentleyGeom.PolyfaceEdgeChain
        """
        ...
    
    def GetPtr(*args, **kwargs):
        """
        GetPtr(self: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain) -> MSPyBentleyGeom.PolyfaceEdgeChain
        """
        ...
    
    @property
    def IndexFamily(arg0: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain) -> int:
        ...
    
    @property
    def IndexedBy(arg0: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain) -> int:
        ...
    
    def NumCompleteRows(*args, **kwargs):
        """
        NumCompleteRows(self: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain) -> int
        """
        ...
    
    @property
    def NumPerStruct(arg0: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain) -> int:
        ...
    
    def ReverseInRange(*args, **kwargs):
        """
        ReverseInRange(self: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain, iFirst: int, iLast: int) -> None
        """
        ...
    
    def SetTags(*args, **kwargs):
        """
        SetTags(self: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain, numPeStruct: int, structsPerRow: int, tag: int, IndexFamily: int, IndexedBy: int, active: bool) -> None
        """
        ...
    
    @property
    def StructsPerRow(arg0: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain) -> int:
        ...
    @StructsPerRow.setter
    def StructsPerRow(arg0: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain, arg1: int) -> None:
        ...
    
    @property
    def Tag(arg0: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain) -> int:
        ...
    
    def Trim(*args, **kwargs):
        """
        Trim(self: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain, index0: int, count: int) -> None
        """
        ...
    
    def TryGet(*args, **kwargs):
        """
        TryGet(self: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain, index: int, defaultValue: MSPyBentleyGeom.PolyfaceEdgeChain) -> Tuple[bool, MSPyBentleyGeom.PolyfaceEdgeChain]
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain) -> None
        
        2. __init__(self: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain, numPerStruct: int, structsPerRow: int = 0, tag: int = 0, indexFamily: int = 0, indexBy: int = 0, active: bool = False) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.PolyfaceEdgeChainArray, x: MSPyBentleyGeom.PolyfaceEdgeChain) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.PolyfaceEdgeChainArray) -> None
        
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.PolyfaceEdgeChainArray, L: MSPyBentleyGeom.PolyfaceEdgeChainArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.PolyfaceEdgeChainArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.PolyfaceEdgeChainArray, i: int, x: MSPyBentleyGeom.PolyfaceEdgeChain) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.PolyfaceEdgeChainArray) -> MSPyBentleyGeom.PolyfaceEdgeChain
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.PolyfaceEdgeChainArray, i: int) -> MSPyBentleyGeom.PolyfaceEdgeChain
        
        Remove and return the item at index ``i``
        """
        ...
    
class BlockedVectorRgbFactor:
    """
    None
    """

    @property
    def Active(arg0: MSPyBentleyGeom.BlockedVectorRgbFactor) -> bool:
        ...
    @Active.setter
    def Active(arg0: MSPyBentleyGeom.BlockedVectorRgbFactor, arg1: bool) -> None:
        ...
    
    def Append(*args, **kwargs):
        """
        Append(*args, **kwargs)
        Overloaded function.
        
        1. Append(self: MSPyBentleyGeom.BlockedVectorRgbFactor, pBuffer: MSPyBentleyGeom.RgbFactor, count: int) -> int
        
        2. Append(self: MSPyBentleyGeom.BlockedVectorRgbFactor, source: MSPyBentleyGeom.BlockedVectorRgbFactor) -> int
        
        3. Append(self: MSPyBentleyGeom.BlockedVectorRgbFactor, source: MSPyBentleyGeom.RgbFactor) -> int
        """
        ...
    
    def AppendAndReturnIndex(*args, **kwargs):
        """
        AppendAndReturnIndex(self: MSPyBentleyGeom.BlockedVectorRgbFactor, source: MSPyBentleyGeom.RgbFactor) -> int
        """
        ...
    
    def ClearAndAppend(*args, **kwargs):
        """
        ClearAndAppend(self: MSPyBentleyGeom.BlockedVectorRgbFactor, source: MSPyBentleyGeom.RgbFactorArray) -> None
        """
        ...
    
    def ClearAndAppendBlock(*args, **kwargs):
        """
        ClearAndAppendBlock(*args, **kwargs)
        Overloaded function.
        
        1. ClearAndAppendBlock(self: MSPyBentleyGeom.BlockedVectorRgbFactor, source: MSPyBentleyGeom.BlockedVectorRgbFactor, i0: int, numWrap: int, n: int) -> int
        
        2. ClearAndAppendBlock(self: MSPyBentleyGeom.BlockedVectorRgbFactor, source: MSPyBentleyGeom.RgbFactor, sourceSize: int, i0: int, numWrap: int, n: int) -> int
        """
        ...
    
    def CopyData(*args, **kwargs):
        """
        CopyData(self: MSPyBentleyGeom.BlockedVectorRgbFactor, fromIndex: int, toIndex: int) -> None
        """
        ...
    
    def CopyVectorFrom(*args, **kwargs):
        """
        CopyVectorFrom(self: MSPyBentleyGeom.BlockedVectorRgbFactor, source: MSPyBentleyGeom.RgbFactorArray) -> None
        """
        ...
    
    def GetCP(*args, **kwargs):
        """
        GetCP(self: MSPyBentleyGeom.BlockedVectorRgbFactor) -> MSPyBentleyGeom.RgbFactor
        """
        ...
    
    def GetPtr(*args, **kwargs):
        """
        GetPtr(self: MSPyBentleyGeom.BlockedVectorRgbFactor) -> MSPyBentleyGeom.RgbFactor
        """
        ...
    
    @property
    def IndexFamily(arg0: MSPyBentleyGeom.BlockedVectorRgbFactor) -> int:
        ...
    
    @property
    def IndexedBy(arg0: MSPyBentleyGeom.BlockedVectorRgbFactor) -> int:
        ...
    
    def NumCompleteRows(*args, **kwargs):
        """
        NumCompleteRows(self: MSPyBentleyGeom.BlockedVectorRgbFactor) -> int
        """
        ...
    
    @property
    def NumPerStruct(arg0: MSPyBentleyGeom.BlockedVectorRgbFactor) -> int:
        ...
    
    def ReverseInRange(*args, **kwargs):
        """
        ReverseInRange(self: MSPyBentleyGeom.BlockedVectorRgbFactor, iFirst: int, iLast: int) -> None
        """
        ...
    
    def SetTags(*args, **kwargs):
        """
        SetTags(self: MSPyBentleyGeom.BlockedVectorRgbFactor, numPeStruct: int, structsPerRow: int, tag: int, IndexFamily: int, IndexedBy: int, active: bool) -> None
        """
        ...
    
    @property
    def StructsPerRow(arg0: MSPyBentleyGeom.BlockedVectorRgbFactor) -> int:
        ...
    @StructsPerRow.setter
    def StructsPerRow(arg0: MSPyBentleyGeom.BlockedVectorRgbFactor, arg1: int) -> None:
        ...
    
    @property
    def Tag(arg0: MSPyBentleyGeom.BlockedVectorRgbFactor) -> int:
        ...
    
    def Trim(*args, **kwargs):
        """
        Trim(self: MSPyBentleyGeom.BlockedVectorRgbFactor, index0: int, count: int) -> None
        """
        ...
    
    def TryGet(*args, **kwargs):
        """
        TryGet(self: MSPyBentleyGeom.BlockedVectorRgbFactor, index: int, defaultValue: MSPyBentleyGeom.RgbFactor) -> Tuple[bool, MSPyBentleyGeom.RgbFactor]
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.BlockedVectorRgbFactor) -> None
        
        2. __init__(self: MSPyBentleyGeom.BlockedVectorRgbFactor, numPerStruct: int, structsPerRow: int = 0, tag: int = 0, indexFamily: int = 0, indexBy: int = 0, active: bool = False) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.RgbFactorArray, x: MSPyBentleyGeom.RgbFactor) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.RgbFactorArray) -> None
        
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.RgbFactorArray, L: MSPyBentleyGeom.RgbFactorArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.RgbFactorArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.RgbFactorArray, i: int, x: MSPyBentleyGeom.RgbFactor) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.RgbFactorArray) -> MSPyBentleyGeom.RgbFactor
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.RgbFactorArray, i: int) -> MSPyBentleyGeom.RgbFactor
        
        Remove and return the item at index ``i``
        """
        ...
    
class BlockedVectorUInt32:
    """
    None
    """

    @property
    def Active(arg0: MSPyBentleyGeom.BlockedVectorUInt32) -> bool:
        ...
    @Active.setter
    def Active(arg0: MSPyBentleyGeom.BlockedVectorUInt32, arg1: bool) -> None:
        ...
    
    def Append(*args, **kwargs):
        """
        Append(*args, **kwargs)
        Overloaded function.
        
        1. Append(self: MSPyBentleyGeom.BlockedVectorUInt32, pBuffer: int, count: int) -> int
        
        2. Append(self: MSPyBentleyGeom.BlockedVectorUInt32, source: MSPyBentleyGeom.BlockedVectorUInt32) -> int
        
        3. Append(self: MSPyBentleyGeom.BlockedVectorUInt32, source: int) -> int
        """
        ...
    
    def AppendAndReturnIndex(*args, **kwargs):
        """
        AppendAndReturnIndex(self: MSPyBentleyGeom.BlockedVectorUInt32, source: int) -> int
        """
        ...
    
    def ClearAndAppend(*args, **kwargs):
        """
        ClearAndAppend(self: MSPyBentleyGeom.BlockedVectorUInt32, source: MSPyBentley.UInt32Array) -> None
        """
        ...
    
    def ClearAndAppendBlock(*args, **kwargs):
        """
        ClearAndAppendBlock(*args, **kwargs)
        Overloaded function.
        
        1. ClearAndAppendBlock(self: MSPyBentleyGeom.BlockedVectorUInt32, source: MSPyBentleyGeom.BlockedVectorUInt32, i0: int, numWrap: int, n: int) -> int
        
        2. ClearAndAppendBlock(self: MSPyBentleyGeom.BlockedVectorUInt32, source: int, sourceSize: int, i0: int, numWrap: int, n: int) -> int
        """
        ...
    
    def CopyData(*args, **kwargs):
        """
        CopyData(self: MSPyBentleyGeom.BlockedVectorUInt32, fromIndex: int, toIndex: int) -> None
        """
        ...
    
    def CopyVectorFrom(*args, **kwargs):
        """
        CopyVectorFrom(self: MSPyBentleyGeom.BlockedVectorUInt32, source: MSPyBentley.UInt32Array) -> None
        """
        ...
    
    def GetCP(*args, **kwargs):
        """
        GetCP(self: MSPyBentleyGeom.BlockedVectorUInt32) -> int
        """
        ...
    
    def GetPtr(*args, **kwargs):
        """
        GetPtr(self: MSPyBentleyGeom.BlockedVectorUInt32) -> int
        """
        ...
    
    @property
    def IndexFamily(arg0: MSPyBentleyGeom.BlockedVectorUInt32) -> int:
        ...
    
    @property
    def IndexedBy(arg0: MSPyBentleyGeom.BlockedVectorUInt32) -> int:
        ...
    
    def NumCompleteRows(*args, **kwargs):
        """
        NumCompleteRows(self: MSPyBentleyGeom.BlockedVectorUInt32) -> int
        """
        ...
    
    @property
    def NumPerStruct(arg0: MSPyBentleyGeom.BlockedVectorUInt32) -> int:
        ...
    
    def ReverseInRange(*args, **kwargs):
        """
        ReverseInRange(self: MSPyBentleyGeom.BlockedVectorUInt32, iFirst: int, iLast: int) -> None
        """
        ...
    
    def SetTags(*args, **kwargs):
        """
        SetTags(self: MSPyBentleyGeom.BlockedVectorUInt32, numPeStruct: int, structsPerRow: int, tag: int, IndexFamily: int, IndexedBy: int, active: bool) -> None
        """
        ...
    
    @property
    def StructsPerRow(arg0: MSPyBentleyGeom.BlockedVectorUInt32) -> int:
        ...
    @StructsPerRow.setter
    def StructsPerRow(arg0: MSPyBentleyGeom.BlockedVectorUInt32, arg1: int) -> None:
        ...
    
    @property
    def Tag(arg0: MSPyBentleyGeom.BlockedVectorUInt32) -> int:
        ...
    
    def Trim(*args, **kwargs):
        """
        Trim(self: MSPyBentleyGeom.BlockedVectorUInt32, index0: int, count: int) -> None
        """
        ...
    
    def TryGet(*args, **kwargs):
        """
        TryGet(self: MSPyBentleyGeom.BlockedVectorUInt32, index: int, defaultValue: int) -> Tuple[bool, int]
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.BlockedVectorUInt32) -> None
        
        2. __init__(self: MSPyBentleyGeom.BlockedVectorUInt32, numPerStruct: int, structsPerRow: int = 0, tag: int = 0, indexFamily: int = 0, indexBy: int = 0, active: bool = False) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentley.UInt32Array, x: int) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentley.UInt32Array) -> None
        
        Clear the contents
        """
        ...
    
    def count(*args, **kwargs):
        """
        count(self: MSPyBentley.UInt32Array, x: int) -> int
        
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentley.UInt32Array, L: MSPyBentley.UInt32Array) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentley.UInt32Array, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentley.UInt32Array, i: int, x: int) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentley.UInt32Array) -> int
        
        Remove and return the last item
        
        2. pop(self: MSPyBentley.UInt32Array, i: int) -> int
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(*args, **kwargs):
        """
        remove(self: MSPyBentley.UInt32Array, x: int) -> None
        
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class BoolSelect:
    """
    Members:
    
    eBoolSelect_Parity
    
    eBoolSelect_Union
    
    eBoolSelect_Summed_Parity
    
    eBoolSelect_Summed_Positive
    
    eBoolSelect_Summed_NonZero
    
    eBoolSelect_Summed_Negative
    
    eBoolSelect_FromStructure
    """

    def __init__(self: MSPyBentleyGeom.BoolSelect, value: int) -> None:
        ...
    
    eBoolSelect_FromStructure: BoolSelect
    
    eBoolSelect_Parity: BoolSelect
    
    eBoolSelect_Summed_Negative: BoolSelect
    
    eBoolSelect_Summed_NonZero: BoolSelect
    
    eBoolSelect_Summed_Parity: BoolSelect
    
    eBoolSelect_Summed_Positive: BoolSelect
    
    eBoolSelect_Union: BoolSelect
    
    @property
    def name(self: handle) -> str:
        ...
    
    @property
    def value(arg0: MSPyBentleyGeom.BoolSelect) -> int:
        ...
    
class BsplineDisplay:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    
    @property
    def curveDisplay(self: MSPyBentleyGeom.BsplineDisplay) -> int:
        ...
    @curveDisplay.setter
    def curveDisplay(self: MSPyBentleyGeom.BsplineDisplay, arg0: int) -> None:
        ...
    
    @property
    def polygonDisplay(self: MSPyBentleyGeom.BsplineDisplay) -> int:
        ...
    @polygonDisplay.setter
    def polygonDisplay(self: MSPyBentleyGeom.BsplineDisplay, arg0: int) -> None:
        ...
    
    @property
    def rulesByLength(self: MSPyBentleyGeom.BsplineDisplay) -> int:
        ...
    @rulesByLength.setter
    def rulesByLength(self: MSPyBentleyGeom.BsplineDisplay, arg0: int) -> None:
        ...
    
class BsplineParam:
    """
    None
    """

    def NumberAllocatedKnots(*args, **kwargs):
        """
        NumberAllocatedKnots(numPoles: int, order: int, closed: int) -> int
        
        Return the number of knots in the allocated knot array. Note that this
        number may be different from the value of the numKnots field of this
        structure because the numKnots field traditionally indicated only the
        number of interior knots.
        """
        ...
    
    def NumberInteriorKnots(*args, **kwargs):
        """
        NumberInteriorKnots(numPoles: int, order: int, closed: int) -> int
        
        Return the number of interior knots, as recorded (for legacy reasons)
        in the params structures
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    
    @property
    def closed(self: MSPyBentleyGeom.BsplineParam) -> int:
        ...
    @closed.setter
    def closed(self: MSPyBentleyGeom.BsplineParam, arg0: int) -> None:
        ...
    
    @property
    def numKnots(self: MSPyBentleyGeom.BsplineParam) -> int:
        ...
    @numKnots.setter
    def numKnots(self: MSPyBentleyGeom.BsplineParam, arg0: int) -> None:
        ...
    
    @property
    def numPoles(self: MSPyBentleyGeom.BsplineParam) -> int:
        ...
    @numPoles.setter
    def numPoles(self: MSPyBentleyGeom.BsplineParam, arg0: int) -> None:
        ...
    
    @property
    def numRules(self: MSPyBentleyGeom.BsplineParam) -> int:
        ...
    @numRules.setter
    def numRules(self: MSPyBentleyGeom.BsplineParam, arg0: int) -> None:
        ...
    
    @property
    def order(self: MSPyBentleyGeom.BsplineParam) -> int:
        ...
    @order.setter
    def order(self: MSPyBentleyGeom.BsplineParam, arg0: int) -> None:
        ...
    
CURVATURE_CONTINUITY: int

class ClipPlane:
    """
    None
    """

    def BoundedSegmentHasSimpleIntersection(*args, **kwargs):
        """
        BoundedSegmentHasSimpleIntersection(self: MSPyBentleyGeom.ClipPlane, pointA: Bentley.DPoint3d, pointB: Bentley.DPoint3d) -> tuple
        
        Return true if the through{pointA} and{pointB} crosses the plane at
        a fractional coordinate between 0 and 1. Note that if both points are
        ON the plane the return value is false -- the " on " case is not a
        simple intersection.
        """
        ...
    
    def ClipPlaneToRange(*args, **kwargs):
        """
        ClipPlaneToRange(range: Bentley.DRange3d, plane: Bentley.DPlane3d, clippedPoints: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >, largeRectangle: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> > = None) -> None
        
        Return the (possibly empty) polygon of intersection between a DRange3d
        and an (unbounded) plane.
        """
        ...
    
    def ConvexPolygonClipInPlace(*args, **kwargs):
        """
        ConvexPolygonClipInPlace(*args, **kwargs)
        Overloaded function.
        
        1. ConvexPolygonClipInPlace(self: MSPyBentleyGeom.ClipPlane, xyz: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >, work: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >, onPlaneHandling: int) -> None
        
        Clip a convex polygon. caller supplies work and altitude arrays as
        works space. result is written inplace to xyz.
        
        * onPlaneHandling=0 means no special handling for all-oin.
        
        * onPlaneHandling=1 means treat all-on as IN
        
        * onPlaneHandling= -1 means treat all-on as OUT
        
        2. ConvexPolygonClipInPlace(self: MSPyBentleyGeom.ClipPlane, xyz: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >, work: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >) -> None
        
        Clip a convex polygon. caller supplies work and altitude arrays as
        works space. result is written inplace to xyz.
        
        * onPlaneHandling=0 means no special handling for all-oin.
        
        * onPlaneHandling=1 means treat all-on as IN
        
        * onPlaneHandling= -1 means treat all-on as OUT
        """
        ...
    
    def ConvexPolygonSplitInsideOutside(*args, **kwargs):
        """
        ConvexPolygonSplitInsideOutside(self: MSPyBentleyGeom.ClipPlane, xyz: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >, xyzIn: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >, xyzOut: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >, altitudeRange: Bentley.DRange1d) -> None
        
        [in] original polygon [out] inside part [out] outside part [out] min
        and max altitude values.
        """
        ...
    
    @property
    def DPlane4d(arg0: MSPyBentleyGeom.ClipPlane) -> Bentley.DPoint4d:
        ...
    @DPlane4d.setter
    def DPlane4d(arg0: MSPyBentleyGeom.ClipPlane, arg1: Bentley.DPoint4d) -> None:
        ...
    
    def DotProduct(*args, **kwargs):
        """
        DotProduct(*args, **kwargs)
        Overloaded function.
        
        1. DotProduct(self: MSPyBentleyGeom.ClipPlane, normal: Bentley.DVec3d) -> float
        
        Evaluate Dot Product with plane normal.
        
        2. DotProduct(self: MSPyBentleyGeom.ClipPlane, point: Bentley.DPoint3d) -> float
        
        Evaluate Dot Product with plane normal.
        """
        ...
    
    def EvaluatePoint(*args, **kwargs):
        """
        EvaluatePoint(self: MSPyBentleyGeom.ClipPlane, point: Bentley.DPoint3d) -> float
        
        Evaluate the plane equation at{point}.
        """
        ...
    
    def FindPointOnBothPlanes(*args, **kwargs):
        """
        FindPointOnBothPlanes(data: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >, plane0: MSPyBentleyGeom.ClipPlane, plane1: MSPyBentleyGeom.ClipPlane, tolerance: float) -> MSPyBentleyGeom.ValidatedSize
        
        Search an array of points for the first index at which the point is on
        both of two planes.
        """
        ...
    
    @property
    def Flags(arg0: MSPyBentleyGeom.ClipPlane) -> int:
        ...
    @Flags.setter
    def Flags(arg0: MSPyBentleyGeom.ClipPlane, arg1: int) -> None:
        ...
    
    def FromEdgeAndUpVector(*args, **kwargs):
        """
        FromEdgeAndUpVector(point0: Bentley.DPoint3d, point1: Bentley.DPoint3d, upVector: Bentley.DVec3d, tiltAngle: MSPyBentleyGeom.Angle) -> MSPyBentleyGeom.ValidatedClipPlane
        
        ul> li>For non-tilted case, (tiltAngle = 0), the inward normal vector
        is upVector cross edge vector. li>If tilt is nonzero, that plane is
        rotated around the (forward) edge vector. ul>
        """
        ...
    
    def FromPointsAndDistanceAlongPlaneNormal(*args, **kwargs):
        """
        FromPointsAndDistanceAlongPlaneNormal(points: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >, upVector: Bentley.DVec3d, distance: float, pointInside: bool) -> MSPyBentleyGeom.ValidatedClipPlane
        
        Create a clip plane perpendicular to upVvector, positioned a distance
        forward or backward of given points. ul> li>
        """
        ...
    
    def GetDPlane3d(*args, **kwargs):
        """
        GetDPlane3d(self: MSPyBentleyGeom.ClipPlane) -> Bentley.DPlane3d
        
        Return the plane as origin and normal.
        """
        ...
    
    def GetDPlane4d(*args, **kwargs):
        """
        GetDPlane4d(self: MSPyBentleyGeom.ClipPlane) -> Bentley.DPoint4d
        
        Return the plane for use as h = [ax,ay,az,aw] DOT [x,y,z,1]
        """
        ...
    
    def GetDistance(*args, **kwargs):
        """
        GetDistance(self: MSPyBentleyGeom.ClipPlane) -> float
        
        Return the plane distance.
        """
        ...
    
    def GetEvaluationCount(*args, **kwargs):
        """
        GetEvaluationCount(clear: bool = False) -> int
        """
        ...
    
    def GetFlags(*args, **kwargs):
        """
        GetFlags(self: MSPyBentleyGeom.ClipPlane) -> int
        
        Get flags.
        """
        ...
    
    def GetInvisible(*args, **kwargs):
        """
        GetInvisible(self: MSPyBentleyGeom.ClipPlane) -> bool
        """
        ...
    
    def GetIsInterior(*args, **kwargs):
        """
        GetIsInterior(self: MSPyBentleyGeom.ClipPlane) -> bool
        
        Return the interior flag.
        """
        ...
    
    def GetLocalToWorldTransform(*args, **kwargs):
        """
        GetLocalToWorldTransform(*args, **kwargs)
        Overloaded function.
        
        1. GetLocalToWorldTransform(self: MSPyBentleyGeom.ClipPlane, zPointsOut: bool = False) -> Bentley.Transform
        
        Return the plane as a transform with origin on plane, z vector
        perpendicular.
        
        2. GetLocalToWorldTransform(self: MSPyBentleyGeom.ClipPlane, localToWorld: Bentley.Transform, worldToLocal: Bentley.Transform, zPointsOut: bool = False) -> bool
        
        Return the plane as a transform with origin on plane, z vector
        perpendicular.
        """
        ...
    
    def GetNormal(*args, **kwargs):
        """
        GetNormal(self: MSPyBentleyGeom.ClipPlane) -> Bentley.DVec3d
        
        Return the plane normal.
        """
        ...
    
    @property
    def IsInvisible(arg0: MSPyBentleyGeom.ClipPlane) -> bool:
        ...
    @IsInvisible.setter
    def IsInvisible(arg0: MSPyBentleyGeom.ClipPlane, arg1: bool) -> None:
        ...
    
    def IsPointOn(*args, **kwargs):
        """
        IsPointOn(self: MSPyBentleyGeom.ClipPlane, point: Bentley.DPoint3d, tolerance: float) -> bool
        
        Return if the point is on plane within tolerance
        """
        ...
    
    def IsPointOnOrInside(*args, **kwargs):
        """
        IsPointOnOrInside(*args, **kwargs)
        Overloaded function.
        
        1. IsPointOnOrInside(self: MSPyBentleyGeom.ClipPlane, point: Bentley.DPoint3d) -> bool
        
        Return if the point is on or inside plane.
        
        2. IsPointOnOrInside(self: MSPyBentleyGeom.ClipPlane, point: Bentley.DPoint3d, tolerance: float) -> bool
        
        Return if the point is on or inside plane.
        """
        ...
    
    def IsVisible(*args, **kwargs):
        """
        IsVisible(self: MSPyBentleyGeom.ClipPlane) -> bool
        
        Return whether cut for this flag should be displayed (!invisible &&
        !isInterior);
        """
        ...
    
    def MultiplyPlaneTimesMatrix(*args, **kwargs):
        """
        MultiplyPlaneTimesMatrix(self: MSPyBentleyGeom.ClipPlane, matrix: Bentley.DMatrix4d) -> None
        
        multiply plane coefficients times a DMatrix4d (such as the worldToNPC
        matrix) multiply [ax,ay,az,aw] * matrix
        """
        ...
    
    def Negate(*args, **kwargs):
        """
        Negate(self: MSPyBentleyGeom.ClipPlane) -> None
        
        Flip the normal direction.
        """
        ...
    
    def OffsetDistance(*args, **kwargs):
        """
        OffsetDistance(self: MSPyBentleyGeom.ClipPlane, distance: float) -> None
        
        Apply offset to plane.
        """
        ...
    
    def PolygonCrossings(*args, **kwargs):
        """
        PolygonCrossings(self: MSPyBentleyGeom.ClipPlane, xyz: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >, crossings: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >) -> None
        
        Return crossings of all edges of a polygon (including final closure)
        This uses simple zero tests -- does not try to filter double data at
        vertex-on-plane case
        """
        ...
    
    def SetDPlane4d(*args, **kwargs):
        """
        SetDPlane4d(self: MSPyBentleyGeom.ClipPlane, plane: Bentley.DPoint4d) -> None
        """
        ...
    
    def SetFlags(*args, **kwargs):
        """
        SetFlags(*args, **kwargs)
        Overloaded function.
        
        1. SetFlags(self: MSPyBentleyGeom.ClipPlane, flags: int) -> None
        
        Set flags.
        
        2. SetFlags(self: MSPyBentleyGeom.ClipPlane, invisible: bool, interior: bool) -> None
        
        Set flags.
        """
        ...
    
    def SetInvisible(*args, **kwargs):
        """
        SetInvisible(self: MSPyBentleyGeom.ClipPlane, invisible: bool) -> None
        
        Get invisible.
        """
        ...
    
    def SimpleIntersectionFractions(*args, **kwargs):
        """
        SimpleIntersectionFractions(self: MSPyBentleyGeom.ClipPlane, arc: Bentley.DEllipse3d, bounded: bool) -> tuple
        """
        ...
    
    def TransformInPlace(*args, **kwargs):
        """
        TransformInPlace(self: MSPyBentleyGeom.ClipPlane, transform: Bentley.Transform) -> None
        
        Transform plane.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ClipPlane) -> None
        
        2. __init__(self: MSPyBentleyGeom.ClipPlane, normal: Bentley.DVec3d, distance: float, invisible: bool = False, interior: bool = False) -> None
        
        3. __init__(self: MSPyBentleyGeom.ClipPlane, normal: Bentley.DVec3d, point: Bentley.DPoint3d, invisible: bool = False, interior: bool = False) -> None
        
        4. __init__(self: MSPyBentleyGeom.ClipPlane, plane: Bentley.DPlane3d, invisible: bool = False, interior: bool = False) -> None
        """
        ...
    
class ClipPlaneArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ClipPlaneArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.ClipPlaneArray, arg0: MSPyBentleyGeom.ClipPlaneArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.ClipPlaneArray, arg0: Iterable) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.ClipPlaneArray, x: MSPyBentleyGeom.ClipPlane) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.ClipPlaneArray) -> None
        
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.ClipPlaneArray, L: MSPyBentleyGeom.ClipPlaneArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.ClipPlaneArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.ClipPlaneArray, i: int, x: MSPyBentleyGeom.ClipPlane) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.ClipPlaneArray) -> MSPyBentleyGeom.ClipPlane
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.ClipPlaneArray, i: int) -> MSPyBentleyGeom.ClipPlane
        
        Remove and return the item at index ``i``
        """
        ...
    
class ClipPlaneContainment:
    """
    Members:
    
    eClipPlaneContainment_StronglyInside
    
    eClipPlaneContainment_Ambiguous
    
    eClipPlaneContainment_StronglyOutside
    """

    def __init__(self: MSPyBentleyGeom.ClipPlaneContainment, value: int) -> None:
        ...
    
    eClipPlaneContainment_Ambiguous: ClipPlaneContainment
    
    eClipPlaneContainment_StronglyInside: ClipPlaneContainment
    
    eClipPlaneContainment_StronglyOutside: ClipPlaneContainment
    
    @property
    def name(self: handle) -> str:
        ...
    
    @property
    def value(arg0: MSPyBentleyGeom.ClipPlaneContainment) -> int:
        ...
    
class ClipPlaneSet:
    """
    None
    """

    def AppendCrossings(*args, **kwargs):
        """
        AppendCrossings(*args, **kwargs)
        Overloaded function.
        
        1. AppendCrossings(self: MSPyBentleyGeom.ClipPlaneSet, curves: Bentley.CurveVector, crossings: Bentley.Bstdcxx.bvector<Bentley.CurveLocationDetailPair,Bentley.BentleyAllocator<Bentley.CurveLocationDetailPair> >) -> None
        
        Compute crossings of this ClipPlaneSet with curve primitives within a
        CurveVector.
        
        Parameter ``[in]``:
        curves candidate curves
        
        Parameter ``[out]``:
        crossings detailed crossing data.
        
        2. AppendCrossings(self: MSPyBentleyGeom.ClipPlaneSet, curve: Bentley.ICurvePrimitive, crossings: Bentley.Bstdcxx.bvector<Bentley.CurveLocationDetailPair,Bentley.BentleyAllocator<Bentley.CurveLocationDetailPair> >) -> None
        
        Compute crossings of this ClipPlaneSet with curve primitives within a
        CurveVector.
        
        Parameter ``[in]``:
        curves candidate curves
        
        Parameter ``[out]``:
        crossings detailed crossing data.
        """
        ...
    
    def AppendIntervals(*args, **kwargs):
        """
        AppendIntervals(*args, **kwargs)
        Overloaded function.
        
        1. AppendIntervals(self: MSPyBentleyGeom.ClipPlaneSet, segment: Bentley.DSegment3d, intervals: Bentley.Bstdcxx.bvector<Bentley.DSegment1d,Bentley.BentleyAllocator<Bentley.DSegment1d> >) -> None
        
        Enumerate the " in " intervals .. the array is NOT cleared
        
        2. AppendIntervals(self: MSPyBentleyGeom.ClipPlaneSet, arc: Bentley.DEllipse3d, intervals: Bentley.Bstdcxx.bvector<Bentley.DSegment1d,Bentley.BentleyAllocator<Bentley.DSegment1d> >) -> None
        
        Enumerate the " in " intervals .. the array is NOT cleared
        
        3. AppendIntervals(self: MSPyBentleyGeom.ClipPlaneSet, curve: Bentley.MSBsplineCurve, intervals: Bentley.Bstdcxx.bvector<Bentley.DSegment1d,Bentley.BentleyAllocator<Bentley.DSegment1d> >) -> None
        
        Enumerate the " in " intervals .. the array is NOT cleared
        """
        ...
    
    def ClassifyCurvePrimitiveInSetDifference(*args, **kwargs):
        """
        ClassifyCurvePrimitiveInSetDifference(curve: Bentley.ICurvePrimitive, clipSet: MSPyBentleyGeom.ClipPlaneSet, maskSet: MSPyBentleyGeom.ClipPlaneSet) -> MSPyBentleyGeom.ClipPlaneContainment
        
        Determine if a CurveVector is completely in, completely out, or mixed
        with respect to a postive ClipPlaneSet and a mask (hole) ClipPlaneSet.
        
        Parameter ``curve``:
        [in] curve to test
        
        Parameter ``clipSet``:
        [in] the positive clip set
        
        Parameter ``maskSet``:
        [in] the negative (holes) clip set
        """
        ...
    
    def ClassifyCurveVectorInSetDifference(*args, **kwargs):
        """
        ClassifyCurveVectorInSetDifference(curves: Bentley.CurveVector, clipSet: MSPyBentleyGeom.ClipPlaneSet, maskSet: MSPyBentleyGeom.ClipPlaneSet, considerRegions: bool) -> MSPyBentleyGeom.ClipPlaneContainment
        
        Determine if a CurveVector is completely in, completely out, or mixed
        with respect to a postive ClipPlaneSet and a mask (hole) ClipPlaneSet.
        
        Parameter ``curves``:
        [in] curves or region to clip.
        
        Parameter ``clipSet``:
        [in] the positive clip set
        
        Parameter ``maskSet``:
        [in] the negative (holes) clip set
        
        Parameter ``considerRegions``:
        [in] if true, treat Outer, Inner, Parity, and Union regions as
        areas. If false, only consider boundaries.
        """
        ...
    
    def ClassifyPointContainment(*args, **kwargs):
        """
        ClassifyPointContainment(self: MSPyBentleyGeom.ClipPlaneSet, points: List[Bentley.DPoint3d], onIsOutsize: bool = False) -> MSPyBentleyGeom.ClipPlaneContainment
        
        @description return a summary classification
        
        * ClipPlaneContainment_StronglyInside All points are inside the plane
        set
        
        * ClipPlaneContainment_Ambiguous
        
        * ClipPlaneContainment_StronglyOut Strongly out. All points are out,
        and are all on one side of one of planes, so edges joining pairs of
        points will always be out also.
        """
        ...
    
    def ClassifyPolyfaceInSetDifference(*args, **kwargs):
        """
        ClassifyPolyfaceInSetDifference(polyface: Bentley.PolyfaceQuery, clipSet: MSPyBentleyGeom.ClipPlaneSet, maskSet: MSPyBentleyGeom.ClipPlaneSet) -> MSPyBentleyGeom.ClipPlaneContainment
        
        Determine if a Polyface is completely in, completely out, or mixed
        with respect to a postive ClipPlaneSet and a mask (hole) ClipPlaneSet.
        
        Parameter ``polyface``:
        [in] polyface to test
        
        Parameter ``clipSet``:
        [in] the positive clip set
        
        Parameter ``maskSet``:
        [in] the negative (holes) clip set
        """
        ...
    
    def ClipAndMaskPlanarRegion(*args, **kwargs):
        """
        ClipAndMaskPlanarRegion(outsideClip: MSPyBentleyGeom.ClipPlaneSet, holeClip: MSPyBentleyGeom.ClipPlaneSet, planarRegion: Bentley.CurveVector) -> Bentley.CurveVector
        
        Clip a planar region to the (optional) outsideClip. Subtract the
        (optional) holeClip.
        
        Parameter ``outsideClip``:
        [in] optional outer clip
        
        Parameter ``holeClip``:
        [in] optional hole clip
        
        Parameter ``planarRegion``:
        A CurveVector of type Loop or ParityRegion.
        """
        ...
    
    def ClipPlanarRegion(*args, **kwargs):
        """
        ClipPlanarRegion(self: MSPyBentleyGeom.ClipPlaneSet, planarRegion: Bentley.CurveVector, localToWorld: Bentley.Transform, worldToLocal: Bentley.Transform) -> Bentley.CurveVector
        
        Clip a planar region to this ClipPlaneset
        
        Parameter ``planarRegion``:
        [in] A CurveVector of type Loop or ParityRegion.
        
        Parameter ``localToWorld``:
        [out] transform from the plane of the planarRegion to world
        
        Parameter ``worldToLocal``:
        [out] transform from world to the plane of the planarRegion
        """
        ...
    
    def ClipPlaneSetIntersectPolyface(*args, **kwargs):
        """
        ClipPlaneSetIntersectPolyface(polyface: Bentley.PolyfaceQuery, clipSet: MSPyBentleyGeom.ClipPlaneSet, constructNewFacetsOnClipSetPlanes: bool) -> tuple
        
        Clip a polyface to a a postive ClipPlaneSet. This produces cut faces
        where the clipSet is inside the polyface. If the polyface is not
        closed, cut faces may be produced where sections are closed loops.
        
        Parameter ``polyface``:
        [in] polyface to test
        
        Parameter ``clipSet``:
        [in] the positive clip set
        
        Parameter ``constructNewFacetsOnClipSetPlanes``:
        [in] true to construct new faces where clip planes are inside the
        facet.
        
        Parameter ``inside``:
        [out] (optional) " inside " parts
        
        Parameter ``outside``:
        [out] (optional) " outside " parts
        
        Parameter ``distanceTolerance``:
        (optional) if nonzero, this is the distance tolerance for various
        internal steps. It is recommended that callers with metric data
        pass DoubleOps.SmallMetricDistance ().
        """
        ...
    
    def ClipToSetDifference(*args, **kwargs):
        """
        ClipToSetDifference(polyface: Bentley.PolyfaceQuery, clipSet: MSPyBentleyGeom.ClipPlaneSet, maskSet: MSPyBentleyGeom.ClipPlaneSet) -> tuple
        
        Clip a polyface to a a postive ClipPlaneSet and a mask (hole)
        ClipPlaneSet.
        
        Parameter ``polyface``:
        [in] polyface to test
        
        Parameter ``clipSet``:
        [in] the positive clip set
        
        Parameter ``maskSet``:
        [in] the negative (holes) clip set
        
        Parameter ``inside``:
        [out] (optional) " inside " parts
        
        Parameter ``outside``:
        [out] (optional) " outside " parts
        """
        ...
    
    def FromSweptPolygon(*args, **kwargs):
        """
        FromSweptPolygon(points: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >, direction: Bentley.DVec3d = None) -> MSPyBentleyGeom.ClipPlaneSet
        
        Create a (chain of) convex clippers for an (unbounded) polygon sweep
        in given direction. polygon may have disconnects. default sweep
        direction is Z
        """
        ...
    
    def GetRange(*args, **kwargs):
        """
        GetRange(self: MSPyBentleyGeom.ClipPlaneSet, range: Bentley.DRange3d, transform: Bentley.Transform) -> bool
        
        Get range of this ClipPlaneSet.
        """
        ...
    
    def GetRayIntersection(*args, **kwargs):
        """
        GetRayIntersection(self: MSPyBentleyGeom.ClipPlaneSet, point: Bentley.DPoint3d, direction: Bentley.DVec3d) -> tuple
        
        Get nearest intersect distance along ray.
        """
        ...
    
    def IsAnyPointInOrOn(*args, **kwargs):
        """
        IsAnyPointInOrOn(*args, **kwargs)
        Overloaded function.
        
        1. IsAnyPointInOrOn(self: MSPyBentleyGeom.ClipPlaneSet, segment: Bentley.DSegment3d) -> bool
        
        Clip a bounded line segment
        
        2. IsAnyPointInOrOn(self: MSPyBentleyGeom.ClipPlaneSet, arc: Bentley.DEllipse3d) -> bool
        
        Clip a bounded line segment
        
        3. IsAnyPointInOrOn(self: MSPyBentleyGeom.ClipPlaneSet, curve: Bentley.MSBsplineCurve) -> bool
        
        Clip a bounded line segment
        """
        ...
    
    def IsPointInside(*args, **kwargs):
        """
        IsPointInside(self: MSPyBentleyGeom.ClipPlaneSet, point: Bentley.DPoint3d) -> bool
        
        Test if point is inside.
        """
        ...
    
    def IsPointOnOrInside(*args, **kwargs):
        """
        IsPointOnOrInside(self: MSPyBentleyGeom.ClipPlaneSet, point: Bentley.DPoint3d, tolerance: float) -> bool
        
        Test if point is inside to supplied tolerance.
        """
        ...
    
    def IsSphereInside(*args, **kwargs):
        """
        IsSphereInside(self: MSPyBentleyGeom.ClipPlaneSet, point: Bentley.DPoint3d, radius: float) -> bool
        
        Test if point is inside to supplied tolerance.
        """
        ...
    
    def MultiplyPlanesTimesMatrix(*args, **kwargs):
        """
        MultiplyPlanesTimesMatrix(self: MSPyBentleyGeom.ClipPlaneSet, matrix: Bentley.DMatrix4d) -> None
        
        multiply plane coefficients times a DMatrix4d (such as the worldToNPC
        matrix) multiply [ax,ay,az,aw] * matrix
        """
        ...
    
    def SweptPolygonClipPolyface(*args, **kwargs):
        """
        SweptPolygonClipPolyface(polyface: Bentley.PolyfaceQuery, polygon: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >, sweepDirection: Bentley.DVec3d, constructNewFacetsOnClipSetPlanes: bool) -> tuple
        
        Clip a polyface to a swept polygon. This produces side faces where the
        sweep makes a closed cut. If the polyface is not closed, cut faces may
        be produced where sections are closed loops.
        
        Parameter ``polyface``:
        [in] polyface to test
        
        Parameter ``polygon``:
        [in] polygon points.
        
        Parameter ``sweepDirection``:
        [in] sweep direction for the polygon.
        
        Parameter ``constructNewFacetsOnClipSetPlanes``:
        [in] true to construct new faces where clip planes are inside the
        facet.
        
        Parameter ``inside``:
        [out] (optional) " inside " parts
        
        Parameter ``outside``:
        [out] (optional) " outside " parts
        """
        ...
    
    def TestRayIntersect(*args, **kwargs):
        """
        TestRayIntersect(self: MSPyBentleyGeom.ClipPlaneSet, point: Bentley.DPoint3d, direction: Bentley.DVec3d) -> bool
        
        Test for intersection with ray.
        """
        ...
    
    def TransformInPlace(*args, **kwargs):
        """
        TransformInPlace(self: MSPyBentleyGeom.ClipPlaneSet, transform: Bentley.Transform) -> None
        
        Transform each plane set.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ClipPlaneSet) -> None
        
        2. __init__(self: MSPyBentleyGeom.ClipPlaneSet, planes: MSPyBentleyGeom.ClipPlaneArray) -> None
        
        3. __init__(self: MSPyBentleyGeom.ClipPlaneSet, convexSet: MSPyBentleyGeom.ConvexClipPlaneSet) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.ConvexClipPlaneSetArray, x: MSPyBentleyGeom.ConvexClipPlaneSet) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.ConvexClipPlaneSetArray) -> None
        
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.ConvexClipPlaneSetArray, L: MSPyBentleyGeom.ConvexClipPlaneSetArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.ConvexClipPlaneSetArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.ConvexClipPlaneSetArray, i: int, x: MSPyBentleyGeom.ConvexClipPlaneSet) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.ConvexClipPlaneSetArray) -> MSPyBentleyGeom.ConvexClipPlaneSet
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.ConvexClipPlaneSetArray, i: int) -> MSPyBentleyGeom.ConvexClipPlaneSet
        
        Remove and return the item at index ``i``
        """
        ...
    
class CompoundDrawState:
    """
    None
    """

    @property
    def ConditionalBlockIndices(arg0: MSPyBentleyGeom.CompoundDrawState) -> MSPyBentley.UInt64Array:
        ...
    
    @property
    def DebugString(arg0: MSPyBentleyGeom.CompoundDrawState) -> MSPyBentley.WString:
        ...
    
    @property
    def DrawGeomMethodIndex(arg0: MSPyBentleyGeom.CompoundDrawState) -> int:
        ...
    @DrawGeomMethodIndex.setter
    def DrawGeomMethodIndex(arg0: MSPyBentleyGeom.CompoundDrawState, arg1: int) -> None:
        ...
    
    def GetConditionalBlockIndices(*args, **kwargs):
        """
        GetConditionalBlockIndices(self: MSPyBentleyGeom.CompoundDrawState) -> MSPyBentley.UInt64Array
        
        return (reference to) the stored block indices.
        """
        ...
    
    def GetDebugString(*args, **kwargs):
        """
        GetDebugString(self: MSPyBentleyGeom.CompoundDrawState) -> MSPyBentley.WString
        
        Return debug representation.
        """
        ...
    
    def GetDrawGeomMethodIndex(*args, **kwargs):
        """
        GetDrawGeomMethodIndex(self: MSPyBentleyGeom.CompoundDrawState) -> int
        """
        ...
    
    def Load(*args, **kwargs):
        """
        Load(self: MSPyBentleyGeom.CompoundDrawState, data: MSPyBentley.UInt16Array) -> None
        
        Copy data from the caller's memory into this CompoundDrawState.
        """
        ...
    
    def SetDrawGeomMethodIndex(*args, **kwargs):
        """
        SetDrawGeomMethodIndex(self: MSPyBentleyGeom.CompoundDrawState, index: int) -> None
        
        set the drawGeom index.
        """
        ...
    
    def Store(*args, **kwargs):
        """
        Store(self: MSPyBentleyGeom.CompoundDrawState, arg0: MSPyBentley.UInt16Array) -> None
        
        copy all data into the caller's bvector.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.CompoundDrawState) -> None
        
        2. __init__(self: MSPyBentleyGeom.CompoundDrawState, drawIndex: int, conditionBlockIndices: MSPyBentley.UInt64Array) -> None
        
        3. __init__(self: MSPyBentleyGeom.CompoundDrawState, rhs: MSPyBentleyGeom.CompoundDrawState) -> None
        """
        ...
    
class ConvexClipPlaneSet:
    """
    None
    """

    def Add(*args, **kwargs):
        """
        Add(self: MSPyBentleyGeom.ConvexClipPlaneSet, plane: MSPyBentleyGeom.ValidatedClipPlane) -> bool
        
        Add the plane if it is valid.
        """
        ...
    
    def AddSweptPolyline(*args, **kwargs):
        """
        AddSweptPolyline(self: MSPyBentleyGeom.ConvexClipPlaneSet, points: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >, upVector: Bentley.DVec3d, tiltAngle: MSPyBentleyGeom.Angle) -> None
        
        Add space " to the left of a polyline ", with left determined by edges
        and an upvector. ul> li>If teh polyline is closed, an orientation test
        is done and the point order is reveresed if needed to be sure the
        planes are oriented to enclose the space. li>For each edge of the
        polyline, the primary plane has its primary outward normal as edge
        vector cross up vector. li>The normal is then rotated by the tilt
        angle towards the up vector. li>to close around a polygon, repeat the
        first point at end. li>When closed, this correspondes to a CCW polygon
        with the upVector pointing at the eye, and the volume expands behind
        the polygon li> ul>
        """
        ...
    
    def AppendCrossings(*args, **kwargs):
        """
        AppendCrossings(*args, **kwargs)
        Overloaded function.
        
        1. AppendCrossings(self: MSPyBentleyGeom.ConvexClipPlaneSet, curves: Bentley.CurveVector, crossings: Bentley.Bstdcxx.bvector<Bentley.CurveLocationDetailPair,Bentley.BentleyAllocator<Bentley.CurveLocationDetailPair> >) -> None
        
        Compute crossings of this set's planes with curve primitives within a
        CurveVector.
        
        Parameter ``[in]``:
        curves candidate curves
        
        Parameter ``[out]``:
        crossings detailed crossing data.
        
        2. AppendCrossings(self: MSPyBentleyGeom.ConvexClipPlaneSet, curve: Bentley.ICurvePrimitive, crossings: Bentley.Bstdcxx.bvector<Bentley.CurveLocationDetailPair,Bentley.BentleyAllocator<Bentley.CurveLocationDetailPair> >) -> None
        
        Compute crossings of this set's planes with curve primitives within a
        CurveVector.
        
        Parameter ``[in]``:
        curves candidate curves
        
        Parameter ``[out]``:
        crossings detailed crossing data.
        """
        ...
    
    def AppendIntervals(*args, **kwargs):
        """
        AppendIntervals(*args, **kwargs)
        Overloaded function.
        
        1. AppendIntervals(self: MSPyBentleyGeom.ConvexClipPlaneSet, arc: Bentley.DEllipse3d, intervals: Bentley.Bstdcxx.bvector<Bentley.DSegment1d,Bentley.BentleyAllocator<Bentley.DSegment1d> >, planeSign: float = 1.0) -> bool
        
        Enumerate the " in " intervals .. the array is NOT cleared If the
        intervals array is nullptr, returns true immediately when any interior
        interval is found.
        
        2. AppendIntervals(self: MSPyBentleyGeom.ConvexClipPlaneSet, curve: Bentley.MSBsplineCurve, intervals: Bentley.Bstdcxx.bvector<Bentley.DSegment1d,Bentley.BentleyAllocator<Bentley.DSegment1d> >) -> bool
        
        Enumerate the " in " intervals .. the array is NOT cleared If the
        intervals array is nullptr, returns true immediately when any interior
        interval is found.
        """
        ...
    
    def ClassifyPointContainment(*args, **kwargs):
        """
        ClassifyPointContainment(self: MSPyBentleyGeom.ConvexClipPlaneSet, points: List[Bentley.DPoint3d], onIsOutsize: bool = False) -> MSPyBentleyGeom.ClipPlaneContainment
        
        @description return a summary classification
        
        * ClipPlaneContainment_StronglyInside All points are inside the plane
        set
        
        * ClipPlaneContainment_Ambiguous
        
        * ClipPlaneContainment_StronglyOut Strongly out. All points are out,
        and are all on one side of one of planes, so edges joining pairs of
        points will always be out also.
        """
        ...
    
    def ClipBoundedSegment(*args, **kwargs):
        """
        ClipBoundedSegment(self: MSPyBentleyGeom.ConvexClipPlaneSet, pointA: Bentley.DPoint3d, pointB: Bentley.DPoint3d, planeSign: float = 1.0) -> tuple
        
        Clip a (bounded) line segment to this set of planes.
        """
        ...
    
    def ClipPointsOnOrInside(*args, **kwargs):
        """
        ClipPointsOnOrInside(self: MSPyBentleyGeom.ConvexClipPlaneSet, points: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >, inOrOn: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >, out: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >) -> None
        
        Clip points.
        """
        ...
    
    def ClipUnBoundedSegment(*args, **kwargs):
        """
        ClipUnBoundedSegment(self: MSPyBentleyGeom.ConvexClipPlaneSet, pointA: Bentley.DPoint3d, pointB: Bentley.DPoint3d, planeSign: float = 1.0) -> tuple
        
        Clip an unbounded line to this set of planes.
        """
        ...
    
    def ConvexPolygonClip(*args, **kwargs):
        """
        ConvexPolygonClip(*args, **kwargs)
        Overloaded function.
        
        1. ConvexPolygonClip(self: MSPyBentleyGeom.ConvexClipPlaneSet, input: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >, output: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >, work: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >) -> None
        
        Return the (polygon) of intersection
        
        2. ConvexPolygonClip(self: MSPyBentleyGeom.ConvexClipPlaneSet, input: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >, output: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >, work: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >, onPlaneHandling: int) -> None
        
        Return the (polygon) of intersection
        """
        ...
    
    def FromXYPolyLine(*args, **kwargs):
        """
        FromXYPolyLine(points: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >, hiddenEdge: MSPyBentley.BoolArray, leftIsInside: bool) -> MSPyBentleyGeom.ConvexClipPlaneSet
        
        Create clip plane set for regiosn to one side of a polyline. If
        hiddenEdge is an empty array, all clips are marked as regular
        clippers. The hiddenEdge array must contain a boolean (usual false)
        for each point of the points array. If (true), clip output from that
        intersections with that edge may be made invisible by some later
        methods.
        """
        ...
    
    def GetRange(*args, **kwargs):
        """
        GetRange(self: MSPyBentleyGeom.ConvexClipPlaneSet, range: Bentley.DRange3d, transform: Bentley.Transform) -> bool
        
        Get range of this ConvexClipPlaneSet.
        """
        ...
    
    def IsPointInside(*args, **kwargs):
        """
        IsPointInside(self: MSPyBentleyGeom.ConvexClipPlaneSet, point: Bentley.DPoint3d) -> bool
        
        Test if point is inside all planes.
        """
        ...
    
    def IsPointOnOrInside(*args, **kwargs):
        """
        IsPointOnOrInside(self: MSPyBentleyGeom.ConvexClipPlaneSet, point: Bentley.DPoint3d, tolerance: float) -> bool
        
        Test if point is inside all planes to supplied tolerance.
        """
        ...
    
    def IsSphereInside(*args, **kwargs):
        """
        IsSphereInside(self: MSPyBentleyGeom.ConvexClipPlaneSet, point: Bentley.DPoint3d, tolerance: float) -> bool
        
        Test if sphere is inside all planes.
        """
        ...
    
    def MultiplyPlanesTimesMatrix(*args, **kwargs):
        """
        MultiplyPlanesTimesMatrix(self: MSPyBentleyGeom.ConvexClipPlaneSet, matrix: Bentley.DMatrix4d) -> None
        
        multiply plane coefficients times a DMatrix4d (such as the worldToNPC
        matrix) multiply [ax,ay,az,aw] * matrix
        """
        ...
    
    def ReloadSweptConvexPolygon(*args, **kwargs):
        """
        ReloadSweptConvexPolygon(self: MSPyBentleyGeom.ConvexClipPlaneSet, points: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >, sweepDirection: Bentley.DVec3d, sideSelect: int) -> int
        
        reinitialize to clip to a swept polygon. ul> li> 1 -- success, and the
        sweep vector and polygon area normal have positive dot product li> -1
        -- success, and the sweep vector and polygon area normal have negative
        dot product ul> 0 -- failure - polygon normal is perpendicular to
        sweep.
        """
        ...
    
    def TransformInPlace(*args, **kwargs):
        """
        TransformInPlace(self: MSPyBentleyGeom.ConvexClipPlaneSet, transform: Bentley.Transform) -> None
        
        Transform plane set.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ConvexClipPlaneSet) -> None
        
        2. __init__(self: MSPyBentleyGeom.ConvexClipPlaneSet, n: int) -> None
        
        3. __init__(self: MSPyBentleyGeom.ConvexClipPlaneSet, planes: MSPyBentleyGeom.ClipPlaneArray) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.ClipPlaneArray, x: MSPyBentleyGeom.ClipPlane) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.ClipPlaneArray) -> None
        
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.ClipPlaneArray, L: MSPyBentleyGeom.ClipPlaneArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.ClipPlaneArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.ClipPlaneArray, i: int, x: MSPyBentleyGeom.ClipPlane) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.ClipPlaneArray) -> MSPyBentleyGeom.ClipPlane
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.ClipPlaneArray, i: int) -> MSPyBentleyGeom.ClipPlane
        
        Remove and return the item at index ``i``
        """
        ...
    
class ConvexClipPlaneSetArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ConvexClipPlaneSetArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.ConvexClipPlaneSetArray, arg0: MSPyBentleyGeom.ConvexClipPlaneSetArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.ConvexClipPlaneSetArray, arg0: Iterable) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.ConvexClipPlaneSetArray, x: MSPyBentleyGeom.ConvexClipPlaneSet) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.ConvexClipPlaneSetArray) -> None
        
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.ConvexClipPlaneSetArray, L: MSPyBentleyGeom.ConvexClipPlaneSetArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.ConvexClipPlaneSetArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.ConvexClipPlaneSetArray, i: int, x: MSPyBentleyGeom.ConvexClipPlaneSet) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.ConvexClipPlaneSetArray) -> MSPyBentleyGeom.ConvexClipPlaneSet
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.ConvexClipPlaneSetArray, i: int) -> MSPyBentleyGeom.ConvexClipPlaneSet
        
        Remove and return the item at index ``i``
        """
        ...
    
class CurveAndSolidLocationDetail:
    """
    None
    """

    def __init__(self: MSPyBentleyGeom.CurveAndSolidLocationDetail, curveDetail: MSPyBentleyGeom.CurveLocationDetail, solidDetail: MSPyBentleyGeom.SolidLocationDetail) -> None:
        ...
    
    @property
    def curveDetail(self: MSPyBentleyGeom.CurveAndSolidLocationDetail) -> MSPyBentleyGeom.CurveLocationDetail:
        ...
    @curveDetail.setter
    def curveDetail(self: MSPyBentleyGeom.CurveAndSolidLocationDetail, arg0: MSPyBentleyGeom.CurveLocationDetail) -> None:
        ...
    
    @property
    def solidDetail(self: MSPyBentleyGeom.CurveAndSolidLocationDetail) -> MSPyBentleyGeom.SolidLocationDetail:
        ...
    @solidDetail.setter
    def solidDetail(self: MSPyBentleyGeom.CurveAndSolidLocationDetail, arg0: MSPyBentleyGeom.SolidLocationDetail) -> None:
        ...
    
class CurveAndSolidLocationDetailArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.CurveAndSolidLocationDetailArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.CurveAndSolidLocationDetailArray, arg0: MSPyBentleyGeom.CurveAndSolidLocationDetailArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.CurveAndSolidLocationDetailArray, arg0: Iterable) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.CurveAndSolidLocationDetailArray, x: MSPyBentleyGeom.CurveAndSolidLocationDetail) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.CurveAndSolidLocationDetailArray) -> None
        
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.CurveAndSolidLocationDetailArray, L: MSPyBentleyGeom.CurveAndSolidLocationDetailArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.CurveAndSolidLocationDetailArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.CurveAndSolidLocationDetailArray, i: int, x: MSPyBentleyGeom.CurveAndSolidLocationDetail) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.CurveAndSolidLocationDetailArray) -> MSPyBentleyGeom.CurveAndSolidLocationDetail
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.CurveAndSolidLocationDetailArray, i: int) -> MSPyBentleyGeom.CurveAndSolidLocationDetail
        
        Remove and return the item at index ``i``
        """
        ...
    
class CurveCurve:
    """
    None
    """

    def CloseApproach(*args, **kwargs):
        """
        CloseApproach(pointsOnA: MSPyBentleyGeom.CurveVector, pointsOnB: MSPyBentleyGeom.CurveVector, curveA: MSPyBentleyGeom.ICurvePrimitive, curveB: MSPyBentleyGeom.ICurvePrimitive, maxDist: float = 1.7976931348623157e+308) -> None
        """
        ...
    
    def ClosestApproach(*args, **kwargs):
        """
        ClosestApproach(*args, **kwargs)
        Overloaded function.
        
        1. ClosestApproach(pointOnA: MSPyBentleyGeom.CurveLocationDetail, pointOnB: MSPyBentleyGeom.CurveLocationDetail, curveA: MSPyBentleyGeom.ICurvePrimitive, curveB: MSPyBentleyGeom.ICurvePrimitive) -> bool
        
        2. ClosestApproach(pointOnA: MSPyBentleyGeom.CurveLocationDetail, pointOnB: MSPyBentleyGeom.CurveLocationDetail, chainA: MSPyBentleyGeom.CurveVector, chainB: MSPyBentleyGeom.CurveVector) -> bool
        """
        ...
    
    def ClosestApproachNewton(*args, **kwargs):
        """
        ClosestApproachNewton(arg0: MSPyBentleyGeom.ICurvePrimitive, arg1: MSPyBentleyGeom.ICurvePrimitive) -> tuple
        """
        ...
    
    def CollectBlends(*args, **kwargs):
        """
        CollectBlends(*args, **kwargs)
        Overloaded function.
        
        1. CollectBlends(curveA: MSPyBentleyGeom.ICurvePrimitive, curveB: MSPyBentleyGeom.ICurvePrimitive, blendType: MSPyBentleyGeom.BlendType, distanceA: float, distanceB: float, extend: bool, blendCurves: MSPyBentleyGeom.BlendDetailArray) -> None
        
        2. CollectBlends(chainA: MSPyBentleyGeom.CurveVector, chainB: MSPyBentleyGeom.CurveVector, blendType: MSPyBentleyGeom.BlendType, distanceA: float, distanceB: float, extend: bool, blendCurves: MSPyBentleyGeom.BlendDetailArray) -> None
        """
        ...
    
    def CollectFilletArcs(*args, **kwargs):
        """
        CollectFilletArcs(*args, **kwargs)
        Overloaded function.
        
        1. CollectFilletArcs(curveA: MSPyBentleyGeom.ICurvePrimitive, curveB: MSPyBentleyGeom.ICurvePrimitive, radius: float, extend: bool, arcs: MSPyBentleyGeom.FilletDetailArray) -> None
        
        2. CollectFilletArcs(chainA: MSPyBentleyGeom.CurveVector, chainB: MSPyBentleyGeom.CurveVector, radius: float, extend: bool, arcs: MSPyBentleyGeom.FilletDetailArray) -> None
        """
        ...
    
    class FilletDetail:
        """
        None
        """
    
        def __init__(*args, **kwargs):
            """
            Initialize self.  See help(type(self)) for accurate signature.
            """
            ...
        
        @property
        def arc(self: MSPyBentleyGeom.CurveCurve.FilletDetail) -> Bentley.DEllipse3d:
            ...
        @arc.setter
        def arc(self: MSPyBentleyGeom.CurveCurve.FilletDetail, arg0: Bentley.DEllipse3d) -> None:
            ...
        
        @property
        def detailA(self: MSPyBentleyGeom.CurveCurve.FilletDetail) -> MSPyBentleyGeom.CurveLocationDetail:
            ...
        @detailA.setter
        def detailA(self: MSPyBentleyGeom.CurveCurve.FilletDetail, arg0: MSPyBentleyGeom.CurveLocationDetail) -> None:
            ...
        
        @property
        def detailB(self: MSPyBentleyGeom.CurveCurve.FilletDetail) -> MSPyBentleyGeom.CurveLocationDetail:
            ...
        @detailB.setter
        def detailB(self: MSPyBentleyGeom.CurveCurve.FilletDetail, arg0: MSPyBentleyGeom.CurveLocationDetail) -> None:
            ...
        
    def GetPartialCurveDetailPair(*args, **kwargs):
        """
        GetPartialCurveDetailPair(intersectionA: MSPyBentleyGeom.CurveVector, intersectionB: MSPyBentleyGeom.CurveVector, i: int, detailA: MSPyBentleyGeom.PartialCurveDetail, detailB: MSPyBentleyGeom.PartialCurveDetail) -> bool
        
        Convenience function for extracting PartialCurveDetail data from two
        arrays returned by CurveCurve.IntersectionsXY return false if index
        out of range or addresses something other than PartialCurveData.
        
        Parameter ``[in]``:
        intersectionA first source vector
        
        Parameter ``[in]``:
        intersectionB second source vector
        
        Parameter ``[in]``:
        i index to acccess in source vectors.
        
        Parameter ``[out]``:
        detailA data from intersectionA
        
        Parameter ``[out]``:
        detailB data from intersectionB
        """
        ...
    
    def IntersectRotatedCurveSpaceCurve(*args, **kwargs):
        """
        IntersectRotatedCurveSpaceCurve(worldToLocal: Bentley.Transform, rotatedCurve: MSPyBentleyGeom.CurveVector, spaceCurve: MSPyBentleyGeom.ICurvePrimitive, detailA: MSPyBentleyGeom.CurveLocationDetailArray, detailB: MSPyBentleyGeom.CurveLocationDetailArray) -> None
        
        Compute intersections of (a) a curve rotated around an axis and (b) a
        space curve.
        """
        ...
    
    def IntersectionsXY(*args, **kwargs):
        """
        IntersectionsXY(*args, **kwargs)
        Overloaded function.
        
        1. IntersectionsXY(intersectionA: MSPyBentleyGeom.CurveVector, intersectionB: MSPyBentleyGeom.CurveVector, curveA: MSPyBentleyGeom.CurveVector, curveB: MSPyBentleyGeom.CurveVector, pWorldToLocal: Bentley.DMatrix4d) -> None
        
        2. IntersectionsXY(intersectionA: MSPyBentleyGeom.CurveVector, intersectionB: MSPyBentleyGeom.CurveVector, curveA: MSPyBentleyGeom.ICurvePrimitive, curveB: MSPyBentleyGeom.ICurvePrimitive, pWorldToLocal: Bentley.DMatrix4d, extend: bool = False) -> None
        
        3. IntersectionsXY(intersectionA: MSPyBentleyGeom.CurveVector, intersectionB: MSPyBentleyGeom.CurveVector, curveA: MSPyBentleyGeom.ICurvePrimitive, curveB: MSPyBentleyGeom.CurveVector, pWorldToLocal: Bentley.DMatrix4d) -> None
        """
        ...
    
    def IsContained(*args, **kwargs):
        """
        IsContained(intersectionA: MSPyBentleyGeom.CurveVector, intersectionB: MSPyBentleyGeom.CurveVector, i: int, j: int, considerSinglePoints: bool, considerIntervals: bool) -> bool
        
        Test if interval i is contained in interval j.
        """
        ...
    
    def IsSinglePointPair(*args, **kwargs):
        """
        IsSinglePointPair(*args, **kwargs)
        Overloaded function.
        
        1. IsSinglePointPair(arg0: MSPyBentleyGeom.CurveVector, arg1: MSPyBentleyGeom.CurveVector, arg2: int) -> tuple
        
        2. IsSinglePointPair(intersectionA: MSPyBentleyGeom.CurveVector, intersectionB: MSPyBentleyGeom.CurveVector, i: int, detailA: MSPyBentleyGeom.CurveLocationDetail, detailB: MSPyBentleyGeom.CurveLocationDetail) -> bool
        """
        ...
    
    def TransverseRegionIntersectionSegments(*args, **kwargs):
        """
        TransverseRegionIntersectionSegments(regionA: MSPyBentleyGeom.CurveVector, regionB: MSPyBentleyGeom.CurveVector, segments: Bentley.Bstdcxx.bvector<Bentley.DSegment3d,Bentley.BentleyAllocator<Bentley.DSegment3d> >) -> bool
        
        Determine the line of intersection of the planes of the two containing
        planes. In that line, find all segments as split by the two curve
        vectors. Return false if the curve vectors are not individually planar
        or are not closed
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    
class CurveGapOptions:
    """
    None
    """

    @property
    def EqualPointTolerance(arg0: MSPyBentleyGeom.CurveGapOptions) -> float:
        ...
    @EqualPointTolerance.setter
    def EqualPointTolerance(arg0: MSPyBentleyGeom.CurveGapOptions, arg1: float) -> None:
        ...
    
    def GetEqualPointTolerance(*args, **kwargs):
        """
        GetEqualPointTolerance(self: MSPyBentleyGeom.CurveGapOptions) -> float
        
        Returns:
        tolerance for gaps that do not have to be closed at all.
        """
        ...
    
    def GetMaxAdjustAlongCurve(*args, **kwargs):
        """
        GetMaxAdjustAlongCurve(self: MSPyBentleyGeom.CurveGapOptions) -> float
        
        Returns:
        max allowable motion along a curve.
        """
        ...
    
    def GetMaxDirectAdjustTolerance(*args, **kwargs):
        """
        GetMaxDirectAdjustTolerance(self: MSPyBentleyGeom.CurveGapOptions) -> float
        
        Returns:
        max allowable motion of line and linestring endpoints.
        """
        ...
    
    def GetRemovePriorGapPrimitives(*args, **kwargs):
        """
        GetRemovePriorGapPrimitives(self: MSPyBentleyGeom.CurveGapOptions) -> bool
        
        Returns:
        flag to remove prior gap primitives
        """
        ...
    
    @property
    def MaxAdjustAlongCurve(arg0: MSPyBentleyGeom.CurveGapOptions) -> float:
        ...
    @MaxAdjustAlongCurve.setter
    def MaxAdjustAlongCurve(arg0: MSPyBentleyGeom.CurveGapOptions, arg1: float) -> None:
        ...
    
    @property
    def MaxDirectAdjustTolerance(arg0: MSPyBentleyGeom.CurveGapOptions) -> float:
        ...
    @MaxDirectAdjustTolerance.setter
    def MaxDirectAdjustTolerance(arg0: MSPyBentleyGeom.CurveGapOptions, arg1: float) -> None:
        ...
    
    @property
    def RemovePriorGapPrimitives(arg0: MSPyBentleyGeom.CurveGapOptions) -> bool:
        ...
    @RemovePriorGapPrimitives.setter
    def RemovePriorGapPrimitives(arg0: MSPyBentleyGeom.CurveGapOptions, arg1: bool) -> None:
        ...
    
    def SetEqualPointTolerance(*args, **kwargs):
        """
        SetEqualPointTolerance(self: MSPyBentleyGeom.CurveGapOptions, value: float) -> None
        
        Set gap size that does not need to be corrected.
        """
        ...
    
    def SetMaxAdjustAlongCurve(*args, **kwargs):
        """
        SetMaxAdjustAlongCurve(self: MSPyBentleyGeom.CurveGapOptions, value: float) -> None
        
        Set max motion along a curve.
        """
        ...
    
    def SetMaxDirectAdjustTolerance(*args, **kwargs):
        """
        SetMaxDirectAdjustTolerance(self: MSPyBentleyGeom.CurveGapOptions, value: float) -> None
        
        Set max allowable motion of line and linestring endpoints.
        """
        ...
    
    def SetRemovePriorGapPrimitives(*args, **kwargs):
        """
        SetRemovePriorGapPrimitives(self: MSPyBentleyGeom.CurveGapOptions, value: bool) -> None
        
        Set flag to remove prior gap primitives
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.CurveGapOptions) -> None
        
        2. __init__(self: MSPyBentleyGeom.CurveGapOptions, equalPointTolerance: float, maxDirectAdjust: float, maxAdjustAlongCurve: float) -> None
        """
        ...
    
class CurveKeyPointCollector:
    """
    None
    """

    def EnableKeyPointType(*args, **kwargs):
        """
        EnableKeyPointType(self: MSPyBentleyGeom.CurveKeyPointCollector, selector: MSPyBentleyGeom.CurveKeyPointCollector.KeyPointType, value: bool) -> None
        
        Indicate keypoint preference
        """
        ...
    
    def EnableSingleKeyPointType(*args, **kwargs):
        """
        EnableSingleKeyPointType(self: MSPyBentleyGeom.CurveKeyPointCollector, selector: MSPyBentleyGeom.CurveKeyPointCollector.KeyPointType) -> None
        
        Indicate keypoint preference, and suppress all others.
        """
        ...
    
    def GetWorldToLocal(*args, **kwargs):
        """
        GetWorldToLocal(self: MSPyBentleyGeom.CurveKeyPointCollector, worldToLocal: Bentley.DMatrix4d) -> bool
        
        Query the worldTolocal matrix.
        """
        ...
    
    class KeyPointType:
        """
        Members:
        
        eEndPoint
        
        ePerpendicular
        
        eTangency
        
        eBreakPoint
        
        eNumTypes
        """
    
        def __init__(self: MSPyBentleyGeom.CurveKeyPointCollector.KeyPointType, value: int) -> None:
            ...
        
        eBreakPoint: KeyPointType
        
        eEndPoint: KeyPointType
        
        eNumTypes: KeyPointType
        
        ePerpendicular: KeyPointType
        
        eTangency: KeyPointType
        
        @property
        def name(self: handle) -> str:
            ...
        
        @property
        def value(arg0: MSPyBentleyGeom.CurveKeyPointCollector.KeyPointType) -> int:
            ...
        
    def NeedKeyPointType(*args, **kwargs):
        """
        NeedKeyPointType(self: MSPyBentleyGeom.CurveKeyPointCollector, selector: MSPyBentleyGeom.CurveKeyPointCollector.KeyPointType) -> bool
        
        Ask if a particular KeyPointType is requested.
        """
        ...
    
    def SetXYOnly(*args, **kwargs):
        """
        SetXYOnly(self: MSPyBentleyGeom.CurveKeyPointCollector, worldToLocal: Bentley.DMatrix4d) -> None
        
        Request projection to XY plane.
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.CurveKeyPointCollector) -> None:
        ...
    
    eBreakPoint: KeyPointType
    
    eEndPoint: KeyPointType
    
    eNumTypes: KeyPointType
    
    ePerpendicular: KeyPointType
    
    eTangency: KeyPointType
    
class CurveKeyPoint_ClosestPointCollector:
    """
    None
    """

    def AnnouncePoint(*args, **kwargs):
        """
        AnnouncePoint(self: MSPyBentleyGeom.CurveKeyPoint_ClosestPointCollector, worldDetail: MSPyBentleyGeom.CurveLocationDetail, selector: MSPyBentleyGeom.CurveKeyPointCollector.KeyPointType) -> None
        
        Announce a keypoint in world form. Derived class override captures as
        needed.
        """
        ...
    
    def EnableKeyPointType(*args, **kwargs):
        """
        EnableKeyPointType(self: MSPyBentleyGeom.CurveKeyPointCollector, selector: MSPyBentleyGeom.CurveKeyPointCollector.KeyPointType, value: bool) -> None
        
        Indicate keypoint preference
        """
        ...
    
    def EnableSingleKeyPointType(*args, **kwargs):
        """
        EnableSingleKeyPointType(self: MSPyBentleyGeom.CurveKeyPointCollector, selector: MSPyBentleyGeom.CurveKeyPointCollector.KeyPointType) -> None
        
        Indicate keypoint preference, and suppress all others.
        """
        ...
    
    def GetResult(*args, **kwargs):
        """
        GetResult(self: MSPyBentleyGeom.CurveKeyPoint_ClosestPointCollector) -> tuple
        
        Access the saved detail
        """
        ...
    
    def GetWorldToLocal(*args, **kwargs):
        """
        GetWorldToLocal(self: MSPyBentleyGeom.CurveKeyPointCollector, worldToLocal: Bentley.DMatrix4d) -> bool
        
        Query the worldTolocal matrix.
        """
        ...
    
    class KeyPointType:
        """
        Members:
        
        eEndPoint
        
        ePerpendicular
        
        eTangency
        
        eBreakPoint
        
        eNumTypes
        """
    
        def __init__(self: MSPyBentleyGeom.CurveKeyPointCollector.KeyPointType, value: int) -> None:
            ...
        
        eBreakPoint: KeyPointType
        
        eEndPoint: KeyPointType
        
        eNumTypes: KeyPointType
        
        ePerpendicular: KeyPointType
        
        eTangency: KeyPointType
        
        @property
        def name(self: handle) -> str:
            ...
        
        @property
        def value(arg0: MSPyBentleyGeom.CurveKeyPointCollector.KeyPointType) -> int:
            ...
        
    def NeedKeyPointType(*args, **kwargs):
        """
        NeedKeyPointType(self: MSPyBentleyGeom.CurveKeyPointCollector, selector: MSPyBentleyGeom.CurveKeyPointCollector.KeyPointType) -> bool
        
        Ask if a particular KeyPointType is requested.
        """
        ...
    
    def SetXYOnly(*args, **kwargs):
        """
        SetXYOnly(self: MSPyBentleyGeom.CurveKeyPointCollector, worldToLocal: Bentley.DMatrix4d) -> None
        
        Request projection to XY plane.
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.CurveKeyPoint_ClosestPointCollector, biasPoint: Bentley.DPoint3d) -> None:
        ...
    
    eBreakPoint: KeyPointType
    
    eEndPoint: KeyPointType
    
    eNumTypes: KeyPointType
    
    ePerpendicular: KeyPointType
    
    eTangency: KeyPointType
    
class CurveLocationDetail:
    """
    None
    """

    def AlmostEqualPoint(*args, **kwargs):
        """
        AlmostEqualPoint(self: MSPyBentleyGeom.CurveLocationDetail, other: MSPyBentleyGeom.CurveLocationDetail) -> bool
        
        test if point coordinates are AlmostEqual
        """
        ...
    
    def Distance(*args, **kwargs):
        """
        Distance(self: MSPyBentleyGeom.CurveLocationDetail, other: MSPyBentleyGeom.CurveLocationDetail) -> float
        
        Return distance between point fields of this and other.
        """
        ...
    
    def Interpolate(*args, **kwargs):
        """
        Interpolate(*args, **kwargs)
        Overloaded function.
        
        1. Interpolate(self: MSPyBentleyGeom.CurveLocationDetail, param: MSPyBentley.DoubleArray) -> tuple
        
        Use the componentIndex and componentFraction to interpolate doubles.
        
        2. Interpolate(self: MSPyBentleyGeom.CurveLocationDetail, fraction: float, dataB: MSPyBentleyGeom.CurveLocationDetail) -> MSPyBentleyGeom.ValidatedCurveLocationDetail
        
        Use the componentIndex and componentFraction to interpolate doubles.
        """
        ...
    
    def PointAndUnitTangent(*args, **kwargs):
        """
        PointAndUnitTangent(self: MSPyBentleyGeom.CurveLocationDetail) -> Bentley.ValidatedValue<Bentley.DRay3d>
        
        Try to evalute the point and unit tangent at the detail's fraction
        """
        ...
    
    def SetComponentFractionFromFraction(*args, **kwargs):
        """
        SetComponentFractionFromFraction(self: MSPyBentleyGeom.CurveLocationDetail, globalFraction: float, numComponent: int) -> None
        
        Set the componentIndex, numComponent, componentFraction, and fraction.
        (Component fraction and index are computed from global fraction and
        indices) All other data (point, curve pointer, a) is left unchanged.
        """
        ...
    
    def SetDistance(*args, **kwargs):
        """
        SetDistance(self: MSPyBentleyGeom.CurveLocationDetail, value: float) -> None
        
        set distance field ({a})
        """
        ...
    
    def SetDistanceFrom(*args, **kwargs):
        """
        SetDistanceFrom(self: MSPyBentleyGeom.CurveLocationDetail, refPoint: Bentley.DPoint3d) -> float
        
        set xyz distance from point.
        """
        ...
    
    def SetFractionFromComponentFraction(*args, **kwargs):
        """
        SetFractionFromComponentFraction(self: MSPyBentleyGeom.CurveLocationDetail, componentFraction: float, componentIndex: int, numComponent: int) -> None
        
        Set the componentIndex, numComponent, componentFraction, and fraction.
        (Global fraction is computed as (componentIndex + componentFraction)/
        numComponent. All other data (point, curve pointer, a) is left
        unchanged.
        """
        ...
    
    def SetMaxDistance(*args, **kwargs):
        """
        SetMaxDistance(self: MSPyBentleyGeom.CurveLocationDetail) -> None
        
        set distance to very large value.
        """
        ...
    
    def SetSingleComponentData(*args, **kwargs):
        """
        SetSingleComponentData(self: MSPyBentleyGeom.CurveLocationDetail) -> None
        
        copy fraction to componentFraction and set component index and count
        for single component.
        """
        ...
    
    def SetSingleComponentFractionAndA(*args, **kwargs):
        """
        SetSingleComponentFractionAndA(self: MSPyBentleyGeom.CurveLocationDetail, fraction: float, a: float) -> None
        
        Set fraction and a fields from parameters. Make the component fraction
        match. Set componentIndex and numComponentIndex to 0 and 1.
        """
        ...
    
    def SortByCurveAndFraction(*args, **kwargs):
        """
        SortByCurveAndFraction(detail: MSPyBentleyGeom.CurveLocationDetailArray) -> None
        
        Sort to gather CurveLocationDetail's with same curve, and then by
        fraction within those curves.
        """
        ...
    
    def TryComponentFractionToPoint(*args, **kwargs):
        """
        TryComponentFractionToPoint(self: MSPyBentleyGeom.CurveLocationDetail, xyz: Bentley.DPoint3d, dXdf: Bentley.DVec3d) -> bool
        
        Try to evaluate the referenced curve at the detail's component
        fraction.
        """
        ...
    
    def TryFractionToPoint(*args, **kwargs):
        """
        TryFractionToPoint(self: MSPyBentleyGeom.CurveLocationDetail, xyz: Bentley.DPoint3d, dXdf: Bentley.DVec3d) -> bool
        
        Try to evaluate the referenced curve at the detail's fraction.
        """
        ...
    
    def UpdateIfCloser(*args, **kwargs):
        """
        UpdateIfCloser(self: MSPyBentleyGeom.CurveLocationDetail, otherDetail: MSPyBentleyGeom.CurveLocationDetail) -> bool
        
        conditional replace candidate, with minDistance update if needed.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.CurveLocationDetail) -> None
        
        2. __init__(self: MSPyBentleyGeom.CurveLocationDetail, curve: Bentley.ICurvePrimitive, numComponent: int = 1) -> None
        
        3. __init__(self: MSPyBentleyGeom.CurveLocationDetail, curve: Bentley.ICurvePrimitive, fraction: float, point: Bentley.DPoint3d) -> None
        
        4. __init__(self: MSPyBentleyGeom.CurveLocationDetail, curve: Bentley.ICurvePrimitive, fraction: float, point: Bentley.DPoint3d, componentIndex: int, numComponent: int, componentFraction: float) -> None
        
        5. __init__(self: MSPyBentleyGeom.CurveLocationDetail, curve: Bentley.ICurvePrimitive, fraction: float, point: Bentley.DPoint3d, componentIndex: int, numComponent: int, componentFraction: float, a: float) -> None
        """
        ...
    
    @property
    def a(self: MSPyBentleyGeom.CurveLocationDetail) -> float:
        ...
    @a.setter
    def a(self: MSPyBentleyGeom.CurveLocationDetail, arg0: float) -> None:
        ...
    
    @property
    def componentFraction(self: MSPyBentleyGeom.CurveLocationDetail) -> float:
        ...
    @componentFraction.setter
    def componentFraction(self: MSPyBentleyGeom.CurveLocationDetail, arg0: float) -> None:
        ...
    
    @property
    def componentIndex(self: MSPyBentleyGeom.CurveLocationDetail) -> int:
        ...
    @componentIndex.setter
    def componentIndex(self: MSPyBentleyGeom.CurveLocationDetail, arg0: int) -> None:
        ...
    
    @property
    def curve(arg0: MSPyBentleyGeom.CurveLocationDetail) -> Bentley.ICurvePrimitive:
        ...
    
    @property
    def fraction(self: MSPyBentleyGeom.CurveLocationDetail) -> float:
        ...
    @fraction.setter
    def fraction(self: MSPyBentleyGeom.CurveLocationDetail, arg0: float) -> None:
        ...
    
    @property
    def numComponent(self: MSPyBentleyGeom.CurveLocationDetail) -> int:
        ...
    @numComponent.setter
    def numComponent(self: MSPyBentleyGeom.CurveLocationDetail, arg0: int) -> None:
        ...
    
    @property
    def point(self: MSPyBentleyGeom.CurveLocationDetail) -> Bentley.DPoint3d:
        ...
    @point.setter
    def point(self: MSPyBentleyGeom.CurveLocationDetail, arg0: Bentley.DPoint3d) -> None:
        ...
    
class CurveLocationDetailArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.CurveLocationDetailArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.CurveLocationDetailArray, arg0: MSPyBentleyGeom.CurveLocationDetailArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.CurveLocationDetailArray, arg0: Iterable) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.CurveLocationDetailArray, x: MSPyBentleyGeom.CurveLocationDetail) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.CurveLocationDetailArray) -> None
        
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.CurveLocationDetailArray, L: MSPyBentleyGeom.CurveLocationDetailArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.CurveLocationDetailArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.CurveLocationDetailArray, i: int, x: MSPyBentleyGeom.CurveLocationDetail) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.CurveLocationDetailArray) -> MSPyBentleyGeom.CurveLocationDetail
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.CurveLocationDetailArray, i: int) -> MSPyBentleyGeom.CurveLocationDetail
        
        Remove and return the item at index ``i``
        """
        ...
    
class CurveLocationDetailPair:
    """
    None
    """

    def GetDSegment3d(*args, **kwargs):
        """
        GetDSegment3d(self: MSPyBentleyGeom.CurveLocationDetailPair) -> Bentley.DSegment3d
        
        assemble points from detailA, detailB into a DSegment3d.
        """
        ...
    
    def SameCurveAndFraction(*args, **kwargs):
        """
        SameCurveAndFraction(self: MSPyBentleyGeom.CurveLocationDetailPair) -> bool
        
        Return true if the two details are for (bitwise) identical curve and
        fraction.
        """
        ...
    
    def Set(*args, **kwargs):
        """
        Set(*args, **kwargs)
        Overloaded function.
        
        1. Set(self: MSPyBentleyGeom.CurveLocationDetailPair, fraction0: float, point0: Bentley.DPoint3d, a0: float, fraction1: float, point1: Bentley.DPoint3d, a1: float) -> None
        
        update fractions, points, and a
        
        2. Set(self: MSPyBentleyGeom.CurveLocationDetailPair, curveA: Bentley.ICurvePrimitive, curveB: Bentley.ICurvePrimitive) -> None
        
        update fractions, points, and a
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.CurveLocationDetailPair) -> None
        
        2. __init__(self: MSPyBentleyGeom.CurveLocationDetailPair, detailA: MSPyBentleyGeom.CurveLocationDetail, detailB: MSPyBentleyGeom.CurveLocationDetail) -> None
        
        3. __init__(self: MSPyBentleyGeom.CurveLocationDetailPair, detailA: MSPyBentleyGeom.CurveLocationDetail) -> None
        
        4. __init__(self: MSPyBentleyGeom.CurveLocationDetailPair, curve: Bentley.ICurvePrimitive, fraction0: float, point0: Bentley.DPoint3d) -> None
        
        5. __init__(self: MSPyBentleyGeom.CurveLocationDetailPair, curve: Bentley.ICurvePrimitive, fraction0: float, point0: Bentley.DPoint3d, componentIndex: int, numComponent: int, componentFraction: float) -> None
        
        6. __init__(self: MSPyBentleyGeom.CurveLocationDetailPair, curve0: Bentley.ICurvePrimitive, a0: float, curve1: Bentley.ICurvePrimitive, a1: float) -> None
        """
        ...
    
    @property
    def detailA(self: MSPyBentleyGeom.CurveLocationDetailPair) -> MSPyBentleyGeom.CurveLocationDetail:
        ...
    @detailA.setter
    def detailA(self: MSPyBentleyGeom.CurveLocationDetailPair, arg0: MSPyBentleyGeom.CurveLocationDetail) -> None:
        ...
    
    @property
    def detailB(self: MSPyBentleyGeom.CurveLocationDetailPair) -> MSPyBentleyGeom.CurveLocationDetail:
        ...
    @detailB.setter
    def detailB(self: MSPyBentleyGeom.CurveLocationDetailPair, arg0: MSPyBentleyGeom.CurveLocationDetail) -> None:
        ...
    
class CurveLocationDetailPairArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.CurveLocationDetailPairArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.CurveLocationDetailPairArray, arg0: MSPyBentleyGeom.CurveLocationDetailPairArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.CurveLocationDetailPairArray, arg0: Iterable) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.CurveLocationDetailPairArray, x: MSPyBentleyGeom.CurveLocationDetailPair) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.CurveLocationDetailPairArray) -> None
        
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.CurveLocationDetailPairArray, L: MSPyBentleyGeom.CurveLocationDetailPairArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.CurveLocationDetailPairArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.CurveLocationDetailPairArray, i: int, x: MSPyBentleyGeom.CurveLocationDetailPair) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.CurveLocationDetailPairArray) -> MSPyBentleyGeom.CurveLocationDetailPair
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.CurveLocationDetailPairArray, i: int) -> MSPyBentleyGeom.CurveLocationDetailPair
        
        Remove and return the item at index ``i``
        """
        ...
    
class CurveOffsetOptions:
    """
    None
    """

    @property
    def ArcAngle(arg0: MSPyBentleyGeom.CurveOffsetOptions) -> float:
        ...
    @ArcAngle.setter
    def ArcAngle(arg0: MSPyBentleyGeom.CurveOffsetOptions, arg1: float) -> None:
        ...
    
    @property
    def BCurveMethod(arg0: MSPyBentleyGeom.CurveOffsetOptions) -> int:
        ...
    @BCurveMethod.setter
    def BCurveMethod(arg0: MSPyBentleyGeom.CurveOffsetOptions, arg1: int) -> None:
        ...
    
    @property
    def BCurvePointsPerKnot(arg0: MSPyBentleyGeom.CurveOffsetOptions) -> int:
        ...
    @BCurvePointsPerKnot.setter
    def BCurvePointsPerKnot(arg0: MSPyBentleyGeom.CurveOffsetOptions, arg1: int) -> None:
        ...
    
    @property
    def ChamferAngle(arg0: MSPyBentleyGeom.CurveOffsetOptions) -> float:
        ...
    @ChamferAngle.setter
    def ChamferAngle(arg0: MSPyBentleyGeom.CurveOffsetOptions, arg1: float) -> None:
        ...
    
    @property
    def ForceClosure(arg0: MSPyBentleyGeom.CurveOffsetOptions) -> bool:
        ...
    @ForceClosure.setter
    def ForceClosure(arg0: MSPyBentleyGeom.CurveOffsetOptions, arg1: bool) -> None:
        ...
    
    def GetArcAngle(*args, **kwargs):
        """
        GetArcAngle(self: MSPyBentleyGeom.CurveOffsetOptions) -> float
        """
        ...
    
    def GetBCurveMethod(*args, **kwargs):
        """
        GetBCurveMethod(self: MSPyBentleyGeom.CurveOffsetOptions) -> int
        """
        ...
    
    def GetBCurvePointsPerKnot(*args, **kwargs):
        """
        GetBCurvePointsPerKnot(self: MSPyBentleyGeom.CurveOffsetOptions) -> int
        """
        ...
    
    def GetChamferAngle(*args, **kwargs):
        """
        GetChamferAngle(self: MSPyBentleyGeom.CurveOffsetOptions) -> float
        """
        ...
    
    def GetForceClosure(*args, **kwargs):
        """
        GetForceClosure(self: MSPyBentleyGeom.CurveOffsetOptions) -> bool
        """
        ...
    
    def GetOffsetDistance(*args, **kwargs):
        """
        GetOffsetDistance(self: MSPyBentleyGeom.CurveOffsetOptions) -> float
        """
        ...
    
    def GetTolerance(*args, **kwargs):
        """
        GetTolerance(self: MSPyBentleyGeom.CurveOffsetOptions) -> float
        """
        ...
    
    @property
    def OffsetDistance(arg0: MSPyBentleyGeom.CurveOffsetOptions) -> float:
        ...
    @OffsetDistance.setter
    def OffsetDistance(arg0: MSPyBentleyGeom.CurveOffsetOptions, arg1: float) -> None:
        ...
    
    def SetArcAngle(*args, **kwargs):
        """
        SetArcAngle(self: MSPyBentleyGeom.CurveOffsetOptions, valueRadians: float) -> None
        """
        ...
    
    def SetBCurveMethod(*args, **kwargs):
        """
        SetBCurveMethod(self: MSPyBentleyGeom.CurveOffsetOptions, n: int) -> None
        """
        ...
    
    def SetBCurvePointsPerKnot(*args, **kwargs):
        """
        SetBCurvePointsPerKnot(self: MSPyBentleyGeom.CurveOffsetOptions, n: int) -> None
        """
        ...
    
    def SetChamferAngle(*args, **kwargs):
        """
        SetChamferAngle(self: MSPyBentleyGeom.CurveOffsetOptions, value: float) -> None
        """
        ...
    
    def SetForceClosure(*args, **kwargs):
        """
        SetForceClosure(self: MSPyBentleyGeom.CurveOffsetOptions, value: bool) -> None
        """
        ...
    
    def SetOffsetDistance(*args, **kwargs):
        """
        SetOffsetDistance(self: MSPyBentleyGeom.CurveOffsetOptions, distance: float) -> None
        """
        ...
    
    def SetTolerance(*args, **kwargs):
        """
        SetTolerance(self: MSPyBentleyGeom.CurveOffsetOptions, tol: float) -> None
        """
        ...
    
    @property
    def Tolerance(arg0: MSPyBentleyGeom.CurveOffsetOptions) -> float:
        ...
    @Tolerance.setter
    def Tolerance(arg0: MSPyBentleyGeom.CurveOffsetOptions, arg1: float) -> None:
        ...
    
    def __init__(self: MSPyBentleyGeom.CurveOffsetOptions, offsetDistance: float) -> None:
        ...
    
class CurveParameterMapping:
    """
    Members:
    
    eCURVE_PARAMETER_MAPPING_BezierFraction
    
    eCURVE_PARAMETER_MAPPING_CurveKnot
    
    eCURVE_PARAMETER_MAPPING_CurveFraction
    """

    def __init__(self: MSPyBentleyGeom.CurveParameterMapping, value: int) -> None:
        ...
    
    eCURVE_PARAMETER_MAPPING_BezierFraction: CurveParameterMapping
    
    eCURVE_PARAMETER_MAPPING_CurveFraction: CurveParameterMapping
    
    eCURVE_PARAMETER_MAPPING_CurveKnot: CurveParameterMapping
    
    @property
    def name(self: handle) -> str:
        ...
    
    @property
    def value(arg0: MSPyBentleyGeom.CurveParameterMapping) -> int:
        ...
    
class CurvePrimitiveId:
    """
    None
    """

    def Clone(*args, **kwargs):
        """
        Clone(self: MSPyBentleyGeom.CurvePrimitiveId) -> MSPyBentleyGeom.CurvePrimitiveId
        
        Return a copy.
        """
        ...
    
    @property
    def CurveTopologyId(arg0: MSPyBentleyGeom.CurvePrimitiveId) -> Bentley.CurveTopologyId:
        ...
    
    @property
    def DebugString(arg0: MSPyBentleyGeom.CurvePrimitiveId) -> MSPyBentley.WString:
        ...
    
    def GetCompoundDrawState(*args, **kwargs):
        """
        GetCompoundDrawState(self: MSPyBentleyGeom.CurvePrimitiveId) -> MSPyBentleyGeom.CompoundDrawState
        
        Query the compound draw state (refCounted)
        """
        ...
    
    def GetCurveTopologyId(*args, **kwargs):
        """
        GetCurveTopologyId(self: MSPyBentleyGeom.CurvePrimitiveId) -> Bentley.CurveTopologyId
        
        Return the topologyId object. This may fail (and return defaulted
        structure) for some types.
        """
        ...
    
    def GetDebugString(*args, **kwargs):
        """
        GetDebugString(self: MSPyBentleyGeom.CurvePrimitiveId) -> MSPyBentley.WString
        
        Get debug string
        """
        ...
    
    def GetLineStringAssociationIds(*args, **kwargs):
        """
        GetLineStringAssociationIds(self: MSPyBentleyGeom.CurvePrimitiveId, nTargetIds: int) -> tuple
        
        If this is a Type_PolyfaceCut with exactly nTargetIds id values, copy
        out the topology type and the ids.
        """
        ...
    
    def GetParasolidBodyId(*args, **kwargs):
        """
        GetParasolidBodyId(self: MSPyBentleyGeom.CurvePrimitiveId, id: Bentley.CurveTopologyId) -> Bentley.BentleyStatus
        
        Copy data to target object if this is a parasolid body.
        """
        ...
    
    def GetRawIdString(*args, **kwargs):
        """
        GetRawIdString(self: MSPyBentleyGeom.CurvePrimitiveId) -> MSPyBentley.WString
        
        Get hex form of the ids
        """
        ...
    
    def GetSolidPrimitiveId(*args, **kwargs):
        """
        GetSolidPrimitiveId(self: MSPyBentleyGeom.CurvePrimitiveId, id: Bentley.CurveTopologyId) -> Bentley.BentleyStatus
        
        Copy data to target object if this is a solid primitive.
        """
        ...
    
    def GetType(*args, **kwargs):
        """
        GetType(self: MSPyBentleyGeom.CurvePrimitiveId) -> MSPyBentleyGeom.CurvePrimitiveId.Type
        
        Get the type code.
        """
        ...
    
    @property
    def RawIdString(arg0: MSPyBentleyGeom.CurvePrimitiveId) -> MSPyBentley.WString:
        ...
    
    def SetCompoundDrawState(*args, **kwargs):
        """
        SetCompoundDrawState(self: MSPyBentleyGeom.CurvePrimitiveId, arg0: MSPyBentleyGeom.CompoundDrawState) -> None
        
        Set the compound draw state.
        """
        ...
    
    def Store(*args, **kwargs):
        """
        Store(self: MSPyBentleyGeom.CurvePrimitiveId, data: MSPyBentley.UInt8Array) -> None
        
        Copy the id data into bytes.
        """
        ...
    
    @property
    def Type(arg0: MSPyBentleyGeom.CurvePrimitiveId) -> MSPyBentleyGeom.CurvePrimitiveId.Type:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.CurvePrimitiveId, type: MSPyBentleyGeom.CurvePrimitiveId.Type, data: bytes, cds: MSPyBentleyGeom.CompoundDrawState) -> None
        
        2. __init__(self: MSPyBentleyGeom.CurvePrimitiveId, type: MSPyBentleyGeom.CurvePrimitiveId.Type, topologyId: Bentley.CurveTopologyId, cds: MSPyBentleyGeom.CompoundDrawState) -> None
        
        3. __init__(self: MSPyBentleyGeom.CurvePrimitiveId, data: bytes) -> None
        
        4. __init__(self: MSPyBentleyGeom.CurvePrimitiveId, id: MSPyBentleyGeom.CurvePrimitiveId) -> None
        """
        ...
    
    eType_ACISCut: Type
    
    eType_CachedCut: Type
    
    eType_CachedEdge: Type
    
    eType_CachedUnderlay: Type
    
    eType_CurveVector: Type
    
    eType_CutGeometry: Type
    
    eType_Max: Type
    
    eType_OpenCascadeBody: Type
    
    eType_ParaSolidBody: Type
    
    eType_ParaSolidCut: Type
    
    eType_PolyfaceCut: Type
    
    eType_PolyfaceEdge: Type
    
    eType_SolidPrimitive: Type
    
    eType_UnspecifiedTopologyId: Type
    
    eType_UnusedWasFacetSet: Type
    
class CurveTopologyId:
    """
    None
    """

    def AddCurveVectorIds(*args, **kwargs):
        """
        AddCurveVectorIds(curveVector: Bentley.CurveVector, type: MSPyBentleyGeom.CurvePrimitiveId.Type, id: MSPyBentleyGeom.CurveTopologyId, cds: MSPyBentleyGeom.CompoundDrawState) -> Bentley.BentleyStatus
        """
        ...
    
    def Clear(*args, **kwargs):
        """
        Clear(self: MSPyBentleyGeom.CurveTopologyId) -> None
        
        Clear the id array and set the type code to default unknown value.
        """
        ...
    
    @property
    def Count(arg0: MSPyBentleyGeom.CurveTopologyId) -> int:
        ...
    
    @property
    def DebugString(arg0: MSPyBentleyGeom.CurveTopologyId) -> MSPyBentley.WString:
        ...
    
    def FromBRepIsoline(*args, **kwargs):
        """
        FromBRepIsoline(faceId: Bentley.faceId, isolineIndex: int) -> MSPyBentleyGeom.CurveTopologyId
        
        construct and return with FaceId and isolineIndex
        """
        ...
    
    def FromBRepPlanarFace(*args, **kwargs):
        """
        FromBRepPlanarFace(faceId: Bentley.faceId) -> MSPyBentleyGeom.CurveTopologyId
        
        Construct and return for brep edge with one face.
        """
        ...
    
    def FromBRepSharedEdge(*args, **kwargs):
        """
        FromBRepSharedEdge(faceId0: Bentley.faceId, faceId1: Bentley.faceId) -> MSPyBentleyGeom.CurveTopologyId
        
        Construct an return for brep edge with two faces.
        """
        ...
    
    def FromBRepSheetEdge(*args, **kwargs):
        """
        FromBRepSheetEdge(edgeId: Bentley.faceId) -> MSPyBentleyGeom.CurveTopologyId
        
        Construct and return for brep edge with one face.
        """
        ...
    
    def FromBRepSilhouette(*args, **kwargs):
        """
        FromBRepSilhouette(edgeId: Bentley.faceId) -> MSPyBentleyGeom.CurveTopologyId
        
        Construct and return for brep silhouette edge.
        """
        ...
    
    def FromCurveVector(*args, **kwargs):
        """
        FromCurveVector() -> MSPyBentleyGeom.CurveTopologyId
        
        construct and return for curve vector
        """
        ...
    
    def FromGeometryMap(*args, **kwargs):
        """
        FromGeometryMap() -> MSPyBentleyGeom.CurveTopologyId
        
        construct and return for geometry map.
        """
        ...
    
    def FromMeshEdgeVertices(*args, **kwargs):
        """
        FromMeshEdgeVertices(vertexIndex0: int, vertexIndex1: int) -> MSPyBentleyGeom.CurveTopologyId
        
        construct and return for mesh edge with 2 vertices
        """
        ...
    
    def FromMeshSharedEdge(*args, **kwargs):
        """
        FromMeshSharedEdge(faceIndex0: int, faceIndex1: int) -> MSPyBentleyGeom.CurveTopologyId
        
        construct and return for mesh edge with 2 faces
        """
        ...
    
    def FromParasolidGPArrayId(*args, **kwargs):
        """
        FromParasolidGPArrayId(arg0: int, arg1: int) -> MSPyBentleyGeom.CurveTopologyId
        
        construct and return from Parasolid parasolid GPArray ID
        """
        ...
    
    def FromSweepLateral(*args, **kwargs):
        """
        FromSweepLateral(lateralIndex: int) -> MSPyBentleyGeom.CurveTopologyId
        
        construct and return for indexed lateral within sweep.
        """
        ...
    
    def FromSweepProfile(*args, **kwargs):
        """
        FromSweepProfile(profileIndex: int) -> MSPyBentleyGeom.CurveTopologyId
        
        construct and return for index of swept profile curve.
        """
        ...
    
    def FromSweepSilhouette(*args, **kwargs):
        """
        FromSweepSilhouette(silhouetteIndex: int) -> MSPyBentleyGeom.CurveTopologyId
        
        construct and return for silhouette of sweep
        """
        ...
    
    def FromUnknownCurve(*args, **kwargs):
        """
        FromUnknownCurve(curveIndex: int) -> MSPyBentleyGeom.CurveTopologyId
        
        construct and return for unknown curve
        """
        ...
    
    def FromVisEdgesAnalytic(*args, **kwargs):
        """
        FromVisEdgesAnalytic(curveIndex: int) -> MSPyBentleyGeom.CurveTopologyId
        """
        ...
    
    def FromVisEdgesBoundedPlane(*args, **kwargs):
        """
        FromVisEdgesBoundedPlane(arg0: int) -> MSPyBentleyGeom.CurveTopologyId
        
        construct and return for indexed loop in visible edges
        """
        ...
    
    def FromVisEdgesIntersection(*args, **kwargs):
        """
        FromVisEdgesIntersection() -> MSPyBentleyGeom.CurveTopologyId
        
        construct and return for intersection curve in visible edges
        """
        ...
    
    def FromWire(*args, **kwargs):
        """
        FromWire() -> MSPyBentleyGeom.CurveTopologyId
        
        construct and return for wire edge
        """
        ...
    
    def GetBRepIsoline(*args, **kwargs):
        """
        GetBRepIsoline(self: MSPyBentleyGeom.CurveTopologyId, faceId: Bentley.faceId) -> tuple
        
        Extract brep isoline.
        """
        ...
    
    def GetBRepPlanarFace(*args, **kwargs):
        """
        GetBRepPlanarFace(self: MSPyBentleyGeom.CurveTopologyId, faceId: Bentley.faceId) -> Bentley.BentleyStatus
        """
        ...
    
    def GetBRepSharedEdge(*args, **kwargs):
        """
        GetBRepSharedEdge(self: MSPyBentleyGeom.CurveTopologyId, faceId0: Bentley.faceId, faceId1: Bentley.faceId) -> Bentley.BentleyStatus
        
        extract adjacent faces of brep edge
        """
        ...
    
    def GetBRepSheetEdge(*args, **kwargs):
        """
        GetBRepSheetEdge(self: MSPyBentleyGeom.CurveTopologyId, edgeId: Bentley.faceId) -> Bentley.BentleyStatus
        
        extract adjacent face of brep edge
        """
        ...
    
    def GetCount(*args, **kwargs):
        """
        GetCount(self: MSPyBentleyGeom.CurveTopologyId) -> int
        
        Return the id data count (in UInt32's)
        """
        ...
    
    def GetDebugString(*args, **kwargs):
        """
        GetDebugString(self: MSPyBentleyGeom.CurveTopologyId) -> MSPyBentley.WString
        
        Return debug string form
        """
        ...
    
    def GetId(*args, **kwargs):
        """
        GetId(self: MSPyBentleyGeom.CurveTopologyId, index: int) -> int
        
        Return id by index
        """
        ...
    
    def GetType(*args, **kwargs):
        """
        GetType(self: MSPyBentleyGeom.CurveTopologyId) -> MSPyBentleyGeom.CurveTopologyId.Type
        
        Return the type code
        """
        ...
    
    def Init(*args, **kwargs):
        """
        Init(*args, **kwargs)
        Overloaded function.
        
        1. Init(self: MSPyBentleyGeom.CurveTopologyId, type: MSPyBentleyGeom.CurveTopologyId.Type, ids: MSPyBentley.UInt32Array) -> None
        
        Initializer with type code and array of ids.
        
        2. Init(self: MSPyBentleyGeom.CurveTopologyId, ids: MSPyBentley.UInt32Array) -> None
        
        Initializer with type code and array of ids.
        """
        ...
    
    def IsEmpty(*args, **kwargs):
        """
        IsEmpty(self: MSPyBentleyGeom.CurveTopologyId) -> bool
        
        Return true if there are no ids.
        """
        ...
    
    def Pack(*args, **kwargs):
        """
        Pack(self: MSPyBentleyGeom.CurveTopologyId, packed: MSPyBentley.UInt8Array) -> None
        
        Return a packed form of the ids.
        """
        ...
    
    @property
    def Type(arg0: MSPyBentleyGeom.CurveTopologyId) -> MSPyBentleyGeom.CurveTopologyId.Type:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.CurveTopologyId) -> None
        
        2. __init__(self: MSPyBentleyGeom.CurveTopologyId, type: MSPyBentleyGeom.CurveTopologyId.Type) -> None
        
        3. __init__(self: MSPyBentleyGeom.CurveTopologyId, type: MSPyBentleyGeom.CurveTopologyId.Type, id: int) -> None
        
        4. __init__(self: MSPyBentleyGeom.CurveTopologyId, type: MSPyBentleyGeom.CurveTopologyId.Type, id0: int, id1: int) -> None
        
        5. __init__(self: MSPyBentleyGeom.CurveTopologyId, type: MSPyBentleyGeom.CurveTopologyId.Type, id0: int, id1: int, id2: int) -> None
        
        6. __init__(self: MSPyBentleyGeom.CurveTopologyId, rhs: MSPyBentleyGeom.CurveTopologyId) -> None
        
        7. __init__(self: MSPyBentleyGeom.CurveTopologyId, curveId: MSPyBentleyGeom.CurveTopologyId, id: int) -> None
        
        8. __init__(self: MSPyBentleyGeom.CurveTopologyId, id: int, curveId: MSPyBentleyGeom.CurveTopologyId) -> None
        """
        ...
    
    eType_BRepIsoIsoline: Type
    
    eType_BRepPlanarFace: Type
    
    eType_BRepSharedEdge: Type
    
    eType_BRepSheetEdge: Type
    
    eType_BRepSilhouette: Type
    
    eType_CurveVector: Type
    
    eType_CutFill: Type
    
    eType_CutWires: Type
    
    eType_GeometryMap: Type
    
    eType_IndexedMeshEdge: Type
    
    eType_Max: Type
    
    eType_MeshEdgeVertices: Type
    
    eType_MeshSharedEdge: Type
    
    eType_MeshSheetEdge: Type
    
    eType_MeshUnknown: Type
    
    eType_PolyfaceCut: Type
    
    eType_PolyfaceEdge: Type
    
    eType_SweepLateral: Type
    
    eType_SweepProfile: Type
    
    eType_SweepSilhouette: Type
    
    eType_UnannnouncedSectionShape: Type
    
    eType_UnannouncedSectionWire: Type
    
    eType_Unknown: Type
    
    eType_VisEdgesAnalytic: Type
    
    eType_VisEdgesBoundedPlane: Type
    
    eType_VisEdgesIntersection: Type
    
    eType_Wire: Type
    
class CurveTopologyIdArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.CurveTopologyIdArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.CurveTopologyIdArray, arg0: MSPyBentleyGeom.CurveTopologyIdArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.CurveTopologyIdArray, arg0: Iterable) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.CurveTopologyIdArray, x: MSPyBentleyGeom.CurveTopologyId) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.CurveTopologyIdArray) -> None
        
        Clear the contents
        """
        ...
    
    def count(*args, **kwargs):
        """
        count(self: MSPyBentleyGeom.CurveTopologyIdArray, x: MSPyBentleyGeom.CurveTopologyId) -> int
        
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.CurveTopologyIdArray, L: MSPyBentleyGeom.CurveTopologyIdArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.CurveTopologyIdArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.CurveTopologyIdArray, i: int, x: MSPyBentleyGeom.CurveTopologyId) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.CurveTopologyIdArray) -> MSPyBentleyGeom.CurveTopologyId
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.CurveTopologyIdArray, i: int) -> MSPyBentleyGeom.CurveTopologyId
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(*args, **kwargs):
        """
        remove(self: MSPyBentleyGeom.CurveTopologyIdArray, x: MSPyBentleyGeom.CurveTopologyId) -> None
        
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class CurveVector:
    """
    None
    """

    def Add(*args, **kwargs):
        """
        Add(*args, **kwargs)
        Overloaded function.
        
        1. Add(self: MSPyBentleyGeom.CurveVector, child: MSPyBentleyGeom.ICurvePrimitive) -> None
        
        add single curve primitive
        
        2. Add(self: MSPyBentleyGeom.CurveVector, child: MSPyBentleyGeom.CurveVector) -> None
        
        add single curve primitive
        """
        ...
    
    def AddPrimitives(*args, **kwargs):
        """
        AddPrimitives(self: MSPyBentleyGeom.CurveVector, source: MSPyBentleyGeom.CurveVector) -> int
        
        recurse through source. append all leaf primitives to this. Return
        number added.
        """
        ...
    
    def AddSpacedPoints(*args, **kwargs):
        """
        AddSpacedPoints(*args, **kwargs)
        Overloaded function.
        
        1. AddSpacedPoints(self: MSPyBentleyGeom.CurveVector, distances: MSPyBentley.DoubleArray, locations: MSPyBentleyGeom.CurveLocationDetailArray) -> bool
        
        2. AddSpacedPoints(self: MSPyBentleyGeom.CurveVector, distances: MSPyBentley.DoubleArray, locations: MSPyBentleyGeom.CurveLocationDetailArray) -> bool
        
        Compute points at (many) specified distances along the (many) curves
        in the CurveVector. Intervals between successive distances can " jump "
        from one curve to the next. If curves to not connect head to tail, the
        gap is NOT filled -- measurement just picks up after the gap.
        
        Parameter ``[in]``:
        distances vector of distances, all measured from the start of the
        first primitive.
        
        Parameter ``[out]``:
        locations vector of locations. (This is NOT cleared at start --
        points are just added.)
        """
        ...
    
    def AddStrokePoints(*args, **kwargs):
        """
        AddStrokePoints(*args, **kwargs)
        Overloaded function.
        
        1. AddStrokePoints(self: MSPyBentleyGeom.CurveVector, points: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >, options: Bentley.IFacetOptions) -> None
        
        2. AddStrokePoints(self: MSPyBentleyGeom.CurveVector, points: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >, options: Bentley.IFacetOptions) -> None
        
        Add stroke points form all children to output. Strokes from all
        children are concatenated into the same vector, separated only by
        DISCONNECT points. Use Stroke() to get structured strokes.
        
        Parameter ``[in,out]``:
        points growing vector of strokes.
        
        Parameter ``[in]``:
        options options for stroke density. chordTolerance,
        angleTolerance, and maxEdgeLength will be used.
        """
        ...
    
    def AnnounceKeyPoints(*args, **kwargs):
        """
        AnnounceKeyPoints(*args, **kwargs)
        Overloaded function.
        
        1. AnnounceKeyPoints(self: MSPyBentleyGeom.CurveVector, spacePoint: Bentley.DPoint3d, collector: MSPyBentleyGeom.CurveKeyPointCollector, extend0: bool, extend1: bool) -> None
        
        2. AnnounceKeyPoints(self: MSPyBentleyGeom.CurveVector, spacePoint: Bentley.DPoint3d, collector: MSPyBentleyGeom.CurveKeyPointCollector, extend0: bool, extend1: bool) -> None
        
        Search for various keypoints (as requested by the collector) During
        recursion, extension bits are changed to false for interior points of
        paths
        """
        ...
    
    def AppendClosedCurvePlaneIntersections(*args, **kwargs):
        """
        AppendClosedCurvePlaneIntersections(*args, **kwargs)
        Overloaded function.
        
        1. AppendClosedCurvePlaneIntersections(self: MSPyBentleyGeom.CurveVector, plane: Bentley.DPlane3d, intersections: MSPyBentleyGeom.CurveLocationDetailPairArray, tolerance: float = 0.0) -> bool
        
        2. AppendClosedCurvePlaneIntersections(self: MSPyBentleyGeom.CurveVector, plane: Bentley.DPlane3d, intersections: MSPyBentleyGeom.CurveLocationDetailPairArray, tolerance: float = 0.0) -> bool
        
        Compute intersections of closed CurveVector with a plane and organize
        as start end pairs by parity rules. Intersections are reported as
        CurveLocationDetailPairs for start and end of segments.
        
        Parameter ``[in]``:
        plane
        
        Parameter ``[out]``:
        intersections intersection details
        
        Parameter ``[in]``:
        tolerance for on-plane decisions. If 0, a tolerance is computed
        based on the coordinates in the curve.
        """
        ...
    
    def AppendCurvePlaneIntersections(*args, **kwargs):
        """
        AppendCurvePlaneIntersections(*args, **kwargs)
        Overloaded function.
        
        1. AppendCurvePlaneIntersections(self: MSPyBentleyGeom.CurveVector, plane: Bentley.DPlane3d, intersections: MSPyBentleyGeom.CurveLocationDetailPairArray, tolerance: float = 0.0) -> None
        
        2. AppendCurvePlaneIntersections(self: MSPyBentleyGeom.CurveVector, plane: Bentley.DPlane3d, intersections: MSPyBentleyGeom.CurveLocationDetailPairArray, tolerance: float = 0.0) -> None
        
        Compute simple points of intersection of the curve with a plane.
        Single point intersection appears as a CurveLocationDetailPair with
        identical locations for both parts of the pair (SameCurveAndFraction)
        Curve-on-plane appears as CurveLocationDetailPair with curve,fraction
        data for start and end of on-plane sections.
        
        Parameter ``[in]``:
        plane
        
        Parameter ``[out]``:
        intersections intersection details
        
        Parameter ``[in]``:
        tolerance for on-plane decisions. If 0, a tolerance is computed
        based on the coordinates in the curve.
        """
        ...
    
    def AppendSplitCurvesByPlane(*args, **kwargs):
        """
        AppendSplitCurvesByPlane(self: MSPyBentleyGeom.CurveVector, plane: Bentley.DPlane3d, belowCollector: MSPyBentleyGeom.CurveVector, aboveCollector: MSPyBentleyGeom.CurveVector, onCollector: MSPyBentleyGeom.CurveVector) -> None
        
        Return curves (not regions) that are below, above, and on a plane
        """
        ...
    
    def AppendSplitCurvesByRegion(*args, **kwargs):
        """
        AppendSplitCurvesByRegion(self: MSPyBentleyGeom.CurveVector, region: MSPyBentleyGeom.CurveVector, insideCollector: MSPyBentleyGeom.CurveVector, outsideCollector: MSPyBentleyGeom.CurveVector, onCollector: MSPyBentleyGeom.CurveVector) -> None
        
        Return curves (not regions) that are inside, outside, or on a region.
        """
        ...
    
    def AreStartEndAlmostEqual(*args, **kwargs):
        """
        AreStartEndAlmostEqual(self: MSPyBentleyGeom.CurveVector) -> bool
        
        Query:Does this have start and end points and are the points almost
        equal?
        """
        ...
    
    def AreaAnalysis(*args, **kwargs):
        """
        AreaAnalysis(*args, **kwargs)
        Overloaded function.
        
        1. AreaAnalysis(region: MSPyBentleyGeom.CurveVector, select1: MSPyBentleyGeom.AreaSelect, select2: MSPyBentleyGeom.BoolSelect, reverse: bool) -> MSPyBentleyGeom.CurveVector
        
        2. AreaAnalysis(region: MSPyBentleyGeom.CurveVector, select1: MSPyBentleyGeom.AreaSelect, select2: MSPyBentleyGeom.BoolSelect, reverse: bool) -> MSPyBentleyGeom.CurveVector
        
        Return a curve vector containing the " inside " areas by various
        conditions.
        
        Parameter ``[in]``:
        region Region that may have loops back over its area.
        
        Parameter ``[in]``:
        select1 Rule for classifying single area:one of
        AreaSelect_Parity, AreaSelect_CCWPositiveWindingNumber,
        AreaSelect_CCWNonzeroWindingNumber,
        AreaSelect_CCWNegativeWindingNumber
        
        Parameter ``[in]``:
        select2 Rule for combining leaf left results:One of
        BoolSelect_Parity, BoolSelect_Union, BoolSelect_Sum_Parity,
        BoolSelect_CCWPositiveWindingNumber,
        BoolSelect_CCWNonzeroWindingNumber,
        BoolSelect_CCWNegativeWindingNumber
        
        Parameter ``[in]``:
        reverse to return the opposite set of faces.
        """
        ...
    
    def AreaDifference(*args, **kwargs):
        """
        AreaDifference(*args, **kwargs)
        Overloaded function.
        
        1. AreaDifference(regionA: MSPyBentleyGeom.CurveVector, regionB: MSPyBentleyGeom.CurveVector, newToOld: Bentley.Bstdcxx.bvector<Bentley.CurvePrimitivePtrPair,Bentley.BentleyAllocator<Bentley.CurvePrimitivePtrPair> > = None) -> MSPyBentleyGeom.CurveVector
        
        2. AreaDifference(regionA: MSPyBentleyGeom.CurveVector, regionB: MSPyBentleyGeom.CurveVector, newToOld: Bentley.Bstdcxx.bvector<Bentley.CurvePrimitivePtrPair,Bentley.BentleyAllocator<Bentley.CurvePrimitivePtrPair> > = None) -> MSPyBentleyGeom.CurveVector
        
        Return a curve vector containing the difference of input areas.
        
        Parameter ``[in]``:
        regionA left operand
        
        Parameter ``[in]``:
        regionB right operand
        
        Parameter ``[in,out]``:
        newToOld (optional) pointer to bvector to receive paring of new
        and old curves.
        """
        ...
    
    def AreaIntersection(*args, **kwargs):
        """
        AreaIntersection(*args, **kwargs)
        Overloaded function.
        
        1. AreaIntersection(regionA: MSPyBentleyGeom.CurveVector, regionB: MSPyBentleyGeom.CurveVector, newToOld: Bentley.Bstdcxx.bvector<Bentley.CurvePrimitivePtrPair,Bentley.BentleyAllocator<Bentley.CurvePrimitivePtrPair> > = None) -> MSPyBentleyGeom.CurveVector
        
        2. AreaIntersection(regionA: MSPyBentleyGeom.CurveVector, regionB: MSPyBentleyGeom.CurveVector, newToOld: Bentley.Bstdcxx.bvector<Bentley.CurvePrimitivePtrPair,Bentley.BentleyAllocator<Bentley.CurvePrimitivePtrPair> > = None) -> MSPyBentleyGeom.CurveVector
        
        Return a curve vector containing the intersection of input areas.
        
        Parameter ``[in]``:
        regionA left operand
        
        Parameter ``[in]``:
        regionB right operand
        
        Parameter ``[in,out]``:
        newToOld (optional) pointer to bvector to receive paring of new
        and old curves.
        """
        ...
    
    def AreaOffset(*args, **kwargs):
        """
        AreaOffset(self: MSPyBentleyGeom.CurveVector, options: MSPyBentleyGeom.CurveOffsetOptions) -> MSPyBentleyGeom.CurveVector
        
        return a (deep) clone with all areas increased or decreased according
        to the offset distance.
        
        Remark:
        A positive offset is to the right of the curve (i.e. CCW outer
        loop offsets to a larger area)
        """
        ...
    
    def AreaParity(*args, **kwargs):
        """
        AreaParity(*args, **kwargs)
        Overloaded function.
        
        1. AreaParity(regionA: MSPyBentleyGeom.CurveVector, regionB: MSPyBentleyGeom.CurveVector, newToOld: Bentley.Bstdcxx.bvector<Bentley.CurvePrimitivePtrPair,Bentley.BentleyAllocator<Bentley.CurvePrimitivePtrPair> > = None) -> MSPyBentleyGeom.CurveVector
        
        2. AreaParity(regionA: MSPyBentleyGeom.CurveVector, regionB: MSPyBentleyGeom.CurveVector, newToOld: Bentley.Bstdcxx.bvector<Bentley.CurvePrimitivePtrPair,Bentley.BentleyAllocator<Bentley.CurvePrimitivePtrPair> > = None) -> MSPyBentleyGeom.CurveVector
        
        Return a curve vector containing the parity of input areas.
        
        Parameter ``[in]``:
        regionA left operand
        
        Parameter ``[in]``:
        regionB right operand
        
        Parameter ``[in,out]``:
        newToOld (optional) pointer to bvector to receive paring of new
        and old curves.
        """
        ...
    
    def AreaUnion(*args, **kwargs):
        """
        AreaUnion(*args, **kwargs)
        Overloaded function.
        
        1. AreaUnion(regionA: MSPyBentleyGeom.CurveVector, regionB: MSPyBentleyGeom.CurveVector, newToOld: Bentley.Bstdcxx.bvector<Bentley.CurvePrimitivePtrPair,Bentley.BentleyAllocator<Bentley.CurvePrimitivePtrPair> > = None) -> MSPyBentleyGeom.CurveVector
        
        2. AreaUnion(regionA: MSPyBentleyGeom.CurveVector, regionB: MSPyBentleyGeom.CurveVector, newToOld: Bentley.Bstdcxx.bvector<Bentley.CurvePrimitivePtrPair,Bentley.BentleyAllocator<Bentley.CurvePrimitivePtrPair> > = None) -> MSPyBentleyGeom.CurveVector
        
        Return a curve vector containing the union of input areas.
        
        Parameter ``[in]``:
        regionA left operand
        
        Parameter ``[in]``:
        regionB right operand
        
        Parameter ``[in,out]``:
        newToOld (optional) pointer to bvector to receive paring of new
        and old curves.
        """
        ...
    
    def AssembleChains(*args, **kwargs):
        """
        AssembleChains(*args, **kwargs)
        Overloaded function.
        
        1. AssembleChains(self: MSPyBentleyGeom.CurveVector) -> MSPyBentleyGeom.CurveVector
        
        2. AssembleChains(self: MSPyBentleyGeom.CurveVector) -> MSPyBentleyGeom.CurveVector
        
        Join curve primitives head to tail. Return a top level
        BOUNDARY_TYPE_None containing the various BOUNDARY_TYPE_Open and
        BOUNDARY_TYPE_Outer
        """
        ...
    
    @property
    def BoundaryType(arg0: MSPyBentleyGeom.CurveVector) -> MSPyBentleyGeom.CurveVector.BoundaryType:
        ...
    
    def CentroidAreaXY(*args, **kwargs):
        """
        CentroidAreaXY(self: MSPyBentleyGeom.CurveVector) -> tuple
        
        Return the centroid and area of the curve vector as viewed in the xy
        plane. return false if the CurveVector is not one of the area types
        (union region, parity region, or closed loop)
        
        Remark:
        Union region moments are the simple sum of constituents (i.e
        overlap is not determined)
        
        Remark:
        Parity region moments are signed sum per area, assuming largest is
        outer and all others are inner (subtractive)
        
        Parameter ``[out]``:
        centroid curve centroid
        
        Parameter ``[out]``:
        area area of region.
        """
        ...
    
    def CentroidNormalArea(*args, **kwargs):
        """
        CentroidNormalArea(self: MSPyBentleyGeom.CurveVector) -> tuple
        
        Return the centroid, normal and area of the curve vector. return false
        if the CurveVector is not one of the area types (union region, parity
        region, or closed loop)
        
        Remark:
        Union region moments are the simple sum of constituents (i.e
        overlap is not determined)
        
        Remark:
        Parity region moments are signed sum per area, assuming largest is
        outer and all others are inner (subtractive)
        
        Remark:
        If curves are non-planar, the centroid and normal are
        approximations with no particular guarantees.
        
        Parameter ``[out]``:
        centroid curve centroid
        
        Parameter ``[out]``:
        normal curve normal
        
        Parameter ``[out]``:
        area area of region.
        """
        ...
    
    def Clone(*args, **kwargs):
        """
        Clone(self: MSPyBentleyGeom.CurveVector) -> MSPyBentleyGeom.CurveVector
        
        Return a " deep copy "
        """
        ...
    
    def CloneAsBsplines(*args, **kwargs):
        """
        CloneAsBsplines(*args, **kwargs)
        Overloaded function.
        
        1. CloneAsBsplines(self: MSPyBentleyGeom.CurveVector) -> MSPyBentleyGeom.CurveVector
        
        2. CloneAsBsplines(self: MSPyBentleyGeom.CurveVector) -> MSPyBentleyGeom.CurveVector
        
        Return a " deep copy " with primitives replaced by bsplines The tree
        upper levels of the tree structure are retained -- i.e. the output
        contains corresponding tree structure ParityRegion, UnionRegion,
        OuterLoop, and InnerLoop ul> li>UnionRegion and ParityRegion vectors:
        Create a new CurveVector of the same type. Recursively create
        children. li>OuterLoop, InnerLoop, OpenPath:Create a new curve vector
        of the same type. li>Primitives:Each primitive is copied as a bspline
        curve primitive. ul>
        """
        ...
    
    def CloneBetweenCyclicIndexedFractions(*args, **kwargs):
        """
        CloneBetweenCyclicIndexedFractions(*args, **kwargs)
        Overloaded function.
        
        1. CloneBetweenCyclicIndexedFractions(self: MSPyBentleyGeom.CurveVector, index0: int, fraction0: float, index1: int, fraction1: float) -> MSPyBentleyGeom.CurveVector
        
        2. CloneBetweenCyclicIndexedFractions(self: MSPyBentleyGeom.CurveVector, index0: int, fraction0: float, index1: int, fraction1: float) -> MSPyBentleyGeom.CurveVector
        
        Return a new vector containing curves from index0,fraction0 to
        index1,fraction1 with the (signed int!!) indices interpretted
        cyclically.
        """
        ...
    
    def CloneBetweenDirectedFractions(*args, **kwargs):
        """
        CloneBetweenDirectedFractions(*args, **kwargs)
        Overloaded function.
        
        1. CloneBetweenDirectedFractions(self: MSPyBentleyGeom.CurveVector, index0: int, fraction0: float, index1: int, fraction1: float, allowExtrapolation: bool, usePartialCurves: bool = False) -> MSPyBentleyGeom.CurveVector
        
        2. CloneBetweenDirectedFractions(self: MSPyBentleyGeom.CurveVector, location0: MSPyBentleyGeom.CurveLocationDetail, location1: MSPyBentleyGeom.CurveLocationDetail, allowExtrapolation: bool = False, usePartialCurves: bool = False) -> MSPyBentleyGeom.CurveVector
        """
        ...
    
    def CloneDereferenced(*args, **kwargs):
        """
        CloneDereferenced(self: MSPyBentleyGeom.CurveVector, allowExtrapolation: bool = False, maximumDeref: bool = True) -> MSPyBentleyGeom.CurveVector
        
        Return a " deep copy " with PartialCurve primitives replaced by full
        curves.
        
        Parameter ``[in]``:
        maximumDeref true to recurse through all steps of PartialCurve
        chains
        
        Parameter ``[in]``:
        allowExtrapolation true to allow extension before/after endpoints.
        """
        ...
    
    def CloneInLocalCoordinates(*args, **kwargs):
        """
        CloneInLocalCoordinates(self: MSPyBentleyGeom.CurveVector, rameType: Bentley.LocalCoordinateSelect, localToWorld: Bentley.Transform, worldToLocal: Bentley.Transform, localRange: Bentley.DRange3d) -> MSPyBentleyGeom.CurveVector
        
        Return curve copy and transforms for a local coordinate system related
        to the curves. The local x and y axes are parallel to the x and y axes
        of the Frenet frame at the curve start.
        
        Returns:
        curves transformed to local system.
        
        Parameter ``[out]``:
        localToWorld local to world transform
        
        Parameter ``[out]``:
        worldToLocal world to local transform
        
        Parameter ``[out]``:
        localRange curve vector range in the local frame.
        
        Parameter ``[in]``:
        frameType Selects how the geometry size is represented in the
        scale. ul> li>LOCAL_COORDINATE_SCALE_UnitAxesAtStart -- x,y,z
        columns in the transform are unit vectors. localRange values are
        true geometry sizes. origin is at start point of first primitive.
        li>LOCAL_COORDINATE_SCALE_UnitAxesAtLowerLeft -- x,y,z columns in
        the transform are unit vectors. localRange values are true
        geometry sizes. origin is at lower left of range.
        li>LOCAL_COORDINATE_SCALE_01RangeBothAxes -- x column is a vector
        spanning the x range from min to max. y column is a vector
        spanning the y range from min to max. localRange values are 0..1
        (inclusive) in both directions. origin is at lower left of range.
        li>LOCAL_COORDINATE_SCALE_01RangeLargerAxis -- x and y columns
        have the same length, large enough to span the larger direction.
        localRange values are 0..1 in the larger direction, 0..f in the
        smaller direction, where f is that direction's size as a fraction
        of the larger direction. origin is at lower left of range. ul>
        """
        ...
    
    def CloneOffsetCurvesXY(*args, **kwargs):
        """
        CloneOffsetCurvesXY(self: MSPyBentleyGeom.CurveVector, options: MSPyBentleyGeom.CurveOffsetOptions) -> MSPyBentleyGeom.CurveVector
        
        return a (deep) clone with all curves offset by signed distance. This
        is a curve operation, and may result in self-intersecting offset
        curves.
        
        Remark:
        A positive offset is to the right of the curve (i.e. CCW outer
        loop offsets to a larger area)
        """
        ...
    
    def CloneReversed(*args, **kwargs):
        """
        CloneReversed(*args, **kwargs)
        Overloaded function.
        
        1. CloneReversed(self: MSPyBentleyGeom.CurveVector) -> MSPyBentleyGeom.CurveVector
        
        2. CloneReversed(self: MSPyBentleyGeom.CurveVector) -> MSPyBentleyGeom.CurveVector
        
        Return a new curve vector that has all components reversed.
        """
        ...
    
    def CloneWithBlends(*args, **kwargs):
        """
        CloneWithBlends(self: MSPyBentleyGeom.CurveVector, blendType: MSPyBentleyGeom.BlendType, radiusA: float, radiusB: float) -> MSPyBentleyGeom.CurveVector
        
        return a (deep) clone with fillets inserted between successive curves.
        """
        ...
    
    def CloneWithExplodedLinestrings(*args, **kwargs):
        """
        CloneWithExplodedLinestrings(self: MSPyBentleyGeom.CurveVector) -> MSPyBentleyGeom.CurveVector
        
        Return a curve vector that is a clone, but with all polylines split
        into individual line segments.
        """
        ...
    
    def CloneWithFillets(*args, **kwargs):
        """
        CloneWithFillets(self: MSPyBentleyGeom.CurveVector, radius: float) -> MSPyBentleyGeom.CurveVector
        
        return a (deep) clone with fillets inserted between successive curves.
        """
        ...
    
    def CloneWithGapsClosed(*args, **kwargs):
        """
        CloneWithGapsClosed(self: MSPyBentleyGeom.CurveVector, options: MSPyBentleyGeom.CurveGapOptions) -> MSPyBentleyGeom.CurveVector
        
        return a (deep) clone with endpoint gaps closed. When gaps are found
        larger than gapTolerance, line segments are added. The options that
        will be used are:1) options.SetEqualPointTolerance(value):Gaps
        smaller than this are acceptable. This Suggested value:around 1e-7 in
        master units. 2) options.SetMaxDirectAdjustTolerance:gaps this small
        may be closed by directly moving endopints of lines or linestrings.
        SuggestedValue:10 to 1000 times the equal point tolerance 3)
        options.SetRemovePriorGapPrimitives(true):primitives marked as gaps
        are purged. (And the gaps are re-closed) Suggested value:true.
        (default is true) 4) options.SetMaxAdjustAlongPrimitive:points may
        move this far if the final point is on the extended element.
        """
        ...
    
    def CloneWithSplits(*args, **kwargs):
        """
        CloneWithSplits(self: MSPyBentleyGeom.CurveVector, splitterCurves: MSPyBentleyGeom.CurveVector, primitivesOnly: bool = False) -> MSPyBentleyGeom.CurveVector
        
        Return a curve vector that is a clone, but with all primitives split
        at intersections with any splitter curve. Optionally omit tree
        structure and only copy primitives.
        """
        ...
    
    def ClosestCurveOrRegionPoint(*args, **kwargs):
        """
        ClosestCurveOrRegionPoint(*args, **kwargs)
        Overloaded function.
        
        1. ClosestCurveOrRegionPoint(self: MSPyBentleyGeom.CurveVector, spacePoint: Bentley.DPoint3d, curveOrRegionPoint: Bentley.DPoint3d) -> MSPyBentleyGeom.CurveVector.InOutClassification
        
        2. ClosestCurveOrRegionPoint(self: MSPyBentleyGeom.CurveVector, spacePoint: Bentley.DPoint3d, curveOrRegionPoint: Bentley.DPoint3d) -> MSPyBentleyGeom.CurveVector.InOutClassification
        
        Search for closest point on curve. If CV is a region type, also look
        for projection onto interior of the region.
        
        Parameter ``[in]``:
        spacePoint fixed point of search
        
        Parameter ``[out]``:
        curveOrRegionPoint computed point on curve or region interior.
        
        Returns:
        INOUT_On if the point is a curve point. INOUT_In if the point is a
        projection to the region interior. INOUT_Unknown for empty curve
        vector.
        """
        ...
    
    def ClosestPointBounded(*args, **kwargs):
        """
        ClosestPointBounded(*args, **kwargs)
        Overloaded function.
        
        1. ClosestPointBounded(self: MSPyBentleyGeom.CurveVector, spacePoint: Bentley.DPoint3d, location: MSPyBentleyGeom.CurveLocationDetail) -> bool
        
        2. ClosestPointBounded(self: MSPyBentleyGeom.CurveVector, spacePoint: Bentley.DPoint3d, location: MSPyBentleyGeom.CurveLocationDetail, extend0: bool, extend1: bool) -> bool
        
        3. ClosestPointBounded(self: MSPyBentleyGeom.CurveVector, spacePoint: Bentley.DPoint3d, location: MSPyBentleyGeom.CurveLocationDetail) -> bool
        
        Search for the closest point on any contained curve.
        
        4. ClosestPointBounded(self: MSPyBentleyGeom.CurveVector, spacePoint: Bentley.DPoint3d, location: MSPyBentleyGeom.CurveLocationDetail, extend0: bool, extend1: bool) -> bool
        
        Search for the closest point on any contained curve.
        """
        ...
    
    def ClosestPointBoundedXY(*args, **kwargs):
        """
        ClosestPointBoundedXY(*args, **kwargs)
        Overloaded function.
        
        1. ClosestPointBoundedXY(self: MSPyBentleyGeom.CurveVector, spacePoint: Bentley.DPoint3d, worldToLocal: Bentley.DMatrix4d, location: MSPyBentleyGeom.CurveLocationDetail) -> bool
        
        2. ClosestPointBoundedXY(self: MSPyBentleyGeom.CurveVector, spacePoint: Bentley.DPoint3d, worldToLocal: Bentley.DMatrix4d, location: MSPyBentleyGeom.CurveLocationDetail, extend0: bool, extend1: bool) -> bool
        
        3. ClosestPointBoundedXY(self: MSPyBentleyGeom.CurveVector, spacePoint: Bentley.DPoint3d, worldToLocal: Bentley.DMatrix4d, location: MSPyBentleyGeom.CurveLocationDetail) -> bool
        
        Search for the closest point on any contained curve, using only xy
        (viewed) coordinates.
        
        4. ClosestPointBoundedXY(self: MSPyBentleyGeom.CurveVector, spacePoint: Bentley.DPoint3d, worldToLocal: Bentley.DMatrix4d, location: MSPyBentleyGeom.CurveLocationDetail, extend0: bool, extend1: bool) -> bool
        
        Search for the closest point on any contained curve, using only xy
        (viewed) coordinates.
        """
        ...
    
    def CollectLinearGeometry(*args, **kwargs):
        """
        CollectLinearGeometry(*args, **kwargs)
        Overloaded function.
        
        1. CollectLinearGeometry(self: MSPyBentleyGeom.CurveVector, regionsPoints: Bentley.Bstdcxx.bvector<Bentley.Bstdcxx.bvector<Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >,Bentley.BentleyAllocator<Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> > > >,Bentley.BentleyAllocator<Bentley.Bstdcxx.bvector<Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >,Bentley.BentleyAllocator<Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> > > > > >) -> bool
        
        2. CollectLinearGeometry(self: MSPyBentleyGeom.CurveVector, regionsPoints: Bentley.Bstdcxx.bvector<Bentley.Bstdcxx.bvector<Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >,Bentley.BentleyAllocator<Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> > > >,Bentley.BentleyAllocator<Bentley.Bstdcxx.bvector<Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >,Bentley.BentleyAllocator<Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> > > > > >) -> bool
        
        Add all strokes from the structure. This is intended to be called on
        structures with only lines and linestrings. The outer curve vector may
        be a single loop, parity region, or union region. AddLinearLoops
        recurses The regionsPoints[i] is an array of loops.
        regionsPoints[i][j] is loop j of regionsPoints[i].
        
        Returns:
        false if unexpected structure -- e.g. curves. --- was encountered.
        """
        ...
    
    def ComputeSecondMomentAreaProducts(*args, **kwargs):
        """
        ComputeSecondMomentAreaProducts(self: MSPyBentleyGeom.CurveVector, products: Bentley.DMatrix4d) -> bool
        
        Return the area, centroid, orientation, and principal moments,
        treating this as a thin planar sheet.
        
        Parameter ``[out]``:
        products integrated [xx xy xz x; xy yy yz y; xz yz zz z; x y z 1]
        dA
        """
        ...
    
    def ComputeSecondMomentDifferentialAreaRotationProducts(*args, **kwargs):
        """
        ComputeSecondMomentDifferentialAreaRotationProducts(self: MSPyBentleyGeom.CurveVector, rotationAxis: Bentley.DRay3d, rotationToWorld: Bentley.Transform, products: Bentley.DMatrix4d) -> bool
        
        Return the moment products [xx,xy,xz,xw; etc] of the area as a
        differential rotational slice.
        
        Parameter ``[in]``:
        rotationAxis the origin and z axis of the rotation.
        
        Parameter ``[out]``:
        rotationToWorld transformation from rotation system (origin on
        rotation axis) to world. The products are base don local
        coordinates in the system.
        
        Parameter ``[out]``:
        products products in the rotation system.
        
        Returns:
        false if invalid area for rotational sweep.
        """
        ...
    
    def ComputeSecondMomentDifferentialWireRotationProducts(*args, **kwargs):
        """
        ComputeSecondMomentDifferentialWireRotationProducts(self: MSPyBentleyGeom.CurveVector, rotationAxis: Bentley.DRay3d, rotationToWorld: Bentley.Transform, products: Bentley.DMatrix4d) -> bool
        
        Return the moment products [xx,xy,xz,xw; etc] of the wire as a
        differential rotational contribution
        
        Parameter ``[in]``:
        rotationAxis the origin and z axis of the rotation.
        
        Parameter ``[out]``:
        rotationToWorld transformation from rotation system (origin on
        rotation axis) to world. The products are base don local
        coordinates in the system.
        
        Parameter ``[out]``:
        products products in the rotation system.
        
        Returns:
        false if invalid area for rotational sweep.
        """
        ...
    
    def ComputeSecondMomentWireProducts(*args, **kwargs):
        """
        ComputeSecondMomentWireProducts(self: MSPyBentleyGeom.CurveVector, products: Bentley.DMatrix4d) -> bool
        
        Return the area, centroid, orientation, and principal moments,
        treating this as a wire
        
        Parameter ``[out]``:
        products integrated [xx xy xz x; xy yy yz y; xz yz zz z; x y z 1]
        dA
        """
        ...
    
    def ConsolidateAdjacentPrimitives(*args, **kwargs):
        """
        ConsolidateAdjacentPrimitives(*args, **kwargs)
        Overloaded function.
        
        1. ConsolidateAdjacentPrimitives(self: MSPyBentleyGeom.CurveVector) -> None
        
        2. ConsolidateAdjacentPrimitives(self: MSPyBentleyGeom.CurveVector, doSimplifyLinestrings: bool) -> None
        
        3. ConsolidateAdjacentPrimitives(self: MSPyBentleyGeom.CurveVector) -> None
        
        Inplace update to consolidate contiguous parts. Adjacent lines and
        linestrings become a single linestring. Interior colinear points of
        linestrings are eliminated. Adjacent and compatible arcs become single
        arc.
        
        4. ConsolidateAdjacentPrimitives(self: MSPyBentleyGeom.CurveVector, doSimplifyLinestrings: bool) -> None
        
        Inplace update to consolidate contiguous parts. Adjacent lines and
        linestrings become a single linestring. Interior colinear points of
        linestrings are eliminated. Adjacent and compatible arcs become single
        arc.
        """
        ...
    
    def ContainsNonLinearPrimitive(*args, **kwargs):
        """
        ContainsNonLinearPrimitive(*args, **kwargs)
        Overloaded function.
        
        1. ContainsNonLinearPrimitive(self: MSPyBentleyGeom.CurveVector) -> bool
        
        2. ContainsNonLinearPrimitive(self: MSPyBentleyGeom.CurveVector) -> bool
        
        Return true if CurveVector has a component that is not a line or
        linestring.
        """
        ...
    
    def CountPrimitivesOfType(*args, **kwargs):
        """
        CountPrimitivesOfType(self: MSPyBentleyGeom.CurveVector, targetType: MSPyBentleyGeom.ICurvePrimitive.CurvePrimitiveType) -> int
        
        Count primitives of specified type.
        
        Parameter ``[in]``:
        targetType primitive type to count.
        """
        ...
    
    def CreateDisk(*args, **kwargs):
        """
        CreateDisk(*args, **kwargs)
        Overloaded function.
        
        1. CreateDisk(arc: Bentley.DEllipse3d, boundaryType: MSPyBentleyGeom.CurveVector.BoundaryType = <BoundaryType.eBOUNDARY_TYPE_Outer: 2>, forceXYOrientation: bool = False) -> MSPyBentleyGeom.CurveVector
        
        2. CreateDisk(arc: Bentley.DEllipse3d, boundaryType: MSPyBentleyGeom.CurveVector.BoundaryType = <BoundaryType.eBOUNDARY_TYPE_Outer: 2>, forceXYOrientation: bool = False) -> MSPyBentleyGeom.CurveVector
        
        Create a (deep) curve vector structure for a complete elliptic
        (circular) disk.
        
        Parameter ``[in]``:
        arc boundary ellipse
        
        Parameter ``[in]``:
        boundaryType is one of
        
        * BOUNDARY_TYPE_Outer:force to counterclockwise and positive area as
        seen looking at xy plane.
        
        * BOUNDARY_TYPE_Inner:force to clockwise and negative area as seen
        looking at xy plane.
        
        * BOUNDARY_TYPE_Open, BOUNDARY_TYPE_None:ellipse inserted with its
        own direction.
        
        * BOUNDARY_TYPE_UnionRegion, BOUNDARY_TYPE_ParityRegion create two-
        level structure with arc at second level with BOUNDARY_TYPE_Outer
        
        Parameter ``[in]``:
        forceXYOrientation if true, reverse arc sweep so it acts as
        requested inner/outer in xy view.
        """
        ...
    
    def CreateLinear(*args, **kwargs):
        """
        CreateLinear(*args, **kwargs)
        Overloaded function.
        
        1. CreateLinear(points: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >, boundaryType: MSPyBentleyGeom.CurveVector.BoundaryType = <BoundaryType.eBOUNDARY_TYPE_Open: 1>, forceXYOrientation: bool = False) -> MSPyBentleyGeom.CurveVector
        
        Create a linestring or polygon from xyz data.
        
        Parameter ``[in]``:
        points vertex coordinates points.
        
        Parameter ``[in]``:
        boundaryType is one of
        
        * BOUNDARY_TYPE_Outer, or BOUNDARY_TYPE_INNER:Duplication forced on
        first/last point. Orientation optionally enforced.
        
        * BOUNDARY_TYPE_Open, BOUNDARY_TYPE_None:points copied unchanged.
        
        * BOUNDARY_TYPE_UnionRegion, BOUNDARY_TYPE_ParityRegion create two-
        level structure with polygon at second level with BOUNDARY_TYPE_Outer.
        
        Parameter ``[in]``:
        forceXYOrientation true to force outer and inner loops to have
        correct (CCW/CW) order.
        
        2. CreateLinear(points: Bentley.Bstdcxx.bvector<Bentley.DPoint2d,Bentley.BentleyAllocator<Bentley.DPoint2d> >, boundaryType: MSPyBentleyGeom.CurveVector.BoundaryType = <BoundaryType.eBOUNDARY_TYPE_Open: 1>, forceXYOrientation: bool = False) -> MSPyBentleyGeom.CurveVector
        
        Create a linestring or polygon from xyz data.
        
        Parameter ``[in]``:
        points vertex coordinates points.
        
        Parameter ``[in]``:
        boundaryType is one of
        
        * BOUNDARY_TYPE_Outer, or BOUNDARY_TYPE_INNER:Duplication forced on
        first/last point. Orientation optionally enforced.
        
        * BOUNDARY_TYPE_Open, BOUNDARY_TYPE_None:points copied unchanged.
        
        * BOUNDARY_TYPE_UnionRegion, BOUNDARY_TYPE_ParityRegion create two-
        level structure with polygon at second level with BOUNDARY_TYPE_Outer.
        
        Parameter ``[in]``:
        forceXYOrientation true to force outer and inner loops to have
        correct (CCW/CW) order.
        """
        ...
    
    def CreateRectangle(*args, **kwargs):
        """
        CreateRectangle(*args, **kwargs)
        Overloaded function.
        
        1. CreateRectangle(x0: float, y0: float, x1: float, y1: float, z: float, boundaryType: MSPyBentleyGeom.CurveVector.BoundaryType = <BoundaryType.eBOUNDARY_TYPE_Outer: 2>) -> MSPyBentleyGeom.CurveVector
        
        2. CreateRectangle(x0: float, y0: float, x1: float, y1: float, z: float, boundaryType: MSPyBentleyGeom.CurveVector.BoundaryType = <BoundaryType.eBOUNDARY_TYPE_Outer: 2>) -> MSPyBentleyGeom.CurveVector
        
        Create a rectangle from xy corners.
        
        Parameter ``[in]``:
        x0 start point x coordinate
        
        Parameter ``[in]``:
        y0 start point y coordinate
        
        Parameter ``[in]``:
        x1 opposite corner x coordinate
        
        Parameter ``[in]``:
        y1 opposite corner y coordinate
        
        Parameter ``[in]``:
        z z value for all points.
        
        Parameter ``[in]``:
        boundaryType is one of
        
        * BOUNDARY_TYPE_Outer:force to counterclockwise and positive area
        
        * BOUNDARY_TYPE_Inner:force to clockwise and negative area
        
        * BOUNDARY_TYPE_Open, BOUNDARY_TYPE_None:point order
        (x0,y0)(x1,y0),(x1,y1),(x0,y1)
        
        * BOUNDARY_TYPE_UnionRegion, BOUNDARY_TYPE_ParityRegion create two-
        level structure with rectangle at second level with
        BOUNDARY_TYPE_Outer
        """
        ...
    
    def CreateXYHatch(*args, **kwargs):
        """
        CreateXYHatch(*args, **kwargs)
        Overloaded function.
        
        1. CreateXYHatch(boundary: MSPyBentleyGeom.CurveVector, startPoint: Bentley.DPoint3d, angleRadians: float, spacing: float, selection: int = 0) -> MSPyBentleyGeom.CurveVector
        
        2. CreateXYHatch(boundary: MSPyBentleyGeom.CurveVector, startPoint: Bentley.DPoint3d, angleRadians: float, spacing: float, selection: int = 0) -> MSPyBentleyGeom.CurveVector
        
        Return a curve vector (of type BOUNDARY_TYPE_None) containing hatch
        sticks.
        """
        ...
    
    def CurveLocationDetailCompare(*args, **kwargs):
        """
        CurveLocationDetailCompare(*args, **kwargs)
        Overloaded function.
        
        1. CurveLocationDetailCompare(self: MSPyBentleyGeom.CurveVector, location0: MSPyBentleyGeom.CurveLocationDetail, location1: MSPyBentleyGeom.CurveLocationDetail) -> int
        
        2. CurveLocationDetailCompare(self: MSPyBentleyGeom.CurveVector, location0: MSPyBentleyGeom.CurveLocationDetail, location1: MSPyBentleyGeom.CurveLocationDetail) -> int
        
        return 0 of locations are equal, -1 if location 0 is less than
        location 1, and 1 if location 0> location 1. This is a lexical
        comparison using (only) the curve index and the fraction.
        """
        ...
    
    def CurveLocationDetailIndex(*args, **kwargs):
        """
        CurveLocationDetailIndex(*args, **kwargs)
        Overloaded function.
        
        1. CurveLocationDetailIndex(self: MSPyBentleyGeom.CurveVector, location: MSPyBentleyGeom.CurveLocationDetail) -> int
        
        2. CurveLocationDetailIndex(self: MSPyBentleyGeom.CurveVector, location: MSPyBentleyGeom.CurveLocationDetail) -> int
        
        return index of curve location detail in vector (only valid for a
        vector that is a single open or closed path). Returns SIZE_MAX if not
        found.
        """
        ...
    
    def CyclicIndex(*args, **kwargs):
        """
        CyclicIndex(*args, **kwargs)
        Overloaded function.
        
        1. CyclicIndex(self: MSPyBentleyGeom.CurveVector, index: int) -> int
        
        2. CyclicIndex(self: MSPyBentleyGeom.CurveVector, index: int) -> int
        
        return mod of index with vector length, properly corrected for
        negatives.
        """
        ...
    
    def FastLength(*args, **kwargs):
        """
        FastLength(*args, **kwargs)
        Overloaded function.
        
        1. FastLength(self: MSPyBentleyGeom.CurveVector) -> float
        
        2. FastLength(self: MSPyBentleyGeom.CurveVector) -> float
        
        Sum lengths of contained curves, using fast method that may
        overestimate the length but is reasonable for setting tolerances.
        """
        ...
    
    def FastMaxAbs(*args, **kwargs):
        """
        FastMaxAbs(*args, **kwargs)
        Overloaded function.
        
        1. FastMaxAbs(self: MSPyBentleyGeom.CurveVector) -> float
        
        2. FastMaxAbs(self: MSPyBentleyGeom.CurveVector) -> float
        
        Return a fast estimate of the maximum absolute value in any
        coordinate. This will examine all curves, but is allowed to use safe
        approximations like bspline pole coordinates instead of exact curve
        calculations.
        """
        ...
    
    def FindIndexOfPrimitive(*args, **kwargs):
        """
        FindIndexOfPrimitive(*args, **kwargs)
        Overloaded function.
        
        1. FindIndexOfPrimitive(self: MSPyBentleyGeom.CurveVector, primitive: MSPyBentleyGeom.ICurvePrimitive) -> int
        
        2. FindIndexOfPrimitive(self: MSPyBentleyGeom.CurveVector, primitive: MSPyBentleyGeom.ICurvePrimitive) -> int
        
        return index of primitive in vector (only valid for a vector that is a
        single open or closed path). Returns SIZE_MAX if not found.
        """
        ...
    
    def FindParentOfPrimitive(*args, **kwargs):
        """
        FindParentOfPrimitive(*args, **kwargs)
        Overloaded function.
        
        1. FindParentOfPrimitive(self: MSPyBentleyGeom.CurveVector, primitive: MSPyBentleyGeom.ICurvePrimitive) -> MSPyBentleyGeom.CurveVector
        
        2. FindParentOfPrimitive(self: MSPyBentleyGeom.CurveVector, primitive: MSPyBentleyGeom.ICurvePrimitive) -> MSPyBentleyGeom.CurveVector
        
        Search the tree (below the calling instance) for the curve vector
        which is the immediate parent of given primitive.
        """
        ...
    
    def FixupXYOuterInner(*args, **kwargs):
        """
        FixupXYOuterInner(*args, **kwargs)
        Overloaded function.
        
        1. FixupXYOuterInner(self: MSPyBentleyGeom.CurveVector, fullGeometryCheck: bool = False) -> bool
        
        2. FixupXYOuterInner(self: MSPyBentleyGeom.CurveVector, fullGeometryCheck: bool = False) -> bool
        
        Update order, boundary type, and direction of contained loops. Loop A
        is considered " inside " loop B if (a) loop A has smaller area and (b)
        the start point of loop A is inside loop B. A loop that is " inside " an
        ODD number of other loops is considered to be a " hole " (inner loop)
        within the containing loop that has smallest area. Any other loop is
        considered an outer loop.
        
        * If there is a single outer loop, the (modified) curve vector is
        marked as a parity region. The outer loop is moved first and the inner
        loops follows.
        
        * If there are multiple outer loops, the (modified) curve vector is
        marked as a union region. Within the UnionRegion
        
        * Outer loops with no contained loops are present as simple Outer
        loops.
        
        * Outer loops with holes are parity regions.
        
        Parameter ``[in]``:
        fullGeometryCheck if true, perform all (expensive) tests for
        intersections among curves. When this is enabled, the returned
        curve vector is typically a (possibly significantly modified)
        clone of the original.
        """
        ...
    
    def GenerateAllParts(*args, **kwargs):
        """
        GenerateAllParts(*args, **kwargs)
        Overloaded function.
        
        1. GenerateAllParts(self: MSPyBentleyGeom.CurveVector, indexA: int, fractionA: float, indexB: int, fractionB: float) -> MSPyBentleyGeom.CurveVector
        
        2. GenerateAllParts(self: MSPyBentleyGeom.CurveVector, indexA: int, fractionA: float, indexB: int, fractionB: float) -> MSPyBentleyGeom.CurveVector
        
        Return a CurveVector (BOUNDARY_TYPE_None) which is a collection of
        open CurveVectors that collectively contain all parts of the input For
        (indexA,fractionA) prededing (indexB,fractionB) the output traces the
        input in the forward direction and has the following possibilities (of
        which null ones are skipped) ul> li> BOUNDARY_TYPE_Open - (A B), (B to
        end), (start to A) li> BOUNDARY_TYPE_Inner or BOUNDARY_TYPE_Outer - (A
        B), (B to where A appears in the next period) li>
        BOUNDARY_TYPE_ParityRegion, BOUNDARY_TYPE_UnionRegion,
        BOUNDARY_TYPE_None -- no output. ul> For (indexA,fractionA) prededing
        (indexB,fractionB) the output traces the input in the reverse
        direction and has the following possibilities (of which null ones are
        skipped) ul> li> BOUNDARY_TYPE_Open - (A backwards to B), (B backwards
        to start), (end backwards to A) li> BOUNDARY_TYPE_Inner or
        BOUNDARY_TYPE_Outer - (A backwards to B), (B backwards to where A
        appears in the previous period.) li> BOUNDARY_TYPE_ParityRegion,
        BOUNDARY_TYPE_UnionRegion, BOUNDARY_TYPE_None -- no output. ul>
        """
        ...
    
    def GetAnyFrenetFrame(*args, **kwargs):
        """
        GetAnyFrenetFrame(*args, **kwargs)
        Overloaded function.
        
        1. GetAnyFrenetFrame(self: MSPyBentleyGeom.CurveVector, frame: Bentley.Transform) -> bool
        
        Deep search for any curve primitive that has a well defined coordinate
        frame.
        
        Parameter ``[out]``:
        frame coordinate frame with origin on a primitive.
        
        Returns:
        true if a primitive was found.
        
        2. GetAnyFrenetFrame(self: MSPyBentleyGeom.CurveVector, frame: Bentley.Transform, searchPreference: int) -> bool
        
        Deep search for any curve primitive that has a well defined coordinate
        frame.
        
        Parameter ``[out]``:
        frame coordinate frame with origin on a primitive.
        
        Returns:
        true if a primitive was found.
        """
        ...
    
    def GetBoundaryType(*args, **kwargs):
        """
        GetBoundaryType(self: MSPyBentleyGeom.CurveVector) -> MSPyBentleyGeom.CurveVector.BoundaryType
        
        Return the type code indicating whether the vector is a path, outer
        boundary, inner boundary, or higher level grouping.
        """
        ...
    
    def GetBsplineCurve(*args, **kwargs):
        """
        GetBsplineCurve(*args, **kwargs)
        Overloaded function.
        
        1. GetBsplineCurve(self: MSPyBentleyGeom.CurveVector) -> Bentley.RefCountedMSBsplineCurve
        
        2. GetBsplineCurve(self: MSPyBentleyGeom.CurveVector) -> Bentley.RefCountedMSBsplineCurve
        
        Represent a curve vector that denotes an open or closed path as a
        single bspline curve.
        """
        ...
    
    def GetCyclic(*args, **kwargs):
        """
        GetCyclic(*args, **kwargs)
        Overloaded function.
        
        1. GetCyclic(self: MSPyBentleyGeom.CurveVector, index: int) -> MSPyBentleyGeom.ICurvePrimitive
        
        2. GetCyclic(self: MSPyBentleyGeom.CurveVector, index: int) -> MSPyBentleyGeom.ICurvePrimitive
        
        return child at cyclic index, propertly corrected for negatives.
        """
        ...
    
    def GetRange(*args, **kwargs):
        """
        GetRange(*args, **kwargs)
        Overloaded function.
        
        1. GetRange(self: MSPyBentleyGeom.CurveVector, range: Bentley.DRange3d) -> bool
        
        2. GetRange(self: MSPyBentleyGeom.CurveVector, range: Bentley.DRange3d, transform: Bentley.Transform) -> bool
        
        3. GetRange(self: MSPyBentleyGeom.CurveVector, range: Bentley.DRange3d) -> bool
        
        Return the xyz range of contained curves.
        
        4. GetRange(self: MSPyBentleyGeom.CurveVector, range: Bentley.DRange3d, transform: Bentley.Transform) -> bool
        
        Return the xyz range of contained curves.
        """
        ...
    
    def GetStartEnd(*args, **kwargs):
        """
        GetStartEnd(*args, **kwargs)
        Overloaded function.
        
        1. GetStartEnd(self: MSPyBentleyGeom.CurveVector, pointA: Bentley.DPoint3d, pointB: Bentley.DPoint3d) -> bool
        
        2. GetStartEnd(self: MSPyBentleyGeom.CurveVector, pointA: Bentley.DPoint3d, pointB: Bentley.DPoint3d, unitTangentA: Bentley.DVec3d, unitTangentB: Bentley.DVec3d) -> bool
        
        3. GetStartEnd(self: MSPyBentleyGeom.CurveVector, pointA: Bentley.DPoint3d, pointB: Bentley.DPoint3d) -> bool
        
        Return first/last among children.
        
        Parameter ``[out]``:
        pointA start point
        
        Parameter ``[out]``:
        pointB end point
        
        4. GetStartEnd(self: MSPyBentleyGeom.CurveVector, pointA: Bentley.DPoint3d, pointB: Bentley.DPoint3d, unitTangentA: Bentley.DVec3d, unitTangentB: Bentley.DVec3d) -> bool
        
        Return first/last among children.
        
        Parameter ``[out]``:
        pointA start point
        
        Parameter ``[out]``:
        pointB end point
        """
        ...
    
    def GetStartPoint(*args, **kwargs):
        """
        GetStartPoint(*args, **kwargs)
        Overloaded function.
        
        1. GetStartPoint(self: MSPyBentleyGeom.CurveVector, point: Bentley.DPoint3d) -> bool
        
        2. GetStartPoint(self: MSPyBentleyGeom.CurveVector, point: Bentley.DPoint3d) -> bool
        
        Return start point of the primitive (or first primitive in deep
        search)
        
        Parameter ``[out]``:
        point start point.
        """
        ...
    
    def HasSingleCurvePrimitive(*args, **kwargs):
        """
        HasSingleCurvePrimitive(self: MSPyBentleyGeom.CurveVector) -> MSPyBentleyGeom.ICurvePrimitive.CurvePrimitiveType
        
        Return true if the curve vector has a single element and that element
        is a primitive.
        """
        ...
    
    class InOutClassification:
        """
        Members:
        
        eINOUT_Unknown
        
        eINOUT_In
        
        eINOUT_Out
        
        eINOUT_On
        """
    
        def __init__(self: MSPyBentleyGeom.CurveVector.InOutClassification, value: int) -> None:
            ...
        
        eINOUT_In: InOutClassification
        
        eINOUT_On: InOutClassification
        
        eINOUT_Out: InOutClassification
        
        eINOUT_Unknown: InOutClassification
        
        @property
        def name(self: handle) -> str:
            ...
        
        @property
        def value(arg0: MSPyBentleyGeom.CurveVector.InOutClassification) -> int:
            ...
        
    def IsAnyRegionType(*args, **kwargs):
        """
        IsAnyRegionType(self: MSPyBentleyGeom.CurveVector) -> bool
        
        Query:is this any closed area type (single, parity, union)
        """
        ...
    
    def IsClosedPath(*args, **kwargs):
        """
        IsClosedPath(self: MSPyBentleyGeom.CurveVector) -> bool
        
        Query:Is this (single) closed path?
        """
        ...
    
    def IsEllipticDisk(*args, **kwargs):
        """
        IsEllipticDisk(self: MSPyBentleyGeom.CurveVector, ellipse: Bentley.DEllipse3d) -> bool
        
        Query:Is this an outer loop with an ellipse as its only curve?
        """
        ...
    
    def IsOpenPath(*args, **kwargs):
        """
        IsOpenPath(self: MSPyBentleyGeom.CurveVector) -> bool
        
        Query:Is this an open path?
        """
        ...
    
    def IsParityRegion(*args, **kwargs):
        """
        IsParityRegion(self: MSPyBentleyGeom.CurveVector) -> bool
        
        Query:Is this a collection of loops with parity rules?
        """
        ...
    
    def IsPhysicallyClosedPath(*args, **kwargs):
        """
        IsPhysicallyClosedPath(self: MSPyBentleyGeom.CurveVector) -> bool
        
        Query:Is this a nominally open path but with matching start and end?
        """
        ...
    
    def IsPlanar(*args, **kwargs):
        """
        IsPlanar(*args, **kwargs)
        Overloaded function.
        
        1. IsPlanar(self: MSPyBentleyGeom.CurveVector, localToWorld: Bentley.Transform, worldToLocal: Bentley.Transform, range: Bentley.DRange3d) -> bool
        
        2. IsPlanar(self: MSPyBentleyGeom.CurveVector, localToWorld: Bentley.Transform, worldToLocal: Bentley.Transform, range: Bentley.DRange3d) -> bool
        
        Test if the contained curves are planar. If so, return transforms and
        local range.
        
        Parameter ``[out]``:
        localToWorld A coordinate frame somewhere on the curves. The
        curves are on the xy plane.
        
        Parameter ``[out]``:
        worldToLocal Inverse of localToWorld.
        
        Parameter ``[out]``:
        range range of the curves when worldToLocal is applied.
        
        Returns:
        true if range is computed and has small z component.
        
        Remark:
        returns true (planar!!) for a single line. Test the local range
        with IsAlmostZeroY to identify this condition.
        """
        ...
    
    def IsPlanarWithDefaultNormal(*args, **kwargs):
        """
        IsPlanarWithDefaultNormal(*args, **kwargs)
        Overloaded function.
        
        1. IsPlanarWithDefaultNormal(self: MSPyBentleyGeom.CurveVector, localToWorld: Bentley.Transform, worldToLocal: Bentley.Transform, range: Bentley.DRange3d, normal: Bentley.DVec3d) -> bool
        
        2. IsPlanarWithDefaultNormal(self: MSPyBentleyGeom.CurveVector, localToWorld: Bentley.Transform, worldToLocal: Bentley.Transform, range: Bentley.DRange3d, normal: Bentley.DVec3d) -> bool
        
        Test if the contained curves are planar. If so, return transforms and
        local range.
        
        Parameter ``[out]``:
        localToWorld A coordinate frame somewhere on the curves. The
        curves are on the xy plane.
        
        Parameter ``[out]``:
        worldToLocal Inverse of localToWorld.
        
        Parameter ``[out]``:
        range range of the curves when worldToLocal is applied.
        
        Parameter ``[in]``:
        normal optional normal to resolve ambiguous cases. If this is
        NULL, any perpendicular to an ambiguous line will be used.
        
        Returns:
        true if range is computed and has small z component.
        """
        ...
    
    def IsRectangle(*args, **kwargs):
        """
        IsRectangle(self: MSPyBentleyGeom.CurveVector, localToWorld: Bentley.Transform, worldToLocal: Bentley.Transform) -> bool
        
        Query:Is this a rectangle?
        
        Parameter ``[out]``:
        localToWorld transform with origin at start, x and y vectors to
        adjacent points, z vector unit normal. (i.e. the x and y vector
        lengths are the side lengths)
        
        Parameter ``[out]``:
        worldToLocal transform to map rectangle to 0..1 in each direction.
        """
        ...
    
    def IsSameStructure(*args, **kwargs):
        """
        IsSameStructure(*args, **kwargs)
        Overloaded function.
        
        1. IsSameStructure(self: MSPyBentleyGeom.CurveVector, other: MSPyBentleyGeom.CurveVector) -> bool
        
        2. IsSameStructure(self: MSPyBentleyGeom.CurveVector, other: MSPyBentleyGeom.CurveVector) -> bool
        
        Recursive check for structural match (tree structure and leaf type)
        with the other curve vector.
        """
        ...
    
    def IsSameStructureAndGeometry(*args, **kwargs):
        """
        IsSameStructureAndGeometry(*args, **kwargs)
        Overloaded function.
        
        1. IsSameStructureAndGeometry(self: MSPyBentleyGeom.CurveVector, other: MSPyBentleyGeom.CurveVector, tolerance: float = 0.0) -> bool
        
        2. IsSameStructureAndGeometry(self: MSPyBentleyGeom.CurveVector, other: MSPyBentleyGeom.CurveVector, tolerance: float = 0.0) -> bool
        
        Recursive check for match (tree structure. leaf type, and geometry)
        with a peer. <param name=" other ">peer for comparison</param> <param
        name=" tolerance ">distance tolerance. (See DoubleOps.AlmostEqual
        ())</param>
        """
        ...
    
    def IsUnionRegion(*args, **kwargs):
        """
        IsUnionRegion(self: MSPyBentleyGeom.CurveVector) -> bool
        
        Query:is this a collection of areas with union rules?
        """
        ...
    
    def Length(*args, **kwargs):
        """
        Length(*args, **kwargs)
        Overloaded function.
        
        1. Length(self: MSPyBentleyGeom.CurveVector) -> float
        
        2. Length(self: MSPyBentleyGeom.CurveVector, worldToLocal: Bentley.RotMatrix) -> float
        
        3. Length(self: MSPyBentleyGeom.CurveVector) -> float
        
        Sum lengths of contained curves.
        
        4. Length(self: MSPyBentleyGeom.CurveVector, worldToLocal: Bentley.RotMatrix) -> float
        
        Sum lengths of contained curves.
        """
        ...
    
    def MaxGapWithinPath(*args, **kwargs):
        """
        MaxGapWithinPath(*args, **kwargs)
        Overloaded function.
        
        1. MaxGapWithinPath(self: MSPyBentleyGeom.CurveVector) -> float
        
        2. MaxGapWithinPath(self: MSPyBentleyGeom.CurveVector) -> float
        
        Maximum gap distance between end of primitive and start of its
        successor within Open, outer, or Inner loop.
        """
        ...
    
    def PlaneSection(*args, **kwargs):
        """
        PlaneSection(*args, **kwargs)
        Overloaded function.
        
        1. PlaneSection(self: MSPyBentleyGeom.CurveVector, plane: Bentley.DPlane3d, tolerance: float = 0.0) -> MSPyBentleyGeom.ICurvePrimitive
        
        2. PlaneSection(self: MSPyBentleyGeom.CurveVector, plane: Bentley.DPlane3d, tolerance: float = 0.0) -> MSPyBentleyGeom.ICurvePrimitive
        
        Compute intersections of closed CurveVector with a plane and organize
        as start end pairs by parity rules. Return as a single curve primitive
        (which may be child vector of multiple primitives) If there are no
        intersections the smart pointer is empty (IsValid () returns false)
        
        Parameter ``[in]``:
        plane
        
        Parameter ``[in]``:
        tolerance for on-plane decisions. If 0, a tolerance is computed
        based on the coordinates in the curve.
        """
        ...
    
    def PointInOnOutXY(*args, **kwargs):
        """
        PointInOnOutXY(*args, **kwargs)
        Overloaded function.
        
        1. PointInOnOutXY(self: MSPyBentleyGeom.CurveVector, xyz: Bentley.DPoint3d) -> MSPyBentleyGeom.CurveVector.InOutClassification
        
        2. PointInOnOutXY(self: MSPyBentleyGeom.CurveVector, xyz: Bentley.DPoint3d) -> MSPyBentleyGeom.CurveVector.InOutClassification
        
        Test if a point is in, on, or outside when looking at xy plane. return
        INOUT_Unknown if the CurveVector is not an area. (i.e. type
        BOUNDARY_TYPE_Outer, BOUNDARY_TYPE_Inner, BOUNDARY_TYPE_ParityRegion,
        or BOUNDARY_TYPE_Union
        
        Parameter ``[in]``:
        xyz test point
        """
        ...
    
    def ProjectedParameterRange(*args, **kwargs):
        """
        ProjectedParameterRange(self: MSPyBentleyGeom.CurveVector, ray: Bentley.DRay3d) -> Bentley.DRange1d
        
        Return the range of ray parameters when contents of the CurveVector
        are projected to a ray. return DRange1d with range data.
        
        Parameter ``[in]``:
        ray test ray.
        
        Remark:
        If the ray's direction vector is a unit vector, the projected
        parameters are physical distances.
        
        Remark:
        If the ray's direction vector is NOT a unit vector, the projected
        parameters are fractions of the ray's direction vector.
        
        Remark:
        If the CurveVector has no curves, the returned range returns true
        on the DRange1d.IsNull() predicate.
        """
        ...
    
    def RayPierceInOnOut(*args, **kwargs):
        """
        RayPierceInOnOut(*args, **kwargs)
        Overloaded function.
        
        1. RayPierceInOnOut(self: MSPyBentleyGeom.CurveVector, ray: Bentley.DRay3d, hitDetail: MSPyBentleyGeom.SolidLocationDetail) -> MSPyBentleyGeom.CurveVector.InOutClassification
        
        2. RayPierceInOnOut(self: MSPyBentleyGeom.CurveVector, ray: Bentley.DRay3d, hitDetail: MSPyBentleyGeom.SolidLocationDetail) -> MSPyBentleyGeom.CurveVector.InOutClassification
        
        Test for a ray hit in the curve vector's planar region. return
        INOUT_Unknown if the CurveVector is not an area. (i.e. type
        BOUNDARY_TYPE_Outer, BOUNDARY_TYPE_Inner, BOUNDARY_TYPE_ParityRegion,
        or BOUNDARY_TYPE_Union
        """
        ...
    
    def ReduceToCCWAreas(*args, **kwargs):
        """
        ReduceToCCWAreas(*args, **kwargs)
        Overloaded function.
        
        1. ReduceToCCWAreas(regionA: MSPyBentleyGeom.CurveVector) -> MSPyBentleyGeom.CurveVector
        
        2. ReduceToCCWAreas(regionA: MSPyBentleyGeom.CurveVector) -> MSPyBentleyGeom.CurveVector
        
        Return a curve vector containing only clockwise areas. Loops within
        parity regions are fixed first. Then multiple regions in a union are
        combined.
        
        Parameter ``[in]``:
        regionA input areas
        """
        ...
    
    def ReorderForSmallGaps(*args, **kwargs):
        """
        ReorderForSmallGaps(*args, **kwargs)
        Overloaded function.
        
        1. ReorderForSmallGaps(self: MSPyBentleyGeom.CurveVector) -> float
        
        2. ReorderForSmallGaps(self: MSPyBentleyGeom.CurveVector) -> float
        
        Reorder curve primitives to produce small head-to-tail gaps.
        reordering is applied only within boundary types None, Open, and
        Closed. other types are updated recursively. Return the largest gap.
        """
        ...
    
    def ResolveTolerance(*args, **kwargs):
        """
        ResolveTolerance(*args, **kwargs)
        Overloaded function.
        
        1. ResolveTolerance(self: MSPyBentleyGeom.CurveVector, tolerance: float) -> float
        
        2. ResolveTolerance(self: MSPyBentleyGeom.CurveVector, tolerance: float) -> float
        
        return larger of given tolerance and default tolerance based on
        FastMasAbs of contents ...
        """
        ...
    
    def ReverseCurvesInPlace(*args, **kwargs):
        """
        ReverseCurvesInPlace(*args, **kwargs)
        Overloaded function.
        
        1. ReverseCurvesInPlace(self: MSPyBentleyGeom.CurveVector) -> bool
        
        2. ReverseCurvesInPlace(self: MSPyBentleyGeom.CurveVector) -> bool
        
        Recursively reverse. All leaf curves are reversed. Primitive order
        within path types (_Outer, _Inner, _Open) is reversed. All others
        (_Union, _Parity, _None) are unchanged.
        """
        ...
    
    def SimplifyLinestrings(*args, **kwargs):
        """
        SimplifyLinestrings(*args, **kwargs)
        Overloaded function.
        
        1. SimplifyLinestrings(self: MSPyBentleyGeom.CurveVector, distanceTol: float, eliminateOverdraw: bool, wrap: bool) -> None
        
        2. SimplifyLinestrings(self: MSPyBentleyGeom.CurveVector, distanceTol: float, eliminateOverdraw: bool, wrap: bool) -> None
        
        Inplace update to consolidate colinear interior points of linestrings.
        If distance tolerance is nonpositive a tolerance will be assigned from
        the range.
        """
        ...
    
    def Stroke(*args, **kwargs):
        """
        Stroke(*args, **kwargs)
        Overloaded function.
        
        1. Stroke(self: MSPyBentleyGeom.CurveVector, options: Bentley.IFacetOptions) -> MSPyBentleyGeom.CurveVector
        
        2. Stroke(self: MSPyBentleyGeom.CurveVector, options: Bentley.IFacetOptions) -> MSPyBentleyGeom.CurveVector
        
        Return a " deep copy " with primitives replaced by strokes. The tree
        upper levels of the tree structure are retained -- i.e. the output
        contains corresponding tree structure ParityRegion, UnionRegion,
        OuterLoop, and InnerLoop ul> li>UnionRegion and ParityRegion vectors:
        Create a new CurveVector of the same type. Recursively create
        children. li>OuterLoop, InnerLoop, OpenPath:Create a new curve vector
        of the same type. Stroke all curve primitives into a single linestring
        with the child curves' AddStrokes method. ul>
        """
        ...
    
    def SwapAt(*args, **kwargs):
        """
        SwapAt(self: MSPyBentleyGeom.CurveVector, index0: int, index1: int) -> bool
        
        Swap the entries at given indices. Return false if either index is out
        of bounds.
        """
        ...
    
    def SwapContents(*args, **kwargs):
        """
        SwapContents(self: MSPyBentleyGeom.CurveVector, other: MSPyBentleyGeom.CurveVector) -> None
        
        Swap bvectors and type.
        """
        ...
    
    def ToBsplineCurve(*args, **kwargs):
        """
        ToBsplineCurve(*args, **kwargs)
        Overloaded function.
        
        1. ToBsplineCurve(self: MSPyBentleyGeom.CurveVector, curve: Bentley.MSBsplineCurve) -> Bentley.BentleyStatus
        
        2. ToBsplineCurve(self: MSPyBentleyGeom.CurveVector, curve: Bentley.MSBsplineCurve) -> Bentley.BentleyStatus
        
        Represent a curve vector that denotes an open or closed path as a
        single bspline curve.
        """
        ...
    
    def TransformInPlace(*args, **kwargs):
        """
        TransformInPlace(*args, **kwargs)
        Overloaded function.
        
        1. TransformInPlace(self: MSPyBentleyGeom.CurveVector, transform: Bentley.Transform) -> bool
        
        2. TransformInPlace(self: MSPyBentleyGeom.CurveVector, transform: Bentley.Transform) -> bool
        
        Apply a transform to all contained curves.
        """
        ...
    
    def TryUVFractionToXYZ(*args, **kwargs):
        """
        TryUVFractionToXYZ(self: MSPyBentleyGeom.CurveVector, uFraction: float, vFraction: float, xyz: Bentley.DPoint3d, dXdu: Bentley.DVec3d, dXdv: Bentley.DVec3d) -> bool
        
        convert u,v fraction to xyz and derivatives. This is an expensive
        operation. It has to call CloneInLocalCoordinates before it can
        multiply uv by the localToWorld transformation. To do this efficiently
        many times, call CloneInLocalCoordinates once and reuse the
        localToWorld transform.
        
        Parameter ``[in]``:
        uFraction fractional coordinate in u direction.
        
        Parameter ``[in]``:
        vFraction fractional coordinate in v direction.
        
        Parameter ``[out]``:
        xyz point on face.
        
        Parameter ``[out]``:
        dXdu derivative of face point wrt uFraction.
        
        Parameter ``[out]``:
        dXdv derivative of face point wrt vFraction.
        """
        ...
    
    def WireCentroid(*args, **kwargs):
        """
        WireCentroid(self: MSPyBentleyGeom.CurveVector) -> tuple
        
        Return the centroid of the contained curves, considered as wires.
        (Isolated points are not considered.) (Bounded area centroids are not
        computed. The boundary curves are used as wires.) return false if no
        curves are found.
        
        Parameter ``[out]``:
        length curve length
        
        Parameter ``[out]``:
        centroid curve centroid
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.CurveVector, boundaryType: MSPyBentleyGeom.CurveVector.BoundaryType) -> None
        
        2. __init__(self: MSPyBentleyGeom.CurveVector, boundaryType: MSPyBentleyGeom.CurveVector.BoundaryType, primitive: MSPyBentleyGeom.ICurvePrimitive) -> None
        
        3. __init__(self: MSPyBentleyGeom.CurveVector, segments: Bentley.Bstdcxx.bvector<Bentley.DSegment3d,Bentley.BentleyAllocator<Bentley.DSegment3d> >) -> None
        
        4. __init__(self: MSPyBentleyGeom.CurveVector, child: MSPyBentleyGeom.ICurvePrimitive, boundaryType: MSPyBentleyGeom.CurveVector.BoundaryType) -> None
        """
        ...
    
    eBOUNDARY_TYPE_Inner: BoundaryType
    
    eBOUNDARY_TYPE_None: BoundaryType
    
    eBOUNDARY_TYPE_Open: BoundaryType
    
    eBOUNDARY_TYPE_Outer: BoundaryType
    
    eBOUNDARY_TYPE_ParityRegion: BoundaryType
    
    eBOUNDARY_TYPE_UnionRegion: BoundaryType
    
    eINOUT_In: InOutClassification
    
    eINOUT_On: InOutClassification
    
    eINOUT_Out: InOutClassification
    
    eINOUT_Unknown: InOutClassification
    
class CurveVectorPtrArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.CurveVectorPtrArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.CurveVectorPtrArray, arg0: MSPyBentleyGeom.CurveVectorPtrArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.CurveVectorPtrArray, arg0: Iterable) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.CurveVectorPtrArray, x: MSPyBentleyGeom.CurveVector) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.CurveVectorPtrArray) -> None
        
        Clear the contents
        """
        ...
    
    def count(*args, **kwargs):
        """
        count(self: MSPyBentleyGeom.CurveVectorPtrArray, x: MSPyBentleyGeom.CurveVector) -> int
        
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.CurveVectorPtrArray, L: MSPyBentleyGeom.CurveVectorPtrArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.CurveVectorPtrArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.CurveVectorPtrArray, i: int, x: MSPyBentleyGeom.CurveVector) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.CurveVectorPtrArray) -> MSPyBentleyGeom.CurveVector
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.CurveVectorPtrArray, i: int) -> MSPyBentleyGeom.CurveVector
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(*args, **kwargs):
        """
        remove(self: MSPyBentleyGeom.CurveVectorPtrArray, x: MSPyBentleyGeom.CurveVector) -> None
        
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class CurveVectorWithDistanceIndex:
    """
    None
    """

    def AtEnd(*args, **kwargs):
        """
        AtEnd(self: MSPyBentleyGeom.CurveVectorWithDistanceIndex) -> MSPyBentleyGeom.PathLocationDetail
        
        Return the final location.
        """
        ...
    
    def AtStart(*args, **kwargs):
        """
        AtStart(self: MSPyBentleyGeom.CurveVectorWithDistanceIndex) -> MSPyBentleyGeom.PathLocationDetail
        
        Return the start location.
        """
        ...
    
    def DistanceBetweenPointsXY(*args, **kwargs):
        """
        DistanceBetweenPointsXY(self: MSPyBentleyGeom.CurveVectorWithDistanceIndex, xyzA: Bentley.DPoint3d, xyzB: Bentley.DPoint3d) -> float
        
        projected distance between points
        """
        ...
    
    def DistanceXYFromPathStart(*args, **kwargs):
        """
        DistanceXYFromPathStart(self: MSPyBentleyGeom.CurveVectorWithDistanceIndex, arg0: MSPyBentleyGeom.PathLocationDetail) -> tuple
        
        Given a path location, find the projected curve distance from the path
        start.
        """
        ...
    
    def IsEmpty(*args, **kwargs):
        """
        IsEmpty(self: MSPyBentleyGeom.CurveVectorWithDistanceIndex) -> bool
        
        Return true if there are no curves.
        """
        ...
    
    def NumberOfPrimitives(*args, **kwargs):
        """
        NumberOfPrimitives(self: MSPyBentleyGeom.CurveVectorWithDistanceIndex) -> int
        
        Return the total number of curve primitives in the path.
        """
        ...
    
    def SearchByDistanceFromPathStart(*args, **kwargs):
        """
        SearchByDistanceFromPathStart(self: MSPyBentleyGeom.CurveVectorWithDistanceIndex, targetDistance: float, detail: MSPyBentleyGeom.PathLocationDetail) -> bool
        
        Return detailed curve location for the position at targetDistance
        along the curve.
        """
        ...
    
    def SearchByDistanceFromPathStartXY(*args, **kwargs):
        """
        SearchByDistanceFromPathStartXY(self: MSPyBentleyGeom.CurveVectorWithDistanceIndex, targetDistanceXY: float, detail: MSPyBentleyGeom.PathLocationDetail) -> bool
        
        Return detailed curve location for the position at targetDistance
        along the curve, measuring in path distance. WARNING:The distance
        entry in the PositionLocationDetail is true distance (with z
        variation)
        """
        ...
    
    def SearchClosestPointBounded(*args, **kwargs):
        """
        SearchClosestPointBounded(self: MSPyBentleyGeom.CurveVectorWithDistanceIndex, spacePoint: Bentley.DPoint3d, computeDistanceAlong: bool) -> MSPyBentleyGeom.PathLocationDetail
        
        Search for curve point closest to given space point.
        """
        ...
    
    def SearchFirstIntersectionWithCircleXY(*args, **kwargs):
        """
        SearchFirstIntersectionWithCircleXY(self: MSPyBentleyGeom.CurveVectorWithDistanceIndex, startLocation: MSPyBentleyGeom.PathLocationDetail, signedRadius: float, intersectionLocation: MSPyBentleyGeom.PathLocationDetail) -> bool
        
        Start at specified location. Make a circle of given radius. Look for
        the " first " intersection of the circle with the path, moving only
        forward if the radius is positive and only backward if negative.
        """
        ...
    
    def SetExtendedPath(*args, **kwargs):
        """
        SetExtendedPath(self: MSPyBentleyGeom.CurveVectorWithDistanceIndex, path: MSPyBentleyGeom.CurveVector, extensionDistance: float, boundedStart: MSPyBentleyGeom.PathLocationDetail, boundedEnd: MSPyBentleyGeom.PathLocationDetail, measureExtensionInView: bool = False, maxExtensionFactor: float = 4.0) -> bool
        
        Announce the path to be indexed. This will 1) Construct line segments
        to extend in the directions of the start and end tangents. 2) create
        the <curve,distance> index 3) return PositionLocationDetails for the
        limits of the bounded path.
        """
        ...
    
    def SetPath(*args, **kwargs):
        """
        SetPath(self: MSPyBentleyGeom.CurveVectorWithDistanceIndex, path: MSPyBentleyGeom.CurveVector) -> None
        
        Announce the path to be indexed. This will:1) save a pointer to the
        path. 2) create an index of <curve,distance> to support fast search
        and navigation by distance.
        """
        ...
    
    def TotalPathLength(*args, **kwargs):
        """
        TotalPathLength(self: MSPyBentleyGeom.CurveVectorWithDistanceIndex) -> float
        
        Return complete path length.
        """
        ...
    
    def TotalPathLengthXY(*args, **kwargs):
        """
        TotalPathLengthXY(self: MSPyBentleyGeom.CurveVectorWithDistanceIndex) -> float
        
        Return complete path length as flattened into the view.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.CurveVectorWithDistanceIndex, worldToView: Bentley.RotMatrix) -> None
        
        2. __init__(self: MSPyBentleyGeom.CurveVectorWithDistanceIndex) -> None
        """
        ...
    
class DBilinearPatch3d:
    """
    None
    """

    def Evaluate(*args, **kwargs):
        """
        Evaluate(*args, **kwargs)
        Overloaded function.
        
        1. Evaluate(self: MSPyBentleyGeom.DBilinearPatch3d, u: float, v: float) -> Bentley.DPoint3d
        
        Return surface coordinates at u,v parameters
        
        2. Evaluate(self: MSPyBentleyGeom.DBilinearPatch3d, u: float, v: float, xyz: Bentley.DPoint3d, dXdu: Bentley.DVec3d, dXdv: Bentley.DVec3d) -> None
        
        Return surface coordinates at u,v parameters
        """
        ...
    
    def EvaluateGrid(*args, **kwargs):
        """
        EvaluateGrid(self: MSPyBentleyGeom.DBilinearPatch3d, numUPoint: int, numVPoint: int, gridPoints: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >) -> None
        """
        ...
    
    def EvaluateNormal(*args, **kwargs):
        """
        EvaluateNormal(self: MSPyBentleyGeom.DBilinearPatch3d, u: float, v: float, xyz: Bentley.DPoint3d, unitNormal: Bentley.DVec3d) -> None
        
        Return surface coordinates and unit normal at u,v parameters
        """
        ...
    
    def GetCCWEdge(*args, **kwargs):
        """
        GetCCWEdge(self: MSPyBentleyGeom.DBilinearPatch3d, i: int) -> Bentley.DSegment3d
        
        Return specified edge as a line segment. Edge order is:bottom, right,
        top, left with CCW loop direction.
        """
        ...
    
    def GetDiagonalFrom00(*args, **kwargs):
        """
        GetDiagonalFrom00(self: MSPyBentleyGeom.DBilinearPatch3d) -> Bentley.DVec3d
        
        return diagonal vector starting at 00
        """
        ...
    
    def GetDiagonalFrom01(*args, **kwargs):
        """
        GetDiagonalFrom01(self: MSPyBentleyGeom.DBilinearPatch3d) -> Bentley.DVec3d
        
        return diagonal vector starting at 01
        """
        ...
    
    def GetUEdgeVector(*args, **kwargs):
        """
        GetUEdgeVector(self: MSPyBentleyGeom.DBilinearPatch3d, i: int) -> Bentley.DVec3d
        
        return vector along u edge (lower or upper)
        
        Parameter ``[in]``:
        i 0,1 for lower, upper edge.
        """
        ...
    
    def GetVEdgeVector(*args, **kwargs):
        """
        GetVEdgeVector(self: MSPyBentleyGeom.DBilinearPatch3d, i: int) -> Bentley.DVec3d
        
        return vector along v edge (left, right)
        
        Parameter ``[in]``:
        i 0,1 for left, right edge.
        """
        ...
    
    def IsParallelogram(*args, **kwargs):
        """
        IsParallelogram(self: MSPyBentleyGeom.DBilinearPatch3d) -> bool
        
        Test if the patch is just a parallelogram
        """
        ...
    
    def IsPlanar(*args, **kwargs):
        """
        IsPlanar(*args, **kwargs)
        Overloaded function.
        
        1. IsPlanar(self: MSPyBentleyGeom.DBilinearPatch3d) -> bool
        
        Test if the patch is planar, with usual system angle tolerances
        (tight)
        
        2. IsPlanar(self: MSPyBentleyGeom.DBilinearPatch3d, angleTol: float) -> bool
        
        Test if the patch is planar, with usual system angle tolerances
        (tight)
        """
        ...
    
    def PerpendicularsOnBoundedPatch(*args, **kwargs):
        """
        PerpendicularsOnBoundedPatch(self: MSPyBentleyGeom.DBilinearPatch3d, spacePoint: Bentley.DPoint3d, uv: Bentley.Bstdcxx.bvector<Bentley.DPoint2d,Bentley.BentleyAllocator<Bentley.DPoint2d> >) -> bool
        
        return uv coordinates of projections of xyz onto the (bounded) patch.
        This returns only true perpendicular projections (i.e. does not give
        " close but nonperpendicular point on edge ")
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DBilinearPatch3d) -> None
        
        2. __init__(self: MSPyBentleyGeom.DBilinearPatch3d, xyz0: Bentley.DPoint3d, xyz10: Bentley.DPoint3d, xyz01: Bentley.DPoint3d, xyz11: Bentley.DPoint3d) -> None
        
        3. __init__(self: MSPyBentleyGeom.DBilinearPatch3d, xyz0: Bentley.DPoint2d, xyz10: Bentley.DPoint2d, xyz01: Bentley.DPoint2d, xyz11: Bentley.DPoint2d) -> None
        
        4. __init__(self: MSPyBentleyGeom.DBilinearPatch3d, lowerEdge: Bentley.DSegment3d, upperEdge: Bentley.DSegment3d) -> None
        """
        ...
    
class DCatenary3dPlacement:
    """
    None
    """

    def AlmostEqual(*args, **kwargs):
        """
        AlmostEqual(self: MSPyBentleyGeom.DCatenary3dPlacement, other: MSPyBentleyGeom.DCatenary3dPlacement, tolerance: float) -> bool
        """
        ...
    
    def AppendPlaneIntersections(*args, **kwargs):
        """
        AppendPlaneIntersections(self: MSPyBentleyGeom.DCatenary3dPlacement, plane: MSPyBentleyGeom.DPlane3d, xValues: MSPyBentley.DoubleArray, bounded: bool) -> bool
        
        compute intersections with a plane. Return x values
        """
        ...
    
    def CloneBetweenFractions(*args, **kwargs):
        """
        CloneBetweenFractions(self: MSPyBentleyGeom.DCatenary3dPlacement, fraction0: float, fraction1: float) -> MSPyBentleyGeom.DCatenary3dPlacement
        
        Return a clone over a fractional interval within the existing curve.
        """
        ...
    
    def EndDistance(*args, **kwargs):
        """
        EndDistance(self: MSPyBentleyGeom.DCatenary3dPlacement) -> float
        
        Return the local coordinate (parameter) of the catenary end.
        """
        ...
    
    def FractionToPoint(*args, **kwargs):
        """
        FractionToPoint(self: MSPyBentleyGeom.DCatenary3dPlacement, f: float) -> MSPyBentleyGeom.DPoint3d
        """
        ...
    
    def FractionToPointAndDerivatives(*args, **kwargs):
        """
        FractionToPointAndDerivatives(self: MSPyBentleyGeom.DCatenary3dPlacement, f: float) -> Bentley.Transform
        """
        ...
    
    def FractionToPointAndTangent(*args, **kwargs):
        """
        FractionToPointAndTangent(self: MSPyBentleyGeom.DCatenary3dPlacement, f: float) -> MSPyBentleyGeom.DRay3d
        """
        ...
    
    def Get(*args, **kwargs):
        """
        Get(self: MSPyBentleyGeom.DCatenary3dPlacement, basis: Bentley.DPlane3dByVectors, segment: MSPyBentleyGeom.DSegment1d) -> float
        
        Get explicit contents ...
        """
        ...
    
    def MultiplyInPlace(*args, **kwargs):
        """
        MultiplyInPlace(self: MSPyBentleyGeom.DCatenary3dPlacement, arg0: Bentley.Transform) -> None
        
        transform
        """
        ...
    
    def ReverseInPlace(*args, **kwargs):
        """
        ReverseInPlace(self: MSPyBentleyGeom.DCatenary3dPlacement) -> None
        """
        ...
    
    def StartDistance(*args, **kwargs):
        """
        StartDistance(self: MSPyBentleyGeom.DCatenary3dPlacement) -> float
        
        Return the local coordinate (parameter) of the catenary start.
        """
        ...
    
    def Stroke(*args, **kwargs):
        """
        Stroke(self: MSPyBentleyGeom.DCatenary3dPlacement, xyz: MSPyBentleyGeom.DPoint3dArray, fraction: MSPyBentley.DoubleArray, fraction0: float, fraction1: float, chordTolerance: float, angleTolerance: float, maxEdgeLength: float) -> None
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DCatenary3dPlacement) -> None
        
        2. __init__(self: MSPyBentleyGeom.DCatenary3dPlacement, a: float, basis: Bentley.DPlane3dByVectors, distance0: float, distance1: float) -> None
        
        3. __init__(self: MSPyBentleyGeom.DCatenary3dPlacement, xyCurve: MSPyBentleyGeom.DCatenaryXY, basis: Bentley.DPlane3dByVectors, x0: float, x1: float) -> None
        
        4. __init__(self: MSPyBentleyGeom.DCatenary3dPlacement, other: MSPyBentleyGeom.DCatenary3dPlacement) -> None
        """
        ...
    
class DCatenaryXY:
    """
    None
    """

    def AlmostEqual(*args, **kwargs):
        """
        AlmostEqual(self: MSPyBentleyGeom.DCatenaryXY, other: MSPyBentleyGeom.DCatenaryXY, tolerance: float) -> bool
        """
        ...
    
    def CoshIntersectHomogeneousLine(*args, **kwargs):
        """
        CoshIntersectHomogeneousLine(hLine: Bentley.DVec3d, roots: MSPyBentley.DoubleArray) -> bool
        
        Solve for simultaneous roots of
        
        * y = cosh(x)
        
        * x*hLine.x + y*hLine.y + hLine.z = 0
        
        * Note that the cosh(x) is raw x -- NOT divided by the " a " parameter
        used in the catenary.
        
        * At most 2 roots are possible.
        
        * A false return is detection of failed iteration.
        
        * A true return with 0,1,or 2 roots is normal.
        
        * The false case is probably due to very large numbers. cosh(x) gets
        large very quickly.
        """
        ...
    
    def CoshIntersectLine(*args, **kwargs):
        """
        CoshIntersectLine(alpha: float, beta: float, gamma: float, roots: MSPyBentley.DoubleArray) -> bool
        
        Solve for roots of alpha + beta*x + gamma * cosh(x) = 0
        
        * Note that the cosh(x) is raw x -- NOT divided by the " a " parameter
        used in the catenary.
        
        * At most 2 roots are possible.
        
        * A false return is detection of failed iteration.
        
        * A true return with 0,1,or 2 roots is normal.
        
        * The false case is probably due to very large numbers. cosh(x) gets
        large very quickly.
        """
        ...
    
    def CurvatureAtLength(*args, **kwargs):
        """
        CurvatureAtLength(self: MSPyBentleyGeom.DCatenaryXY, s: float) -> float
        
        return curvature at (signed) distance along.
        """
        ...
    
    def DerivativesAtLength(*args, **kwargs):
        """
        DerivativesAtLength(self: MSPyBentleyGeom.DCatenaryXY, s: float, uv: MSPyBentleyGeom.DPoint2d, duv: Bentley.DVec2d, dduv: Bentley.DVec2d, ddduv: Bentley.DVec2d) -> None
        
        Return the point and 2 derivatives at distance from min point
        """
        ...
    
    def LengthAtX(*args, **kwargs):
        """
        LengthAtX(self: MSPyBentleyGeom.DCatenaryXY, x: float) -> float
        
        Return curve length from origin to x. This is signed.
        """
        ...
    
    def RadiansAtLength(*args, **kwargs):
        """
        RadiansAtLength(self: MSPyBentleyGeom.DCatenaryXY, s: float) -> float
        
        Return the tangent angle at distance
        """
        ...
    
    def RadiansAtX(*args, **kwargs):
        """
        RadiansAtX(self: MSPyBentleyGeom.DCatenaryXY, x: float) -> float
        
        Return curve angle (from X axis) at x.
        """
        ...
    
    def TangentAtLength(*args, **kwargs):
        """
        TangentAtLength(self: MSPyBentleyGeom.DCatenaryXY, s: float) -> Bentley.DVec2d
        
        Return the tangent vector (unit), derivative of XY wrt s.
        """
        ...
    
    def XYAtLength(*args, **kwargs):
        """
        XYAtLength(self: MSPyBentleyGeom.DCatenaryXY, s: float) -> MSPyBentleyGeom.DPoint2d
        
        return x,y at arc length from the min point.
        """
        ...
    
    def YAtX(*args, **kwargs):
        """
        YAtX(self: MSPyBentleyGeom.DCatenaryXY, x: float) -> float
        
        Return curve y value at x
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DCatenaryXY) -> None
        
        2. __init__(self: MSPyBentleyGeom.DCatenaryXY, a: float) -> None
        """
        ...
    
    def d2YdX2AtX(*args, **kwargs):
        """
        d2YdX2AtX(self: MSPyBentleyGeom.DCatenaryXY, x: float) -> float
        
        Return 2nd derivative at x.
        """
        ...
    
    def dYdXAtX(*args, **kwargs):
        """
        dYdXAtX(self: MSPyBentleyGeom.DCatenaryXY, x: float) -> float
        
        Return slope at x
        """
        ...
    
DERIVATIVE_CONTINUITY: int

class DEllipse3d:
    """
    None
    """

    def AlignedRange(*args, **kwargs):
        """
        AlignedRange(self: MSPyBentleyGeom.DEllipse3d, localToGlobal: Bentley.Transform, globalToLocal: Bentley.Transform, range: Bentley.DRange3d) -> bool
        
        Parameter ``[out]``:
        localToGlobal coordinate frame with origin at lower right of local
        range.
        
        Parameter ``[out]``:
        globalToLocal transformation from world to local
        
        Parameter ``[out]``:
        range ellipse range in the local coordinates.
        """
        ...
    
    def AngleToFraction(*args, **kwargs):
        """
        AngleToFraction(self: MSPyBentleyGeom.DEllipse3d, angle: float) -> float
        
        @description Convert an angular parameter to a fraction of bounded arc
        length.
        
        Parameter ``[in]``:
        angle angle (radians) to convert
        
        Returns:
        fractional parameter
        """
        ...
    
    def ArcLength(*args, **kwargs):
        """
        ArcLength(self: MSPyBentleyGeom.DEllipse3d) -> float
        
        @description Return arc length of ellipse.
        
        Returns:
        arc length of ellipse.
        """
        ...
    
    def ClosestApproach(*args, **kwargs):
        """
        ClosestApproach(self: MSPyBentleyGeom.DEllipse3d, ray: Bentley.DRay3d) -> list
        """
        ...
    
    def ClosestPointBounded(*args, **kwargs):
        """
        ClosestPointBounded(self: MSPyBentleyGeom.DEllipse3d, point: Bentley.DPoint3d) -> tuple
        
        @description Find the closest point on a bounded ellipse, considering
        both endpoints and perpendicular projections.
        
        Parameter ``[out]``:
        minAngle angular parameter at closest point
        
        Parameter ``[out]``:
        minDistanceSquared squared distance to closest point
        
        Parameter ``[out]``:
        minPoint closest point
        
        Parameter ``[in]``:
        point space point
        
        Returns:
        always true
        """
        ...
    
    def ClosestPointBoundedXY(*args, **kwargs):
        """
        ClosestPointBoundedXY(*args, **kwargs)
        Overloaded function.
        
        1. ClosestPointBoundedXY(self: MSPyBentleyGeom.DEllipse3d, spacePoint: Bentley.DPoint3d, worldToLocal: Bentley.DMatrix4d) -> tuple
        
        Find the closest point (projection or end), as viewed in xy plane,
        after applying optional transformation.
        
        Parameter ``[out]``:
        closePoint closest point, in coordinates of the input segment.
        
        Parameter ``[out]``:
        closeParam parameter at closest point
        
        Parameter ``[out]``:
        distanceXY distance in transformed coordinates
        
        Parameter ``[in]``:
        spacePoint world coordinates of test point.
        
        Parameter ``[in]``:
        worldToLocal optional transformation.
        
        2. ClosestPointBoundedXY(self: MSPyBentleyGeom.DEllipse3d, spacePoint: Bentley.DPoint3d, worldToLocal: Bentley.DMatrix4d, extend0: bool, extend1: bool) -> tuple
        
        Find the closest point (projection or end), as viewed in xy plane,
        after applying optional transformation.
        
        Parameter ``[out]``:
        closePoint closest point, in coordinates of the input segment.
        
        Parameter ``[out]``:
        closeParam parameter at closest point
        
        Parameter ``[out]``:
        distanceXY distance in transformed coordinates
        
        Parameter ``[in]``:
        spacePoint world coordinates of test point.
        
        Parameter ``[in]``:
        worldToLocal optional transformation.
        """
        ...
    
    def ClosestPointXYBounded(*args, **kwargs):
        """
        ClosestPointXYBounded(self: MSPyBentleyGeom.DEllipse3d, point: Bentley.DPoint3d) -> tuple
        
        @description Find the closest point on a bounded ellipse, considering
        both endpoints and perpendicular projections, and ignoring z of both
        the ellipse and space point.
        
        Parameter ``[out]``:
        minAngle angular parameter at closest point
        
        Parameter ``[out]``:
        minDistanceSquared squared distance to closest point
        
        Parameter ``[out]``:
        minPoint closest point
        
        Parameter ``[in]``:
        point space point
        
        Returns:
        always true
        """
        ...
    
    def ComplementSweep(*args, **kwargs):
        """
        ComplementSweep(self: MSPyBentleyGeom.DEllipse3d) -> None
        
        @description Set the ellipse sweep to the complement of its current
        angular range.
        
        Remark:
        s Full ellipse is left unchanged.
        """
        ...
    
    def Construct_Point_Direction_TangentXY(*args, **kwargs):
        """
        Construct_Point_Direction_TangentXY(ellipses: Bentley.Bstdcxx.bvector<Bentley.DEllipse3d,Bentley.BentleyAllocator<Bentley.DEllipse3d> >, fractionB: MSPyBentley.DoubleArray, pointA: Bentley.DPoint3d, directionA: Bentley.DVec3d, ray: Bentley.DRay3d) -> None
        
        Construct circular arc(s) with given start point and tangent, tangent
        to a given ray.
        
        Parameter ``[out]``:
        ellipse constructed ellipses.
        
        Parameter ``[out]``:
        fractionB parameters on the ray.
        
        Parameter ``[in]``:
        pointA start ponit
        
        Parameter ``[in]``:
        directionA start tangent
        
        Parameter ``[in]``:
        rayB ray for tangency. The tangency can occur anywhere on the ray.
        """
        ...
    
    def Construct_XPoint_EdgePoint_EdgePoint_XRadius(*args, **kwargs):
        """
        Construct_XPoint_EdgePoint_EdgePoint_XRadius(ellipses: Bentley.Bstdcxx.bvector<Bentley.DEllipse3d,Bentley.BentleyAllocator<Bentley.DEllipse3d> >, xPoint: Bentley.DPoint3d, edgePoint0: Bentley.DPoint3d, edgePoint1: Bentley.DPoint3d, a: float) -> None
        
        Construct (up to 3) ellipses defined by known primary radius, primary
        axis point, and two other edge points
        
        Parameter ``[out]``:
        ellipses computed ellipses.
        
        Parameter ``[in]``:
        xPoint x axis point
        
        Parameter ``[in]``:
        edgePoint0 any other point on the ellipse.
        
        Parameter ``[in]``:
        edgePoint1 any other point on the ellipse.
        
        Parameter ``[in]``:
        a x axis radius.
        """
        ...
    
    def Construct_XRadius_YRadius_XPoint_EdgePoint(*args, **kwargs):
        """
        Construct_XRadius_YRadius_XPoint_EdgePoint(ellipses: Bentley.Bstdcxx.bvector<Bentley.DEllipse3d,Bentley.BentleyAllocator<Bentley.DEllipse3d> >, a: float, b: float, xPoint: Bentley.DPoint3d, edgePoint: Bentley.DPoint3d) -> None
        
        Construct (up to 4) ellipses defined by known primary radii, primary
        axis point, and another edge point.
        
        Parameter ``[out]``:
        ellipses computed ellipses.
        
        Parameter ``[in]``:
        a x axis radius.
        
        Parameter ``[in]``:
        b y axis radius.
        
        Parameter ``[in]``:
        xPoint x axis point
        
        Parameter ``[in]``:
        edgePoint any other point on the ellipse.
        """
        ...
    
    def DeterminantJXY(*args, **kwargs):
        """
        DeterminantJXY(self: MSPyBentleyGeom.DEllipse3d) -> float
        
        @description Compute the determinant of the Jacobian matrix for the
        transformation from local coordinates (cosine, sine) to global xy-
        coordinates.
        
        Returns:
        determinant of Jacobian.
        """
        ...
    
    def Evaluate(*args, **kwargs):
        """
        Evaluate(*args, **kwargs)
        Overloaded function.
        
        1. Evaluate(self: MSPyBentleyGeom.DEllipse3d, point: Bentley.DPoint3d, xx: float, yy: float) -> None
        
        @description Compute the ellipse xyz point at a given parametric (xy)
        coordinate.
        
        Parameter ``[out]``:
        point evaluated point
        
        Parameter ``[in]``:
        xx local x coordinate:cos(theta)
        
        Parameter ``[in]``:
        yy local y coordinate:sin(theta)
        
        2. Evaluate(self: MSPyBentleyGeom.DEllipse3d, point3dX: Bentley.DPoint3d, dX: Bentley.DVec3d, ddX: Bentley.DVec3d, theta: float) -> None
        
        @description Compute the ellipse xyz point at a given parametric (xy)
        coordinate.
        
        Parameter ``[out]``:
        point evaluated point
        
        Parameter ``[in]``:
        xx local x coordinate:cos(theta)
        
        Parameter ``[in]``:
        yy local y coordinate:sin(theta)
        
        3. Evaluate(self: MSPyBentleyGeom.DEllipse3d, numDerivative: int, theta: float) -> list
        """
        ...
    
    def EvaluateEndPoints(*args, **kwargs):
        """
        EvaluateEndPoints(self: MSPyBentleyGeom.DEllipse3d, startPoint: Bentley.DPoint3d, endPoint: Bentley.DPoint3d) -> None
        
        @description Compute the ellipse start and end points.
        
        Parameter ``[out]``:
        startPoint start point of ellipse
        
        Parameter ``[out]``:
        endPoint end point of ellipse
        """
        ...
    
    def EvaluateTrigPairs(*args, **kwargs):
        """
        EvaluateTrigPairs(self: MSPyBentleyGeom.DEllipse3d, point: Bentley.DPoint3d, trig: Bentley.DPoint2d, numPoint: int) -> None
        
        @description Evaluate an ellipse using given coefficients for the
        axes.
        
        Remark:
        s If the x,y components of the coefficients define a unit vector,
        the point is " on " the ellipse.
        
        Parameter ``[out]``:
        point array of cartesian points
        
        Parameter ``[in]``:
        trig array of local coords (e.g., (cos, sin)).
        
        Parameter ``[in]``:
        numPoint number of pairs
        """
        ...
    
    def FractionParameterToDerivatives(*args, **kwargs):
        """
        FractionParameterToDerivatives(self: MSPyBentleyGeom.DEllipse3d, point3dX: Bentley.DPoint3d, dX: Bentley.DVec3d, ddX: Bentley.DVec3d, fraction: float) -> None
        
        @description Compute the ellipse xyz point and derivatives at a given
        fraction of the angular parametric range.
        
        Parameter ``[out]``:
        point3dX point on ellipse
        
        Parameter ``[out]``:
        dX second derivative vector
        
        Parameter ``[out]``:
        ddX second derivative vector
        
        Parameter ``[in]``:
        fraction fractional parameter for evaluation
        """
        ...
    
    def FractionParameterToPoint(*args, **kwargs):
        """
        FractionParameterToPoint(self: MSPyBentleyGeom.DEllipse3d, point3dX: Bentley.DPoint3d, fraction: float) -> None
        
        @description Compute the ellipse xyz point at a given fraction of the
        angular parametric range.
        
        Parameter ``[out]``:
        point3dX point on ellipse
        
        Parameter ``[in]``:
        fraction fractional parameter for evaluation
        """
        ...
    
    def FractionToAngle(*args, **kwargs):
        """
        FractionToAngle(self: MSPyBentleyGeom.DEllipse3d, fraction: float) -> float
        
        @description Convert a fractional parameter to ellipse
        parameterization angle.
        
        Parameter ``[in]``:
        fraction fraction of angular range
        
        Returns:
        angular parameter
        """
        ...
    
    def FractionToLength(*args, **kwargs):
        """
        FractionToLength(self: MSPyBentleyGeom.DEllipse3d, fraction0: float, fraction1: float) -> tuple
        
        @description Compute the (signed) arc length between specified
        fractional parameters.
        
        Remark:
        s Fractions outside [0,1] return error.
        
        Parameter ``[out]``:
        arcLength computed arc length. Negative if fraction1<fraction0.
        
        Parameter ``[in]``:
        fraction0 start fraction for interval to measure
        
        Parameter ``[in]``:
        fraction1 end fraction for interval to measure
        
        Returns:
        true if the arc length was computed.
        """
        ...
    
    def FractionToPoint(*args, **kwargs):
        """
        FractionToPoint(self: MSPyBentleyGeom.DEllipse3d, fraction: float) -> Bentley.DPoint3d
        
        return ellipse point at fractional position in its angular sweep.
        """
        ...
    
    def From(*args, **kwargs):
        """
        From(cx: float, cy: float, cz: float, ux: float, uy: float, uz: float, vx: float, vy: float, vz: float, theta0: float, sweep: float) -> MSPyBentleyGeom.DEllipse3d
        
        @description Returns a DEllipse3d with given fields.
        
        Parameter ``[in]``:
        cx center x coordinate
        
        Parameter ``[in]``:
        cy center y coordinate
        
        Parameter ``[in]``:
        cz center z coordinate
        
        Parameter ``[in]``:
        ux x part of 0 degree vector
        
        Parameter ``[in]``:
        uy y part of 0 degree vector
        
        Parameter ``[in]``:
        uz z part of 0 degree vector
        
        Parameter ``[in]``:
        vx x part of 90 degree vector
        
        Parameter ``[in]``:
        vy y part of 90 degree vector
        
        Parameter ``[in]``:
        vz z part of 90 degree vector
        
        Parameter ``[in]``:
        theta0 start angle in parameter space
        
        Parameter ``[in]``:
        sweep sweep angle
        
        Returns:
        DEllipse3d object.
        """
        ...
    
    def FromArcCenterStartEnd(*args, **kwargs):
        """
        FromArcCenterStartEnd(center: Bentley.DPoint3d, startPoint: Bentley.DPoint3d, endTarget: Bentley.DPoint3d) -> MSPyBentleyGeom.DEllipse3d
        
        Return a circular arc with gven center and start. Endpoint is on the
        vector to given endTarget. Sweep angle is the smaller of the two
        possible sweeps.
        
        Parameter ``[in]``:
        center circle center
        
        Parameter ``[in]``:
        startPoint arc start point. This point determines the circle
        radius.
        
        Parameter ``[in]``:
        endTarget Target point for end of circle. If it is at a different
        radius, the actual end point will be at the same radius as the
        start point.
        """
        ...
    
    def FromCenterNormalRadius(*args, **kwargs):
        """
        FromCenterNormalRadius(center: Bentley.DPoint3d, normal: Bentley.DVec3d, radius: float) -> MSPyBentleyGeom.DEllipse3d
        
        Return an (full 360 degree) circular arc with given center, plane
        normal, and radius.
        
        Parameter ``[in]``:
        center ellipse center.
        
        Parameter ``[in]``:
        normal plane normal.
        
        Parameter ``[in]``:
        radius circle radius.
        """
        ...
    
    def FromCenterRadiusXY(*args, **kwargs):
        """
        FromCenterRadiusXY(center: Bentley.DPoint3d, radius: float) -> MSPyBentleyGeom.DEllipse3d
        
        Return an xy-plane full circle with center and radius.
        """
        ...
    
    def FromCopyWithPositiveSweep(*args, **kwargs):
        """
        FromCopyWithPositiveSweep(source: MSPyBentleyGeom.DEllipse3d) -> MSPyBentleyGeom.DEllipse3d
        
        Return an ellipse that sweeps the same points in space (with identical
        fraction-to-point results) but is driven by a positive sweep angle.
        
        Remark:
        If the source ellipse has positive sweep it is simply copied back
        out. If it has a negative sweep, the start angle, sweep angle, and
        vector90 are negated. If a point is on the ellipse, its angular
        coordinate will be negated, but its fractional position is
        maintained.
        
        Parameter ``[in]``:
        source original ellipse
        """
        ...
    
    def FromFractionInterval(*args, **kwargs):
        """
        FromFractionInterval(parent: MSPyBentleyGeom.DEllipse3d, startFraction: float, endFraction: float) -> MSPyBentleyGeom.DEllipse3d
        
        @description Return an ellipse defined by fractional start and end on
        a parent ellipse
        
        Parameter ``[in]``:
        parent existing ellipse.
        
        Parameter ``[in]``:
        startFraction fractional coordiante of new ellipse start on
        parent.
        
        Parameter ``[in]``:
        endFraction fractional coordiante of new ellipse end on parent.
        """
        ...
    
    def FromMajorMinor(*args, **kwargs):
        """
        FromMajorMinor(source: MSPyBentleyGeom.DEllipse3d) -> MSPyBentleyGeom.DEllipse3d
        
        Return an ellispe that sweeps the same points as source but has axes
        adjusted so vectors to parametric 0 and 90 degree points are
        perpendicular and the 0 degree vector is the customary major (larger)
        direction.
        
        Parameter ``[in]``:
        source original ellipse, in which vectors might be non
        perpendicular.
        """
        ...
    
    def FromNegateVector90(*args, **kwargs):
        """
        FromNegateVector90(self: MSPyBentleyGeom.DEllipse3d, source: MSPyBentleyGeom.DEllipse3d) -> MSPyBentleyGeom.DEllipse3d
        
        Return an ellipse that sweeps the same points in space (with identical
        fraction-to-point results) but has negated vector90 (and hence negated
        normal)
        """
        ...
    
    def FromPerpendicularAxes(*args, **kwargs):
        """
        FromPerpendicularAxes(source: MSPyBentleyGeom.DEllipse3d) -> MSPyBentleyGeom.DEllipse3d
        
        Return an ellispe that sweeps the same points as source but has axes
        adjusted so vectors to parametric 0 and 90 degree points are
        perpendicular. This may choose a " small " adjustment of the axes even
        if the 90 degree axis ends up longer. Use FromMajorMinor to force the
        0 degree direction to be the larger axis.
        
        Parameter ``[in]``:
        source original ellipse, in which vectors might be non
        perpendicular.
        """
        ...
    
    def FromPoints(*args, **kwargs):
        """
        FromPoints(center: Bentley.DPoint3d, point0: Bentley.DPoint3d, point90: Bentley.DPoint3d, theta0: float, sweep: float) -> MSPyBentleyGeom.DEllipse3d
        
        @description Returns a DEllipse3d with fill in ellipse data from
        center, 0 degree, and 90 degree points.
        
        Parameter ``[in]``:
        center ellipse center
        
        Parameter ``[in]``:
        point0 0 degree point
        
        Parameter ``[in]``:
        point90 90 degree point
        
        Parameter ``[in]``:
        theta0 start angle
        
        Parameter ``[in]``:
        sweep sweep angle
        
        Returns:
        DEllipse3d object.
        """
        ...
    
    def FromPointsOnArc(*args, **kwargs):
        """
        FromPointsOnArc(start: Bentley.DPoint3d, middle: Bentley.DPoint3d, end: Bentley.DPoint3d) -> MSPyBentleyGeom.DEllipse3d
        
        @description Initialize an elliptical arc from 3 points.
        
        Parameter ``[in]``:
        start start point
        
        Parameter ``[in]``:
        middle mid point
        
        Parameter ``[in]``:
        end end point
        """
        ...
    
    def FromReversed(*args, **kwargs):
        """
        FromReversed(source: MSPyBentleyGeom.DEllipse3d) -> MSPyBentleyGeom.DEllipse3d
        
        Return an ellipse that sweeps the same points in space but in the
        reversed direction.
        
        Parameter ``[in]``:
        source original ellipse
        """
        ...
    
    def FromRotatedAxes(*args, **kwargs):
        """
        FromRotatedAxes(source: MSPyBentleyGeom.DEllipse3d, newStart: float) -> MSPyBentleyGeom.DEllipse3d
        
        Return an ellipse that traverses the same points in space but has its
        vector0 and vector90 axes shifted so that the parametric start takes
        on specified value.
        
        Parameter ``[in]``:
        source original ellipse.
        
        Parameter ``[in]``:
        newStart the angle value that should be the start in the new
        ellispe.
        """
        ...
    
    def FromScaledRotMatrix(*args, **kwargs):
        """
        FromScaledRotMatrix(center: Bentley.DPoint3d, matrix: Bentley.RotMatrix, r0: float, r90: float, theta0: float, sweep: float) -> MSPyBentleyGeom.DEllipse3d
        
        Return an (arc of an) ellipse, with axes defined by a RotMatrix XY
        columns and scale factors.
        """
        ...
    
    def FromScaledVectors(*args, **kwargs):
        """
        FromScaledVectors(*args, **kwargs)
        Overloaded function.
        
        1. FromScaledVectors(center: Bentley.DPoint3d, vector0: Bentley.DVec3d, vector90: Bentley.DVec3d, r0: float, r90: float, theta0: float, sweep: float) -> MSPyBentleyGeom.DEllipse3d
        
        Return an (arc of an) ellipse with axes defined directly by scaled
        vectors.
        
        2. FromScaledVectors(source: MSPyBentleyGeom.DEllipse3d, factor: float) -> MSPyBentleyGeom.DEllipse3d
        
        Return an (arc of an) ellipse with axes defined directly by scaled
        vectors.
        """
        ...
    
    def FromStartTangentNormalRadiusSweep(*args, **kwargs):
        """
        FromStartTangentNormalRadiusSweep(pointA: Bentley.DPoint3d, tangent: Bentley.DVec3d, planeNormal: Bentley.DVec3d, radius: float, sweepRadians: float) -> MSPyBentleyGeom.ValidatedDEllipse3d
        
        Construct an arc from start point, start tangent, radius and sweep
        (and plane normal)
        """
        ...
    
    def FromVectors(*args, **kwargs):
        """
        FromVectors(center: Bentley.DPoint3d, vector0: Bentley.DVec3d, vector90: Bentley.DVec3d, theta0: float, sweep: float) -> MSPyBentleyGeom.DEllipse3d
        
        Return a (arc of an) ellipse with given 0 and 90 degree vectors.
        """
        ...
    
    def FromXYMajorMinor(*args, **kwargs):
        """
        FromXYMajorMinor(cx: float, cy: float, cz: float, rx: float, ry: float, thetaX: float, theta0: float, sweep: float) -> MSPyBentleyGeom.DEllipse3d
        
        @description Returns a DEllipse3d with fill in ellipse data from 2D
        major and minor axis lengths and the angle from the global to the
        local x-axis.
        
        Parameter ``[in]``:
        cx center x coordinate
        
        Parameter ``[in]``:
        cy center y coordinate
        
        Parameter ``[in]``:
        cz z coordinate of all points on the ellipse
        
        Parameter ``[in]``:
        rx radius along local x axis
        
        Parameter ``[in]``:
        ry radius along local y axis
        
        Parameter ``[in]``:
        thetaX angle from global x to local x
        
        Parameter ``[in]``:
        theta0 start angle in parameter space
        
        Parameter ``[in]``:
        sweep sweep angle
        
        Returns:
        DEllipse3d object.
        """
        ...
    
    def GetDGNFields2d(*args, **kwargs):
        """
        GetDGNFields2d(self: MSPyBentleyGeom.DEllipse3d) -> tuple
        """
        ...
    
    def GetDGNFields3d(*args, **kwargs):
        """
        GetDGNFields3d(self: MSPyBentleyGeom.DEllipse3d) -> tuple
        
        @description Fill in ellipse data from data fields in DGN 3d ellipse
        element.
        
        Parameter ``[out]``:
        centerOUT center of ellipse.
        
        Parameter ``[out]``:
        pQuatWXYZ quaternion for orthogonal frame. As per DGN convention,
        ordered WXYZ. If this is NULL, major and minor directions must be
        supplied as pDirection0 and pDirection90;
        
        Parameter ``[out]``:
        directionX unit vector in ellipse x direction.
        
        Parameter ``[out]``:
        directionY unit vector in ellipse y direction.
        
        Parameter ``[out]``:
        rx scale factor (usually a true distance) for x direction.
        
        Parameter ``[out]``:
        ry scale factor (usually a true distance) for y direction.
        
        Parameter ``[out]``:
        startAngle start angle.
        
        Parameter ``[out]``:
        sweepAngle sweep angle.
        """
        ...
    
    def GetLimits(*args, **kwargs):
        """
        GetLimits(self: MSPyBentleyGeom.DEllipse3d) -> tuple
        
        @description Get the start and end angles of the ellipse.
        
        Parameter ``[out]``:
        startAngle start angle
        
        Parameter ``[out]``:
        endAngle end angle
        """
        ...
    
    def GetLocalFrame(*args, **kwargs):
        """
        GetLocalFrame(self: MSPyBentleyGeom.DEllipse3d, frame: Bentley.Transform, inverse: Bentley.Transform) -> bool
        
        @description Get the coordinate frame for an ellipse. X,Y axes are at
        0 and 90 degrees. Z axis is perpendicular with magnitude equal to the
        geometric mean of the other two.
        
        Parameter ``[out]``:
        frame transformation from (cosine, sine, z) coordinates to global
        xyz.
        
        Parameter ``[out]``:
        inverse inverse of frame.
        
        Returns:
        true if the requested frames were returned.
        """
        ...
    
    def GetLocalRange(*args, **kwargs):
        """
        GetLocalRange(self: MSPyBentleyGeom.DEllipse3d, range: Bentley.DRange2d) -> None
        
        @description Compute the range of the ellipse in its own coordinate
        system.
        
        Remark:
        s This depends on the start and sweep angles but not the center or
        axis coordinates.
        
        Parameter ``[out]``:
        range computed range
        """
        ...
    
    def GetMajorMinorRangeMidlines(*args, **kwargs):
        """
        GetMajorMinorRangeMidlines(self: MSPyBentleyGeom.DEllipse3d, longSegment: Bentley.DSegment3d, shortSegment: Bentley.DSegment3d) -> float
        
        @description Compute the range box of the ellipse in its major-minor
        axis coordinate system. Compute line segments that are the horizontal
        and vertical midlines in that system. Return those line segments
        ordered with the longest first, and return the shorter length.
        
        Remark:
        s The typical use of this is that if the shorter length is less
        than some tolerance the points swept out by the ellipse are the
        longer segment. (But beware that the start and end points of the
        segment can be other than the start and end points of the
        ellipse.)
        
        Parameter ``[out]``:
        longSegment longer axis of local conic range box
        
        Parameter ``[out]``:
        shortSegment shorter axis of local conic range box
        
        Returns:
        size of the shorter dimension
        """
        ...
    
    def GetRange(*args, **kwargs):
        """
        GetRange(self: MSPyBentleyGeom.DEllipse3d, range: Bentley.DRange3d) -> None
        
        @description Compute the xyz range limits of a 3D ellipse.
        
        Parameter ``[out]``:
        range computed range
        """
        ...
    
    def GetScaledRotMatrix(*args, **kwargs):
        """
        GetScaledRotMatrix(self: MSPyBentleyGeom.DEllipse3d) -> tuple
        
        @description Extract major minor axis form of the ellipse.
        
        Parameter ``[out]``:
        center ellipse center
        
        Parameter ``[out]``:
        matrix columns 0, 1 are normalized ellipse basis vectors, column 2
        is their cross product
        
        Parameter ``[out]``:
        r0 scale factor for column 0
        
        Parameter ``[out]``:
        r1 scale factor for column 1
        
        Parameter ``[out]``:
        theta0 start angle
        
        Parameter ``[out]``:
        sweep sweep angle
        """
        ...
    
    def GetScaledTransforms(*args, **kwargs):
        """
        GetScaledTransforms(self: MSPyBentleyGeom.DEllipse3d) -> tuple
        
        @description Extract major minor axis form of the ellipse.
        
        Parameter ``[out]``:
        localToWorld orthogonal frame with origin at center, xy axes n
        major and minor axes.
        
        Parameter ``[out]``:
        r0 scale factor for column 0
        
        Parameter ``[out]``:
        r1 scale factor for column 1
        
        Parameter ``[out]``:
        theta0 start angle
        
        Parameter ``[out]``:
        sweep sweep angle
        
        Parameter ``[out]``:
        worldToLocal inverse of localToWorld.
        """
        ...
    
    def GetStrokeCount(*args, **kwargs):
        """
        GetStrokeCount(self: MSPyBentleyGeom.DEllipse3d, nDefault: int = 12, nMax: int = 180, chordTol: float = 0.0, angTol: float = 0.0) -> int
        
        @description Compute an estimated number of points needed to stroke a
        full ellipse to within the given chord height tolerance.
        
        Parameter ``[in]``:
        nDefault default number of points on full ellipse
        
        Parameter ``[in]``:
        nMax max number of points on full ellipse
        
        Parameter ``[in]``:
        chordTol distance tolerance
        
        Parameter ``[in]``:
        angleTol turning angle tolerance
        
        Returns:
        number of strokes required on the full ellipse
        """
        ...
    
    def GetSweep(*args, **kwargs):
        """
        GetSweep(self: MSPyBentleyGeom.DEllipse3d) -> tuple
        
        @description Get the start and sweep angles of the ellipse.
        
        Parameter ``[out]``:
        startAngle start angle
        
        Parameter ``[out]``:
        sweepAngle sweep angle
        """
        ...
    
    def GetXYLocalFrame(*args, **kwargs):
        """
        GetXYLocalFrame(self: MSPyBentleyGeom.DEllipse3d, frame: Bentley.Transform, inverse: Bentley.Transform) -> bool
        
        @description Get the coordinate frame and inverse of an ellipse as
        viewed along the global z axis.
        
        Parameter ``[out]``:
        frame transformation from (cosine, sine, z) coordinates to global
        xyz.
        
        Parameter ``[out]``:
        inverse inverse of frame.
        
        Returns:
        true if the requested frames were returned.
        """
        ...
    
    def InitArcFromPointPointArcLength(*args, **kwargs):
        """
        InitArcFromPointPointArcLength(self: MSPyBentleyGeom.DEllipse3d, startIN: Bentley.DPoint3d, end: Bentley.DPoint3d, arcLength: float, planeVector: Bentley.DVec3d) -> bool
        
        @description Initialize a circlular arc from start point, end point,
        another vector which determines the plane, and the arc length.
        
        Parameter ``[in]``:
        startIN start point
        
        Parameter ``[in]``:
        end end point
        
        Parameter ``[in]``:
        arcLength required arc length
        
        Parameter ``[in]``:
        planeVector vector to be used to determine the plane of the arc.
        The plane is chosen so that it contains both the start-to-end
        vector and the plane vector, and the arc bulge is in the direction
        of the plane vector (rather than opposite).
        
        Returns:
        true if the arc length exceeds the chord length and the 2 points
        and plane vector determine a clear plane.
        """
        ...
    
    def InitArcFromPointTangentPoint(*args, **kwargs):
        """
        InitArcFromPointTangentPoint(self: MSPyBentleyGeom.DEllipse3d, startIN: Bentley.DPoint3d, tangent: Bentley.DVec3d, end: Bentley.DPoint3d) -> bool
        
        @description Initialize a circular arc from start point, start
        tangent, and end point.
        
        Parameter ``[in]``:
        startIN start point
        
        Parameter ``[in]``:
        tangent start tangent
        
        Parameter ``[in]``:
        end end point
        
        Returns:
        true if circular arc computed. false if start, end and tangent are
        colinear.
        """
        ...
    
    def InitFromCenterMajorAxisPointAndThirdPoint(*args, **kwargs):
        """
        InitFromCenterMajorAxisPointAndThirdPoint(self: MSPyBentleyGeom.DEllipse3d, center: Bentley.DPoint3d, point0: Bentley.DPoint3d, point1: Bentley.DPoint3d) -> bool
        
        @description Initialize an ellipse from center, primary axis point,
        and additional pass-though point.
        
        Parameter ``[in]``:
        centerIN center point of ellipse.
        
        Parameter ``[in]``:
        point0 point to appear at the zero degree point. The ellipse must
        pass through this point as a major or minor axis point, i.e. its
        tangent must be perpendicular to the vector from the center to
        this point.
        
        Parameter ``[in]``:
        point1 additional pass-through point.
        
        Returns:
        false if center, point0 and point1 are not independent, or if
        point1 is too far away from center to allow ellipse constrution.
        """
        ...
    
    def InitFromDGNFields2d(*args, **kwargs):
        """
        InitFromDGNFields2d(*args, **kwargs)
        Overloaded function.
        
        1. InitFromDGNFields2d(self: MSPyBentleyGeom.DEllipse3d, center: Bentley.DPoint2d, direction0: Bentley.DVec2d, rX: float, rY: float, startAngle: float, sweepAngle: float, zDepth: float) -> None
        
        @description Fill in ellipse data from data fields in DGN 2d ellipse
        element.
        
        Parameter ``[in]``:
        centerIN center of ellipse.
        
        Parameter ``[in]``:
        direction0 ellipse x axis direction.
        
        Parameter ``[in]``:
        rX scale factor for ellipse x direction.
        
        Parameter ``[in]``:
        rY scale factor for ellipse y direction.
        
        Parameter ``[in]``:
        startAngle start angle.
        
        Parameter ``[in]``:
        sweepAngle sweep angle.
        
        Parameter ``[in]``:
        zDepth z value for ellipse.
        
        2. InitFromDGNFields2d(self: MSPyBentleyGeom.DEllipse3d, center: Bentley.DPoint2d, xAngle: float, rX: float, rY: float, startAngle: float, sweepAngle: float, zDepth: float) -> None
        
        @description Fill in ellipse data from data fields in DGN 2d ellipse
        element.
        
        Parameter ``[in]``:
        centerIN center of ellipse.
        
        Parameter ``[in]``:
        direction0 ellipse x axis direction.
        
        Parameter ``[in]``:
        rX scale factor for ellipse x direction.
        
        Parameter ``[in]``:
        rY scale factor for ellipse y direction.
        
        Parameter ``[in]``:
        startAngle start angle.
        
        Parameter ``[in]``:
        sweepAngle sweep angle.
        
        Parameter ``[in]``:
        zDepth z value for ellipse.
        """
        ...
    
    def InitFromDGNFields3d(*args, **kwargs):
        """
        InitFromDGNFields3d(*args, **kwargs)
        Overloaded function.
        
        1. InitFromDGNFields3d(self: MSPyBentleyGeom.DEllipse3d, center: Bentley.DPoint3d, directionX: Bentley.DVec3d, directionY: Bentley.DVec3d, rX: float, rY: float, startAngle: float, sweepAngle: float) -> None
        
        @description Fill in ellipse data from data fields in DGN 3d ellipse
        element.
        
        Parameter ``[in]``:
        centerIN center of ellipse.
        
        Parameter ``[in]``:
        directionX vector in the x axis direction. This is scaled by rX.
        (It is NOT normalized before scaling. In common use, it will be a
        unit vector.)
        
        Parameter ``[in]``:
        directionY vector in the y axis direction. This is scaled by rY.
        (It is NOT normalized before scaling. In common use, it will be a
        unit vector.)
        
        Parameter ``[in]``:
        rX scale factor (usually a true distance) for x direction.
        
        Parameter ``[in]``:
        rY scale factor (usually a true distance) for y direction.
        
        Parameter ``[in]``:
        startAngle start angle
        
        Parameter ``[in]``:
        sweepAngle sweep angle
        
        2. InitFromDGNFields3d(self: MSPyBentleyGeom.DEllipse3d, center: Bentley.DPoint3d, quatWXYZ: Bentley.DPoint4d, rX: float, rY: float, startAngle: float, sweepAngle: float) -> None
        
        @description Fill in ellipse data from data fields in DGN 3d ellipse
        element.
        
        Parameter ``[in]``:
        centerIN center of ellipse.
        
        Parameter ``[in]``:
        directionX vector in the x axis direction. This is scaled by rX.
        (It is NOT normalized before scaling. In common use, it will be a
        unit vector.)
        
        Parameter ``[in]``:
        directionY vector in the y axis direction. This is scaled by rY.
        (It is NOT normalized before scaling. In common use, it will be a
        unit vector.)
        
        Parameter ``[in]``:
        rX scale factor (usually a true distance) for x direction.
        
        Parameter ``[in]``:
        rY scale factor (usually a true distance) for y direction.
        
        Parameter ``[in]``:
        startAngle start angle
        
        Parameter ``[in]``:
        sweepAngle sweep angle
        """
        ...
    
    def InitWithPerpendicularAxes(*args, **kwargs):
        """
        InitWithPerpendicularAxes(self: MSPyBentleyGeom.DEllipse3d, source: MSPyBentleyGeom.DEllipse3d) -> None
        
        @description Make a copy of the source ellipse, altering the axis
        vectors and angular limits so that the revised ellipse has
        perpendicular axes in the conventional major/minor axis form.
        
        Remark:
        s Inputs may be the same.
        
        Parameter ``[in]``:
        source ellipse with unconstrained axes
        """
        ...
    
    def IntersectPlane(*args, **kwargs):
        """
        IntersectPlane(self: MSPyBentleyGeom.DEllipse3d, plane: Bentley.DPoint4d) -> list
        
        @description Find intersections of a (full) ellipse with a plane.
        
        Remark:
        s Return value n=1 is a single tangency point returned in
        trigPoints[0]; n=2 is two simple intersections returned in
        trigPoints[0..1]
        
        Remark:
        s The three component values in trigPoints are:<UL> <LI>x ==
        cosine of angle <LI>y == sine of angle <LI>z == angle in radians
        </UL>
        
        Parameter ``[out]``:
        trigPoints 2 points:cosine, sine, theta values of plane
        intersection
        
        Parameter ``[in]``:
        plane homogeneous plane equation
        
        Returns:
        The number of intersections, i.e. 0, 1, or 2
        """
        ...
    
    def IntersectSweptDEllipse3d(*args, **kwargs):
        """
        IntersectSweptDEllipse3d(self: MSPyBentleyGeom.DEllipse3d, ellipse1: MSPyBentleyGeom.DEllipse3d) -> list
        """
        ...
    
    def IntersectSweptDEllipse3dBounded(*args, **kwargs):
        """
        IntersectSweptDEllipse3dBounded(self: MSPyBentleyGeom.DEllipse3d, ellipse1: MSPyBentleyGeom.DEllipse3d) -> list
        """
        ...
    
    def IntersectSweptDSegment3d(*args, **kwargs):
        """
        IntersectSweptDSegment3d(self: MSPyBentleyGeom.DEllipse3d, segment: Bentley.DSegment3d) -> list
        """
        ...
    
    def IntersectSweptDSegment3dBounded(*args, **kwargs):
        """
        IntersectSweptDSegment3dBounded(self: MSPyBentleyGeom.DEllipse3d, segment: Bentley.DSegment3d) -> list
        """
        ...
    
    def IntersectXYDEllipse3d(*args, **kwargs):
        """
        IntersectXYDEllipse3d(self: MSPyBentleyGeom.DEllipse3d, ellipse1: MSPyBentleyGeom.DEllipse3d) -> list
        """
        ...
    
    def IntersectXYDEllipse3dBounded(*args, **kwargs):
        """
        IntersectXYDEllipse3dBounded(self: MSPyBentleyGeom.DEllipse3d, ellipse1: MSPyBentleyGeom.DEllipse3d) -> list
        """
        ...
    
    def IntersectXYLine(*args, **kwargs):
        """
        IntersectXYLine(self: MSPyBentleyGeom.DEllipse3d, startPoint: Bentley.DPoint3d, endPoint: Bentley.DPoint3d) -> list
        """
        ...
    
    def IntersectXYLineBounded(*args, **kwargs):
        """
        IntersectXYLineBounded(self: MSPyBentleyGeom.DEllipse3d, startPoint: Bentley.DPoint3d, endPoint: Bentley.DPoint3d) -> list
        """
        ...
    
    def InverseArcLength(*args, **kwargs):
        """
        InverseArcLength(self: MSPyBentleyGeom.DEllipse3d, arcLength: float) -> float
        
        @description Return the sweep angle corresponding to an arc length.
        
        Remark:
        s Negative returned sweep angle corresponds to arclength traversed
        in the opposite direction of the ellipse sweep.
        
        Parameter ``[in]``:
        arcLength arc length to invert
        
        Returns:
        sweep angle
        """
        ...
    
    def IsAlmostEqual(*args, **kwargs):
        """
        IsAlmostEqual(self: MSPyBentleyGeom.DEllipse3d, other: MSPyBentleyGeom.DEllipse3d, tolerance: float) -> bool
        
        Returns:
        true if AlmostEqual center, vectors, and angles.
        """
        ...
    
    def IsAngleInSweep(*args, **kwargs):
        """
        IsAngleInSweep(self: MSPyBentleyGeom.DEllipse3d, angle: float) -> bool
        
        @description Test if a specified angle is within the sweep of the
        ellipse.
        
        Parameter ``[in]``:
        angle angle (radians) to test
        
        Returns:
        true if angle is within the sweep angle of the elliptical arc.
        """
        ...
    
    def IsCCWSweepXY(*args, **kwargs):
        """
        IsCCWSweepXY(self: MSPyBentleyGeom.DEllipse3d) -> bool
        
        @description Test if the XY projection of the ellipse is CCW when
        considering both the sweep sign and the vector directions.
        
        Returns:
        true if circular
        """
        ...
    
    def IsCircular(*args, **kwargs):
        """
        IsCircular(*args, **kwargs)
        Overloaded function.
        
        1. IsCircular(self: MSPyBentleyGeom.DEllipse3d) -> bool
        
        @description Test if the ellipse is circular.
        
        Returns:
        true if circular
        
        2. IsCircular(self: MSPyBentleyGeom.DEllipse3d) -> tuple
        
        @description Test if the ellipse is circular.
        
        Returns:
        true if circular
        """
        ...
    
    def IsCircularXY(*args, **kwargs):
        """
        IsCircularXY(*args, **kwargs)
        Overloaded function.
        
        1. IsCircularXY(self: MSPyBentleyGeom.DEllipse3d) -> bool
        
        @description Test if the XY projection of the ellipse is circular.
        
        Returns:
        true if circular
        
        2. IsCircularXY(self: MSPyBentleyGeom.DEllipse3d) -> tuple
        
        @description Test if the XY projection of the ellipse is circular.
        
        Returns:
        true if circular
        """
        ...
    
    def IsFullEllipse(*args, **kwargs):
        """
        IsFullEllipse(self: MSPyBentleyGeom.DEllipse3d) -> bool
        
        @description Test whether the ellipse is complete (2pi range).
        
        Returns:
        true if the ellipse is complete
        """
        ...
    
    def IsNearZeroRadius(*args, **kwargs):
        """
        IsNearZeroRadius(self: MSPyBentleyGeom.DEllipse3d) -> bool
        
        @description Test whether both vectors are near zero length.
        
        Returns:
        true if both radii are near zero.
        """
        ...
    
    def MakeFullSweep(*args, **kwargs):
        """
        MakeFullSweep(self: MSPyBentleyGeom.DEllipse3d) -> None
        
        @description Set the ellipse sweep to a full 360 degrees (2pi
        radians), preserving direction of sweep.
        
        Remark:
        s Start angle is left unchanged.
        """
        ...
    
    @property
    def MaxAbs(arg0: MSPyBentleyGeom.DEllipse3d) -> float:
        ...
    
    def PointToAngle(*args, **kwargs):
        """
        PointToAngle(self: MSPyBentleyGeom.DEllipse3d, point: Bentley.DPoint3d) -> float
        
        @description Compute the angular position of the point relative to the
        ellipse's local coordinates.
        
        Remark:
        s If the point is on the ellipse, this is the inverse of
        evaluating the ellipse at the angle.
        
        Parameter ``[in]``:
        point point to evaluate
        
        Returns:
        angle in ellipse parameterization
        """
        ...
    
    def PointToXYLocal(*args, **kwargs):
        """
        PointToXYLocal(self: MSPyBentleyGeom.DEllipse3d, localPoint: Bentley.DPoint3d, point: Bentley.DPoint3d) -> bool
        
        @description Compute the local coordinates of a point in the skewed
        coordinates of the ellipse, using only xy parts of both the ellipse
        and starting point.
        
        Remark:
        s This is equivalent to computing the intersection of the ellipse
        plane with a line through the point and parallel to the z axis,
        and returning the coordinates of the intersection relative to the
        skewed axes of the ellipse.
        
        Parameter ``[out]``:
        localPoint evaluated point. Coordinates x,y are multipliers for
        the ellipse axes. Coordinate z is height of the initial point from
        the plane of the ellipse.
        
        Parameter ``[in]``:
        point point to convert to local coordinates
        
        Returns:
        true if ellipse axes are independent.
        """
        ...
    
    def ProjectPoint(*args, **kwargs):
        """
        ProjectPoint(self: MSPyBentleyGeom.DEllipse3d, point: Bentley.DPoint3d) -> list
        """
        ...
    
    def ProjectPointBounded(*args, **kwargs):
        """
        ProjectPointBounded(self: MSPyBentleyGeom.DEllipse3d, point: Bentley.DPoint3d) -> list
        """
        ...
    
    def ProjectPointToPlane(*args, **kwargs):
        """
        ProjectPointToPlane(self: MSPyBentleyGeom.DEllipse3d, xyz: Bentley.DPoint3d) -> tuple
        
        @description Project a point onto the plane of the ellipse.
        
        Parameter ``[out]``:
        xYZNear projection of point onto ellipse plane
        
        Parameter ``[out]``:
        coff0 coefficient on vector towards 0 degree point
        
        Parameter ``[out]``:
        coff90 coefficient on vector towards 90 degree point
        
        Parameter ``[in]``:
        xYZ point to project onto plane
        
        Returns:
        true if the plane is well defined.
        """
        ...
    
    def ProjectPointXY(*args, **kwargs):
        """
        ProjectPointXY(self: MSPyBentleyGeom.DEllipse3d, point: Bentley.DPoint3d) -> list
        """
        ...
    
    def ProjectPointXYBounded(*args, **kwargs):
        """
        ProjectPointXYBounded(self: MSPyBentleyGeom.DEllipse3d, point: Bentley.DPoint3d) -> list
        """
        ...
    
    def ProjectedParameterRange(*args, **kwargs):
        """
        ProjectedParameterRange(self: MSPyBentleyGeom.DEllipse3d, ray: Bentley.DRay3d) -> Bentley.DRange1d
        
        Returns:
        range when projected to fraction space of the ray
        
        Parameter ``[in]``:
        ray
        """
        ...
    
    def RadiansToPoint(*args, **kwargs):
        """
        RadiansToPoint(self: MSPyBentleyGeom.DEllipse3d, theta: float) -> Bentley.DPoint3d
        
        @description return the point on the ellipse at parameteric angle.
        """
        ...
    
    def SetLimits(*args, **kwargs):
        """
        SetLimits(self: MSPyBentleyGeom.DEllipse3d, startAngle: float, endAngle: float) -> None
        
        @description Set the start and end angles of the ellipse.
        
        Parameter ``[in]``:
        startAngle start angle
        
        Parameter ``[in]``:
        endAngle end angle
        """
        ...
    
    def SetStartEnd(*args, **kwargs):
        """
        SetStartEnd(self: MSPyBentleyGeom.DEllipse3d, startPoint: Bentley.DPoint3d, endPoint: Bentley.DPoint3d, ccw: bool) -> bool
        
        @description Set angular parameters to have given start and end
        points.
        
        Remark:
        s If the given points are really on the ellipse, this does the
        expected thing.
        
        Remark:
        s If the given points are not on the ellipse, here's exactly what
        happens. The start/end points are placed on the original ellipse
        at the point where the ellipse intersects the plane formed by the
        ellipse axis and the given point. This leaves the problem that the
        ellipse defines two paths from the given start to end. This is
        resolved as follows. The ellipse's existing 0 and 90 degree
        vectors define a coordinate system. In that system, the short
        sweep from the 0 degree vector to the 90 degree vector is
        considered " counterclockwise ".
        
        Remark:
        s Beware that the relation of supposed start/end points to the
        ellipse is ambiguous.
        
        Parameter ``[in]``:
        startPoint new start point
        
        Parameter ``[in]``:
        endPoint new end point
        
        Parameter ``[in]``:
        ccw true to force counterclockwise direction, false for clockwise.
        
        Returns:
        true if the ellipse axes are independent. false if the ellipse is
        degenerate.
        """
        ...
    
    def SetSweep(*args, **kwargs):
        """
        SetSweep(self: MSPyBentleyGeom.DEllipse3d, startAngle: float, sweep: float) -> None
        
        @description Set the start and sweep angles of the ellipse.
        
        Parameter ``[in]``:
        startAngle start angle
        
        Parameter ``[in]``:
        sweepIN sweep angle
        """
        ...
    
    def SolveTangentsPerpendicularToVector(*args, **kwargs):
        """
        SolveTangentsPerpendicularToVector(self: MSPyBentleyGeom.DEllipse3d, vector: Bentley.DVec3d) -> list
        
        @description Find angles at which the ellipse tangent vector is
        perpendicular to given vector.
        
        Parameter ``[out]``:
        angles 0,1, or 2 angles. This is an array that must be allocated
        by the caller.
        
        Parameter ``[in]``:
        vector perpendicular vector.
        
        Returns:
        The number of solutions, i.e. 0, 1, or 2
        """
        ...
    
    def TangentMagnitude(*args, **kwargs):
        """
        TangentMagnitude(self: MSPyBentleyGeom.DEllipse3d, theta: float) -> float
        
        @description Compute the magnitude of the tangent vector to the
        ellipse at the specified angle.
        
        Parameter ``[in]``:
        theta angular parameter
        
        Returns:
        tangent magnitude
        """
        ...
    
    def TestAndEvaluateTrigPairs(*args, **kwargs):
        """
        TestAndEvaluateTrigPairs(self: MSPyBentleyGeom.DEllipse3d, point: Bentley.DPoint3d, trig: Bentley.DPoint2d, numPoint: int) -> int
        
        @description Evaluate an ellipse at a number of (cosine, sine) pairs,
        removing pairs whose corresponding angle is not in range.
        
        Parameter ``[out]``:
        point array of cartesian points
        
        Parameter ``[in]``:
        trig array of local coords
        
        Parameter ``[in]``:
        numPoint number of pairs
        
        Returns:
        number of points found to be in the angular range of the ellipse.
        """
        ...
    
    def TryConstruct_EdgePoint_XPoint_EdgePoint_XAngle(*args, **kwargs):
        """
        TryConstruct_EdgePoint_XPoint_EdgePoint_XAngle(ellipse: MSPyBentleyGeom.DEllipse3d, edgePoint0: Bentley.DPoint3d, xPoint: Bentley.DPoint3d, edgePoint1: Bentley.DPoint3d, xAngle: float) -> bool
        
        Construct an ellipse (it is unique if it exists) with given x axis,
        start point, x axis point, and end point.
        
        Parameter ``[out]``:
        ellipse constructed ellipse.
        
        Parameter ``[in]``:
        edgePoint0 start point
        
        Parameter ``[in]``:
        xPoint x axis extrema
        
        Parameter ``[in]``:
        edgePoint1 end point
        
        Parameter ``[in]``:
        xAngle angle from global x axis to ellipse x axis
        """
        ...
    
    def WireCentroid(*args, **kwargs):
        """
        WireCentroid(self: MSPyBentleyGeom.DEllipse3d, fraction0: float, fraction1: float) -> tuple
        
        Compute the length (unit density) and wire centroid. Note that an
        ellipse with zero sweephas zero length but the (single) coordinate is
        a well defined centroid.
        
        Parameter ``[out]``:
        length length.
        
        Parameter ``[out]``:
        centroid centroid point.
        
        Parameter ``[in]``:
        fraction0 start fraction of active part of sweep.
        
        Parameter ``[in]``:
        fraction1 end fraction of active part of sweep.
        """
        ...
    
    def XySweepProperties(*args, **kwargs):
        """
        XySweepProperties(self: MSPyBentleyGeom.DEllipse3d, point: Bentley.DPoint3d) -> tuple
        
        @description Compute area and swept angle as seen from given point.
        
        Parameter ``[out]``:
        area swept area
        
        Parameter ``[out]``:
        sweepOUT swept angle (in radians)
        
        Parameter ``[in]``:
        point base point for sweep line.
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.DEllipse3d) -> None:
        ...
    
    @property
    def center(self: MSPyBentleyGeom.DEllipse3d) -> Bentley.DPoint3d:
        ...
    @center.setter
    def center(self: MSPyBentleyGeom.DEllipse3d, arg0: Bentley.DPoint3d) -> None:
        ...
    
    @property
    def start(self: MSPyBentleyGeom.DEllipse3d) -> float:
        ...
    @start.setter
    def start(self: MSPyBentleyGeom.DEllipse3d, arg0: float) -> None:
        ...
    
    @property
    def sweep(self: MSPyBentleyGeom.DEllipse3d) -> float:
        ...
    @sweep.setter
    def sweep(self: MSPyBentleyGeom.DEllipse3d, arg0: float) -> None:
        ...
    
    @property
    def vector0(self: MSPyBentleyGeom.DEllipse3d) -> Bentley.DVec3d:
        ...
    @vector0.setter
    def vector0(self: MSPyBentleyGeom.DEllipse3d, arg0: Bentley.DVec3d) -> None:
        ...
    
    @property
    def vector90(self: MSPyBentleyGeom.DEllipse3d) -> Bentley.DVec3d:
        ...
    @vector90.setter
    def vector90(self: MSPyBentleyGeom.DEllipse3d, arg0: Bentley.DVec3d) -> None:
        ...
    
DISCONNECT: float

class DMap4d:
    """
    None
    """

    def Explode(*args, **kwargs):
        """
        Explode(self: MSPyBentleyGeom.DMap4d, matrix: Bentley.RotMatrix, translation: Bentley.DPoint3d, perspective: Bentley.DPoint4d, inverse: bool) -> None
        
        Copy various parts of the 4x4 matrix to separate data structures.
        
        Parameter ``[out]``:
        matrix upper 3x3
        
        Parameter ``[out]``:
        translation last column (above diagonal)
        
        Parameter ``[out]``:
        perspective last row (including diagonal)
        
        Parameter ``[in]``:
        inverse false for forward part, true for inverse
        
        Remark:
        The separate pieces do not " mean " much if there is perspective.
        """
        ...
    
    def FromPrincipleProjection(*args, **kwargs):
        """
        FromPrincipleProjection(height: float, axis: int) -> MSPyBentleyGeom.DMap4d
        
        Initialize a transform that is a (noninvertible) projection to a
        principle plane.
        
        Parameter ``[in]``:
        height distance of plane from origin
        
        Parameter ``[in]``:
        axis 0,1,2 for x,y,z normal
        """
        ...
    
    def FromQuadrantRotation(*args, **kwargs):
        """
        FromQuadrantRotation(multiple: int, vx: float, vy: float, vz: float) -> MSPyBentleyGeom.DMap4d
        
        Rotate about vx,yv,vz by an integer multiple of 90 degrees. Providing
        the angle as an integer allows exact table lookup without
        approximation of pi.
        
        Parameter ``[in]``:
        multiple rotation angle is multiple * 90 degrees
        
        Parameter ``[in]``:
        vx x component of rotation axis
        
        Parameter ``[in]``:
        vy y component of rotation axis
        
        Parameter ``[in]``:
        vz z component of rotation axis
        """
        ...
    
    def FromRotation(*args, **kwargs):
        """
        FromRotation(c: float, s: float, vx: float, vy: float, vz: float) -> MSPyBentleyGeom.DMap4d
        
        Initialize a rotation about axis vx,vy,vz by angle whose cosine and
        sine are (proportional to) c and s.
        
        Parameter ``[in]``:
        c cosine of angle
        
        Parameter ``[in]``:
        s sine of angle
        
        Parameter ``[in]``:
        vx x component of rotation axis
        
        Parameter ``[in]``:
        vy y component of rotation axis
        
        Parameter ``[in]``:
        vz z component of rotation axis
        """
        ...
    
    def FromScale(*args, **kwargs):
        """
        FromScale(*args, **kwargs)
        Overloaded function.
        
        1. FromScale(ax: float, ay: float, az: float) -> MSPyBentleyGeom.DMap4d
        
        Initialize a pure scaling transformation. If any scale factor is zero,
        the corresponding inverse entry is also zero.
        
        Parameter ``[in]``:
        ax x scale factor
        
        Parameter ``[in]``:
        ay y scale factor
        
        Parameter ``[in]``:
        az z scale factor
        
        2. FromScale(a: float) -> MSPyBentleyGeom.DMap4d
        
        Initialize a pure scaling transformation. If any scale factor is zero,
        the corresponding inverse entry is also zero.
        
        Parameter ``[in]``:
        ax x scale factor
        
        Parameter ``[in]``:
        ay y scale factor
        
        Parameter ``[in]``:
        az z scale factor
        """
        ...
    
    def FromTranslation(*args, **kwargs):
        """
        FromTranslation(tx: float, ty: float, tz: float) -> MSPyBentleyGeom.DMap4d
        
        Initialize a translation transform.
        
        Parameter ``[in]``:
        tx x component of translation
        
        Parameter ``[in]``:
        ty y component of translation
        
        Parameter ``[in]``:
        tz z component of translation
        """
        ...
    
    def InitFrom(*args, **kwargs):
        """
        InitFrom(self: MSPyBentleyGeom.DMap4d, forwardMatrix: Bentley.DMatrix4d, inverseMatrix: Bentley.DMatrix4d) -> None
        
        Direct initialization from matrices. Caller is responsible for correct
        inverse relationship.
        
        Parameter ``[in]``:
        forwardMatrix " forward " matrix.
        
        Parameter ``[in]``:
        inverseMatrix " inverse " matrix.
        """
        ...
    
    def InitFromRanges(*args, **kwargs):
        """
        InitFromRanges(self: MSPyBentleyGeom.DMap4d, loAP: Bentley.DPoint3d, hiAP: Bentley.DPoint3d, loBP: Bentley.DPoint3d, hiBP: Bentley.DPoint3d) -> bool
        
        Initialize a transform which translates and scales along principle
        axes so box loAP..hiAP maps to box loBP..hiBP
        
        Parameter ``[in]``:
        loAP corner of box A
        
        Parameter ``[in]``:
        hiAP diagonally opposite corner of box A
        
        Parameter ``[in]``:
        loBP corner of box B
        
        Parameter ``[in]``:
        hiBP diagonally opposite corner of box B
        
        Returns:
        int
        """
        ...
    
    def InitFromSkewBox(*args, **kwargs):
        """
        InitFromSkewBox(self: MSPyBentleyGeom.DMap4d, point0001: Bentley.DPoint4d, point1001: Bentley.DPoint4d, point0101: Bentley.DPoint4d, point0010: Bentley.DPoint4d) -> bool
        
        Fill a mapping between a unit prism and homogeneous skew space.
        Example use:We want to map a unit rectangle from font space to
        screen, under a full perspective mapping. That is, given font space
        point (x,y) we want A * (x,y,0,1)^T = the visible pixel. Also, given
        pixel (i,j) we want Ainverse * (i,j,0,1) to map back into font space.
        A long time ago, we were told points P0,P1,P2 which are the
        preperspective points that correspond to font space (0,0), (1,0), and
        (0,1). Since then, P00, P10, P01 have been through a homogeneous
        transformation. (For instance, there may be 'weight' of other than 1
        on each one.) The transformed (homogeneous) points are Q00, Q10, Q01
        In device space, we do a projection in the z direction. Hence we need
        a 4th point Qz=(0,0,1,0). Build this matrix by calling
        jmdlDMap4d_fillHomogeneousSkewFrame (pHMap, Q00, Q10,Q01,Qz)
        
        Parameter ``point0001``:
        0001 in the unit space maps here
        
        Parameter ``point1001``:
        1001 in the unit space maps here
        
        Parameter ``point0101``:
        0100 in the unit space maps here
        
        Parameter ``point0010``:
        0010 in the unit space maps here
        
        Returns:
        true if the 4 points are independent
        """
        ...
    
    def InitFromTaper(*args, **kwargs):
        """
        InitFromTaper(self: MSPyBentleyGeom.DMap4d, taper: float) -> bool
        
        Initialize a transform with perspective entries for a (nonzero) taper
        in the z direction.
        
        Parameter ``[in]``:
        taper taper fraction
        
        Returns:
        true if an invertible map was constructed.
        """
        ...
    
    def InitFromTransform(*args, **kwargs):
        """
        InitFromTransform(self: MSPyBentleyGeom.DMap4d, transform: Bentley.Transform, invert: bool) -> bool
        
        Parameter ``[in]``:
        transform affine transformation 3x4 matrix
        
        Parameter ``[in]``:
        invert true to treat this matrix as the inverse of the mapping,
        false if forward.
        
        Returns:
        true if the Transfrom was invertible.
        """
        ...
    
    def InitProduct(*args, **kwargs):
        """
        InitProduct(*args, **kwargs)
        Overloaded function.
        
        1. InitProduct(self: MSPyBentleyGeom.DMap4d, A: MSPyBentleyGeom.DMap4d, B: MSPyBentleyGeom.DMap4d) -> None
        
        Multiply transforms
        
        Parameter ``[in]``:
        A transform A
        
        Parameter ``[in]``:
        B transform B
        
        2. InitProduct(self: MSPyBentleyGeom.DMap4d, A: MSPyBentleyGeom.DMap4d, invertA: bool, B: MSPyBentleyGeom.DMap4d, invertB: bool) -> None
        
        Multiply transforms
        
        Parameter ``[in]``:
        A transform A
        
        Parameter ``[in]``:
        B transform B
        """
        ...
    
    def InverseOf(*args, **kwargs):
        """
        InverseOf(self: MSPyBentleyGeom.DMap4d, B: MSPyBentleyGeom.DMap4d) -> None
        
        Sets pA to the inverse of B.
        
        Parameter ``[in]``:
        B original mapping
        """
        ...
    
    def IsAffine(*args, **kwargs):
        """
        IsAffine(self: MSPyBentleyGeom.DMap4d) -> bool
        
        Test if a transform is affiine.
        
        Returns:
        true if the mapping is affine.
        """
        ...
    
    def IsIdentity(*args, **kwargs):
        """
        IsIdentity(self: MSPyBentleyGeom.DMap4d) -> bool
        
        Returns:
        true if the mapping is an identity
        """
        ...
    
    def IsIndependent(*args, **kwargs):
        """
        IsIndependent(self: MSPyBentleyGeom.DMap4d, xChange: int, yChange: int, zChange: int) -> bool
        
        Checks if the mapping is strictly a scale/translate in specified
        directions.
        
        Parameter ``[in]``:
        xChange 1 if x may change, 0 if it must stay fixed
        
        Parameter ``[in]``:
        yChange 1 if y may change, 0 if it must stay fixed
        
        Parameter ``[in]``:
        zChange 1 if z may change, 0 if it must stay fixed
        
        Returns:
        true if independence tests are satisfied.
        """
        ...
    
    def IsPerspective(*args, **kwargs):
        """
        IsPerspective(self: MSPyBentleyGeom.DMap4d) -> bool
        
        Test if a transform is perspective.
        
        Returns:
        true if the mapping contains perspective.
        """
        ...
    
    def IsSingular(*args, **kwargs):
        """
        IsSingular(self: MSPyBentleyGeom.DMap4d) -> bool
        
        Test if a transform is singular
        
        Returns:
        true if the mapping is singular
        """
        ...
    
    @property
    def M0(self: MSPyBentleyGeom.DMap4d) -> Bentley.DMatrix4d:
        ...
    @M0.setter
    def M0(self: MSPyBentleyGeom.DMap4d, arg0: Bentley.DMatrix4d) -> None:
        ...
    
    @property
    def M1(self: MSPyBentleyGeom.DMap4d) -> Bentley.DMatrix4d:
        ...
    @M1.setter
    def M1(self: MSPyBentleyGeom.DMap4d, arg0: Bentley.DMatrix4d) -> None:
        ...
    
    def SandwichOf(*args, **kwargs):
        """
        SandwichOf(self: MSPyBentleyGeom.DMap4d, A: MSPyBentleyGeom.DMap4d, B: MSPyBentleyGeom.DMap4d, C: MSPyBentleyGeom.DMap4d) -> None
        
        Form the product C * Binv * A * B * Cinv
        
        Parameter ``[in]``:
        A inside term of sandwich
        
        Parameter ``[in]``:
        B middle term of sandwich
        
        Parameter ``[in]``:
        C outer term of sandwich
        """
        ...
    
    def SandwichOfBABinverse(*args, **kwargs):
        """
        SandwichOfBABinverse(self: MSPyBentleyGeom.DMap4d, A: MSPyBentleyGeom.DMap4d, B: MSPyBentleyGeom.DMap4d) -> None
        
        Form the product B * A * BInv A NULL for B or C skips that part.
        
        Parameter ``[in]``:
        A inside term of sandwich
        
        Parameter ``[in]``:
        B outer term of sandwich
        """
        ...
    
    def SandwichOfBinverseAB(*args, **kwargs):
        """
        SandwichOfBinverseAB(self: MSPyBentleyGeom.DMap4d, A: MSPyBentleyGeom.DMap4d, B: MSPyBentleyGeom.DMap4d) -> None
        
        Form the product Binv * A * B
        
        Parameter ``[in]``:
        A inside term of sandwich
        
        Parameter ``[in]``:
        B outer term of sandwich
        """
        ...
    
    def ZFrustum(*args, **kwargs):
        """
        ZFrustum(self: MSPyBentleyGeom.DMap4d, z0: float, zetaHalf: float) -> None
        
        Parameter ``[in]``:
        z0 reference z. Normalized projective coordinate is 0 at this z
        
        Parameter ``[in]``:
        zetaHalf controls rate of growth of normalized projective z.
        Projective z at z0/k is k-1*zetahalf, i.e. is zetahalf at z0/2
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DMap4d) -> None
        
        2. __init__(self: MSPyBentleyGeom.DMap4d, forwardMatrix: Bentley.DMatrix4d, inverseMatrix: Bentley.DMatrix4d) -> None
        
        3. __init__(self: MSPyBentleyGeom.DMap4d, radians: float, vx: float, vy: float, vz: float) -> None
        """
        ...
    
    @property
    def mask(self: MSPyBentleyGeom.DMap4d) -> int:
        ...
    @mask.setter
    def mask(self: MSPyBentleyGeom.DMap4d, arg0: int) -> None:
        ...
    
class DMatrix4d:
    """
    None
    """

    def Add(*args, **kwargs):
        """
        Add(*args, **kwargs)
        Overloaded function.
        
        1. Add(self: MSPyBentleyGeom.DMatrix4d, delta: MSPyBentleyGeom.DMatrix4d) -> None
        
        Add a matrix (componentwise) to the instance.
        
        Parameter ``[in]``:
        delta matrix to add
        
        2. Add(self: MSPyBentleyGeom.DMatrix4d, delta: MSPyBentleyGeom.DMatrix4d, scaleFactor: float) -> None
        
        Add a matrix (componentwise) to the instance.
        
        Parameter ``[in]``:
        delta matrix to add
        """
        ...
    
    def AddSymmetricScaledOuterProduct(*args, **kwargs):
        """
        AddSymmetricScaledOuterProduct(*args, **kwargs)
        Overloaded function.
        
        1. AddSymmetricScaledOuterProduct(self: MSPyBentleyGeom.DMatrix4d, xyz: Bentley.DPoint3d, scale: float) -> None
        
        Add [xx xy xz x; xy yy yz y; xz yz zz 1; x y z 1] * scale
        
        Parameter ``[in]``:
        xyz x,y,z for products. Implicitly extened to DPoint4d [x,y,z,1]
        for products
        
        Parameter ``[in]``:
        scale scale to apply to all terms.
        
        2. AddSymmetricScaledOuterProduct(self: MSPyBentleyGeom.DMatrix4d, xyzw: Bentley.DPoint4d, scale: float) -> None
        
        Add [xx xy xz x; xy yy yz y; xz yz zz 1; x y z 1] * scale
        
        Parameter ``[in]``:
        xyz x,y,z for products. Implicitly extened to DPoint4d [x,y,z,1]
        for products
        
        Parameter ``[in]``:
        scale scale to apply to all terms.
        
        3. AddSymmetricScaledOuterProduct(self: MSPyBentleyGeom.DMatrix4d, U: Bentley.DPoint4d, V: Bentley.DPoint4d, scale: float) -> None
        
        Add [xx xy xz x; xy yy yz y; xz yz zz 1; x y z 1] * scale
        
        Parameter ``[in]``:
        xyz x,y,z for products. Implicitly extened to DPoint4d [x,y,z,1]
        for products
        
        Parameter ``[in]``:
        scale scale to apply to all terms.
        """
        ...
    
    def ApproximateNullVectorForUpperTriangle(*args, **kwargs):
        """
        ApproximateNullVectorForUpperTriangle(self: MSPyBentleyGeom.DMatrix4d) -> tuple
        
        Approximate solution of A*X=0, i.e. find an approximate null vector; A
        is assumed upper triangular. Method:Find the smallest diagonal. Set
        that entry in X to 1. Backsolve the linear system with RHS 0 and the
        chosen X component fixed.
        
        Parameter ``[out]``:
        nullVector approximate null space vector.
        
        Parameter ``[out]``:
        residual estimate of error in A*X. (Squared residual.)
        """
        ...
    
    def ConvertInertiaProductsToPrincipalAreaMoments(*args, **kwargs):
        """
        ConvertInertiaProductsToPrincipalAreaMoments(self: MSPyBentleyGeom.DMatrix4d, localToWorld: Bentley.Transform) -> tuple
        
        Input matrix contains products of inertia{[xx,xy,xz,x; xy yy yz y; xz
        yz zz z; x y z v]}. returned values are centroid, principal directions
        and 2nd moment tensor entries (yy+zz,xx+zz,xx+yy)
        
        Parameter ``[in]``:
        localToWorld transformation from local coordinate system (where
        the products were computed) to world
        
        Parameter ``[out]``:
        area area
        
        Parameter ``[out]``:
        centroid center of mass
        
        Parameter ``[out]``:
        axes columns of this matrix are the principal x,y,z directions.
        
        Parameter ``[out]``:
        momentTensorDiagonal tensor entries (inertias for rotation around
        each axis)
        """
        ...
    
    def ConvertInertiaProductsToPrincipalMoments(*args, **kwargs):
        """
        ConvertInertiaProductsToPrincipalMoments(*args, **kwargs)
        Overloaded function.
        
        1. ConvertInertiaProductsToPrincipalMoments(self: MSPyBentleyGeom.DMatrix4d) -> tuple
        
        Input matrix contains products of inertia{[xx,xy,xz,x; xy yy yz y; xz
        yz zz z; x y z v]}. returned values are centroid, principal directions
        and 2nd moment tensor entries (yy+zz,xx+zz,xx+yy)
        
        Parameter ``[out]``:
        volume volume
        
        Parameter ``[out]``:
        centroid center of mass
        
        Parameter ``[out]``:
        axes columns of this matrix are the principal x,y,z directions.
        
        Parameter ``[out]``:
        momentTensorDiagonal tensor entries (inertias for rotation around
        each axis)
        
        2. ConvertInertiaProductsToPrincipalMoments(self: MSPyBentleyGeom.DMatrix4d, localToWorld: Bentley.Transform) -> tuple
        
        Input matrix contains products of inertia{[xx,xy,xz,x; xy yy yz y; xz
        yz zz z; x y z v]}. returned values are centroid, principal directions
        and 2nd moment tensor entries (yy+zz,xx+zz,xx+yy)
        
        Parameter ``[out]``:
        volume volume
        
        Parameter ``[out]``:
        centroid center of mass
        
        Parameter ``[out]``:
        axes columns of this matrix are the principal x,y,z directions.
        
        Parameter ``[out]``:
        momentTensorDiagonal tensor entries (inertias for rotation around
        each axis)
        """
        ...
    
    def ConvertInertiaProductsToPrincipalWireMoments(*args, **kwargs):
        """
        ConvertInertiaProductsToPrincipalWireMoments(self: MSPyBentleyGeom.DMatrix4d, localToWorld: Bentley.Transform) -> tuple
        
        Input matrix contains products of inertia{[xx,xy,xz,x; xy yy yz y; xz
        yz zz z; x y z v]}. returned values are centroid, principal directions
        and 2nd moment tensor entries (yy+zz,xx+zz,xx+yy)
        
        Parameter ``[in]``:
        localToWorld transformation from local coordinate system (where
        the products were computed) to world
        
        Parameter ``[out]``:
        length length
        
        Parameter ``[out]``:
        centroid center of mass
        
        Parameter ``[out]``:
        axes columns of this matrix are the principal x,y,z directions.
        
        Parameter ``[out]``:
        momentTensorDiagonal tensor entries (inertias for rotation around
        each axis)
        """
        ...
    
    def CopyUpperTriangleToLower(*args, **kwargs):
        """
        CopyUpperTriangleToLower(self: MSPyBentleyGeom.DMatrix4d) -> None
        
        Copy all 6 values from the upper triangle to mirrored positions in the
        lower triangle.
        """
        ...
    
    def DifferenceOf(*args, **kwargs):
        """
        DifferenceOf(self: MSPyBentleyGeom.DMatrix4d, A: MSPyBentleyGeom.DMatrix4d, B: MSPyBentleyGeom.DMatrix4d) -> None
        
        Subtract two 4x4 matrices.
        
        Parameter ``[in]``:
        A A matrix of A - B
        
        Parameter ``[in]``:
        B B matrix of A - B
        """
        ...
    
    def EvaluateImageGrid(*args, **kwargs):
        """
        EvaluateImageGrid(self: MSPyBentleyGeom.DMatrix4d, grid: Bentley.Bstdcxx.bvector<Bentley.DPoint2d,Bentley.BentleyAllocator<Bentley.DPoint2d> >, x00: float, y00: float, m: int, n: int, tol: float) -> bool
        
        Evaluate pA*X for m*n points X arranged in a grid. The homogeneous
        coordinates of the i,j point in the grid is (x0 + i, y0 + j, 0, 1) The
        returned point grid[i * m + j] is the xy components of the image of
        grid poitn ij AFTER normalization.
        
        Parameter ``[out]``:
        grid Array of mXn mapped, normalized points
        
        Parameter ``[in]``:
        x00 grid origin x
        
        Parameter ``[in]``:
        y00 grid origin y
        
        Parameter ``[in]``:
        m number of grid points in x direction
        
        Parameter ``[in]``:
        n number of grid points in y direction
        
        Parameter ``[in]``:
        tol relative tolerance for 0-weight tests. If 0, 1.0e-10 is used *
        """
        ...
    
    def From(*args, **kwargs):
        """
        From(*args, **kwargs)
        Overloaded function.
        
        1. From(B: Bentley.RotMatrix) -> MSPyBentleyGeom.DMatrix4d
        
        Copy a RotMatrix into corresponding parts of a 4x4 matrix with 4th row
        and column both 0001.
        
        Parameter ``[in]``:
        B 3x3 part to fill
        
        2. From(transform: Bentley.Transform) -> MSPyBentleyGeom.DMatrix4d
        
        Copy a RotMatrix into corresponding parts of a 4x4 matrix with 4th row
        and column both 0001.
        
        Parameter ``[in]``:
        B 3x3 part to fill
        """
        ...
    
    def From101WeightedProduct(*args, **kwargs):
        """
        From101WeightedProduct(transformA: Bentley.Transform, matrixB: Bentley.RotMatrix, transformC: Bentley.Transform) -> MSPyBentleyGeom.DMatrix4d
        
        Promote 3 inputs to 4x4 carrier matrices, with respective scale terms
        1,0,1. Return the product of the carriers. (Huh? What is this for? If
        a transform is defined as A*F*C, and the derivative part of F is has
        nonzero derivative B only for its matrix part, A*B*C is the derivative
        4x4 matrix.
        
        Parameter ``[in]``:
        transformA First term. Promoted to 4x4 with final row 0001.
        
        Parameter ``[in]``:
        matrixB Second term. Promoted to 4x4 with final row 0000.
        
        Parameter ``[in]``:
        transformC Third term. Promoted to 4x4 with final row 0001.
        """
        ...
    
    def FromColumnVectors(*args, **kwargs):
        """
        FromColumnVectors(col0: Bentley.DVec3d, col1: Bentley.DVec3d, col2: Bentley.DVec3d, translation: Bentley.DPoint3d) -> MSPyBentleyGeom.DMatrix4d
        
        Fill the affine part using xyz vectors for each column of the basis
        part and an xyz vector for the translation
        
        Parameter ``[in]``:
        col0 data for column 0 of leading 3x3 submatrix
        
        Parameter ``[in]``:
        col1 data for column 1 of leading 3x3 submatrix
        
        Parameter ``[in]``:
        col2 data for column 2 of leading 3x3 submatrix
        
        Parameter ``[in]``:
        translation data for translation part of matrix
        """
        ...
    
    def FromPerspective(*args, **kwargs):
        """
        FromPerspective(px: float, py: float, pz: float) -> MSPyBentleyGeom.DMatrix4d
        
        Fill a matrix with entries in the perspective row, otherwise an
        identity matrix.
        
        Parameter ``[in]``:
        px x component
        
        Parameter ``[in]``:
        py y component
        
        Parameter ``[in]``:
        pz z component
        """
        ...
    
    def FromRowValues(*args, **kwargs):
        """
        FromRowValues(x00: float, x01: float, x02: float, x03: float, x10: float, x11: float, x12: float, x13: float, x20: float, x21: float, x22: float, x23: float, x30: float, x31: float, x32: float, x33: float) -> MSPyBentleyGeom.DMatrix4d
        
        Copies the double values directly into the rows of this instance.
        
        Parameter ``[in]``:
        x00 (0,0) entry of matrix (row, column)
        
        Parameter ``[in]``:
        x01 (0,1) entry
        
        Parameter ``[in]``:
        x02 (0,2) entry
        
        Parameter ``[in]``:
        x03 (0,3) entry
        
        Parameter ``[in]``:
        x10 (1,0) entry of matrix (row, column)
        
        Parameter ``[in]``:
        x11 (1,1) entry
        
        Parameter ``[in]``:
        x12 (1,2) entry
        
        Parameter ``[in]``:
        x13 (1,3) entry
        
        Parameter ``[in]``:
        x20 (2,0) entry of matrix (row, column)
        
        Parameter ``[in]``:
        x21 (2,1) entry
        
        Parameter ``[in]``:
        x22 (2,2) entry
        
        Parameter ``[in]``:
        x23 (2,3) entry
        
        Parameter ``[in]``:
        x30 (3,0) entry of matrix (row, column)
        
        Parameter ``[in]``:
        x31 (3,1) entry
        
        Parameter ``[in]``:
        x32 (3,2) entry
        
        Parameter ``[in]``:
        x33 (3,3) entry
        """
        ...
    
    def FromSandwichProduct(*args, **kwargs):
        """
        FromSandwichProduct(transform: Bentley.Transform, momentMatrix: MSPyBentleyGeom.DMatrix4d, scaleFactor: float) -> MSPyBentleyGeom.DMatrix4d
        
        Return{A = T * B * Tt * s} where T is an affine transform (expanded
        to 4x4 with 0001 final row), B is a DMatrix4d, and s is a scale
        factor.
        
        This is used to do change of basis when entries in B are xx,xy,xz,x
        moments etc, T is the (possibly non-uniform) transformation, and s is
        a scale factor for changing the integration domain. (If the
        integrations were volume integrals, s is the determinant of the
        orientation part of T. If the integrations were area integrals in a
        plane, s is the jacobian of the plane-to-plane transformation.)
        
        Parameter ``[in]``:
        transform transform to apply
        
        Parameter ``[in]``:
        momentMatrix matrix{B}
        
        Parameter ``[in]``:
        scaleFactor
        """
        ...
    
    def FromScaleAndTranslation(*args, **kwargs):
        """
        FromScaleAndTranslation(scale: Bentley.DPoint3d, translation: Bentley.DPoint3d) -> MSPyBentleyGeom.DMatrix4d
        
        Fill the scale and translate entries in an otherwise identity matrix
        
        Parameter ``[in]``:
        scale scale factor for each diagonal of leading 3x3 submatrix
        
        Parameter ``[in]``:
        translation translation vector
        """
        ...
    
    def FromTranslation(*args, **kwargs):
        """
        FromTranslation(tx: float, ty: float, tz: float) -> MSPyBentleyGeom.DMatrix4d
        
        Fill a 4x4 matrix with a given translation vector and otherwise an
        identity.
        
        Parameter ``[in]``:
        tx x component
        
        Parameter ``[in]``:
        ty y component
        
        Parameter ``[in]``:
        tz z component
        """
        ...
    
    def FromZero(*args, **kwargs):
        """
        FromZero() -> MSPyBentleyGeom.DMatrix4d
        
        Fill a matrix with zeros.
        """
        ...
    
    def GetBlocks(*args, **kwargs):
        """
        GetBlocks(self: MSPyBentleyGeom.DMatrix4d) -> tuple
        
        Return matrix, final row, final column, and scalar parts
        
        Parameter ``[out]``:
        products upper 3x3 part
        
        Parameter ``[out]``:
        row xyz parts of final row
        
        Parameter ``[out]``:
        column xyz parts of final column
        
        Parameter ``[out]``:
        scalar ww entry.
        """
        ...
    
    def GetColumn(*args, **kwargs):
        """
        GetColumn(self: MSPyBentleyGeom.DMatrix4d, vec: Bentley.DPoint4d, i: int) -> None
        
        Copy data from a matrix column to a DPoint4d structure.
        
        Parameter ``[out]``:
        vec point copied from column
        
        Parameter ``[in]``:
        i index of column 0 <= i<4 whose values are to be set
        """
        ...
    
    def GetRow(*args, **kwargs):
        """
        GetRow(self: MSPyBentleyGeom.DMatrix4d, vec: Bentley.DPoint4d, i: int) -> None
        
        Copy data from a matrix row to a DPoint4d structure.
        
        Parameter ``[out]``:
        vec point copied from row
        
        Parameter ``[in]``:
        i index of row 0 <= i<4 whose values are to be set
        """
        ...
    
    def GetRows(*args, **kwargs):
        """
        GetRows(self: MSPyBentleyGeom.DMatrix4d, row0: Bentley.DPoint4d, row1: Bentley.DPoint4d, row2: Bentley.DPoint4d, row3: Bentley.DPoint4d) -> None
        
        Copy data from a matrix rows to DPoint4d structures.
        
        Parameter ``[out]``:
        row0 row 0 data. May be NULL.
        
        Parameter ``[out]``:
        row1 row 1 data. May be NULL.
        
        Parameter ``[out]``:
        row2 row 2 data. May be NULL.
        
        Parameter ``[out]``:
        row3 row 3 data. May be NULL.
        """
        ...
    
    def InitFrom(*args, **kwargs):
        """
        InitFrom(*args, **kwargs)
        Overloaded function.
        
        1. InitFrom(self: MSPyBentleyGeom.DMatrix4d, B: Bentley.RotMatrix) -> None
        
        Copy a RotMatrix into corresponding parts of a 4x4 matrix with 4th row
        and column both 0001.
        
        Parameter ``[in]``:
        B 3x3 part to fill
        
        2. InitFrom(self: MSPyBentleyGeom.DMatrix4d, transform: Bentley.Transform) -> None
        
        Copy a RotMatrix into corresponding parts of a 4x4 matrix with 4th row
        and column both 0001.
        
        Parameter ``[in]``:
        B 3x3 part to fill
        """
        ...
    
    def InitFromColumnVectors(*args, **kwargs):
        """
        InitFromColumnVectors(self: MSPyBentleyGeom.DMatrix4d, col0: Bentley.DVec3d, col1: Bentley.DVec3d, col2: Bentley.DVec3d, translation: Bentley.DPoint3d) -> None
        
        Fill the affine part using xyz vectors for each column of the basis
        part and an xyz vector for the translation
        
        Parameter ``[in]``:
        col0 data for column 0 of leading 3x3 submatrix
        
        Parameter ``[in]``:
        col1 data for column 1 of leading 3x3 submatrix
        
        Parameter ``[in]``:
        col2 data for column 2 of leading 3x3 submatrix
        
        Parameter ``[in]``:
        translation data for translation part of matrix
        """
        ...
    
    def InitFromPerspective(*args, **kwargs):
        """
        InitFromPerspective(self: MSPyBentleyGeom.DMatrix4d, px: float, py: float, pz: float) -> None
        
        Fill a matrix with entries in the perspective row, otherwise an
        identity matrix.
        
        Parameter ``[in]``:
        px x component
        
        Parameter ``[in]``:
        py y component
        
        Parameter ``[in]``:
        pz z component
        """
        ...
    
    def InitFromRowValues(*args, **kwargs):
        """
        InitFromRowValues(self: MSPyBentleyGeom.DMatrix4d, x00: float, x01: float, x02: float, x03: float, x10: float, x11: float, x12: float, x13: float, x20: float, x21: float, x22: float, x23: float, x30: float, x31: float, x32: float, x33: float) -> None
        
        Copies the double values directly into the rows of this instance.
        
        Parameter ``[in]``:
        x00 (0,0) entry of matrix (row, column)
        
        Parameter ``[in]``:
        x01 (0,1) entry
        
        Parameter ``[in]``:
        x02 (0,2) entry
        
        Parameter ``[in]``:
        x03 (0,3) entry
        
        Parameter ``[in]``:
        x10 (1,0) entry of matrix (row, column)
        
        Parameter ``[in]``:
        x11 (1,1) entry
        
        Parameter ``[in]``:
        x12 (1,2) entry
        
        Parameter ``[in]``:
        x13 (1,3) entry
        
        Parameter ``[in]``:
        x20 (2,0) entry of matrix (row, column)
        
        Parameter ``[in]``:
        x21 (2,1) entry
        
        Parameter ``[in]``:
        x22 (2,2) entry
        
        Parameter ``[in]``:
        x23 (2,3) entry
        
        Parameter ``[in]``:
        x30 (3,0) entry of matrix (row, column)
        
        Parameter ``[in]``:
        x31 (3,1) entry
        
        Parameter ``[in]``:
        x32 (3,2) entry
        
        Parameter ``[in]``:
        x33 (3,3) entry
        """
        ...
    
    def InitFromScaleAndTranslation(*args, **kwargs):
        """
        InitFromScaleAndTranslation(self: MSPyBentleyGeom.DMatrix4d, scale: Bentley.DPoint3d, translation: Bentley.DPoint3d) -> None
        
        Fill the scale and translate entries in an otherwise identity matrix
        
        Parameter ``[in]``:
        scale scale factor for each diagonal of leading 3x3 submatrix
        
        Parameter ``[in]``:
        translation translation vector
        """
        ...
    
    def InitFromTranslation(*args, **kwargs):
        """
        InitFromTranslation(self: MSPyBentleyGeom.DMatrix4d, tx: float, ty: float, tz: float) -> None
        
        Fill a 4x4 matrix with a given translation vector and otherwise an
        identity.
        
        Parameter ``[in]``:
        tx x component
        
        Parameter ``[in]``:
        ty y component
        
        Parameter ``[in]``:
        tz z component
        """
        ...
    
    def InitIdentity(*args, **kwargs):
        """
        InitIdentity(self: MSPyBentleyGeom.DMatrix4d) -> None
        
        initialize an identity matrix.
        """
        ...
    
    def InitProduct(*args, **kwargs):
        """
        InitProduct(*args, **kwargs)
        Overloaded function.
        
        1. InitProduct(self: MSPyBentleyGeom.DMatrix4d, A: MSPyBentleyGeom.DMatrix4d, B: MSPyBentleyGeom.DMatrix4d) -> None
        
        Form the product of two 4x4 matrices.
        
        Parameter ``[in]``:
        A first matrix of product A*B
        
        Parameter ``[in]``:
        B second matrix of product A*B
        
        2. InitProduct(self: MSPyBentleyGeom.DMatrix4d, A: MSPyBentleyGeom.DMatrix4d, B: MSPyBentleyGeom.DMatrix4d, C: MSPyBentleyGeom.DMatrix4d) -> None
        
        Form the product of two 4x4 matrices.
        
        Parameter ``[in]``:
        A first matrix of product A*B
        
        Parameter ``[in]``:
        B second matrix of product A*B
        """
        ...
    
    def InitSymmetricProduct(*args, **kwargs):
        """
        InitSymmetricProduct(self: MSPyBentleyGeom.DMatrix4d, sigma: Bentley.DPoint4d, B: MSPyBentleyGeom.DMatrix4d) -> None
        
        Compute A = Bt * D * B where B is a matrix and D is a diagonal matrix
        given as a vector. REMARK:This is a Very Bad Thing for numerical
        purposes. Are you sure you can't get your result without forming this
        product?
        
        Parameter ``[in]``:
        sigma entries of diagonal matrix D
        
        Parameter ``[in]``:
        B matrix B
        """
        ...
    
    def IsAffine(*args, **kwargs):
        """
        IsAffine(self: MSPyBentleyGeom.DMatrix4d) -> bool
        
        Tests if the instance has 0001 final row, within tolerance.
        
        Returns:
        true if matrix is approximately affine.
        """
        ...
    
    def IsIdentity(*args, **kwargs):
        """
        IsIdentity(self: MSPyBentleyGeom.DMatrix4d) -> bool
        
        Tests if pInstance is an identity transform and returns the bool
        indicator. The matrix is considered an identity if the sum of squared
        components after subtracting 1 from the diagonals is less than a small
        tolerance
        
        Returns:
        true if matrix is approximately an identity.
        """
        ...
    
    def MaxAbs(*args, **kwargs):
        """
        MaxAbs(*args, **kwargs)
        Overloaded function.
        
        1. MaxAbs(self: MSPyBentleyGeom.DMatrix4d) -> float
        
        Search the matrix for the entry with the largest absolute value.
        
        Returns:
        max absolute value entry in the matrix.
        
        2. MaxAbs(self: MSPyBentleyGeom.DMatrix4d) -> tuple
        
        Search the matrix for the entry with the largest absolute value.
        
        Returns:
        max absolute value entry in the matrix.
        """
        ...
    
    def MaxAbsDiff(*args, **kwargs):
        """
        MaxAbsDiff(self: MSPyBentleyGeom.DMatrix4d, other: MSPyBentleyGeom.DMatrix4d) -> tuple
        
        Compute max absolute difference between various parts of matrices.
        
        Parameter ``[in]``:
        other matrix to compare to.
        
        Parameter ``[out]``:
        matrixDiff difference in matrix part.
        
        Parameter ``[out]``:
        colDiff difference in final column XYZ part
        
        Parameter ``[out]``:
        rowDiff difference in final row XYZ part
        
        Parameter ``[out]``:
        weightDiff difference in final diagonal entry
        
        Returns:
        max absolute difference
        """
        ...
    
    def Multiply(*args, **kwargs):
        """
        Multiply(*args, **kwargs)
        Overloaded function.
        
        1. Multiply(self: MSPyBentleyGeom.DMatrix4d, outPoints: Bentley.Bstdcxx.bvector<Bentley.DPoint4d,Bentley.BentleyAllocator<Bentley.DPoint4d> >, inPoints: Bentley.Bstdcxx.bvector<Bentley.DPoint4d,Bentley.BentleyAllocator<Bentley.DPoint4d> >) -> None
        
        Matrix multiplication, using all components of both the matrix and the
        points.
        
        Parameter ``[out]``:
        outPoint Array of homogeneous products A*inPoint[i]
        
        Parameter ``[in]``:
        inPoint Array of homogeneous points
        
        Parameter ``[in]``:
        n number of points
        
        2. Multiply(self: MSPyBentleyGeom.DMatrix4d, xyz: Bentley.DPoint3d, w: float) -> Bentley.DPoint4d
        
        Matrix multiplication, using all components of both the matrix and the
        points.
        
        Parameter ``[out]``:
        outPoint Array of homogeneous products A*inPoint[i]
        
        Parameter ``[in]``:
        inPoint Array of homogeneous points
        
        Parameter ``[in]``:
        n number of points
        
        3. Multiply(self: MSPyBentleyGeom.DMatrix4d, outPoints: Bentley.Bstdcxx.bvector<Bentley.DPoint4d,Bentley.BentleyAllocator<Bentley.DPoint4d> >, inPoints: Bentley.Bstdcxx.bvector<Bentley.DPoint4d,Bentley.BentleyAllocator<Bentley.DPoint4d> >) -> None
        
        Matrix multiplication, using all components of both the matrix and the
        points.
        
        Parameter ``[out]``:
        outPoint Array of homogeneous products A*inPoint[i]
        
        Parameter ``[in]``:
        inPoint Array of homogeneous points
        
        Parameter ``[in]``:
        n number of points
        
        4. Multiply(self: MSPyBentleyGeom.DMatrix4d, outPoints: Bentley.Bstdcxx.bvector<Bentley.GraphicsPoint,Bentley.BentleyAllocator<Bentley.GraphicsPoint> >, inPoints: Bentley.Bstdcxx.bvector<Bentley.GraphicsPoint,Bentley.BentleyAllocator<Bentley.GraphicsPoint> >) -> None
        
        Matrix multiplication, using all components of both the matrix and the
        points.
        
        Parameter ``[out]``:
        outPoint Array of homogeneous products A*inPoint[i]
        
        Parameter ``[in]``:
        inPoint Array of homogeneous points
        
        Parameter ``[in]``:
        n number of points
        
        5. Multiply(self: MSPyBentleyGeom.DMatrix4d, outPoints: Bentley.Bstdcxx.bvector<Bentley.DPoint4d,Bentley.BentleyAllocator<Bentley.DPoint4d> >, inPoints: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >, weight: MSPyBentley.DoubleArray) -> None
        
        Matrix multiplication, using all components of both the matrix and the
        points.
        
        Parameter ``[out]``:
        outPoint Array of homogeneous products A*inPoint[i]
        
        Parameter ``[in]``:
        inPoint Array of homogeneous points
        
        Parameter ``[in]``:
        n number of points
        
        6. Multiply(self: MSPyBentleyGeom.DMatrix4d, outPoint: Bentley.DPoint4d, inPoint: Bentley.DPoint4d) -> None
        
        Matrix multiplication, using all components of both the matrix and the
        points.
        
        Parameter ``[out]``:
        outPoint Array of homogeneous products A*inPoint[i]
        
        Parameter ``[in]``:
        inPoint Array of homogeneous points
        
        Parameter ``[in]``:
        n number of points
        """
        ...
    
    def MultiplyAffine(*args, **kwargs):
        """
        MultiplyAffine(*args, **kwargs)
        Overloaded function.
        
        1. MultiplyAffine(self: MSPyBentleyGeom.DMatrix4d, outPoints: Bentley.Bstdcxx.bvector<Bentley.DPoint4d,Bentley.BentleyAllocator<Bentley.DPoint4d> >, inPoints: Bentley.Bstdcxx.bvector<Bentley.DPoint4d,Bentley.BentleyAllocator<Bentley.DPoint4d> >) -> None
        
        Matrix*point multiplication, using full 4d points but assuming the
        matrix is affine, i.e. assume 0001 4th row.
        
        Parameter ``[out]``:
        outPoint Array of homogeneous products A*pPoint[i]
        
        Parameter ``[in]``:
        inPoint Array of homogeneous points
        
        Parameter ``[in]``:
        n number of points
        
        2. MultiplyAffine(self: MSPyBentleyGeom.DMatrix4d, outPoints: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >, inPoints: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >) -> None
        
        Matrix*point multiplication, using full 4d points but assuming the
        matrix is affine, i.e. assume 0001 4th row.
        
        Parameter ``[out]``:
        outPoint Array of homogeneous products A*pPoint[i]
        
        Parameter ``[in]``:
        inPoint Array of homogeneous points
        
        Parameter ``[in]``:
        n number of points
        """
        ...
    
    def MultiplyAffineVectors(*args, **kwargs):
        """
        MultiplyAffineVectors(self: MSPyBentleyGeom.DMatrix4d, outPoints: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >, inPoints: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >) -> None
        
        Matrix times vector multiplication, assume 0001 4th row and padding 3d
        data with 0 weight.
        
        Parameter ``[out]``:
        out Destination array
        
        Parameter ``[in]``:
        in Source array
        
        Parameter ``[in]``:
        n number of vectors
        """
        ...
    
    def MultiplyAndNormalize(*args, **kwargs):
        """
        MultiplyAndNormalize(self: MSPyBentleyGeom.DMatrix4d, outPoints: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >, inPoints: Bentley.Bstdcxx.bvector<Bentley.DPoint4d,Bentley.BentleyAllocator<Bentley.DPoint4d> >) -> None
        
        Multiply an array of points by a matrix, using all components of both
        the matrix and the points.
        
        Parameter ``[out]``:
        outPoint Array of products A*inPoint[i] normalized
        
        Parameter ``[in]``:
        inPoint Array of points points
        
        Parameter ``[in]``:
        n number of points
        """
        ...
    
    def MultiplyAndRenormalize(*args, **kwargs):
        """
        MultiplyAndRenormalize(*args, **kwargs)
        Overloaded function.
        
        1. MultiplyAndRenormalize(self: MSPyBentleyGeom.DMatrix4d, outPoints: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >, inPoints: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >) -> None
        
        Multiply an array of points by a matrix, using all components of both
        the matrix and the points.
        
        Parameter ``[out]``:
        outPoint Array of products A*pPoint[i] renormalized
        
        Parameter ``[in]``:
        inPoint Array of points points
        
        Parameter ``[in]``:
        n number of points
        
        2. MultiplyAndRenormalize(self: MSPyBentleyGeom.DMatrix4d, outPoint: Bentley.DPoint3d, inPoint: Bentley.DPoint3d) -> None
        
        Multiply an array of points by a matrix, using all components of both
        the matrix and the points.
        
        Parameter ``[out]``:
        outPoint Array of products A*pPoint[i] renormalized
        
        Parameter ``[in]``:
        inPoint Array of points points
        
        Parameter ``[in]``:
        n number of points
        """
        ...
    
    def MultiplyScaleAndTranslate(*args, **kwargs):
        """
        MultiplyScaleAndTranslate(*args, **kwargs)
        Overloaded function.
        
        1. MultiplyScaleAndTranslate(self: MSPyBentleyGeom.DMatrix4d, outPoints: Bentley.Bstdcxx.bvector<Bentley.DPoint4d,Bentley.BentleyAllocator<Bentley.DPoint4d> >, inPoints: Bentley.Bstdcxx.bvector<Bentley.DPoint4d,Bentley.BentleyAllocator<Bentley.DPoint4d> >) -> None
        
        Matrix*point multiplication, using full 4d points but assuming the
        matrix is has 3D only scaling and translation.
        
        Parameter ``[out]``:
        outPoint Array of homogeneous products A*pPoint[i]
        
        Parameter ``[in]``:
        inPoint Array of homogeneous points
        
        Parameter ``[in]``:
        n number of points
        
        2. MultiplyScaleAndTranslate(self: MSPyBentleyGeom.DMatrix4d, outPoints: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >, inPoints: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >) -> None
        
        Matrix*point multiplication, using full 4d points but assuming the
        matrix is has 3D only scaling and translation.
        
        Parameter ``[out]``:
        outPoint Array of homogeneous products A*pPoint[i]
        
        Parameter ``[in]``:
        inPoint Array of homogeneous points
        
        Parameter ``[in]``:
        n number of points
        """
        ...
    
    def MultiplyTranspose(*args, **kwargs):
        """
        MultiplyTranspose(self: MSPyBentleyGeom.DMatrix4d, outPoints: Bentley.Bstdcxx.bvector<Bentley.DPoint4d,Bentley.BentleyAllocator<Bentley.DPoint4d> >, inPoints: Bentley.Bstdcxx.bvector<Bentley.DPoint4d,Bentley.BentleyAllocator<Bentley.DPoint4d> >) -> None
        
        Multiply the transformed matrix times points. (Equivalent to
        multiplying transposed points times the matrix.)
        
        Parameter ``[out]``:
        outPoint Array of homogeneous products A^T *pPoint[i]
        
        Parameter ``[in]``:
        inPoint Array of homogeneous points
        
        Parameter ``[in]``:
        n number of points
        """
        ...
    
    def PreMultiplyByTranslateAndScale(*args, **kwargs):
        """
        PreMultiplyByTranslateAndScale(self: MSPyBentleyGeom.DMatrix4d, tx: float, ty: float, tz: float, sx: float, sy: float, sz: float, matrixA: MSPyBentleyGeom.DMatrix4d) -> None
        
        Premultiply matirx A by a matrix with sx,sy,sz,1 on diagonal,
        tx,ty,tz,1 in last column
        
        Parameter ``[in]``:
        tx 03 entry (x translate) of mutliplier.
        
        Parameter ``[in]``:
        ty 13 entry (y translate) of multiplier.
        
        Parameter ``[in]``:
        tz 23 entry (z translate) of multiplier.
        
        Parameter ``[in]``:
        sx 00 entry (x scale) of multiplier.
        
        Parameter ``[in]``:
        sy 11 entry (y scale) of multiplier.
        
        Parameter ``[in]``:
        sz 22 entry (z scale) of multiplier.
        
        Parameter ``[in]``:
        matrixA existing matrix
        """
        ...
    
    def Scale(*args, **kwargs):
        """
        Scale(self: MSPyBentleyGeom.DMatrix4d, scaleFactor: float) -> None
        
        Scale in place.
        
        Parameter ``[in]``:
        scaleFactor scale to apply
        """
        ...
    
    def SetColumn(*args, **kwargs):
        """
        SetColumn(*args, **kwargs)
        Overloaded function.
        
        1. SetColumn(self: MSPyBentleyGeom.DMatrix4d, i: int, r0: float, r1: float, r2: float, r3: float) -> None
        
        Install r0, r1, r2, r3 in an indicated column of an DMatrix4d.
        
        Parameter ``[in]``:
        i index of column 0 <= i<4 whose values are to be set
        
        Parameter ``[in]``:
        r0 row 0 value
        
        Parameter ``[in]``:
        r1 row 1 value
        
        Parameter ``[in]``:
        r2 row 2 value
        
        Parameter ``[in]``:
        r3 row 3 value
        
        2. SetColumn(self: MSPyBentleyGeom.DMatrix4d, i: int, point: Bentley.DPoint4d) -> None
        
        Install r0, r1, r2, r3 in an indicated column of an DMatrix4d.
        
        Parameter ``[in]``:
        i index of column 0 <= i<4 whose values are to be set
        
        Parameter ``[in]``:
        r0 row 0 value
        
        Parameter ``[in]``:
        r1 row 1 value
        
        Parameter ``[in]``:
        r2 row 2 value
        
        Parameter ``[in]``:
        r3 row 3 value
        """
        ...
    
    def SetRow(*args, **kwargs):
        """
        SetRow(*args, **kwargs)
        Overloaded function.
        
        1. SetRow(self: MSPyBentleyGeom.DMatrix4d, i: int, c0: float, c1: float, c2: float, c3: float) -> None
        
        Install c0, c1, c2, c3 in an indicated row of an DMatrix4d.
        
        Parameter ``[in]``:
        i index of row 0 <= i<4 whose values are to be set
        
        Parameter ``[in]``:
        c0 column 0 value
        
        Parameter ``[in]``:
        c1 column 1 value
        
        Parameter ``[in]``:
        c2 column 2 value
        
        Parameter ``[in]``:
        c3 column 3 value
        
        2. SetRow(self: MSPyBentleyGeom.DMatrix4d, i: int, data: Bentley.DPoint4d) -> None
        
        Install c0, c1, c2, c3 in an indicated row of an DMatrix4d.
        
        Parameter ``[in]``:
        i index of row 0 <= i<4 whose values are to be set
        
        Parameter ``[in]``:
        c0 column 0 value
        
        Parameter ``[in]``:
        c1 column 1 value
        
        Parameter ``[in]``:
        c2 column 2 value
        
        Parameter ``[in]``:
        c3 column 3 value
        """
        ...
    
    def Subtract(*args, **kwargs):
        """
        Subtract(self: MSPyBentleyGeom.DMatrix4d, delta: MSPyBentleyGeom.DMatrix4d) -> None
        
        Subtract a matrix (componentwise) from the instance
        
        Parameter ``[in]``:
        delta matrix to subtract
        """
        ...
    
    def SwapColumns(*args, **kwargs):
        """
        SwapColumns(self: MSPyBentleyGeom.DMatrix4d, i: int, j: int) -> None
        
        Install a DPoint4d in an indicated column of an DMatrix4d.
        
        Parameter ``[in]``:
        i first column index
        
        Parameter ``[in]``:
        j second column index
        """
        ...
    
    def SwapRows(*args, **kwargs):
        """
        SwapRows(self: MSPyBentleyGeom.DMatrix4d, i: int, j: int) -> None
        
        Install a DPoint4d in an indicated column of an DMatrix4d.
        
        Parameter ``[in]``:
        i first column index
        
        Parameter ``[in]``:
        j second column index
        """
        ...
    
    def SweepMomentProducts(*args, **kwargs):
        """
        SweepMomentProducts(baseProducts: MSPyBentleyGeom.DMatrix4d, sweepVector: Bentley.DVec3d) -> MSPyBentleyGeom.DMatrix4d
        
        Return the product matrix resulting from sweeping geometry with given
        baseProducts;
        
        Parameter ``[in]``:
        baseProducts products integrated on base curve or area.
        
        Parameter ``[in]``:
        sweepVector vector for sweep (extrusion)
        
        Returns:
        products for integration over swept body.
        """
        ...
    
    def SymmetricEigenvectors(*args, **kwargs):
        """
        SymmetricEigenvectors(self: MSPyBentleyGeom.DMatrix4d, Q: MSPyBentleyGeom.DMatrix4d, D: Bentley.DPoint4d) -> None
        
        Compute eigenvectors, assuming A is symmetric.
        
        Parameter ``[out]``:
        Q orthogonal, unit eigenvectors.
        
        Parameter ``[out]``:
        D corresponding eigenvalues.
        """
        ...
    
    def TransposeOf(*args, **kwargs):
        """
        TransposeOf(self: MSPyBentleyGeom.DMatrix4d, B: MSPyBentleyGeom.DMatrix4d) -> None
        
        Transpose a 4x4 matrix.
        
        Parameter ``[in]``:
        B original matrix
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.DMatrix4d) -> None:
        ...
    
class DPlane3d:
    """
    None
    """

    def Evaluate(*args, **kwargs):
        """
        Evaluate(self: MSPyBentleyGeom.DPlane3d, point: Bentley.DPoint3d) -> float
        
        Dot the plane normal with the vector from the plane
        origin to the point.
        
        Remark:
        s If the plane normal is a unit vector, this is the true distance
        from the plane to the point. If not, it is a scaled distance.
        
        Parameter ``[in]``:
        point point for evaluation
        
        Returns:
        dot product
        """
        ...
    
    def EvaluateMaxAbs(*args, **kwargs):
        """
        EvaluateMaxAbs(self: MSPyBentleyGeom.DPlane3d, points: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >) -> float
        
        Returns:
        The maximum absolute value of plane evaluation among points in an
        array.
        
        Parameter ``[in]``:
        points points to search
        
        Parameter ``[in]``:
        n number of points.
        """
        ...
    
    def EvaluateRange(*args, **kwargs):
        """
        EvaluateRange(self: MSPyBentleyGeom.DPlane3d, points: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >) -> tuple
        
        Returns:
        min and max signed evaluations among points in an array.
        
        Parameter ``[in]``:
        points points to search
        
        Parameter ``[in]``:
        n number of points
        
        Parameter ``[out]``:
        maxIndex index where (signed) max occurs.
        
        Parameter ``[out]``:
        minIndex index where (signed) min occurs.
        """
        ...
    
    def EvaluateVector(*args, **kwargs):
        """
        EvaluateVector(self: MSPyBentleyGeom.DPlane3d, vector: Bentley.DVec3d) -> float
        
        Dot the plane normal with the given vector.
        
        Remark:
        s If the plane normal is a unit vector, this is the true distance
        of altitude change due to motion along by this vector. If not, it
        is a scaled distance.
        
        Parameter ``[in]``:
        vector vector for evaluation
        
        Returns:
        dot product
        """
        ...
    
    def GetCoefficients(*args, **kwargs):
        """
        GetCoefficients(self: MSPyBentleyGeom.DPlane3d) -> tuple
        
        Convert the plane to implicit coeffcients ax+by+cz=d.
        
        Remark:
        s WARNING:Check your usage. It is about equally common to write
        the plane equation with negated d, i.e. ax+by+cz+d=0. If so, pass
        in (a,b,c,-d).
        
        Parameter ``[out]``:
        coffA 4D plane x-coefficient
        
        Parameter ``[out]``:
        coffB 4D plane y-coefficient
        
        Parameter ``[out]``:
        coffC 4D plane z-coefficient
        
        Parameter ``[out]``:
        coffD 4D plane constant coefficient
        """
        ...
    
    def GetDPoint4d(*args, **kwargs):
        """
        GetDPoint4d(self: MSPyBentleyGeom.DPlane3d, hPlane: Bentley.DPoint4d) -> None
        
        Return the plane as a DPoint4d.
        
        Parameter ``[out]``:
        hPlane 4D plane coefficients
        """
        ...
    
    def Init(*args, **kwargs):
        """
        Init(*args, **kwargs)
        Overloaded function.
        
        1. Init(self: MSPyBentleyGeom.DPlane3d, hPlane: Bentley.DPoint4d) -> bool
        
        Extract origin and normal from 4D plane coefficients.
        
        Parameter ``[in]``:
        hPlane 4D plane coefficients
        
        Returns:
        true if plane has a nonzero normal
        
        2. Init(self: MSPyBentleyGeom.DPlane3d, a: float, b: float, c: float, d: float) -> bool
        
        Extract origin and normal from 4D plane coefficients.
        
        Parameter ``[in]``:
        hPlane 4D plane coefficients
        
        Returns:
        true if plane has a nonzero normal
        """
        ...
    
    def InitFrom3Points(*args, **kwargs):
        """
        InitFrom3Points(self: MSPyBentleyGeom.DPlane3d, origin: Bentley.DPoint3d, xpoint: Bentley.DPoint3d, ypoint: Bentley.DPoint3d) -> None
        
        Initialize with first point as origin, normal as
        unnormalized cross product of vectors to 2nd and 3rd points.
        
        Parameter ``[in]``:
        origin origin point
        
        Parameter ``[in]``:
        xPoint first point in plane (e.g., x-axis point)
        
        Parameter ``[in]``:
        yPoint second point in plane (e.g., y-axis point)
        """
        ...
    
    def InitFromArray(*args, **kwargs):
        """
        InitFromArray(self: MSPyBentleyGeom.DPlane3d, points: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >) -> bool
        
        Compute the origin and normal so the plane passes
        (approximiately) through the array of points.
        
        Parameter ``[in]``:
        points array of points defining the plane
        
        Returns:
        true if the points define a clear plane (and are close to it!!!)
        false if the points are (a) closely clustered, (b) nearly
        colinear, or (c) not close to a single plane.
        """
        ...
    
    def InitFromOriginAndNormal(*args, **kwargs):
        """
        InitFromOriginAndNormal(*args, **kwargs)
        Overloaded function.
        
        1. InitFromOriginAndNormal(self: MSPyBentleyGeom.DPlane3d, x0: float, y0: float, z0: float, ux: float, uy: float, uz: float) -> None
        
        Store origin and unnormalized vector.
        
        Parameter ``[in]``:
        x0 x-coordinate of origin point
        
        Parameter ``[in]``:
        y0 y-coordinate of origin point
        
        Parameter ``[in]``:
        z0 z-coordinate of origin point
        
        Parameter ``[in]``:
        ux x-coordinate of normal vector
        
        Parameter ``[in]``:
        uy y-coordinate of normal vector
        
        Parameter ``[in]``:
        uz z-coordinate of normal vector
        
        2. InitFromOriginAndNormal(self: MSPyBentleyGeom.DPlane3d, origin: Bentley.DPoint3d, normal: Bentley.DVec3d) -> None
        
        Store origin and unnormalized vector.
        
        Parameter ``[in]``:
        x0 x-coordinate of origin point
        
        Parameter ``[in]``:
        y0 y-coordinate of origin point
        
        Parameter ``[in]``:
        z0 z-coordinate of origin point
        
        Parameter ``[in]``:
        ux x-coordinate of normal vector
        
        Parameter ``[in]``:
        uy y-coordinate of normal vector
        
        Parameter ``[in]``:
        uz z-coordinate of normal vector
        """
        ...
    
    def Intersect3Planes(*args, **kwargs):
        """
        Intersect3Planes(*args, **kwargs)
        Overloaded function.
        
        1. Intersect3Planes(unitNormalA: Bentley.DVec3d, distanceA: float, unitNormalB: Bentley.DVec3d, distanceB: float, unitNormalC: Bentley.DVec3d, distanceC: float) -> Bentley.ValidatedValue<Bentley.DPoint3d>
        
        Compute the point of intersection of 3 planes given as normal and
        distance from origin. ul> li>All normals are ASSUMED to be unit
        length.
        
        Returns:
        valid point if the three normals are independent. Otherwise
        returns origin of planeA, but marked invalid.
        
        2. Intersect3Planes(planeA: MSPyBentleyGeom.DPlane3d, planeB: MSPyBentleyGeom.DPlane3d, planeC: MSPyBentleyGeom.DPlane3d) -> Bentley.ValidatedValue<Bentley.DPoint3d>
        
        Compute the point of intersection of 3 planes given as normal and
        distance from origin. ul> li>All normals are ASSUMED to be unit
        length.
        
        Returns:
        valid point if the three normals are independent. Otherwise
        returns origin of planeA, but marked invalid.
        """
        ...
    
    def IsZero(*args, **kwargs):
        """
        IsZero(self: MSPyBentleyGeom.DPlane3d) -> bool
        
        Test if the numeric entries in the plane are all
        absolutely zero (no tolerances).
        
        Returns:
        true if the plane contains only zero coordinates.
        """
        ...
    
    def Normalize(*args, **kwargs):
        """
        Normalize(self: MSPyBentleyGeom.DPlane3d) -> bool
        
        Normalize the plane vector.
        
        Returns:
        true if normal vector has nonzero length.
        """
        ...
    
    def ProjectPoint(*args, **kwargs):
        """
        ProjectPoint(self: MSPyBentleyGeom.DPlane3d, projection: Bentley.DPoint3d, point: Bentley.DPoint3d) -> bool
        
        Project a (generally off-plane) point onto the plane.
        
        Parameter ``[out]``:
        projection projection of point onto the plane
        
        Parameter ``[in]``:
        point point to project to plane
        
        Returns:
        true if the plane has a well defined normal.
        """
        ...
    
    def Zero(*args, **kwargs):
        """
        Zero(self: MSPyBentleyGeom.DPlane3d) -> None
        
        Fill the plane data with zeros.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DPlane3d) -> None
        
        2. __init__(self: MSPyBentleyGeom.DPlane3d, x0: float, y0: float, z0: float, ux: float, uy: float, uz: float) -> None
        
        3. __init__(self: MSPyBentleyGeom.DPlane3d, origin: Bentley.DPoint3d, normal: Bentley.DVec3d) -> None
        
        4. __init__(self: MSPyBentleyGeom.DPlane3d, normal: Bentley.DVec3d, distance: float) -> None
        
        5. __init__(self: MSPyBentleyGeom.DPlane3d, origin: Bentley.DPoint3d, xpoint: Bentley.DPoint3d, ypoint: Bentley.DPoint3d) -> None
        """
        ...
    
    @property
    def normal(self: MSPyBentleyGeom.DPlane3d) -> Bentley.DVec3d:
        ...
    @normal.setter
    def normal(self: MSPyBentleyGeom.DPlane3d, arg0: Bentley.DVec3d) -> None:
        ...
    
    @property
    def origin(self: MSPyBentleyGeom.DPlane3d) -> Bentley.DPoint3d:
        ...
    @origin.setter
    def origin(self: MSPyBentleyGeom.DPlane3d, arg0: Bentley.DPoint3d) -> None:
        ...
    
class DPlane3dArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DPlane3dArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.DPlane3dArray, arg0: MSPyBentleyGeom.DPlane3dArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.DPlane3dArray, arg0: Iterable) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.DPlane3dArray, x: MSPyBentleyGeom.DPlane3d) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.DPlane3dArray) -> None
        
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.DPlane3dArray, L: MSPyBentleyGeom.DPlane3dArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.DPlane3dArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.DPlane3dArray, i: int, x: MSPyBentleyGeom.DPlane3d) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.DPlane3dArray) -> MSPyBentleyGeom.DPlane3d
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.DPlane3dArray, i: int) -> MSPyBentleyGeom.DPlane3d
        
        Remove and return the item at index ``i``
        """
        ...
    
class DPlane3dByVectors:
    """
    None
    """

    @property
    def DPlane3dWithUnitNormal(arg0: MSPyBentleyGeom.DPlane3dByVectors) -> MSPyBentleyGeom.ValidatedDPlane3d:
        ...
    
    def Evaluate(*args, **kwargs):
        """
        Evaluate(*args, **kwargs)
        Overloaded function.
        
        1. Evaluate(self: MSPyBentleyGeom.DPlane3dByVectors, u: float, v: float) -> MSPyBentleyGeom.DPoint3d
        
        return{origin + u * vectorU + v * vectorV}
        
        2. Evaluate(self: MSPyBentleyGeom.DPlane3dByVectors, uv: MSPyBentleyGeom.DPoint2d) -> MSPyBentleyGeom.DPoint3d
        
        return{origin + u * vectorU + v * vectorV}
        """
        ...
    
    def EvaluateTangents(*args, **kwargs):
        """
        EvaluateTangents(self: MSPyBentleyGeom.DPlane3dByVectors, u: float, v: float) -> MSPyBentleyGeom.DPlane3dByVectors
        
        Evaluate point and tangents at u,v. (Of course, the tangents are just
        the originals)
        """
        ...
    
    def EvaluateVectorOnly(*args, **kwargs):
        """
        EvaluateVectorOnly(*args, **kwargs)
        Overloaded function.
        
        1. EvaluateVectorOnly(self: MSPyBentleyGeom.DPlane3dByVectors, u: float, v: float) -> Bentley.DVec3d
        
        return{u*vectorU + v*vectorV}
        
        2. EvaluateVectorOnly(self: MSPyBentleyGeom.DPlane3dByVectors, uv: MSPyBentleyGeom.DPoint2d) -> Bentley.DVec3d
        
        return{u*vectorU + v*vectorV}
        """
        ...
    
    def FromOriginAndParallelToXY(*args, **kwargs):
        """
        FromOriginAndParallelToXY(origin: MSPyBentleyGeom.DPoint3d, sizeU: float, sizeV: float) -> MSPyBentleyGeom.DPlane3dByVectors
        
        Return a plane parallel to XY from given origin.
        """
        ...
    
    def FromOriginAndParallelToXZ(*args, **kwargs):
        """
        FromOriginAndParallelToXZ(origin: MSPyBentleyGeom.DPoint3d, sizeU: float, sizeV: float) -> MSPyBentleyGeom.DPlane3dByVectors
        
        Return a plane parallel to XZ from given origin.
        """
        ...
    
    def FromOriginAndParallelToYZ(*args, **kwargs):
        """
        FromOriginAndParallelToYZ(origin: MSPyBentleyGeom.DPoint3d, sizeU: float, sizeV: float) -> MSPyBentleyGeom.DPlane3dByVectors
        
        Return a plane parallel to YZ from given origin.
        """
        ...
    
    def FromOriginAndTargets(*args, **kwargs):
        """
        FromOriginAndTargets(origin: MSPyBentleyGeom.DPoint3d, UTarget: MSPyBentleyGeom.DPoint3d, VTarget: MSPyBentleyGeom.DPoint3d) -> MSPyBentleyGeom.DPlane3dByVectors
        
        Return a plane from orgin and u,v target points
        """
        ...
    
    def FromXYPlane(*args, **kwargs):
        """
        FromXYPlane() -> MSPyBentleyGeom.DPlane3dByVectors
        
        Construct basis for XY plane.
        """
        ...
    
    def GetDPlane3dWithUnitNormal(*args, **kwargs):
        """
        GetDPlane3dWithUnitNormal(self: MSPyBentleyGeom.DPlane3dByVectors) -> MSPyBentleyGeom.ValidatedDPlane3d
        
        Return DPlane3d form with unit normal.
        """
        ...
    
    def GetTransformsUnitZ(*args, **kwargs):
        """
        GetTransformsUnitZ(self: MSPyBentleyGeom.DPlane3dByVectors, localToWorld: Bentley.Transform, worldToLocal: Bentley.Transform) -> bool
        
        Return coordinate transforms, with unit perpendicular as Z vector in
        local to world.
        """
        ...
    
    def MaxDiff(*args, **kwargs):
        """
        MaxDiff(self: MSPyBentleyGeom.DPlane3dByVectors, other: MSPyBentleyGeom.DPlane3dByVectors) -> float
        
        return max difference between corresponding components
        """
        ...
    
    def ProjectPoint(*args, **kwargs):
        """
        ProjectPoint(self: MSPyBentleyGeom.DPlane3dByVectors, spacePoint: MSPyBentleyGeom.DPoint3d) -> MSPyBentleyGeom.ValidatedDPoint2d
        
        Returns:
        u,v coordinates of the projection. This is marked valid in the
        usual case of independent (nonzero, non-parallel) plane vectors.
        
        Remark:
        if the plane vectors are parallel, the returned parameters do a
        projection to the longer vector, and are marked invalid
        
        Remark:
        if the plane vectors are both zero, the returned parameters are
        zero and are marked invalid.
        """
        ...
    
    def TransverseIntersection(*args, **kwargs):
        """
        TransverseIntersection(self: MSPyBentleyGeom.DPlane3dByVectors, segment: MSPyBentleyGeom.DSegment3d, uv: MSPyBentleyGeom.DPoint2d) -> tuple
        
        Compute the simple intersection of a segment with the plane. Returns
        false in any parallel case (both in-plane and off-plane)
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DPlane3dByVectors) -> None
        
        2. __init__(self: MSPyBentleyGeom.DPlane3dByVectors, origin: MSPyBentleyGeom.DPoint3d, vectorU: Bentley.DVec3d, vectorV: Bentley.DVec3d) -> None
        
        3. __init__(self: MSPyBentleyGeom.DPlane3dByVectors, ax: float, ay: float, az: float, ux: float, uy: float, uz: float, vx: float, vy: float, vz: float) -> None
        
        4. __init__(self: MSPyBentleyGeom.DPlane3dByVectors, ellipse: MSPyBentleyGeom.DEllipse3d) -> None
        
        5. __init__(self: MSPyBentleyGeom.DPlane3dByVectors, triangle: MSPyBentleyGeom.DTriangle3d) -> None
        """
        ...
    
    @property
    def origin(self: MSPyBentleyGeom.DPlane3dByVectors) -> MSPyBentleyGeom.DPoint3d:
        ...
    @origin.setter
    def origin(self: MSPyBentleyGeom.DPlane3dByVectors, arg0: MSPyBentleyGeom.DPoint3d) -> None:
        ...
    
    @property
    def vectorU(self: MSPyBentleyGeom.DPlane3dByVectors) -> Bentley.DVec3d:
        ...
    @vectorU.setter
    def vectorU(self: MSPyBentleyGeom.DPlane3dByVectors, arg0: Bentley.DVec3d) -> None:
        ...
    
    @property
    def vectorV(self: MSPyBentleyGeom.DPlane3dByVectors) -> Bentley.DVec3d:
        ...
    @vectorV.setter
    def vectorV(self: MSPyBentleyGeom.DPlane3dByVectors, arg0: Bentley.DVec3d) -> None:
        ...
    
class DPoint2d:
    """
    None
    """

    def Add(*args, **kwargs):
        """
        Add(self: MSPyBentleyGeom.DPoint2d, vector: MSPyBentleyGeom.DPoint2d) -> None
        
        Add a vector to the instance.
        
        Parameter ``[in]``:
        vector vector to add
        """
        ...
    
    def AlmostEqual(*args, **kwargs):
        """
        AlmostEqual(self: MSPyBentleyGeom.DPoint2d, dataB: MSPyBentleyGeom.DPoint2d) -> bool
        
        test if two points are equal. Uses library " small angle " as both
        absolute and relative tolerance. points are equal if squared distance
        between is less than (squared abstol) plus (squared relTol) * sum of
        cmponent squares
        
        Parameter ``[in]``:
        dataB second DPoint2d
        
        Returns:
        true if within tolerance.
        """
        ...
    
    def AngleTo(*args, **kwargs):
        """
        AngleTo(self: MSPyBentleyGeom.DPoint2d, vector2: MSPyBentleyGeom.DPoint2d) -> float
        
        Returns (signed, counterclockwise) angle between two
        vectors. The angle is in radians. The angle range is from -pi to +pi;
        positive angles are counterclockwise, negative angles are clockwise.
        
        Parameter ``[in]``:
        vector2 second vector
        
        Returns:
        angle in radians
        """
        ...
    
    def CrossProduct(*args, **kwargs):
        """
        CrossProduct(self: MSPyBentleyGeom.DPoint2d, vector1: MSPyBentleyGeom.DPoint2d) -> float
        
        Returns the (scalar) cross product of two vectors.
        
        Parameter ``[in]``:
        vector1 first vector
        """
        ...
    
    def CrossProductToPoints(*args, **kwargs):
        """
        CrossProductToPoints(self: MSPyBentleyGeom.DPoint2d, target1: MSPyBentleyGeom.DPoint2d, target2: MSPyBentleyGeom.DPoint2d) -> float
        
        Returns the (scalar) cross product of two vectors. The
        vectors are computed from the Origin to Target1 and Target2.
        
        Parameter ``[in]``:
        target1 target of first vector
        
        Parameter ``[in]``:
        target2 target of second vector
        """
        ...
    
    def DifferenceOf(*args, **kwargs):
        """
        DifferenceOf(self: MSPyBentleyGeom.DPoint2d, point1: MSPyBentleyGeom.DPoint2d, point2: MSPyBentleyGeom.DPoint2d) -> None
        
        Return the difference of two points or vectors.
        
        Parameter ``[in]``:
        point1 First point or vector.
        
        Parameter ``[in]``:
        point2 Second (subtracted) point or vector.
        """
        ...
    
    def Distance(*args, **kwargs):
        """
        Distance(self: MSPyBentleyGeom.DPoint2d, point1: MSPyBentleyGeom.DPoint2d) -> float
        
        Returns the distance between 2 points
        
        Parameter ``[in]``:
        point1 second point
        
        Returns:
        distance from point 0 to point 1
        """
        ...
    
    def DistanceSquared(*args, **kwargs):
        """
        DistanceSquared(self: MSPyBentleyGeom.DPoint2d, point2: MSPyBentleyGeom.DPoint2d) -> float
        
        Return the squared distance between two points or
        vectors.
        
        Parameter ``[in]``:
        point2 end point
        
        Returns:
        squared distance between points
        """
        ...
    
    def DotProduct(*args, **kwargs):
        """
        DotProduct(self: MSPyBentleyGeom.DPoint2d, vector2: MSPyBentleyGeom.DPoint2d) -> float
        
        Returns the (scalar) dot product of two vectors.
        
        Parameter ``[in]``:
        vector2 second vector.
        
        Returns:
        dot product of the two vectors
        """
        ...
    
    def DotProductToPoints(*args, **kwargs):
        """
        DotProductToPoints(self: MSPyBentleyGeom.DPoint2d, target1: MSPyBentleyGeom.DPoint2d, target2: MSPyBentleyGeom.DPoint2d) -> float
        
        Returns the (scalar) dot product of two vectors. The
        vectors are computed from the Origin to Target1 and Target2.
        
        Parameter ``[in]``:
        target1 target of first vector
        
        Parameter ``[in]``:
        target2 target of second vector
        """
        ...
    
    def From(*args, **kwargs):
        """
        From(*args, **kwargs)
        Overloaded function.
        
        1. From(ax: float, ay: float) -> MSPyBentleyGeom.DPoint2d
        
        Returns a DPoint2d with 2 components (xy) from given
        components
        
        Parameter ``[in]``:
        ax x coordinate
        
        Parameter ``[in]``:
        ay y coordinate
        
        2. From(source: Bentley.DPoint3d) -> MSPyBentleyGeom.DPoint2d
        
        Returns a DPoint2d with 2 components (xy) from given
        components
        
        Parameter ``[in]``:
        ax x coordinate
        
        Parameter ``[in]``:
        ay y coordinate
        """
        ...
    
    def FromInterpolate(*args, **kwargs):
        """
        FromInterpolate(point0: MSPyBentleyGeom.DPoint2d, fraction: float, point1: MSPyBentleyGeom.DPoint2d) -> MSPyBentleyGeom.DPoint2d
        
        Returns an interpolated point.
        
        Parameter ``[in]``:
        point0 point at fraction 0
        
        Parameter ``[in]``:
        fraction fraction from interpolation.
        
        Parameter ``[in]``:
        point1 point at fraction 1
        """
        ...
    
    def FromInterpolateBilinear(*args, **kwargs):
        """
        FromInterpolateBilinear(point00: MSPyBentleyGeom.DPoint2d, point10: MSPyBentleyGeom.DPoint2d, point01: MSPyBentleyGeom.DPoint2d, point11: MSPyBentleyGeom.DPoint2d, u: float, v: float) -> MSPyBentleyGeom.DPoint2d
        
        Returns a bilinear interpolation from corners
        (00)(10)(01)(11)
        
        Parameter ``[in]``:
        point00 point at (0,0)
        
        Parameter ``[in]``:
        point10 point at (1,0)
        
        Parameter ``[in]``:
        point01 point at (0,1)
        
        Parameter ``[in]``:
        point11 point at (1,1)
        
        Parameter ``[in]``:
        u interpolation fraction for edges (point00,point10) and
        (point01,point11)
        
        Parameter ``[in]``:
        v interpolation fraction for edges (point00,point10) and
        (point10,point11)
        """
        ...
    
    def FromOne(*args, **kwargs):
        """
        FromOne() -> MSPyBentleyGeom.DPoint2d
        
        Return a DPoint2d with xy = 1.
        """
        ...
    
    def FromScale(*args, **kwargs):
        """
        FromScale(point: MSPyBentleyGeom.DPoint2d, scale: float) -> MSPyBentleyGeom.DPoint2d
        
        Returns a scalar multiple of a DPoint2d
        
        Parameter ``[in]``:
        point input point
        
        Parameter ``[in]``:
        scale scale factor
        """
        ...
    
    def FromSumOf(*args, **kwargs):
        """
        FromSumOf(*args, **kwargs)
        Overloaded function.
        
        1. FromSumOf(point0: MSPyBentleyGeom.DPoint2d, scale0: float, point1: MSPyBentleyGeom.DPoint2d, scale1: float) -> MSPyBentleyGeom.DPoint2d
        
        Returns a linear combination of points
        
        Parameter ``[in]``:
        point0 first point
        
        Parameter ``[in]``:
        scale0 first scale
        
        Parameter ``[in]``:
        point1 second point
        
        Parameter ``[in]``:
        scale1 second scale
        
        2. FromSumOf(point0: MSPyBentleyGeom.DPoint2d, scale0: float, point1: MSPyBentleyGeom.DPoint2d, scale1: float, point2: MSPyBentleyGeom.DPoint2d, scale2: float) -> MSPyBentleyGeom.DPoint2d
        
        Returns a linear combination of points
        
        Parameter ``[in]``:
        point0 first point
        
        Parameter ``[in]``:
        scale0 first scale
        
        Parameter ``[in]``:
        point1 second point
        
        Parameter ``[in]``:
        scale1 second scale
        
        3. FromSumOf(origin: MSPyBentleyGeom.DPoint2d, vector: Bentley.DVec2d, scaleFactor: float) -> MSPyBentleyGeom.DPoint2d
        
        Returns a linear combination of points
        
        Parameter ``[in]``:
        point0 first point
        
        Parameter ``[in]``:
        scale0 first scale
        
        Parameter ``[in]``:
        point1 second point
        
        Parameter ``[in]``:
        scale1 second scale
        
        4. FromSumOf(origin: MSPyBentleyGeom.DPoint2d, vector0: Bentley.DVec2d, scaleFactor0: float, vector1: Bentley.DVec2d, scaleFactor1: float) -> MSPyBentleyGeom.DPoint2d
        
        Returns a linear combination of points
        
        Parameter ``[in]``:
        point0 first point
        
        Parameter ``[in]``:
        scale0 first scale
        
        Parameter ``[in]``:
        point1 second point
        
        Parameter ``[in]``:
        scale1 second scale
        
        5. FromSumOf(origin: MSPyBentleyGeom.DPoint2d, vector0: Bentley.DVec2d, scaleFactor0: float, vector1: Bentley.DVec2d, scaleFactor1: float, vector2: Bentley.DVec2d, scaleFactor2: float) -> MSPyBentleyGeom.DPoint2d
        
        Returns a linear combination of points
        
        Parameter ``[in]``:
        point0 first point
        
        Parameter ``[in]``:
        scale0 first scale
        
        Parameter ``[in]``:
        point1 second point
        
        Parameter ``[in]``:
        scale1 second scale
        """
        ...
    
    def FromZero(*args, **kwargs):
        """
        FromZero() -> MSPyBentleyGeom.DPoint2d
        
        Return a DPoint2d with xy = 0.
        """
        ...
    
    def GetComponent(*args, **kwargs):
        """
        GetComponent(self: MSPyBentleyGeom.DPoint2d, index: int) -> float
        
        Gets a single component of a point. If the index is out
        of range 0,1, it is interpreted cyclically.
        
        Parameter ``[in]``:
        index 0=x, 1=y, others cyclic
        
        Returns:
        specified component of the point or vector.
        """
        ...
    
    def GetComponents(*args, **kwargs):
        """
        GetComponents(self: MSPyBentleyGeom.DPoint2d) -> Tuple[float, float]
        """
        ...
    
    def Init(*args, **kwargs):
        """
        Init(*args, **kwargs)
        Overloaded function.
        
        1. Init(self: MSPyBentleyGeom.DPoint2d, x: float, y: float) -> None
        
        Initialize with given components
        
        Parameter ``[in]``:
        x x component
        
        Parameter ``[in]``:
        y y component
        
        2. Init(self: MSPyBentleyGeom.DPoint2d, source: Bentley.DPoint3d) -> None
        
        Initialize with given components
        
        Parameter ``[in]``:
        x x component
        
        Parameter ``[in]``:
        y y component
        """
        ...
    
    def InitDisconnect(*args, **kwargs):
        """
        InitDisconnect(self: MSPyBentleyGeom.DPoint2d) -> None
        
        Initialize a point with all coordinates as the disconnect value.
        """
        ...
    
    def Interpolate(*args, **kwargs):
        """
        Interpolate(self: MSPyBentleyGeom.DPoint2d, point0: MSPyBentleyGeom.DPoint2d, s: float, point1: MSPyBentleyGeom.DPoint2d) -> None
        
        Compute the point at an interpolated (fractional) position between a
        start and end point.
        
        Parameter ``[in]``:
        point0 start point (at parameter s=0)
        
        Parameter ``[in]``:
        s interpolation parameter
        
        Parameter ``[in]``:
        point1 end point (at parameter s=1)
        """
        ...
    
    def IsConvexPair(*args, **kwargs):
        """
        IsConvexPair(self: MSPyBentleyGeom.DPoint2d) -> bool
        
        return true if the point has x, y, and x+1 all between 0 and 1
        (inclusive).
        """
        ...
    
    def IsDisconnect(*args, **kwargs):
        """
        IsDisconnect(self: MSPyBentleyGeom.DPoint2d) -> bool
        
        Returns:
        true if the point has coordinates which indicate it is a
        disconnect (separator) ponit.
        """
        ...
    
    def IsEqual(*args, **kwargs):
        """
        IsEqual(*args, **kwargs)
        Overloaded function.
        
        1. IsEqual(self: MSPyBentleyGeom.DPoint2d, vector2: MSPyBentleyGeom.DPoint2d) -> bool
        
        Test if two points or vectors are exactly equal.
        
        Parameter ``[in]``:
        vector2 Second point or vector
        
        Returns:
        true if the points are identical. (DPoint2dCR, double)
        
        2. IsEqual(self: MSPyBentleyGeom.DPoint2d, vector2: MSPyBentleyGeom.DPoint2d, tolerance: float) -> bool
        
        Test if two points or vectors are exactly equal.
        
        Parameter ``[in]``:
        vector2 Second point or vector
        
        Returns:
        true if the points are identical. (DPoint2dCR, double)
        """
        ...
    
    def IsParallelTo(*args, **kwargs):
        """
        IsParallelTo(self: MSPyBentleyGeom.DPoint2d, vector2: MSPyBentleyGeom.DPoint2d) -> bool
        
        Test if two vectors are parallel.
        
        Parameter ``[in]``:
        vector2 Second vector
        
        Returns:
        true if vectors are (nearly) parallel.
        """
        ...
    
    def IsPerpendicularTo(*args, **kwargs):
        """
        IsPerpendicularTo(self: MSPyBentleyGeom.DPoint2d, vector2: MSPyBentleyGeom.DPoint2d) -> bool
        
        Test if two vectors are perpendicular.
        
        Parameter ``[in]``:
        vector2 Second vector
        
        Returns:
        true if vectors are (nearly) parallel.
        """
        ...
    
    def Magnitude(*args, **kwargs):
        """
        Magnitude(self: MSPyBentleyGeom.DPoint2d) -> float
        
        Returns the magnitude (length) of a vector.
        
        Returns:
        Length of the vector.
        """
        ...
    
    def MagnitudeSquared(*args, **kwargs):
        """
        MagnitudeSquared(self: MSPyBentleyGeom.DPoint2d) -> float
        
        Returns:
        squared magnitude of the vector
        """
        ...
    
    def MaxAbs(*args, **kwargs):
        """
        MaxAbs(self: MSPyBentleyGeom.DPoint2d) -> float
        
        Finds the largest absolute value among the components of
        a point or vector.
        
        Returns:
        largest absolute value among point coordinates.
        """
        ...
    
    def Negate(*args, **kwargs):
        """
        Negate(self: MSPyBentleyGeom.DPoint2d, vector: MSPyBentleyGeom.DPoint2d) -> None
        
        returns the negative of a vector.
        
        Parameter ``[in]``:
        vector input
        """
        ...
    
    def Normalize(*args, **kwargs):
        """
        Normalize(*args, **kwargs)
        Overloaded function.
        
        1. Normalize(self: MSPyBentleyGeom.DPoint2d) -> float
        
        normalizes pVector1 in place, and returns the original magnitude. If
        the original magnitude is 0 the vector is left unchanged.
        
        Returns:
        original length
        
        2. Normalize(self: MSPyBentleyGeom.DPoint2d, vector1: MSPyBentleyGeom.DPoint2d) -> float
        
        normalizes pVector1 in place, and returns the original magnitude. If
        the original magnitude is 0 the vector is left unchanged.
        
        Returns:
        original length
        """
        ...
    
    def NormalizedDifferenceOf(*args, **kwargs):
        """
        NormalizedDifferenceOf(self: MSPyBentleyGeom.DPoint2d, point1: MSPyBentleyGeom.DPoint2d, point2: MSPyBentleyGeom.DPoint2d) -> float
        
        Sets pNormal to the unit vector in the direction of point1 point2
        
        Parameter ``[in]``:
        point1 point 1
        
        Parameter ``[in]``:
        point2 point 2
        
        Returns:
        double distance between input points
        """
        ...
    
    def One(*args, **kwargs):
        """
        One(self: MSPyBentleyGeom.DPoint2d) -> None
        
        Returns a point or vector with all components 1.0.
        """
        ...
    
    def Rotate90(*args, **kwargs):
        """
        Rotate90(self: MSPyBentleyGeom.DPoint2d, vec: MSPyBentleyGeom.DPoint2d) -> None
        
        Parameter ``[in]``:
        vec original vector
        """
        ...
    
    def RotateCCW(*args, **kwargs):
        """
        RotateCCW(self: MSPyBentleyGeom.DPoint2d, vec: MSPyBentleyGeom.DPoint2d, radians: float) -> None
        
        Parameter ``[in]``:
        vec original vector
        
        Parameter ``[in]``:
        radians rotation angle
        
        Remark:
        Note that this is a counterclockwise rotation. The " rotate " method
        in prior api was clockwise.
        """
        ...
    
    def Scale(*args, **kwargs):
        """
        Scale(*args, **kwargs)
        Overloaded function.
        
        1. Scale(self: MSPyBentleyGeom.DPoint2d, source: MSPyBentleyGeom.DPoint2d, s: float) -> None
        
        Scale the instance coordinates from source
        
        Parameter ``[in]``:
        source input point
        
        Parameter ``[in]``:
        s scale factor
        
        2. Scale(self: MSPyBentleyGeom.DPoint2d, s: float) -> None
        
        Scale the instance coordinates from source
        
        Parameter ``[in]``:
        source input point
        
        Parameter ``[in]``:
        s scale factor
        """
        ...
    
    def ScaleToLength(*args, **kwargs):
        """
        ScaleToLength(*args, **kwargs)
        Overloaded function.
        
        1. ScaleToLength(self: MSPyBentleyGeom.DPoint2d, source: MSPyBentleyGeom.DPoint2d, length: float) -> float
        
        Scales a vector to specified length. If the input vector
        length is 0, the output vector is a zero vector and the returned
        length is 0.
        
        Parameter ``[in]``:
        source The original vector.
        
        Parameter ``[in]``:
        length The requested length.
        
        Returns:
        The length prior to scaling.
        
        2. ScaleToLength(self: MSPyBentleyGeom.DPoint2d, length: float) -> float
        
        Scales a vector to specified length. If the input vector
        length is 0, the output vector is a zero vector and the returned
        length is 0.
        
        Parameter ``[in]``:
        source The original vector.
        
        Parameter ``[in]``:
        length The requested length.
        
        Returns:
        The length prior to scaling.
        """
        ...
    
    def SetComponent(*args, **kwargs):
        """
        SetComponent(self: MSPyBentleyGeom.DPoint2d, a: float, index: int) -> None
        
        Sets a single component of a point. If the index is out
        of range 0,1, it is interpreted cyclically.
        
        Parameter ``[in]``:
        a value for component
        
        Parameter ``[in]``:
        index 0=x, 1=y, others cyclic
        """
        ...
    
    def Subtract(*args, **kwargs):
        """
        Subtract(self: MSPyBentleyGeom.DPoint2d, vector: MSPyBentleyGeom.DPoint2d) -> None
        
        Subtract one vector from another in place.
        
        Parameter ``[in]``:
        vector vector to subtract
        """
        ...
    
    def SumOf(*args, **kwargs):
        """
        SumOf(*args, **kwargs)
        Overloaded function.
        
        1. SumOf(self: MSPyBentleyGeom.DPoint2d, point1: MSPyBentleyGeom.DPoint2d, point2: MSPyBentleyGeom.DPoint2d) -> None
        
        Compute the sum of two points or vectors.
        
        Parameter ``[in]``:
        point1 First point or vector
        
        Parameter ``[in]``:
        point2 Second point or vector
        
        2. SumOf(self: MSPyBentleyGeom.DPoint2d, vector1: MSPyBentleyGeom.DPoint2d, scale1: float, vector2: MSPyBentleyGeom.DPoint2d, scale2: float, vector3: MSPyBentleyGeom.DPoint2d, scale3: float) -> None
        
        Compute the sum of two points or vectors.
        
        Parameter ``[in]``:
        point1 First point or vector
        
        Parameter ``[in]``:
        point2 Second point or vector
        
        3. SumOf(self: MSPyBentleyGeom.DPoint2d, point: MSPyBentleyGeom.DPoint2d, vector: MSPyBentleyGeom.DPoint2d, s: float) -> None
        
        Compute the sum of two points or vectors.
        
        Parameter ``[in]``:
        point1 First point or vector
        
        Parameter ``[in]``:
        point2 Second point or vector
        
        4. SumOf(self: MSPyBentleyGeom.DPoint2d, origin: MSPyBentleyGeom.DPoint2d, vector1: MSPyBentleyGeom.DPoint2d, scale1: float, vector2: MSPyBentleyGeom.DPoint2d, scale2: float) -> None
        
        Compute the sum of two points or vectors.
        
        Parameter ``[in]``:
        point1 First point or vector
        
        Parameter ``[in]``:
        point2 Second point or vector
        
        5. SumOf(self: MSPyBentleyGeom.DPoint2d, origin: MSPyBentleyGeom.DPoint2d, vector1: MSPyBentleyGeom.DPoint2d, scale1: float, vector2: MSPyBentleyGeom.DPoint2d, scale2: float, vector3: MSPyBentleyGeom.DPoint2d, scale3: float) -> None
        
        Compute the sum of two points or vectors.
        
        Parameter ``[in]``:
        point1 First point or vector
        
        Parameter ``[in]``:
        point2 Second point or vector
        """
        ...
    
    def Swap(*args, **kwargs):
        """
        Swap(self: MSPyBentleyGeom.DPoint2d, other: MSPyBentleyGeom.DPoint2d) -> None
        
        Swap contents of instance, other.
        
        Parameter ``[in,out]``:
        other second point.
        """
        ...
    
    def Zero(*args, **kwargs):
        """
        Zero(self: MSPyBentleyGeom.DPoint2d) -> None
        
        Sets all components of a point or vector to zero.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DPoint2d) -> None
        
        2. __init__(self: MSPyBentleyGeom.DPoint2d, vector: Bentley.DVec2d) -> None
        
        3. __init__(self: MSPyBentleyGeom.DPoint2d, ax: float, ay: float) -> None
        """
        ...
    
    @property
    def x(self: MSPyBentleyGeom.DPoint2d) -> float:
        ...
    @x.setter
    def x(self: MSPyBentleyGeom.DPoint2d, arg0: float) -> None:
        ...
    
    @property
    def y(self: MSPyBentleyGeom.DPoint2d) -> float:
        ...
    @y.setter
    def y(self: MSPyBentleyGeom.DPoint2d, arg0: float) -> None:
        ...
    
class DPoint2dArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DPoint2dArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.DPoint2dArray, arg0: MSPyBentleyGeom.DPoint2dArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.DPoint2dArray, arg0: Iterable) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.DPoint2dArray, x: MSPyBentleyGeom.DPoint2d) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.DPoint2dArray) -> None
        
        Clear the contents
        """
        ...
    
    def count(*args, **kwargs):
        """
        count(self: MSPyBentleyGeom.DPoint2dArray, x: MSPyBentleyGeom.DPoint2d) -> int
        
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.DPoint2dArray, L: MSPyBentleyGeom.DPoint2dArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.DPoint2dArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.DPoint2dArray, i: int, x: MSPyBentleyGeom.DPoint2d) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.DPoint2dArray) -> MSPyBentleyGeom.DPoint2d
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.DPoint2dArray, i: int) -> MSPyBentleyGeom.DPoint2d
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(*args, **kwargs):
        """
        remove(self: MSPyBentleyGeom.DPoint2dArray, x: MSPyBentleyGeom.DPoint2d) -> None
        
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class DPoint2dVecArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DPoint2dVecArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.DPoint2dVecArray, arg0: MSPyBentleyGeom.DPoint2dVecArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.DPoint2dVecArray, arg0: Iterable) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.DPoint2dVecArray, x: MSPyBentleyGeom.DPoint2dArray) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.DPoint2dVecArray) -> None
        
        Clear the contents
        """
        ...
    
    def count(*args, **kwargs):
        """
        count(self: MSPyBentleyGeom.DPoint2dVecArray, x: MSPyBentleyGeom.DPoint2dArray) -> int
        
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.DPoint2dVecArray, L: MSPyBentleyGeom.DPoint2dVecArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.DPoint2dVecArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.DPoint2dVecArray, i: int, x: MSPyBentleyGeom.DPoint2dArray) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.DPoint2dVecArray) -> MSPyBentleyGeom.DPoint2dArray
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.DPoint2dVecArray, i: int) -> MSPyBentleyGeom.DPoint2dArray
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(*args, **kwargs):
        """
        remove(self: MSPyBentleyGeom.DPoint2dVecArray, x: MSPyBentleyGeom.DPoint2dArray) -> None
        
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class DPoint3d:
    """
    None
    """

    def Add(*args, **kwargs):
        """
        Add(*args, **kwargs)
        Overloaded function.
        
        1. Add(self: MSPyBentleyGeom.DPoint3d, vector: Bentley.DVec3d) -> None
        
        @description Adds a vector to a pointer or vector, returns the result
        in place.
        
        Parameter ``[in]``:
        vector The vector to add.
        
        2. Add(self: MSPyBentleyGeom.DPoint3d, vector: MSPyBentleyGeom.DPoint3d) -> None
        
        @description Adds a vector to a pointer or vector, returns the result
        in place.
        
        Parameter ``[in]``:
        vector The vector to add.
        """
        ...
    
    def AddToArray(*args, **kwargs):
        """
        AddToArray(points: MSPyBentleyGeom.DPoint3dArray, delta: MSPyBentleyGeom.DPoint3d) -> None
        
        Add translation to all points.
        """
        ...
    
    def AlmostEqual(*args, **kwargs):
        """
        AlmostEqual(*args, **kwargs)
        Overloaded function.
        
        1. AlmostEqual(self: MSPyBentleyGeom.DPoint3d, dataB: MSPyBentleyGeom.DPoint3d) -> bool
        
        test if two points are equal. Uses library " small angle " as both
        absolute and relative tolerance. points are equal if squared distance
        between is less than (squared abstol) plus (squared relTol) * sum of
        cmponent squares
        
        Parameter ``[in]``:
        dataB second DPoint3d
        
        Returns:
        true if within tolerance.
        
        2. AlmostEqual(self: MSPyBentleyGeom.DPoint3d, dataB: MSPyBentleyGeom.DPoint3d, abstol: float) -> bool
        
        test if two points are equal. Uses library " small angle " as both
        absolute and relative tolerance. points are equal if squared distance
        between is less than (squared abstol) plus (squared relTol) * sum of
        cmponent squares
        
        Parameter ``[in]``:
        dataB second DPoint3d
        
        Returns:
        true if within tolerance.
        """
        ...
    
    def AlmostEqualXY(*args, **kwargs):
        """
        AlmostEqualXY(*args, **kwargs)
        Overloaded function.
        
        1. AlmostEqualXY(self: MSPyBentleyGeom.DPoint3d, dataB: MSPyBentleyGeom.DPoint3d) -> bool
        
        test if two points are equal. Uses library " small angle " as both
        absolute and relative tolerance. points are equal if squared distance
        between is less than (squared abstol) plus (squared relTol) * sum of
        cmponent squares
        
        Parameter ``[in]``:
        dataB second DPoint3d
        
        Returns:
        true if within tolerance.
        
        2. AlmostEqualXY(self: MSPyBentleyGeom.DPoint3d, dataB: MSPyBentleyGeom.DPoint3d, abstol: float) -> bool
        
        test if two points are equal. Uses library " small angle " as both
        absolute and relative tolerance. points are equal if squared distance
        between is less than (squared abstol) plus (squared relTol) * sum of
        cmponent squares
        
        Parameter ``[in]``:
        dataB second DPoint3d
        
        Returns:
        true if within tolerance.
        """
        ...
    
    def AngleTo(*args, **kwargs):
        """
        AngleTo(self: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d) -> float
        
        @description Returns the angle between two vectors. This angle is
        between 0 and pi. Rotating the first vector by this angle around the
        cross product between the vectors aligns it with the second vector.
        
        Parameter ``[in]``:
        point2 The second vector
        
        Returns:
        The angle between the vectors.
        """
        ...
    
    def AngleToXY(*args, **kwargs):
        """
        AngleToXY(self: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d) -> float
        
        @description Returns the angle from Vector1 to Vector2 using only xy
        parts. This angle is between -pi and +pi.
        
        Parameter ``[in]``:
        point2 The second vector
        
        Returns:
        The angle between vectors.
        """
        ...
    
    def AngleXY(*args, **kwargs):
        """
        AngleXY(self: MSPyBentleyGeom.DPoint3d) -> float
        
        @description Computes the (signed) angle from xy axis to the vector,
        using only xy parts.
        """
        ...
    
    def ComponentRange(*args, **kwargs):
        """
        ComponentRange(self: MSPyBentleyGeom.DPoint3d) -> Bentley.DRange1d
        
        Returns:
        min and max of componetns.
        """
        ...
    
    def CrossProduct(*args, **kwargs):
        """
        CrossProduct(self: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d) -> None
        
        @description Returns the cross (vector) cross product of two vectors.
        
        Parameter ``[in]``:
        point1 The first vector
        
        Parameter ``[in]``:
        point2 The second vector
        """
        ...
    
    def CrossProductToPoints(*args, **kwargs):
        """
        CrossProductToPoints(self: MSPyBentleyGeom.DPoint3d, origin: MSPyBentleyGeom.DPoint3d, target1: MSPyBentleyGeom.DPoint3d, target2: MSPyBentleyGeom.DPoint3d) -> None
        
        @description Returns the (vector) cross product of two vectors. The
        vectors are computed from the Origin to target1 and target2.
        
        Parameter ``[in]``:
        origin The base point for computing vectors.
        
        Parameter ``[in]``:
        target1 The target point for the first vector.
        
        Parameter ``[in]``:
        target2 The target point for the second vector.
        """
        ...
    
    def CrossProductToPointsXY(*args, **kwargs):
        """
        CrossProductToPointsXY(self: MSPyBentleyGeom.DPoint3d, target1: MSPyBentleyGeom.DPoint3d, target2: MSPyBentleyGeom.DPoint3d) -> float
        
        @description Returns the (scalar) cross product of the xy parts of two
        vectors. The vectors are computed from the Origin to target1 and
        target2.
        
        Parameter ``[in]``:
        target1 The target point for the first vector.
        
        Parameter ``[in]``:
        target2 The target point for the second vector.
        """
        ...
    
    def CrossProductXY(*args, **kwargs):
        """
        CrossProductXY(self: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d) -> float
        
        @description Return the (scalar) cross product of the xy parts of two
        vectors.
        
        Parameter ``[in]``:
        point2 The second vector
        
        Returns:
        The 2d cross product.
        """
        ...
    
    def DifferenceOf(*args, **kwargs):
        """
        DifferenceOf(self: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d) -> None
        
        @description Subtract coordinates of two vectors or points. (Compute
        Point1 - Point2)
        
        Parameter ``[in]``:
        point1 The first point
        
        Parameter ``[in]``:
        point2 The second (subtracted) point.
        """
        ...
    
    def Distance(*args, **kwargs):
        """
        Distance(self: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d) -> float
        
        @description Computes the (cartesian) distance between two points
        
        Parameter ``[in]``:
        point2 The second point
        
        Returns:
        The distance between points.
        """
        ...
    
    def DistanceSquared(*args, **kwargs):
        """
        DistanceSquared(self: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d) -> float
        
        @description Computes the squared distance between two points.
        
        Parameter ``[in]``:
        point2 The second point.
        
        Returns:
        The squared distance between the points.
        """
        ...
    
    def DistanceSquaredXY(*args, **kwargs):
        """
        DistanceSquaredXY(self: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d) -> float
        
        @description Computes the squared distance between two points, using
        only the xy parts.
        
        Parameter ``[in]``:
        point2 The second point
        
        Returns:
        The squared distance between the XY projections of the two points.
        (i.e. any z difference is ignored)
        """
        ...
    
    def DistanceXY(*args, **kwargs):
        """
        DistanceXY(*args, **kwargs)
        Overloaded function.
        
        1. DistanceXY(self: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d) -> float
        
        @description Computes the distance between two points, using only x
        and y components.
        
        Parameter ``[in]``:
        point2 The second point
        
        Returns:
        The distance between the XY projections of the two points. (i.e.
        any z difference is ignored)
        
        2. DistanceXY(self: MSPyBentleyGeom.DPoint3d, otherPoint: MSPyBentleyGeom.DPoint3d, matrix: MSPyBentleyGeom.DMatrix4d) -> tuple
        
        @description Computes the distance between two points, using only x
        and y components.
        
        Parameter ``[in]``:
        point2 The second point
        
        Returns:
        The distance between the XY projections of the two points. (i.e.
        any z difference is ignored)
        """
        ...
    
    def DivideArrayByScales(*args, **kwargs):
        """
        DivideArrayByScales(outPoints: MSPyBentleyGeom.DPoint3dArray, inPoints: MSPyBentleyGeom.DPoint3dArray, scales: MSPyBentley.DoubleArray) -> None
        
        @description Divide each point in an array by its corresponding scale
        factor. Leave any point with near zero weight unchanged.
        
        Parameter ``[out]``:
        pDest destination array.
        
        Parameter ``[in]``:
        pSource source array.
        
        Parameter ``[in]``:
        pScales scale factors
        
        Parameter ``[in]``:
        n number of points.
        """
        ...
    
    def DotDifference(*args, **kwargs):
        """
        DotDifference(self: MSPyBentleyGeom.DPoint3d, origin: MSPyBentleyGeom.DPoint3d, vector: Bentley.DVec3d) -> float
        
        @description Returns the (scalar) dot product of a two vectors. One
        vector is computed internally as the difference of the TargetPoint and
        Origin. (TargetPoint-Origin) The other is given directly as a single
        argument.
        
        Parameter ``[in]``:
        origin The start (orign) point of the first vector of the cross
        product.
        
        Parameter ``[in]``:
        vector The second
        """
        ...
    
    def DotProduct(*args, **kwargs):
        """
        DotProduct(*args, **kwargs)
        Overloaded function.
        
        1. DotProduct(self: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d) -> float
        
        @description Returns the (scalar) dot product of two vectors.
        
        Parameter ``[in]``:
        point2 The second vector
        
        Returns:
        The dot product of the two vectors
        
        2. DotProduct(self: MSPyBentleyGeom.DPoint3d, ax: float, ay: float, az: float) -> float
        
        @description Returns the (scalar) dot product of two vectors.
        
        Parameter ``[in]``:
        point2 The second vector
        
        Returns:
        The dot product of the two vectors
        """
        ...
    
    def DotProductToPoints(*args, **kwargs):
        """
        DotProductToPoints(self: MSPyBentleyGeom.DPoint3d, target1: MSPyBentleyGeom.DPoint3d, target2: MSPyBentleyGeom.DPoint3d) -> float
        
        @description Returns the (scalar) dot product of two vectors. The
        vectors are computed from the Origin to target1 and target2.
        
        Parameter ``[in]``:
        target1 The target point for the first vector.
        
        Parameter ``[in]``:
        target2 The target point for the second vector.
        """
        ...
    
    def DotProductToPointsXY(*args, **kwargs):
        """
        DotProductToPointsXY(self: MSPyBentleyGeom.DPoint3d, target1: MSPyBentleyGeom.DPoint3d, target2: MSPyBentleyGeom.DPoint3d) -> float
        
        @description Returns the (scalar) dot product of xy parts of two
        vectors. The vectors are computed from the BasePoint to target1 and
        target2.
        
        Parameter ``[in]``:
        target1 The target point for the first vector.
        
        Parameter ``[in]``:
        target2 The target point for the second vector.
        """
        ...
    
    def DotProductXY(*args, **kwargs):
        """
        DotProductXY(self: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d) -> float
        
        @description Returns the (scalar) dot product of xy parts of two
        vectors.
        
        Parameter ``[in]``:
        point2 The second vector
        
        Returns:
        The dot product of the xy parts of the two vectors
        """
        ...
    
    def From(*args, **kwargs):
        """
        From(*args, **kwargs)
        Overloaded function.
        
        1. From(x: float, y: float, z: float = 0.0) -> MSPyBentleyGeom.DPoint3d
        
        Return a DPoint3d with given xyz.
        
        2. From(xy: MSPyBentleyGeom.DPoint2d) -> MSPyBentleyGeom.DPoint3d
        
        Return a DPoint3d with given xyz.
        """
        ...
    
    def FromInterpolate(*args, **kwargs):
        """
        FromInterpolate(pointA: MSPyBentleyGeom.DPoint3d, fraction: float, pointB: MSPyBentleyGeom.DPoint3d) -> MSPyBentleyGeom.DPoint3d
        
        interpolate between points.
        
        Parameter ``[in]``:
        pointA start point
        
        Parameter ``[in]``:
        fraction fractional parameter
        
        Parameter ``[in]``:
        pointB end point
        """
        ...
    
    def FromInterpolateAndPerpendicularXY(*args, **kwargs):
        """
        FromInterpolateAndPerpendicularXY(pointA: MSPyBentleyGeom.DPoint3d, fraction: float, pointB: MSPyBentleyGeom.DPoint3d, fractionXYPerp: float) -> MSPyBentleyGeom.DPoint3d
        
        interpolate between points. Then add a shift in the xy plane by a
        fraction of the XY projection perpendicular
        
        Parameter ``[in]``:
        pointA start point
        
        Parameter ``[in]``:
        fraction fractional parameter along the line from A to B
        
        Parameter ``[in]``:
        pointB end point
        
        Parameter ``[in]``:
        fractionXYPerp fractional parameter applied to vector that is the
        XY parts of (B-A), rotated CCW in plane.
        """
        ...
    
    def FromInterpolateBilinear(*args, **kwargs):
        """
        FromInterpolateBilinear(point00: MSPyBentleyGeom.DPoint3d, point10: MSPyBentleyGeom.DPoint3d, point01: MSPyBentleyGeom.DPoint3d, point11: MSPyBentleyGeom.DPoint3d, u: float, v: float) -> MSPyBentleyGeom.DPoint3d
        
        @description Returns a bilinear interpolation from corners
        (00)(10)(01)(11)
        
        Parameter ``[in]``:
        point00 point at (0,0)
        
        Parameter ``[in]``:
        point10 point at (1,0)
        
        Parameter ``[in]``:
        point01 point at (0,1)
        
        Parameter ``[in]``:
        point11 point at (1,1)
        
        Parameter ``[in]``:
        u interpolation fraction for edges (point00,point10) and
        (point01,point11)
        
        Parameter ``[in]``:
        v interpolation fraction for edges (point00,point10) and
        (point10,point11)
        """
        ...
    
    def FromOne(*args, **kwargs):
        """
        FromOne() -> MSPyBentleyGeom.DPoint3d
        
        Return a DPoint3d with xyz = 1.
        """
        ...
    
    def FromProduct(*args, **kwargs):
        """
        FromProduct(*args, **kwargs)
        Overloaded function.
        
        1. FromProduct(transform: Bentley.Transform, x: float, y: float, z: float) -> MSPyBentleyGeom.DPoint3d
        
        return product of transform times point given as components.
        
        Parameter ``[in]``:
        transform affine transform.
        
        Parameter ``[in]``:
        x x component
        
        Parameter ``[in]``:
        y y component
        
        Parameter ``[in]``:
        z z component
        
        2. FromProduct(transform: Bentley.Transform, point: MSPyBentleyGeom.DPoint3d) -> MSPyBentleyGeom.DPoint3d
        
        return product of transform times point given as components.
        
        Parameter ``[in]``:
        transform affine transform.
        
        Parameter ``[in]``:
        x x component
        
        Parameter ``[in]``:
        y y component
        
        Parameter ``[in]``:
        z z component
        
        3. FromProduct(point: MSPyBentleyGeom.DPoint3d, matrix: Bentley.RotMatrix, x: float, y: float, z: float) -> MSPyBentleyGeom.DPoint3d
        
        return product of transform times point given as components.
        
        Parameter ``[in]``:
        transform affine transform.
        
        Parameter ``[in]``:
        x x component
        
        Parameter ``[in]``:
        y y component
        
        Parameter ``[in]``:
        z z component
        
        4. FromProduct(point: MSPyBentleyGeom.DPoint3d, matrix: Bentley.RotMatrix, vector: Bentley.DVec3d) -> MSPyBentleyGeom.DPoint3d
        
        return product of transform times point given as components.
        
        Parameter ``[in]``:
        transform affine transform.
        
        Parameter ``[in]``:
        x x component
        
        Parameter ``[in]``:
        y y component
        
        Parameter ``[in]``:
        z z component
        """
        ...
    
    def FromScale(*args, **kwargs):
        """
        FromScale(point: MSPyBentleyGeom.DPoint3d, scale: float) -> MSPyBentleyGeom.DPoint3d
        
        @description Returns a scalar multiple of a DPoint3d
        
        Parameter ``[in]``:
        point input point
        
        Parameter ``[in]``:
        scale scale factor
        """
        ...
    
    def FromSumOf(*args, **kwargs):
        """
        FromSumOf(*args, **kwargs)
        Overloaded function.
        
        1. FromSumOf(origin: MSPyBentleyGeom.DPoint3d, vector: MSPyBentleyGeom.DPoint3d) -> MSPyBentleyGeom.DPoint3d
        
        Add a point and a vector.
        
        Parameter ``[in]``:
        origin start point
        
        Parameter ``[in]``:
        vector vector add
        
        2. FromSumOf(origin: MSPyBentleyGeom.DPoint3d, vector: MSPyBentleyGeom.DPoint3d, scaleFactor: float) -> MSPyBentleyGeom.DPoint3d
        
        Add a point and a vector.
        
        Parameter ``[in]``:
        origin start point
        
        Parameter ``[in]``:
        vector vector add
        
        3. FromSumOf(origin: MSPyBentleyGeom.DPoint3d, point0: MSPyBentleyGeom.DPoint3d, scaleFactor0: float, point1: MSPyBentleyGeom.DPoint3d, scaleFactor1: float) -> MSPyBentleyGeom.DPoint3d
        
        Add a point and a vector.
        
        Parameter ``[in]``:
        origin start point
        
        Parameter ``[in]``:
        vector vector add
        
        4. FromSumOf(origin: MSPyBentleyGeom.DPoint3d, point0: MSPyBentleyGeom.DPoint3d, scaleFactor0: float, point1: MSPyBentleyGeom.DPoint3d, scaleFactor1: float, point2: MSPyBentleyGeom.DPoint3d, scaleFactor2: float) -> MSPyBentleyGeom.DPoint3d
        
        Add a point and a vector.
        
        Parameter ``[in]``:
        origin start point
        
        Parameter ``[in]``:
        vector vector add
        
        5. FromSumOf(point0: MSPyBentleyGeom.DPoint3d, scale0: float, point1: MSPyBentleyGeom.DPoint3d, scale1: float) -> MSPyBentleyGeom.DPoint3d
        
        Add a point and a vector.
        
        Parameter ``[in]``:
        origin start point
        
        Parameter ``[in]``:
        vector vector add
        
        6. FromSumOf(point0: MSPyBentleyGeom.DPoint3d, scale0: float, point1: MSPyBentleyGeom.DPoint3d, scale1: float, point2: MSPyBentleyGeom.DPoint3d, scale2: float) -> MSPyBentleyGeom.DPoint3d
        
        Add a point and a vector.
        
        Parameter ``[in]``:
        origin start point
        
        Parameter ``[in]``:
        vector vector add
        """
        ...
    
    def FromWeightedAverage(*args, **kwargs):
        """
        FromWeightedAverage(*args, **kwargs)
        Overloaded function.
        
        1. FromWeightedAverage(pointA: MSPyBentleyGeom.DPoint3d, weightA: float, pointB: MSPyBentleyGeom.DPoint3d, weightB: float) -> MSPyBentleyGeom.DPoint3d
        
        return the centroid for points with specified weights
        
        2. FromWeightedAverage(pointA: MSPyBentleyGeom.DPoint3d, weightA: float, pointB: MSPyBentleyGeom.DPoint3d, weightB: float, pointC: MSPyBentleyGeom.DPoint3d, weightC: float) -> MSPyBentleyGeom.DPoint3d
        
        return the centroid for points with specified weights
        """
        ...
    
    def FromZero(*args, **kwargs):
        """
        FromZero() -> MSPyBentleyGeom.DPoint3d
        
        Return a DPoint3d with xyz = 0.
        """
        ...
    
    def GeometricMeanCrossProduct(*args, **kwargs):
        """
        GeometricMeanCrossProduct(self: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d) -> float
        
        @description Computes the cross product of two vectors and scales it
        to the geometric mean of the lengths of the two vectors. This is
        useful because it has the direction of the cross product (i.e. normal
        to the plane of the two vectors) and a size in between the two
        vectors.
        
        Parameter ``[in]``:
        point1 The first vector
        
        Parameter ``[in]``:
        point2 The second vector
        
        Returns:
        The length of original vector.
        """
        ...
    
    def GetComponent(*args, **kwargs):
        """
        GetComponent(self: MSPyBentleyGeom.DPoint3d, index: int) -> float
        
        @description Gets a single component of a point. If the index is out
        of range 0,1,2, it is interpreted cyclically.
        
        Parameter ``[in]``:
        index Indicates which component is accessed. The values are 0=x,
        1=y, 2=z. Other values are treated cyclically.
        
        Returns:
        The specified component of the point or vector.
        """
        ...
    
    def GetComponents(*args, **kwargs):
        """
        GetComponents(self: MSPyBentleyGeom.DPoint3d) -> Tuple[float, float, float]
        """
        ...
    
    def Init(*args, **kwargs):
        """
        Init(*args, **kwargs)
        Overloaded function.
        
        1. Init(self: MSPyBentleyGeom.DPoint3d, source: MSPyBentleyGeom.DPoint2d) -> None
        
        @description Copy from a 2d point setting z to zero.
        
        Parameter ``[in]``:
        source source point
        
        2. Init(self: MSPyBentleyGeom.DPoint3d, ax: float, ay: float, az: float) -> None
        
        @description Copy from a 2d point setting z to zero.
        
        Parameter ``[in]``:
        source source point
        
        3. Init(self: MSPyBentleyGeom.DPoint3d, ax: float, ay: float) -> None
        
        @description Copy from a 2d point setting z to zero.
        
        Parameter ``[in]``:
        source source point
        
        4. Init(self: MSPyBentleyGeom.DPoint3d, vector: Bentley.DVec3d) -> None
        
        @description Copy from a 2d point setting z to zero.
        
        Parameter ``[in]``:
        source source point
        """
        ...
    
    def InitDisconnect(*args, **kwargs):
        """
        InitDisconnect(self: MSPyBentleyGeom.DPoint3d) -> None
        
        Initialize a point with all coordinates as the disconnect value.
        """
        ...
    
    def Interpolate(*args, **kwargs):
        """
        Interpolate(self: MSPyBentleyGeom.DPoint3d, point0: MSPyBentleyGeom.DPoint3d, fractionParameter: float, point1: MSPyBentleyGeom.DPoint3d) -> None
        
        @description Computes a point whose position is given by a fractional
        argument and two endpoints.
        
        Parameter ``[in]``:
        point0 The point corresponding to fractionParameter of 0.
        
        Parameter ``[in]``:
        fractionParameter The fractional parametric coordinate. 0.0 is the
        start of the segment, 1.0 is the end, 0.5 is midpoint.
        
        Parameter ``[in]``:
        point1 The point corresponding to fractionParameter of 1.
        """
        ...
    
    def IsDisconnect(*args, **kwargs):
        """
        IsDisconnect(self: MSPyBentleyGeom.DPoint3d) -> bool
        
        Returns:
        true if the point has coordinates which indicate it is a
        disconnect (separator) ponit.
        """
        ...
    
    def IsEqual(*args, **kwargs):
        """
        IsEqual(*args, **kwargs)
        Overloaded function.
        
        1. IsEqual(self: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d) -> bool
        
        @description Test for exact equality between all components of two
        points or vectors.
        
        Parameter ``[in]``:
        point2 The second point or vector
        
        Returns:
        true if the points are identical.
        
        2. IsEqual(self: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d, tolerance: float) -> bool
        
        @description Test for exact equality between all components of two
        points or vectors.
        
        Parameter ``[in]``:
        point2 The second point or vector
        
        Returns:
        true if the points are identical.
        """
        ...
    
    def IsParallelTo(*args, **kwargs):
        """
        IsParallelTo(self: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d) -> bool
        
        @description Tests if two vectors are parallel.
        
        Parameter ``[in]``:
        point2 The second vector
        
        Returns:
        true if the vectors are parallel within default tolerance
        """
        ...
    
    def IsPerpendicularTo(*args, **kwargs):
        """
        IsPerpendicularTo(self: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d) -> bool
        
        @description Tests if two vectors are perpendicular.
        
        Parameter ``[in]``:
        point2 The second vector
        
        Returns:
        true if vectors are perpendicular within default tolerance
        """
        ...
    
    def IsPointInCCWector(*args, **kwargs):
        """
        IsPointInCCWector(self: MSPyBentleyGeom.DPoint3d, origin: MSPyBentleyGeom.DPoint3d, target0: MSPyBentleyGeom.DPoint3d, target1: MSPyBentleyGeom.DPoint3d, upVector: Bentley.DVec3d) -> bool
        
        @description Test if a point is within the counter-clockwise sector
        defined by an origin and two boundary points, with an up vector to
        determine which direction is counter clockwise.
        
        Parameter ``[in]``:
        origin The point to test.
        
        Parameter ``[in]``:
        target0 The first target point.
        
        Parameter ``[in]``:
        target1 The second target point.
        
        Parameter ``[in]``:
        upVector vector towards eye to resolve direction.
        
        Returns:
        true if the test point is within the angle.
        """
        ...
    
    def IsPointInSmallerSector(*args, **kwargs):
        """
        IsPointInSmallerSector(self: MSPyBentleyGeom.DPoint3d, origin: MSPyBentleyGeom.DPoint3d, target1: MSPyBentleyGeom.DPoint3d, target2: MSPyBentleyGeom.DPoint3d) -> bool
        
        @description Form vectors from the origin to the test point and the
        two boundary vectors. Test if the test vector is within the smaller
        angle between the other two vectors.
        
        Parameter ``[in]``:
        origin The point to test.
        
        Parameter ``[in]``:
        target1 The first target point.
        
        Parameter ``[in]``:
        target2 The second target point.
        
        Returns:
        true if the test point is within the angle.
        """
        ...
    
    def IsVectorInCCWSector(*args, **kwargs):
        """
        IsVectorInCCWSector(self: MSPyBentleyGeom.DPoint3d, point0: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d, upVector: MSPyBentleyGeom.DPoint3d) -> bool
        
        @description Test if the test vector vector is " between " point0 and
        point1, with CCW direction resolved by an up vector. The cross product
        of point0 and point1 is considered the positive plane normal if its
        dot product with the up vector is positive.
        
        Parameter ``[in]``:
        point0 The boundary vector.
        
        Parameter ``[in]``:
        point1 The boundary vector.
        
        Parameter ``[in]``:
        upVector The out of plane vector.
        
        Returns:
        true if test vector is within the angle.
        """
        ...
    
    def IsVectorInSmallerSector(*args, **kwargs):
        """
        IsVectorInSmallerSector(self: MSPyBentleyGeom.DPoint3d, point0: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d) -> bool
        
        @description Test a vector is " between " point0 and point1. If the
        vectors are coplanar and point0 is neither parallel nor antiparallel
        to point1, betweenness has the expected meaning:there are two angles
        between point0 and point1; one is less than 180; the test vector is
        tested to see if it is in the smaller angle. If the vectors are not
        coplanar, the test is based on the projection of the test vector into
        the plane of the other two vectors.
        
        Zero testing is untoleranced, and is biased to all parallel conditions
        " false ". That is, if any pair of the input vectors is parallel or
        antiparallel, the mathematical answer is false. Floating point
        tolerances will cause " nearby " cases to be unpredictable. It is
        assumed that if the caller considers the " parallel " cases important
        they will be checked explicitly.
        
        Parameter ``[in]``:
        point0 The first boundary vector.
        
        Parameter ``[in]``:
        point1 The second boundary vector.
        
        Returns:
        true if the test vector is within the angle.
        """
        ...
    
    def Magnitude(*args, **kwargs):
        """
        Magnitude(self: MSPyBentleyGeom.DPoint3d) -> float
        
        @description Computes the magnitude of a vector.
        
        Returns:
        The length of the vector
        """
        ...
    
    def MagnitudeSquared(*args, **kwargs):
        """
        MagnitudeSquared(self: MSPyBentleyGeom.DPoint3d) -> float
        
        @description Computes the squared magnitude of a vector.
        
        Returns:
        The squared magnitude of the vector.
        """
        ...
    
    def MagnitudeSquaredXY(*args, **kwargs):
        """
        MagnitudeSquaredXY(self: MSPyBentleyGeom.DPoint3d) -> float
        
        @description Computes the squared magnitude of the xy part of a
        vector.
        
        Returns:
        The squared magnitude of the xy parts of the given vector.
        """
        ...
    
    def MagnitudeXY(*args, **kwargs):
        """
        MagnitudeXY(self: MSPyBentleyGeom.DPoint3d) -> float
        
        @description Computes the magnitude of the xy part of a vector.
        
        Returns:
        The magnitude of the xy parts of the given vector.
        """
        ...
    
    def MaxAbs(*args, **kwargs):
        """
        MaxAbs(self: MSPyBentleyGeom.DPoint3d) -> float
        
        @description Finds the largest absolute value among the components of
        a point or vector.
        
        Returns:
        The largest absolute value among point coordinates.
        """
        ...
    
    def MaxAbsIndex(*args, **kwargs):
        """
        MaxAbsIndex(self: MSPyBentleyGeom.DPoint3d) -> int
        
        return in the index of the MaxAbs () value.
        """
        ...
    
    def MinAbs(*args, **kwargs):
        """
        MinAbs(self: MSPyBentleyGeom.DPoint3d) -> float
        
        @description Finds the smallest absolute value among the components of
        a point or vector.
        
        Returns:
        The smallest absolute value among point coordinates.
        """
        ...
    
    def MinAbsIndex(*args, **kwargs):
        """
        MinAbsIndex(self: MSPyBentleyGeom.DPoint3d) -> int
        
        return in the index of the MinAbs () value
        """
        ...
    
    def MultiplyArrayByScales(*args, **kwargs):
        """
        MultiplyArrayByScales(outPoints: MSPyBentleyGeom.DPoint3dArray, inPoints: MSPyBentleyGeom.DPoint3dArray, scales: MSPyBentley.DoubleArray) -> None
        
        @description Multiply each point in an array by its corresponding
        scale factor.
        
        Parameter ``[out]``:
        pDest destination array.
        
        Parameter ``[in]``:
        pSource source array.
        
        Parameter ``[in]``:
        pScales scale factors
        
        Parameter ``[in]``:
        n number of points.
        """
        ...
    
    def Negate(*args, **kwargs):
        """
        Negate(*args, **kwargs)
        Overloaded function.
        
        1. Negate(self: MSPyBentleyGeom.DPoint3d, vector: MSPyBentleyGeom.DPoint3d) -> None
        
        @description Computes a negated (opposite) vector.
        
        Parameter ``[in]``:
        vector The vector to be negated.
        
        2. Negate(self: MSPyBentleyGeom.DPoint3d) -> None
        
        @description Computes a negated (opposite) vector.
        
        Parameter ``[in]``:
        vector The vector to be negated.
        """
        ...
    
    def Normalize(*args, **kwargs):
        """
        Normalize(*args, **kwargs)
        Overloaded function.
        
        1. Normalize(self: MSPyBentleyGeom.DPoint3d, vector: MSPyBentleyGeom.DPoint3d) -> float
        
        @description Normalizes (scales) a vector to length 1. If the input
        vector length is 0, the output vector is a zero vector and the
        returned length is 0.
        
        Parameter ``[in]``:
        vector The vector to be normalized.
        
        Returns:
        The length prior to normalization
        
        2. Normalize(self: MSPyBentleyGeom.DPoint3d) -> float
        
        @description Normalizes (scales) a vector to length 1. If the input
        vector length is 0, the output vector is a zero vector and the
        returned length is 0.
        
        Parameter ``[in]``:
        vector The vector to be normalized.
        
        Returns:
        The length prior to normalization
        """
        ...
    
    def NormalizedCrossProduct(*args, **kwargs):
        """
        NormalizedCrossProduct(self: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d) -> float
        
        @description Compute the normalized cross product of two vectors and
        return the length of the unnormalized cross product.
        
        Parameter ``[in]``:
        point1 The first vector
        
        Parameter ``[in]``:
        point2 The second vector
        
        Returns:
        The length of the original (prenormalization) cross product vector
        """
        ...
    
    def NormalizedDifference(*args, **kwargs):
        """
        NormalizedDifference(self: MSPyBentleyGeom.DPoint3d, target: MSPyBentleyGeom.DPoint3d, origin: MSPyBentleyGeom.DPoint3d) -> float
        
        @description Computes a unit vector in the direction of the difference
        of the points or vectors (Second parameter vector is subtracted from
        the first parameter vector, exactly as in the subtract function.)
        
        Parameter ``[in]``:
        target The target point.
        
        Parameter ``[in]``:
        origin The origin point.
        
        Returns:
        The length of original difference vector.
        """
        ...
    
    def NpcCoordinatesOf(*args, **kwargs):
        """
        NpcCoordinatesOf(self: MSPyBentleyGeom.DPoint3d, point: MSPyBentleyGeom.DPoint3d, cube: Bentley.DRange3d) -> None
        
        @description Computes the coordinates of point under the translation
        and scaling that puts 000 at cube>low and 111 at cube>high.
        
        Parameter ``[in]``:
        point Point whose NPC coordinates are to be computed
        
        Parameter ``[in]``:
        cube Cube whose corners map to 000 and 111
        """
        ...
    
    def One(*args, **kwargs):
        """
        One(self: MSPyBentleyGeom.DPoint3d) -> None
        
        @description Returns a point or vector with all components 1.0.
        """
        ...
    
    def PlanarAngleTo(*args, **kwargs):
        """
        PlanarAngleTo(self: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d, planeNormal: MSPyBentleyGeom.DPoint3d) -> float
        
        @description Computes the signed angle between the projection of two
        vectors onto a plane with given normal.
        
        Parameter ``[in]``:
        point2 The second vector
        
        Parameter ``[in]``:
        planeNormal The plane normal vector
        
        Returns:
        The angle in plane
        """
        ...
    
    def RotateXY(*args, **kwargs):
        """
        RotateXY(*args, **kwargs)
        Overloaded function.
        
        1. RotateXY(self: MSPyBentleyGeom.DPoint3d, vector: MSPyBentleyGeom.DPoint3d, theta: float) -> None
        
        @description Rotate vector around the z axis, return as calling
        instance.
        
        Parameter ``[in]``:
        vector vector to rotate.
        
        Parameter ``[in]``:
        theta The rotation angle.
        
        2. RotateXY(self: MSPyBentleyGeom.DPoint3d, theta: float) -> None
        
        @description Rotate vector around the z axis, return as calling
        instance.
        
        Parameter ``[in]``:
        vector vector to rotate.
        
        Parameter ``[in]``:
        theta The rotation angle.
        """
        ...
    
    def SafeDivide(*args, **kwargs):
        """
        SafeDivide(self: MSPyBentleyGeom.DPoint3d, vector: MSPyBentleyGeom.DPoint3d, denominator: float) -> bool
        
        @description Try to divide each component of a vector by a scalar. If
        the denominator near zero compared to any numerator component, return
        the original vector.
        
        Parameter ``[in]``:
        vector The initial vector.
        
        Parameter ``[in]``:
        denominator The divisor.
        
        Returns:
        true if division is numerically safe.
        """
        ...
    
    def Scale(*args, **kwargs):
        """
        Scale(*args, **kwargs)
        Overloaded function.
        
        1. Scale(self: MSPyBentleyGeom.DPoint3d, vector: MSPyBentleyGeom.DPoint3d, scale: float) -> None
        
        @description Multiplies a vector by a scale factor.
        
        Parameter ``[in]``:
        vector The vector to be scaled.
        
        Parameter ``[in]``:
        scale The scale factor.
        
        2. Scale(self: MSPyBentleyGeom.DPoint3d, scale: float) -> None
        
        @description Multiplies a vector by a scale factor.
        
        Parameter ``[in]``:
        vector The vector to be scaled.
        
        Parameter ``[in]``:
        scale The scale factor.
        """
        ...
    
    def ScaleToLength(*args, **kwargs):
        """
        ScaleToLength(*args, **kwargs)
        Overloaded function.
        
        1. ScaleToLength(self: MSPyBentleyGeom.DPoint3d, vector: MSPyBentleyGeom.DPoint3d, length: float) -> float
        
        @description Scales a vector to specified length. If the input vector
        length is 0, the output vector is a zero vector and the returned
        length is 0.
        
        Parameter ``[in]``:
        vector The original vector.
        
        Parameter ``[in]``:
        length The requested length.
        
        Returns:
        The length prior to scaling.
        
        2. ScaleToLength(self: MSPyBentleyGeom.DPoint3d, length: float) -> float
        
        @description Scales a vector to specified length. If the input vector
        length is 0, the output vector is a zero vector and the returned
        length is 0.
        
        Parameter ``[in]``:
        vector The original vector.
        
        Parameter ``[in]``:
        length The requested length.
        
        Returns:
        The length prior to scaling.
        """
        ...
    
    def SetComponent(*args, **kwargs):
        """
        SetComponent(self: MSPyBentleyGeom.DPoint3d, a: float, index: int) -> None
        
        @description Set one of three components (x,y,z) of the point.
        
        Parameter ``[in]``:
        a The component value.
        
        Parameter ``[in]``:
        index Selects the the axis:0=x, 1=y, 2=z, others cyclic.
        """
        ...
    
    def SignedAngleTo(*args, **kwargs):
        """
        SignedAngleTo(self: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d, orientationVector: MSPyBentleyGeom.DPoint3d) -> float
        
        @description Computes the signed from one vector to another, in the
        plane of the two vectors. Initial computation using only the two
        vectors yields two possible angles depending on which side of the
        plane of the vectors is viewed. To choose which side to view, go on
        the side whose normal has a positive dot product with the orientation
        vector. This angle can be between -pi and +pi.
        
        Parameter ``[in]``:
        point2 The second vector
        
        Parameter ``[in]``:
        orientationVector The vector used to determine orientation.
        
        Returns:
        The signed angle
        """
        ...
    
    def SizedCrossProduct(*args, **kwargs):
        """
        SizedCrossProduct(self: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d, productLength: float) -> float
        
        @description Computes the cross product of the two parameter vectors
        and scales it to a given length. The scaled vector is stored as the
        product vector, and the length of the original cross product vector is
        returned.
        
        Parameter ``[in]``:
        point1 The first vector
        
        Parameter ``[in]``:
        point2 The second vector
        
        Parameter ``[in]``:
        productLength The Desired length
        
        Returns:
        The length of original vector.
        """
        ...
    
    def SmallerUnorientedAngleTo(*args, **kwargs):
        """
        SmallerUnorientedAngleTo(self: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d) -> float
        
        @description Returns the angle between two vectors, choosing the
        smaller of the two possible angles when both the vectors and their
        negations are considered. This angle is between 0 and pi/2.
        
        Parameter ``[in]``:
        point2 The second vector
        
        Returns:
        The angle between the vectors.
        """
        ...
    
    def SmallerUnorientedAngleToXY(*args, **kwargs):
        """
        SmallerUnorientedAngleToXY(self: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d) -> float
        
        @description Returns the angle between two vectors, considering both
        the vectors and their negations and choosing the smaller. This angle
        is between 0 and pi/2.
        
        Parameter ``[in]``:
        point2 The second vector
        
        Returns:
        The angle between vectors.
        """
        ...
    
    def Subtract(*args, **kwargs):
        """
        Subtract(*args, **kwargs)
        Overloaded function.
        
        1. Subtract(self: MSPyBentleyGeom.DPoint3d, base: MSPyBentleyGeom.DPoint3d, vector: Bentley.DVec3d) -> None
        
        @description Subtract a vector from a point.
        
        Parameter ``[in]``:
        base The the first point or vector
        
        Parameter ``[in]``:
        vector The second point or vector
        
        2. Subtract(self: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d) -> None
        
        @description Subtract a vector from a point.
        
        Parameter ``[in]``:
        base The the first point or vector
        
        Parameter ``[in]``:
        vector The second point or vector
        """
        ...
    
    def SumOf(*args, **kwargs):
        """
        SumOf(*args, **kwargs)
        Overloaded function.
        
        1. SumOf(self: MSPyBentleyGeom.DPoint3d, origin: MSPyBentleyGeom.DPoint3d, vector: Bentley.DVec3d, scale: float) -> None
        
        @description Adds an origin and a scaled vector.
        
        Parameter ``[in]``:
        origin Origin for the sum.
        
        Parameter ``[in]``:
        vector The vector to be added.
        
        Parameter ``[in]``:
        scale The scale factor.
        
        2. SumOf(self: MSPyBentleyGeom.DPoint3d, origin: MSPyBentleyGeom.DPoint3d, point1: Bentley.DVec3d, scale1: float, point2: Bentley.DVec3d, scale2: float) -> None
        
        @description Adds an origin and a scaled vector.
        
        Parameter ``[in]``:
        origin Origin for the sum.
        
        Parameter ``[in]``:
        vector The vector to be added.
        
        Parameter ``[in]``:
        scale The scale factor.
        
        3. SumOf(self: MSPyBentleyGeom.DPoint3d, origin: MSPyBentleyGeom.DPoint3d, point1: Bentley.DVec3d, scale1: float, point2: Bentley.DVec3d, scale2: float, point3: Bentley.DVec3d, scale3: float) -> None
        
        @description Adds an origin and a scaled vector.
        
        Parameter ``[in]``:
        origin Origin for the sum.
        
        Parameter ``[in]``:
        vector The vector to be added.
        
        Parameter ``[in]``:
        scale The scale factor.
        
        4. SumOf(self: MSPyBentleyGeom.DPoint3d, origin: MSPyBentleyGeom.DPoint3d, vector: MSPyBentleyGeom.DPoint3d, scale: float) -> None
        
        @description Adds an origin and a scaled vector.
        
        Parameter ``[in]``:
        origin Origin for the sum.
        
        Parameter ``[in]``:
        vector The vector to be added.
        
        Parameter ``[in]``:
        scale The scale factor.
        
        5. SumOf(self: MSPyBentleyGeom.DPoint3d, origin: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d, scale1: float, point2: MSPyBentleyGeom.DPoint3d, scale2: float) -> None
        
        @description Adds an origin and a scaled vector.
        
        Parameter ``[in]``:
        origin Origin for the sum.
        
        Parameter ``[in]``:
        vector The vector to be added.
        
        Parameter ``[in]``:
        scale The scale factor.
        
        6. SumOf(self: MSPyBentleyGeom.DPoint3d, origin: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d, scale1: float, point2: MSPyBentleyGeom.DPoint3d, scale2: float, point3: MSPyBentleyGeom.DPoint3d, scale3: float) -> None
        
        @description Adds an origin and a scaled vector.
        
        Parameter ``[in]``:
        origin Origin for the sum.
        
        Parameter ``[in]``:
        vector The vector to be added.
        
        Parameter ``[in]``:
        scale The scale factor.
        
        7. SumOf(self: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d, a1: float, point2: MSPyBentleyGeom.DPoint3d, a2: float) -> None
        
        @description Adds an origin and a scaled vector.
        
        Parameter ``[in]``:
        origin Origin for the sum.
        
        Parameter ``[in]``:
        vector The vector to be added.
        
        Parameter ``[in]``:
        scale The scale factor.
        
        8. SumOf(self: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d, a1: float, point2: MSPyBentleyGeom.DPoint3d, a2: float, point3: MSPyBentleyGeom.DPoint3d, a3: float) -> None
        
        @description Adds an origin and a scaled vector.
        
        Parameter ``[in]``:
        origin Origin for the sum.
        
        Parameter ``[in]``:
        vector The vector to be added.
        
        Parameter ``[in]``:
        scale The scale factor.
        
        9. SumOf(self: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d) -> None
        
        @description Adds an origin and a scaled vector.
        
        Parameter ``[in]``:
        origin Origin for the sum.
        
        Parameter ``[in]``:
        vector The vector to be added.
        
        Parameter ``[in]``:
        scale The scale factor.
        """
        ...
    
    def Swap(*args, **kwargs):
        """
        Swap(self: MSPyBentleyGeom.DPoint3d, other: MSPyBentleyGeom.DPoint3d) -> None
        
        Swap contents of instance, other.
        
        Parameter ``[in,out]``:
        other second point.
        """
        ...
    
    def TripleProduct(*args, **kwargs):
        """
        TripleProduct(self: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d, point3: MSPyBentleyGeom.DPoint3d) -> float
        
        @description Computes the triple product of three vectors. The
        following are equivalent definitions of the triple product of three
        vectors V1, V2, and V3:
        
        <UL> <LI> (V1 cross V2) dot V3 <LI> V1 dot (V2 cross V3) <LI>The
        determinant of the 3x3 matrix with the three vectors as its columns.
        <LI>The determinant of the 3x3 matrix with the three vectors as its
        rows. <LI>The (signed)volume of the parallelepiped whose 4 vertices
        are at the origin and at the ends of the 3 vectors placed at the
        origin. </UL>
        
        Parameter ``[in]``:
        point2 The second vector.
        
        Parameter ``[in]``:
        point3 The third vector.
        
        Returns:
        The triple product
        """
        ...
    
    def TripleProductToPoints(*args, **kwargs):
        """
        TripleProductToPoints(self: MSPyBentleyGeom.DPoint3d, target1: MSPyBentleyGeom.DPoint3d, target2: MSPyBentleyGeom.DPoint3d, target3: MSPyBentleyGeom.DPoint3d) -> float
        
        @description Computes the triple product of vectors from a base point
        three target points.
        
        Parameter ``[in]``:
        target1 The target point for the first vector.
        
        Parameter ``[in]``:
        target2 The target point for the second vector.
        
        Parameter ``[in]``:
        target3 The target point for the third vector.
        
        Returns:
        The triple product
        """
        ...
    
    def UnitPerpendicularXY(*args, **kwargs):
        """
        UnitPerpendicularXY(self: MSPyBentleyGeom.DPoint3d, vector: MSPyBentleyGeom.DPoint3d) -> bool
        
        @description Compute a unit vector perpendicular to the xy parts of
        given vector.
        
        Parameter ``[in]``:
        vector The source vector
        
        Returns:
        true if the input vector has nonzero length
        """
        ...
    
    def WeightedDifferenceCrossProduct(*args, **kwargs):
        """
        WeightedDifferenceCrossProduct(self: MSPyBentleyGeom.DPoint3d, basePoint: Bentley.DPoint4d, target1: Bentley.DPoint4d, target2: Bentley.DPoint4d) -> None
        
        @description Form the cross product of the weighted differences from
        point0 to point1 and point2.
        
        Parameter ``[in]``:
        basePoint The common base point (second point for differences)
        
        Parameter ``[in]``:
        target1 The first target point.
        
        Parameter ``[in]``:
        target2 The second target point.
        """
        ...
    
    def WeightedDifferenceOf(*args, **kwargs):
        """
        WeightedDifferenceOf(self: MSPyBentleyGeom.DPoint3d, point1: Bentley.DPoint4d, point2: Bentley.DPoint4d) -> None
        
        @description Scale each point by the other's weight and subtract, i.e.
        form (point1 * point2.w - point2 * point1.w). The weight term
        vanishes. Copy the xyz parts back as a vector.
        
        Parameter ``[in]``:
        point1 The first point
        
        Parameter ``[in]``:
        point2 The second pont.
        """
        ...
    
    def XyzOf(*args, **kwargs):
        """
        XyzOf(self: MSPyBentleyGeom.DPoint3d, hPoint: Bentley.DPoint4d) -> None
        
        @description Sets the x,y, and z components of a DPoint3d structure
        from the corresponding parts of a DPoint4d. Weight part of DPoint4d is
        not used.
        
        Parameter ``[in]``:
        hPoint The homogeneous point
        """
        ...
    
    def Zero(*args, **kwargs):
        """
        Zero(self: MSPyBentleyGeom.DPoint3d) -> None
        
        @description Sets all components of a point or vector to zero.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DPoint3d, vector: Bentley.DVec3d) -> None
        
        2. __init__(self: MSPyBentleyGeom.DPoint3d) -> None
        
        3. __init__(self: MSPyBentleyGeom.DPoint3d, x: float, y: float, z: float = 0.0) -> None
        
        4. __init__(self: MSPyBentleyGeom.DPoint3d, xy: MSPyBentleyGeom.DPoint2d) -> None
        """
        ...
    
    @property
    def x(self: MSPyBentleyGeom.DPoint3d) -> float:
        ...
    @x.setter
    def x(self: MSPyBentleyGeom.DPoint3d, arg0: float) -> None:
        ...
    
    @property
    def y(self: MSPyBentleyGeom.DPoint3d) -> float:
        ...
    @y.setter
    def y(self: MSPyBentleyGeom.DPoint3d, arg0: float) -> None:
        ...
    
    @property
    def z(self: MSPyBentleyGeom.DPoint3d) -> float:
        ...
    @z.setter
    def z(self: MSPyBentleyGeom.DPoint3d, arg0: float) -> None:
        ...
    
class DPoint3dArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DPoint3dArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.DPoint3dArray, arg0: MSPyBentleyGeom.DPoint3dArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.DPoint3dArray, arg0: Iterable) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.DPoint3dArray, x: MSPyBentleyGeom.DPoint3d) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.DPoint3dArray) -> None
        
        Clear the contents
        """
        ...
    
    def count(*args, **kwargs):
        """
        count(self: MSPyBentleyGeom.DPoint3dArray, x: MSPyBentleyGeom.DPoint3d) -> int
        
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.DPoint3dArray, L: MSPyBentleyGeom.DPoint3dArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.DPoint3dArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.DPoint3dArray, i: int, x: MSPyBentleyGeom.DPoint3d) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.DPoint3dArray) -> MSPyBentleyGeom.DPoint3d
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.DPoint3dArray, i: int) -> MSPyBentleyGeom.DPoint3d
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(*args, **kwargs):
        """
        remove(self: MSPyBentleyGeom.DPoint3dArray, x: MSPyBentleyGeom.DPoint3d) -> None
        
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class DPoint3dSizeSize:
    """
    None
    """

    def Get(*args, **kwargs):
        """
        Get(self: MSPyBentleyGeom.DPoint3dSizeSize) -> MSPyBentleyGeom.DPoint3d
        """
        ...
    
    def GetCR(*args, **kwargs):
        """
        GetCR(self: MSPyBentleyGeom.DPoint3dSizeSize) -> MSPyBentleyGeom.DPoint3d
        """
        ...
    
    def GetTag(*args, **kwargs):
        """
        GetTag(self: MSPyBentleyGeom.DPoint3dSizeSize, tagA: bool) -> int
        """
        ...
    
    def GetTagA(*args, **kwargs):
        """
        GetTagA(self: MSPyBentleyGeom.DPoint3dSizeSize) -> int
        """
        ...
    
    def GetTagB(*args, **kwargs):
        """
        GetTagB(self: MSPyBentleyGeom.DPoint3dSizeSize) -> int
        """
        ...
    
    def Set(*args, **kwargs):
        """
        Set(self: MSPyBentleyGeom.DPoint3dSizeSize, value: MSPyBentleyGeom.DPoint3d) -> None
        """
        ...
    
    def SetTagA(*args, **kwargs):
        """
        SetTagA(self: MSPyBentleyGeom.DPoint3dSizeSize, tag: int) -> None
        """
        ...
    
    def SetTagB(*args, **kwargs):
        """
        SetTagB(self: MSPyBentleyGeom.DPoint3dSizeSize, tag: int) -> None
        """
        ...
    
    def SwapTags(*args, **kwargs):
        """
        SwapTags(self: MSPyBentleyGeom.DPoint3dSizeSize) -> None
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DPoint3dSizeSize) -> None
        
        2. __init__(self: MSPyBentleyGeom.DPoint3dSizeSize, value: MSPyBentleyGeom.DPoint3d, tagA: int, tagB: int) -> None
        """
        ...
    
class DPoint3dVecArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DPoint3dVecArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.DPoint3dVecArray, arg0: MSPyBentleyGeom.DPoint3dVecArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.DPoint3dVecArray, arg0: Iterable) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.DPoint3dVecArray, x: MSPyBentleyGeom.DPoint3dArray) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.DPoint3dVecArray) -> None
        
        Clear the contents
        """
        ...
    
    def count(*args, **kwargs):
        """
        count(self: MSPyBentleyGeom.DPoint3dVecArray, x: MSPyBentleyGeom.DPoint3dArray) -> int
        
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.DPoint3dVecArray, L: MSPyBentleyGeom.DPoint3dVecArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.DPoint3dVecArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.DPoint3dVecArray, i: int, x: MSPyBentleyGeom.DPoint3dArray) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.DPoint3dVecArray) -> MSPyBentleyGeom.DPoint3dArray
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.DPoint3dVecArray, i: int) -> MSPyBentleyGeom.DPoint3dArray
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(*args, **kwargs):
        """
        remove(self: MSPyBentleyGeom.DPoint3dVecArray, x: MSPyBentleyGeom.DPoint3dArray) -> None
        
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class DPoint3dVecVecArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DPoint3dVecVecArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.DPoint3dVecVecArray, arg0: MSPyBentleyGeom.DPoint3dVecVecArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.DPoint3dVecVecArray, arg0: Iterable) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.DPoint3dVecVecArray, x: MSPyBentleyGeom.DPoint3dVecArray) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.DPoint3dVecVecArray) -> None
        
        Clear the contents
        """
        ...
    
    def count(*args, **kwargs):
        """
        count(self: MSPyBentleyGeom.DPoint3dVecVecArray, x: MSPyBentleyGeom.DPoint3dVecArray) -> int
        
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.DPoint3dVecVecArray, L: MSPyBentleyGeom.DPoint3dVecVecArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.DPoint3dVecVecArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.DPoint3dVecVecArray, i: int, x: MSPyBentleyGeom.DPoint3dVecArray) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.DPoint3dVecVecArray) -> MSPyBentleyGeom.DPoint3dVecArray
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.DPoint3dVecVecArray, i: int) -> MSPyBentleyGeom.DPoint3dVecArray
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(*args, **kwargs):
        """
        remove(self: MSPyBentleyGeom.DPoint3dVecVecArray, x: MSPyBentleyGeom.DPoint3dVecArray) -> None
        
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class DPoint4d:
    """
    None
    """

    def Add(*args, **kwargs):
        """
        Add(self: MSPyBentleyGeom.DPoint4d, vector: MSPyBentleyGeom.DPoint4d) -> None
        
        Add a vector to the instance.
        
        Parameter ``[in]``:
        vector vector to add
        """
        ...
    
    def AlmostEqual(*args, **kwargs):
        """
        AlmostEqual(dataA: MSPyBentleyGeom.DPoint4dArray, dataB: MSPyBentleyGeom.DPoint4dArray, xyzTol: float, wTol: float) -> bool
        
        test for nearly equal points in two arrays
        """
        ...
    
    def AlmostEqualReversed(*args, **kwargs):
        """
        AlmostEqualReversed(dataA: MSPyBentleyGeom.DPoint4dArray, dataB: MSPyBentleyGeom.DPoint4dArray, xyzTol: float, wTol: float) -> bool
        
        test for nearly equal points in two arrays, reversing the second
        """
        ...
    
    def DifferenceOf(*args, **kwargs):
        """
        DifferenceOf(self: MSPyBentleyGeom.DPoint4d, point1: MSPyBentleyGeom.DPoint4d, point2: MSPyBentleyGeom.DPoint4d) -> None
        
        Subtract second point from first.
        
        Parameter ``[in]``:
        point1 first point
        
        Parameter ``[in]``:
        point2 second point
        """
        ...
    
    def DotProduct(*args, **kwargs):
        """
        DotProduct(*args, **kwargs)
        Overloaded function.
        
        1. DotProduct(self: MSPyBentleyGeom.DPoint4d, point: MSPyBentleyGeom.DPoint4d) -> float
        
        Return the full 4d (xyzw) dot product of two homogeneous points.
        
        Parameter ``[in]``:
        point second point of dot product.
        
        Returns:
        dot product of two homogeneous points.
        
        2. DotProduct(self: MSPyBentleyGeom.DPoint4d, x: float, y: float, z: float, w: float) -> float
        
        Return the full 4d (xyzw) dot product of two homogeneous points.
        
        Parameter ``[in]``:
        point second point of dot product.
        
        Returns:
        dot product of two homogeneous points.
        
        3. DotProduct(self: MSPyBentleyGeom.DPoint4d, point2: MSPyBentleyGeom.DPoint3d, w: float) -> float
        
        Return the full 4d (xyzw) dot product of two homogeneous points.
        
        Parameter ``[in]``:
        point second point of dot product.
        
        Returns:
        dot product of two homogeneous points.
        """
        ...
    
    def DotProductXY(*args, **kwargs):
        """
        DotProductXY(self: MSPyBentleyGeom.DPoint4d, point: MSPyBentleyGeom.DPoint4d) -> float
        
        Return the dot product of only the xy parts of two homogeneous points.
        Ignore z, ignore w.
        
        Parameter ``[in]``:
        point second point
        
        Returns:
        dot product of two homogeneous points.
        """
        ...
    
    def DotProductXYW(*args, **kwargs):
        """
        DotProductXYW(self: MSPyBentleyGeom.DPoint4d, point: MSPyBentleyGeom.DPoint4d) -> float
        
        Return the xyz dot product of two homogeneous points, i.e. ignore z.
        
        Parameter ``[in]``:
        point second second
        
        Returns:
        dot product of two homogeneous points.
        """
        ...
    
    def DotProductXYZ(*args, **kwargs):
        """
        DotProductXYZ(self: MSPyBentleyGeom.DPoint4d, point: MSPyBentleyGeom.DPoint4d) -> float
        
        Return the xyz dot product of two homogeneous points, i.e. ignore w.
        
        Parameter ``[in]``:
        point2 second point of dot product.
        
        Returns:
        dot product of two homogeneous points.
        """
        ...
    
    def EyePlaneTest(*args, **kwargs):
        """
        EyePlaneTest(self: MSPyBentleyGeom.DPoint4d, origin: MSPyBentleyGeom.DPoint3d, normal: MSPyBentleyGeom.DPoint3d) -> float
        
        Return the dot product of a plane normal and a vector 'to the
        eyepoint'. The plane is given as cartesian origin and normal; the eye
        is given as homogeneous point, i.e. weight zero for flat view, nonzero
        for perspective. Eyepoints constucted 'by hand' usually look like
        this:Flat view " from infinity " looking in direction (xyz):eyepoint =
        (x,y,z,0) i.e. a top view has eyepoint (0,0,1,0) Perspective from
        eyepoint at (x,y,z):eyepoint (x,y,z,1) When viewing is constructed by
        a sequence of homogeneous transformations, with the final (device)
        projection to the xy plane, the (pretransform) eyepoint is 'by
        definition' Tinverse * (0,0,1,0)' i.e column 2 (zero based) of the
        composite viewing transform. (Note that the weight part can be
        nonzero.)
        
        Parameter ``[in]``:
        origin any cartesian point on plane
        
        Parameter ``[in]``:
        normal cartesian plane normal
        
        Returns:
        dot product of plane normal with vector towards eye.
        """
        ...
    
    def From(*args, **kwargs):
        """
        From(*args, **kwargs)
        Overloaded function.
        
        1. From(x: float, y: float, z: float, w: float) -> MSPyBentleyGeom.DPoint4d
        
        Return point with direct initialization
        
        Parameter ``[in]``:
        x x coordinate
        
        Parameter ``[in]``:
        y y coordinate
        
        Parameter ``[in]``:
        z z coordinate
        
        Parameter ``[in]``:
        w w coordinate
        
        2. From(xyz: MSPyBentleyGeom.DPoint3d, w: float) -> MSPyBentleyGeom.DPoint4d
        
        Return point with direct initialization
        
        Parameter ``[in]``:
        x x coordinate
        
        Parameter ``[in]``:
        y y coordinate
        
        Parameter ``[in]``:
        z z coordinate
        
        Parameter ``[in]``:
        w w coordinate
        """
        ...
    
    def FromCrossProduct(*args, **kwargs):
        """
        FromCrossProduct(pointA: MSPyBentleyGeom.DPoint4d, pointB: MSPyBentleyGeom.DPoint4d, pointC: MSPyBentleyGeom.DPoint4d) -> MSPyBentleyGeom.DPoint4d
        
        Return a point " perpendicular " to all 3 inputs.
        """
        ...
    
    def FromInterpolate(*args, **kwargs):
        """
        FromInterpolate(point0: MSPyBentleyGeom.DPoint4d, s: float, point1: MSPyBentleyGeom.DPoint4d) -> MSPyBentleyGeom.DPoint4d
        
        Interpolates between two homogeneous vectors. |
        
        Parameter ``[in]``:
        point0 s=0 point
        
        Parameter ``[in]``:
        s interpolation parameter
        
        Parameter ``[in]``:
        point1 s=1 point
        
        Returns:
        interpolated point
        """
        ...
    
    def FromMultiply(*args, **kwargs):
        """
        FromMultiply(*args, **kwargs)
        Overloaded function.
        
        1. FromMultiply(matrix: MSPyBentleyGeom.DMatrix4d, point: MSPyBentleyGeom.DPoint3d) -> MSPyBentleyGeom.DPoint4d
        
        Return product of 3d point with (possibly omitted) DMatrix4d
        
        Parameter ``[in]``:
        matrix if missing, identity matrix is implied.
        
        Parameter ``[in]``:
        point 3d point.
        
        2. FromMultiply(matrix: MSPyBentleyGeom.DMatrix4d, point: MSPyBentleyGeom.DPoint4d) -> MSPyBentleyGeom.DPoint4d
        
        Return product of 3d point with (possibly omitted) DMatrix4d
        
        Parameter ``[in]``:
        matrix if missing, identity matrix is implied.
        
        Parameter ``[in]``:
        point 3d point.
        """
        ...
    
    def FromSumOf(*args, **kwargs):
        """
        FromSumOf(xyzw0: MSPyBentleyGeom.DPoint4d, scale0: float, xyzw1: MSPyBentleyGeom.DPoint4d, scale1: float, xyzw2: MSPyBentleyGeom.DPoint4d, scale2: float) -> MSPyBentleyGeom.DPoint4d
        
        Return point with sum of scaled inputs
        """
        ...
    
    def GetComponent(*args, **kwargs):
        """
        GetComponent(self: MSPyBentleyGeom.DPoint4d, index: int) -> float
        
        Parameter ``[in]``:
        index 0=x, 1=y, 2=z, 3=w, others cyclic
        
        Returns:
        specified component of the point or vector
        """
        ...
    
    def GetComponents(*args, **kwargs):
        """
        GetComponents(self: MSPyBentleyGeom.DPoint4d) -> tuple
        
        Copies component data out of this instance into doubles pXCoord,
        pYCoord, pZCoord and pWCoord.
        
        Parameter ``[out]``:
        xCoord x component
        
        Parameter ``[out]``:
        yCoord y component
        
        Parameter ``[out]``:
        zCoord z component
        
        Parameter ``[out]``:
        wCoord w component
        """
        ...
    
    def GetProjectedXYZ(*args, **kwargs):
        """
        GetProjectedXYZ(self: MSPyBentleyGeom.DPoint4d, rPoint: MSPyBentleyGeom.DPoint3d) -> bool
        
        Normalizes a homogeneous point (by dividing by w part.)
        
        Parameter ``[out]``:
        rPoint normalized point
        
        Returns:
        true if normalization succeeded
        """
        ...
    
    def GetRotationAngleAndVectorFromQuaternion(*args, **kwargs):
        """
        GetRotationAngleAndVectorFromQuaternion(self: MSPyBentleyGeom.DPoint4d, axis: MSPyBentleyGeom.DPoint3d) -> float
        
        Returns the angle of rotation represented by this instance quaternion
        and sets axis to be the normalized vector about which this instance
        rotates. The instance is assumed to be a normalized quaternion, i.e.
        of the form (x,y,z,w) where
        
        x*x + y*y + z*z + w*w = 1.
        
        The angle is returned within the closed interval [0,Pi].
        
        Parameter ``[out]``:
        axis normalized axis of rotation
        
        Returns:
        rotation angle (in radians) between 0 and Pi, inclusive
        """
        ...
    
    def GetXYW(*args, **kwargs):
        """
        GetXYW(self: MSPyBentleyGeom.DPoint4d, point: MSPyBentleyGeom.DPoint3d) -> None
        
        Copy the xyw components out of a homogeneous point. The z component
        not referenced. This is a copy, not a normalization.
        
        Parameter ``[out]``:
        point xyw parts copied to xyz
        """
        ...
    
    def GetXYZ(*args, **kwargs):
        """
        GetXYZ(*args, **kwargs)
        Overloaded function.
        
        1. GetXYZ(self: MSPyBentleyGeom.DPoint4d, point: MSPyBentleyGeom.DPoint3d) -> None
        
        Copy the xyz components out of a homogeneous point. The weight is not
        referenced, i.e. the xyz components are NOT normalized.
        
        Parameter ``[out]``:
        point cartesian point
        
        2. GetXYZ(self: MSPyBentleyGeom.DPoint4d, point: MSPyBentleyGeom.DPoint3d, xIndex: int, yIndex: int, zIndex: int) -> None
        
        Copy the xyz components out of a homogeneous point. The weight is not
        referenced, i.e. the xyz components are NOT normalized.
        
        Parameter ``[out]``:
        point cartesian point
        """
        ...
    
    def Init(*args, **kwargs):
        """
        Init(*args, **kwargs)
        Overloaded function.
        
        1. Init(self: MSPyBentleyGeom.DPoint4d, source: MSPyBentleyGeom.DPoint3d, w: float) -> None
        
        Fill a DPoint4d, using given xyz components and weight. All components
        are copied in directly -- the xyz components are not multiplied by the
        weight.
        
        Parameter ``[in]``:
        source xyz components
        
        Parameter ``[in]``:
        w w component
        
        2. Init(self: MSPyBentleyGeom.DPoint4d, x: float, y: float, z: float, w: float) -> None
        
        Fill a DPoint4d, using given xyz components and weight. All components
        are copied in directly -- the xyz components are not multiplied by the
        weight.
        
        Parameter ``[in]``:
        source xyz components
        
        Parameter ``[in]``:
        w w component
        """
        ...
    
    def InitDisconnect(*args, **kwargs):
        """
        InitDisconnect(self: MSPyBentleyGeom.DPoint4d) -> None
        
        Initialize a point with all coordinates as the disconnect value.
        """
        ...
    
    def InitFrom(*args, **kwargs):
        """
        InitFrom(self: MSPyBentleyGeom.DPoint4d, point: MSPyBentleyGeom.DPoint3d, w: float) -> None
        
        Initializ a homogeneous point from a 3D point and separate weight.
        NOTE The xyz components copied unchanged, i.e. not multiplied by the
        weight.
        
        Parameter ``[in]``:
        point cartesian point
        
        Parameter ``[in]``:
        w weight component
        """
        ...
    
    def InitWithNormalizedWeight(*args, **kwargs):
        """
        InitWithNormalizedWeight(self: MSPyBentleyGeom.DPoint4d, source: MSPyBentleyGeom.DPoint4d) -> bool
        
        Initializes the instance by normalizing the weight of the source.
        
        Returns:
        true if normalization succeeded
        """
        ...
    
    def Interpolate(*args, **kwargs):
        """
        Interpolate(self: MSPyBentleyGeom.DPoint4d, point0: MSPyBentleyGeom.DPoint4d, s: float, point1: MSPyBentleyGeom.DPoint4d) -> None
        
        Interpolates between two homogeneous vectors. |
        
        Parameter ``[in]``:
        point0 s=0 point
        
        Parameter ``[in]``:
        s interpolation parameter
        
        Parameter ``[in]``:
        point1 s=1 point
        """
        ...
    
    def IsDisconnect(*args, **kwargs):
        """
        IsDisconnect(self: MSPyBentleyGeom.DPoint4d) -> bool
        
        Returns:
        true if the point has coordinates which indicate it is a
        disconnect (separator) ponit.
        """
        ...
    
    def IsEqual(*args, **kwargs):
        """
        IsEqual(*args, **kwargs)
        Overloaded function.
        
        1. IsEqual(self: MSPyBentleyGeom.DPoint4d, vec2: MSPyBentleyGeom.DPoint4d) -> bool
        
        Exact equality test between points. (Also see method with same name
        but added tolerance argument.)
        
        Parameter ``[in]``:
        vec2 vector
        
        Returns:
        true if the points are identical. (DPoint4dCR, double)
        
        2. IsEqual(self: MSPyBentleyGeom.DPoint4d, vec2: MSPyBentleyGeom.DPoint4d, tolerance: float) -> bool
        
        Exact equality test between points. (Also see method with same name
        but added tolerance argument.)
        
        Parameter ``[in]``:
        vec2 vector
        
        Returns:
        true if the points are identical. (DPoint4dCR, double)
        
        3. IsEqual(self: MSPyBentleyGeom.DPoint4d, vec2: MSPyBentleyGeom.DPoint4d, xyzTol: float, wTol: float) -> bool
        
        Exact equality test between points. (Also see method with same name
        but added tolerance argument.)
        
        Parameter ``[in]``:
        vec2 vector
        
        Returns:
        true if the points are identical. (DPoint4dCR, double)
        """
        ...
    
    def MagnitudeXYZW(*args, **kwargs):
        """
        MagnitudeXYZW(self: MSPyBentleyGeom.DPoint4d) -> float
        
        magnitude as pure 4d point -- sqrt sum of squares.
        """
        ...
    
    def MaxAbs(*args, **kwargs):
        """
        MaxAbs(self: MSPyBentleyGeom.DPoint4d) -> float
        
        Returns:
        largest absoluted value among point coordinates.
        """
        ...
    
    def MaxAbsUnnormalizedXYZ(*args, **kwargs):
        """
        MaxAbsUnnormalizedXYZ(self: MSPyBentleyGeom.DPoint4d) -> float
        
        Returns:
        largest absoluted value among xyz coordinates, ignoring weight.
        """
        ...
    
    def MaxUnnormalizedXYZDiff(*args, **kwargs):
        """
        MaxUnnormalizedXYZDiff(self: MSPyBentleyGeom.DPoint4d, other: MSPyBentleyGeom.DPoint4d) -> float
        
        Returns:
        largest absoluted value among xyz coordinates coordinates,
        ignoring weight.
        """
        ...
    
    def Negate(*args, **kwargs):
        """
        Negate(*args, **kwargs)
        Overloaded function.
        
        1. Negate(self: MSPyBentleyGeom.DPoint4d, point: MSPyBentleyGeom.DPoint4d) -> None
        
        Negate a point.
        
        Parameter ``[in]``:
        point input point
        
        2. Negate(self: MSPyBentleyGeom.DPoint4d) -> None
        
        Negate a point.
        
        Parameter ``[in]``:
        point input point
        """
        ...
    
    def NormalizePlaneOf(*args, **kwargs):
        """
        NormalizePlaneOf(self: MSPyBentleyGeom.DPoint4d, plane0: MSPyBentleyGeom.DPoint4d) -> bool
        
        Normalizes a homogeneous plane (by dividing through by the vector
        magnitude).
        
        Parameter ``[in]``:
        plane0 homogeneous plane
        
        Returns:
        true unless normal is zero vector.
        """
        ...
    
    def NormalizeWeightInPlace(*args, **kwargs):
        """
        NormalizeWeightInPlace(self: MSPyBentleyGeom.DPoint4d) -> bool
        
        Divide through by weight component.
        
        Returns:
        true if normalization succeeded
        """
        ...
    
    def OriginAndNormalFromPlane(*args, **kwargs):
        """
        OriginAndNormalFromPlane(self: MSPyBentleyGeom.DPoint4d, origin: MSPyBentleyGeom.DPoint3d, normal: MSPyBentleyGeom.DPoint3d) -> bool
        
        Parameter ``[out]``:
        origin cartesian orign
        
        Parameter ``[out]``:
        normal cartesian normal
        
        Returns:
        true if
        """
        ...
    
    def PlaneFrom3Points(*args, **kwargs):
        """
        PlaneFrom3Points(self: MSPyBentleyGeom.DPoint4d, origin: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d) -> bool
        
        Computes the homogeneous coordinate vector for a plane defined by 3 3D
        points.
        
        Parameter ``[out]``:
        origin origin point
        
        Parameter ``[out]``:
        point1 another point on plane
        
        Parameter ``[out]``:
        point2 another point on plane
        
        Returns:
        true if normal is well defined.
        """
        ...
    
    def PlaneFromOriginAndNormal(*args, **kwargs):
        """
        PlaneFromOriginAndNormal(self: MSPyBentleyGeom.DPoint4d, origin: MSPyBentleyGeom.DPoint3d, normal: MSPyBentleyGeom.DPoint3d) -> bool
        
        Computes the homogeneous vector for a plane defined by 3D origin and
        normal. NOTE If the normal vector is null, a 0000 vector is returned.
        
        Parameter ``[out]``:
        origin origin point
        
        Parameter ``[out]``:
        normal normal vector
        
        Returns:
        true unless normal is null
        """
        ...
    
    def PlaneFromOriginAndVectors(*args, **kwargs):
        """
        PlaneFromOriginAndVectors(self: MSPyBentleyGeom.DPoint4d, origin: MSPyBentleyGeom.DPoint4d, vector0: MSPyBentleyGeom.DPoint3d, vector1: MSPyBentleyGeom.DPoint3d) -> bool
        
        Computes the homogeneous coordinate vector for a plane defined by a
        DPoint4d origin and a pair of 3D vectors.
        
        Parameter ``[out]``:
        origin a point on the plane.
        
        Parameter ``[out]``:
        vector0 a vector in the plane.
        
        Parameter ``[out]``:
        vector1 another vector in the plane.
        
        Returns:
        false if origin, vectors are not independent.
        """
        ...
    
    def RealDistance(*args, **kwargs):
        """
        RealDistance(self: MSPyBentleyGeom.DPoint4d, vec2: MSPyBentleyGeom.DPoint4d) -> float
        
        Parameter ``[in]``:
        vec2 second point
        
        Returns:
        distance between projections of two homnogeneous points.
        """
        ...
    
    def RealDistanceSquared(*args, **kwargs):
        """
        RealDistanceSquared(*args, **kwargs)
        Overloaded function.
        
        1. RealDistanceSquared(self: MSPyBentleyGeom.DPoint4d, vec2: MSPyBentleyGeom.DPoint3d) -> tuple
        
        Parameter ``[out]``:
        pDistanceSquared squared distance
        
        Parameter ``[in]``:
        vec2 second point
        
        Returns:
        true iff the homogeneous point was properly normalized.
        
        2. RealDistanceSquared(self: MSPyBentleyGeom.DPoint4d, vec2: MSPyBentleyGeom.DPoint4d) -> tuple
        
        Parameter ``[out]``:
        pDistanceSquared squared distance
        
        Parameter ``[in]``:
        vec2 second point
        
        Returns:
        true iff the homogeneous point was properly normalized.
        """
        ...
    
    def RealDistanceSquaredXY(*args, **kwargs):
        """
        RealDistanceSquaredXY(self: MSPyBentleyGeom.DPoint4d, vec2: MSPyBentleyGeom.DPoint3d) -> tuple
        
        Parameter ``[out]``:
        pDistanceSquared squared distance
        
        Parameter ``[in]``:
        vec2 second point
        
        Returns:
        true iff the homogeneous point was properly normalized.
        """
        ...
    
    def RealDistanceXY(*args, **kwargs):
        """
        RealDistanceXY(self: MSPyBentleyGeom.DPoint4d, vec2: MSPyBentleyGeom.DPoint4d) -> tuple
        
        Parameter ``[out]``:
        distance distance between xy parts
        
        Parameter ``[in]``:
        pointB other point.
        
        Returns:
        true iff the homogeneous points could be normalized
        """
        ...
    
    def Scale(*args, **kwargs):
        """
        Scale(*args, **kwargs)
        Overloaded function.
        
        1. Scale(self: MSPyBentleyGeom.DPoint4d, point: MSPyBentleyGeom.DPoint4d, scale: float) -> None
        
        sets pOutVec to pInVec*scale.
        
        Parameter ``[in]``:
        point input vector
        
        Parameter ``[in]``:
        scale scale
        
        2. Scale(self: MSPyBentleyGeom.DPoint4d, scale: float) -> None
        
        sets pOutVec to pInVec*scale.
        
        Parameter ``[in]``:
        point input vector
        
        Parameter ``[in]``:
        scale scale
        """
        ...
    
    def SetComponent(*args, **kwargs):
        """
        SetComponent(self: MSPyBentleyGeom.DPoint4d, a: float, index: int) -> None
        
        Set x,y,z or w component of a point.
        
        Parameter ``[in]``:
        a component value
        
        Parameter ``[in]``:
        index 0=x, 1=y, 2=z, 3=w, others cyclic
        """
        ...
    
    def SetComponents(*args, **kwargs):
        """
        SetComponents(self: MSPyBentleyGeom.DPoint4d, xComponent: float, yComponent: float, zComponent: float, wComponent: float) -> None
        
        Parameter ``[in]``:
        xComponent x component
        
        Parameter ``[in]``:
        yComponent y component
        
        Parameter ``[in]``:
        zComponent z component
        
        Parameter ``[in]``:
        wComponent w component
        """
        ...
    
    def Subtract(*args, **kwargs):
        """
        Subtract(self: MSPyBentleyGeom.DPoint4d, vector: MSPyBentleyGeom.DPoint4d) -> None
        
        Subtract a vector from the instance.
        
        Parameter ``[in]``:
        vector vector to subtract
        """
        ...
    
    def SumOf(*args, **kwargs):
        """
        SumOf(*args, **kwargs)
        Overloaded function.
        
        1. SumOf(self: MSPyBentleyGeom.DPoint4d, pt1: MSPyBentleyGeom.DPoint4d, pt2: MSPyBentleyGeom.DPoint4d) -> None
        
        Adds two homogeneous points.
        
        Parameter ``[in]``:
        pt1 point 1
        
        Parameter ``[in]``:
        pt2 point 2
        
        2. SumOf(self: MSPyBentleyGeom.DPoint4d, point0: MSPyBentleyGeom.DPoint4d, point1: MSPyBentleyGeom.DPoint4d, scale1: float) -> None
        
        Adds two homogeneous points.
        
        Parameter ``[in]``:
        pt1 point 1
        
        Parameter ``[in]``:
        pt2 point 2
        
        3. SumOf(self: MSPyBentleyGeom.DPoint4d, point0: MSPyBentleyGeom.DPoint4d, point1: MSPyBentleyGeom.DPoint4d, scale1: float, point2: MSPyBentleyGeom.DPoint4d, scale2: float) -> None
        
        Adds two homogeneous points.
        
        Parameter ``[in]``:
        pt1 point 1
        
        Parameter ``[in]``:
        pt2 point 2
        
        4. SumOf(self: MSPyBentleyGeom.DPoint4d, point0: MSPyBentleyGeom.DPoint4d, point1: MSPyBentleyGeom.DPoint4d, scale1: float, point2: MSPyBentleyGeom.DPoint4d, scale2: float, point3: MSPyBentleyGeom.DPoint4d, scale3: float) -> None
        
        Adds two homogeneous points.
        
        Parameter ``[in]``:
        pt1 point 1
        
        Parameter ``[in]``:
        pt2 point 2
        
        5. SumOf(self: MSPyBentleyGeom.DPoint4d, point1: MSPyBentleyGeom.DPoint4d, scale1: float, point2: MSPyBentleyGeom.DPoint4d, scale2: float) -> None
        
        Adds two homogeneous points.
        
        Parameter ``[in]``:
        pt1 point 1
        
        Parameter ``[in]``:
        pt2 point 2
        
        6. SumOf(self: MSPyBentleyGeom.DPoint4d, point1: MSPyBentleyGeom.DPoint4d, scale1: float, point2: MSPyBentleyGeom.DPoint4d, scale2: float, point3: MSPyBentleyGeom.DPoint4d, scale3: float) -> None
        
        Adds two homogeneous points.
        
        Parameter ``[in]``:
        pt1 point 1
        
        Parameter ``[in]``:
        pt2 point 2
        """
        ...
    
    def TryNormalizePointAndDerivatives(*args, **kwargs):
        """
        TryNormalizePointAndDerivatives(homogeneousPoint: MSPyBentleyGeom.DPoint4d, homogeneousDerivative1: MSPyBentleyGeom.DPoint4d, homogeneousDerivative2: MSPyBentleyGeom.DPoint4d) -> Bentley.ValidatedValue<Bentley.DPlane3dByVectors>
        
        Return point and vectors that are the cartesian image of a homoegneous
        point and derivatives ul> li>The return is marked invalid if weight is
        zero. ul>
        
        Returns:
        origin and vectors after normalization.
        """
        ...
    
    def WeightedDifferenceOf(*args, **kwargs):
        """
        WeightedDifferenceOf(*args, **kwargs)
        Overloaded function.
        
        1. WeightedDifferenceOf(self: MSPyBentleyGeom.DPoint4d, A: MSPyBentleyGeom.DPoint4d, B: MSPyBentleyGeom.DPoint4d) -> None
        
        Scale each point by the other's weight and return the difference
        
        2. WeightedDifferenceOf(self: MSPyBentleyGeom.DPoint4d, A: MSPyBentleyGeom.DPoint4d, B: MSPyBentleyGeom.DPoint3d, wB: float) -> None
        
        Scale each point by the other's weight and return the difference
        
        3. WeightedDifferenceOf(self: MSPyBentleyGeom.DPoint4d, A: MSPyBentleyGeom.DPoint3d, wA: float, B: MSPyBentleyGeom.DPoint4d) -> None
        
        Scale each point by the other's weight and return the difference
        """
        ...
    
    def Zero(*args, **kwargs):
        """
        Zero(self: MSPyBentleyGeom.DPoint4d) -> None
        
        zero out this point.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DPoint4d, x: float, y: float, z: float, w: float) -> None
        
        2. __init__(self: MSPyBentleyGeom.DPoint4d, xyz: MSPyBentleyGeom.DPoint3d, w: float) -> None
        """
        ...
    
    @property
    def w(self: MSPyBentleyGeom.DPoint4d) -> float:
        ...
    @w.setter
    def w(self: MSPyBentleyGeom.DPoint4d, arg0: float) -> None:
        ...
    
    @property
    def x(self: MSPyBentleyGeom.DPoint4d) -> float:
        ...
    @x.setter
    def x(self: MSPyBentleyGeom.DPoint4d, arg0: float) -> None:
        ...
    
    @property
    def y(self: MSPyBentleyGeom.DPoint4d) -> float:
        ...
    @y.setter
    def y(self: MSPyBentleyGeom.DPoint4d, arg0: float) -> None:
        ...
    
    @property
    def z(self: MSPyBentleyGeom.DPoint4d) -> float:
        ...
    @z.setter
    def z(self: MSPyBentleyGeom.DPoint4d, arg0: float) -> None:
        ...
    
class DPoint4dArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DPoint4dArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.DPoint4dArray, arg0: MSPyBentleyGeom.DPoint4dArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.DPoint4dArray, arg0: Iterable) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.DPoint4dArray, x: MSPyBentleyGeom.DPoint4d) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.DPoint4dArray) -> None
        
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.DPoint4dArray, L: MSPyBentleyGeom.DPoint4dArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.DPoint4dArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.DPoint4dArray, i: int, x: MSPyBentleyGeom.DPoint4d) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.DPoint4dArray) -> MSPyBentleyGeom.DPoint4d
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.DPoint4dArray, i: int) -> MSPyBentleyGeom.DPoint4d
        
        Remove and return the item at index ``i``
        """
        ...
    
class DRange1d:
    """
    None
    """

    def AppendClips(*args, **kwargs):
        """
        AppendClips(dataA: MSPyBentleyGeom.DRange1dArray, clipper: MSPyBentleyGeom.DRange1d, dataOut: MSPyBentleyGeom.DRange1dArray) -> None
        
        Intersect each range in dataA with clipper. Append non-
        empty results to dataOut. Note that if the same array is passed for
        dataA and dataOut, all input contents will remain. (Use{ClipInPlace}
        to get compaction)
        """
        ...
    
    def ClipInPlace(*args, **kwargs):
        """
        ClipInPlace(dataA: MSPyBentleyGeom.DRange1dArray, clipper: MSPyBentleyGeom.DRange1d) -> None
        
        Intersect each range in dataA with clipper. Retain non-
        empty result parts.
        """
        ...
    
    def Contains(*args, **kwargs):
        """
        Contains(self: MSPyBentleyGeom.DRange1d, a: float) -> bool
        
        Test if the range contains a given value.
        """
        ...
    
    def DifferenceSorted(*args, **kwargs):
        """
        DifferenceSorted(dataA: MSPyBentleyGeom.DRange1dArray, dataB: MSPyBentleyGeom.DRange1dArray, dataOut: MSPyBentleyGeom.DRange1dArray) -> None
        
        Intersect intervals in two pre-sorted sets. Output may
        NOT be the same as either input.
        """
        ...
    
    def DoubleToFraction(*args, **kwargs):
        """
        DoubleToFraction(self: MSPyBentleyGeom.DRange1d, x: float, defaultReturnX: float = 0.0) -> tuple
        
        map real to fraction. Returns false if null range or
        single point.
        """
        ...
    
    def Extend(*args, **kwargs):
        """
        Extend(*args, **kwargs)
        Overloaded function.
        
        1. Extend(self: MSPyBentleyGeom.DRange1d, valueA: float) -> None
        
        Extend to include a value.
        
        2. Extend(self: MSPyBentleyGeom.DRange1d, valueA: float, valueB: float) -> None
        
        Extend to include a value.
        
        3. Extend(self: MSPyBentleyGeom.DRange1d, values: MSPyBentley.DoubleArray) -> None
        
        Extend to include a value.
        
        4. Extend(self: MSPyBentleyGeom.DRange1d, other: MSPyBentleyGeom.DRange1d) -> None
        
        Extend to include a value.
        """
        ...
    
    def ExtendBySignedShift(*args, **kwargs):
        """
        ExtendBySignedShift(self: MSPyBentleyGeom.DRange1d, tol: float) -> None
        
        If non empty, shift endpoints by (-tol, +tol). No change if empty !!!
        """
        ...
    
    def FractionToDouble(*args, **kwargs):
        """
        FractionToDouble(self: MSPyBentleyGeom.DRange1d, fraction: float, defaultReturnX: float = 0.0) -> tuple
        
        map fractional coordinate to real. Returns false if null
        range.
        """
        ...
    
    def From(*args, **kwargs):
        """
        From(*args, **kwargs)
        Overloaded function.
        
        1. From(value: float) -> MSPyBentleyGeom.DRange1d
        
        Return a range containing a single value.
        
        2. From(valueA: float, valueB: float) -> MSPyBentleyGeom.DRange1d
        
        Return a range containing a single value.
        
        3. From(valueA: float, valueB: float, valueC: float) -> MSPyBentleyGeom.DRange1d
        
        Return a range containing a single value.
        
        4. From(arg0: List[float]) -> MSPyBentleyGeom.DRange1d
        """
        ...
    
    def FromAltitudes(*args, **kwargs):
        """
        FromAltitudes(points: MSPyBentleyGeom.DPoint3dArray, plane: MSPyBentleyGeom.DPlane3d) -> MSPyBentleyGeom.DRange1d
        
        Return a (sorted) range of altitudes of points.
        """
        ...
    
    def FromExtent(*args, **kwargs):
        """
        FromExtent(data: MSPyBentleyGeom.DRange1dArray) -> MSPyBentleyGeom.DRange1d
        
        Return the encompassing single range.
        """
        ...
    
    def FromIntersection(*args, **kwargs):
        """
        FromIntersection(*args, **kwargs)
        Overloaded function.
        
        1. FromIntersection(rangeA: MSPyBentleyGeom.DRange1d, rangeB: MSPyBentleyGeom.DRange1d) -> MSPyBentleyGeom.DRange1d
        
        return the (possibly null) intersection of two ranges.
        
        2. FromIntersection(data: MSPyBentleyGeom.DRange1dArray) -> MSPyBentleyGeom.DRange1d
        
        return the (possibly null) intersection of two ranges.
        """
        ...
    
    def FromLowHigh(*args, **kwargs):
        """
        FromLowHigh(low: float, high: float) -> MSPyBentleyGeom.DRange1d
        
        Return a range with explicit (possibly reversed) low and
        high.
        """
        ...
    
    def FromUnion(*args, **kwargs):
        """
        FromUnion(rangeA: MSPyBentleyGeom.DRange1d, rangeB: MSPyBentleyGeom.DRange1d) -> MSPyBentleyGeom.DRange1d
        
        return the (possibly null) union of two ranges.
        """
        ...
    
    def GetTolerance(*args, **kwargs):
        """
        GetTolerance(self: MSPyBentleyGeom.DRange1d, absTol: float = 1e-14, localRelTol: float = 1e-14, globalRelTol: float = 0.0) -> float
        
        return a tolerance computed as{absTol + localRelTol *
        Extent() + globalRelTol * MaxAbs ()}
        """
        ...
    
    def HasNonEmptyIntersectionWith(*args, **kwargs):
        """
        HasNonEmptyIntersectionWith(self: MSPyBentleyGeom.DRange1d, other: MSPyBentleyGeom.DRange1d) -> bool
        
        Test if the instance range is a (possibly complete, but
        not empty) subset of{other} range.
        """
        ...
    
    def HasPositiveLengthIntersectionWith(*args, **kwargs):
        """
        HasPositiveLengthIntersectionWith(self: MSPyBentleyGeom.DRange1d, other: MSPyBentleyGeom.DRange1d) -> bool
        
        Test if the instance range has a positive-length (more
        than single point) intersection with{other}.
        """
        ...
    
    def High(*args, **kwargs):
        """
        High(self: MSPyBentleyGeom.DRange1d) -> float
        
        Get the low limit (unchecked).
        """
        ...
    
    def InfiniteRange(*args, **kwargs):
        """
        InfiniteRange() -> MSPyBentleyGeom.DRange1d
        
        Return a complete range (-DBL_MAX to DBL_MAX)
        """
        ...
    
    def InitNull(*args, **kwargs):
        """
        InitNull(self: MSPyBentleyGeom.DRange1d) -> None
        
        Set this range to the{NullRange}
        """
        ...
    
    def IntersectInPlace(*args, **kwargs):
        """
        IntersectInPlace(self: MSPyBentleyGeom.DRange1d, other: MSPyBentleyGeom.DRange1d) -> None
        
        Restrict to overlap with another (possibly null!!) range.
        """
        ...
    
    def IntersectSorted(*args, **kwargs):
        """
        IntersectSorted(dataA: MSPyBentleyGeom.DRange1dArray, dataB: MSPyBentleyGeom.DRange1dArray, dataOut: MSPyBentleyGeom.DRange1dArray) -> None
        
        Intersect intervals in two pre-sorted sets. Output may
        NOT be the same as either input.
        """
        ...
    
    def IsDoublyInfinite(*args, **kwargs):
        """
        IsDoublyInfinite(self: MSPyBentleyGeom.DRange1d) -> bool
        
        Test if the range has the most negative{low} and most
        positive{high}
        """
        ...
    
    def IsEmpty(*args, **kwargs):
        """
        IsEmpty(self: MSPyBentleyGeom.DRange1d) -> bool
        
        Test if the range has{low> high}, i.e. there are no x
        for which{low &le x && x &le high}
        """
        ...
    
    def IsEmptyOrSinglePoint(*args, **kwargs):
        """
        IsEmptyOrSinglePoint(self: MSPyBentleyGeom.DRange1d) -> bool
        
        Test if the range has{high >= low}, i.e. is empty or
        just one point.
        """
        ...
    
    def IsEqualInterval(*args, **kwargs):
        """
        IsEqualInterval(self: MSPyBentleyGeom.DRange1d, other: MSPyBentleyGeom.DRange1d) -> bool
        
        Test if equal intervals in point set sense. Any pair of
        empty intervals (even if different low and high) are equal.
        """
        ...
    
    def IsEqualLowHigh(*args, **kwargs):
        """
        IsEqualLowHigh(self: MSPyBentleyGeom.DRange1d, other: MSPyBentleyGeom.DRange1d) -> bool
        
        Direct equality test for low and high parts.
        """
        ...
    
    def IsIncreasing(*args, **kwargs):
        """
        IsIncreasing(data: MSPyBentleyGeom.DRange1dArray, allowZeroLength: bool = False, allowZeroGaps: bool = False) -> bool
        
        Test for increasing relationships, optionally allowing
        zero length.
        """
        ...
    
    def IsInfiniteNegative(*args, **kwargs):
        """
        IsInfiniteNegative(self: MSPyBentleyGeom.DRange1d) -> bool
        
        Test if the range has the most negative possible{low}
        """
        ...
    
    def IsInfinitePositive(*args, **kwargs):
        """
        IsInfinitePositive(self: MSPyBentleyGeom.DRange1d) -> bool
        
        Test if the range has the largest possible{high}
        """
        ...
    
    def IsNull(*args, **kwargs):
        """
        IsNull(self: MSPyBentleyGeom.DRange1d) -> bool
        
        Test if the range is exactly the same as the null ranges
        returned by NullRange ().
        """
        ...
    
    def IsPositiveLength(*args, **kwargs):
        """
        IsPositiveLength(self: MSPyBentleyGeom.DRange1d) -> bool
        
        Test if the range has{high> low}, i.e. has a non-empty
        set of points with properly sorted lower and upper limit.
        """
        ...
    
    def IsSinglePoint(*args, **kwargs):
        """
        IsSinglePoint(*args, **kwargs)
        Overloaded function.
        
        1. IsSinglePoint(self: MSPyBentleyGeom.DRange1d) -> bool
        
        Test if the range is a single point.
        
        2. IsSinglePoint(self: MSPyBentleyGeom.DRange1d, arg0: float) -> bool
        
        value
        """
        ...
    
    def IsSubsetOf(*args, **kwargs):
        """
        IsSubsetOf(self: MSPyBentleyGeom.DRange1d, other: MSPyBentleyGeom.DRange1d) -> bool
        
        Test if the instance range is a (possibly complete,
        possibly empty) subset of{other} range.
        """
        ...
    
    def Length(*args, **kwargs):
        """
        Length(self: MSPyBentleyGeom.DRange1d) -> float
        
        Return{MAX(0, high - low)} The DRange1.NullRange
        returns 0. A single-point interval returns 0. An interval with{high <
        low} returns 0. Normal case returns{high - low}
        """
        ...
    
    def LengthSum(*args, **kwargs):
        """
        LengthSum(data: MSPyBentleyGeom.DRange1dArray) -> float
        
        Sum the interval lengths
        """
        ...
    
    def Low(*args, **kwargs):
        """
        Low(self: MSPyBentleyGeom.DRange1d) -> float
        
        Get the low limit (unchecked).
        """
        ...
    
    def MaxAbs(*args, **kwargs):
        """
        MaxAbs(self: MSPyBentleyGeom.DRange1d, defaultValeForNullRange: float = 0.0) -> float
        
        return the largest coordinate (absolute value) in the
        range.
        """
        ...
    
    def NullRange(*args, **kwargs):
        """
        NullRange() -> MSPyBentleyGeom.DRange1d
        
        Return a range which satisfies IsNull ()
        """
        ...
    
    def SimplifyInPlace(*args, **kwargs):
        """
        SimplifyInPlace(data: MSPyBentleyGeom.DRange1dArray) -> None
        
        Combine intervals so there are no overlaps.
        """
        ...
    
    def SortLowInPlace(*args, **kwargs):
        """
        SortLowInPlace(data: MSPyBentleyGeom.DRange1dArray) -> None
        
        Sort on low values.
        """
        ...
    
    def StrictlyNonEmptyFractionalIntersection(*args, **kwargs):
        """
        StrictlyNonEmptyFractionalIntersection(self: MSPyBentleyGeom.DRange1d, rangeB: MSPyBentleyGeom.DRange1d, fractionalIntersection: MSPyBentleyGeom.DRange1d) -> bool
        
        Compute intersection of the instance with rangeB. Return
        the intersection as fractions of the instance.
        
        Returns:
        true if the fractional intersection is more than single point.
        """
        ...
    
    def UnionSorted(*args, **kwargs):
        """
        UnionSorted(dataA: MSPyBentleyGeom.DRange1dArray, dataB: MSPyBentleyGeom.DRange1dArray, dataOut: MSPyBentleyGeom.DRange1dArray) -> None
        
        Union of intervals in two pre-sorted sets. Output may NOT
        be the same as either input.
        """
        ...
    
    def UpdateRay1dIntersection(*args, **kwargs):
        """
        UpdateRay1dIntersection(self: MSPyBentleyGeom.DRange1d, x0: float, dxds: float, xA: float, xB: float) -> bool
        
        Update a bounding interval of a line based on the variation of that
        line within one dimension. The ray parameterized{x = x0+s*dxdx} The
        instance is an{s} range that is live. This is usually initialized to
        InfiniteRange before clipping.{xA,xB} is an interval of the{x}
        space. (xA and xB are not required to be sorted.}
        
        Parameter ``[in]``:
        x0 ray start coordinate in this dimension
        
        Parameter ``[in]``:
        dxds Rate of change of ray in this dimension.
        
        Parameter ``[in]``:
        xA x limit
        
        Parameter ``[in]``:
        xB x limit.
        
        Returns:
        true if interval is nonempty at return.
        """
        ...
    
    def ZeroAndNegativeRange(*args, **kwargs):
        """
        ZeroAndNegativeRange() -> MSPyBentleyGeom.DRange1d
        
        Return a complete 0 and negative range (-DBL_MAX to 0)
        """
        ...
    
    def ZeroAndPositiveRange(*args, **kwargs):
        """
        ZeroAndPositiveRange() -> MSPyBentleyGeom.DRange1d
        
        Return a complete 0 and positive range (0 to DBL_MAX)
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DRange1d) -> None
        
        2. __init__(self: MSPyBentleyGeom.DRange1d, low: float, high: float) -> None
        
        3. __init__(self: MSPyBentleyGeom.DRange1d, source: MSPyBentleyGeom.DRange1d) -> None
        """
        ...
    
class DRange1dArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DRange1dArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.DRange1dArray, arg0: MSPyBentleyGeom.DRange1dArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.DRange1dArray, arg0: Iterable) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.DRange1dArray, x: MSPyBentleyGeom.DRange1d) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.DRange1dArray) -> None
        
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.DRange1dArray, L: MSPyBentleyGeom.DRange1dArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.DRange1dArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.DRange1dArray, i: int, x: MSPyBentleyGeom.DRange1d) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.DRange1dArray) -> MSPyBentleyGeom.DRange1d
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.DRange1dArray, i: int) -> MSPyBentleyGeom.DRange1d
        
        Remove and return the item at index ``i``
        """
        ...
    
class DRange2d:
    """
    None
    """

    def Area(*args, **kwargs):
        """
        Area(self: MSPyBentleyGeom.DRange2d) -> float
        
        returns product of axis extents. No test for zero or negative axes.
        """
        ...
    
    def Contains(*args, **kwargs):
        """
        Contains(*args, **kwargs)
        Overloaded function.
        
        1. Contains(self: MSPyBentleyGeom.DRange2d, point: MSPyBentleyGeom.DPoint3d) -> bool
        
        Test if a point is contained in a range.
        
        Parameter ``[in]``:
        point point to test. (z is ignored)
        
        Returns:
        true if the point is in (or on boundary of)
        
        2. Contains(self: MSPyBentleyGeom.DRange2d, point: MSPyBentleyGeom.DPoint2d) -> bool
        
        Test if a point is contained in a range.
        
        Parameter ``[in]``:
        point point to test. (z is ignored)
        
        Returns:
        true if the point is in (or on boundary of)
        
        3. Contains(self: MSPyBentleyGeom.DRange2d, x: float, y: float) -> bool
        
        Test if a point is contained in a range.
        
        Parameter ``[in]``:
        point point to test. (z is ignored)
        
        Returns:
        true if the point is in (or on boundary of)
        """
        ...
    
    def Extend(*args, **kwargs):
        """
        Extend(*args, **kwargs)
        Overloaded function.
        
        1. Extend(self: MSPyBentleyGeom.DRange2d, point: MSPyBentleyGeom.DPoint2d) -> None
        
        Extends the coordinates of the range cube points in pRange so as to
        include the single additional point point.
        
        Parameter ``[in]``:
        point new point to be included in the range.
        
        2. Extend(self: MSPyBentleyGeom.DRange2d, point: MSPyBentleyGeom.DPoint3d) -> None
        
        Extends the coordinates of the range cube points in pRange so as to
        include the single additional point point.
        
        Parameter ``[in]``:
        point new point to be included in the range.
        
        3. Extend(self: MSPyBentleyGeom.DRange2d, point: MSPyBentleyGeom.DPoint4d) -> None
        
        Extends the coordinates of the range cube points in pRange so as to
        include the single additional point point.
        
        Parameter ``[in]``:
        point new point to be included in the range.
        
        4. Extend(self: MSPyBentleyGeom.DRange2d, x: float, y: float) -> None
        
        Extends the coordinates of the range cube points in pRange so as to
        include the single additional point point.
        
        Parameter ``[in]``:
        point new point to be included in the range.
        
        5. Extend(self: MSPyBentleyGeom.DRange2d, points: MSPyBentleyGeom.DPoint2dArray) -> None
        
        Extends the coordinates of the range cube points in pRange so as to
        include the single additional point point.
        
        Parameter ``[in]``:
        point new point to be included in the range.
        
        6. Extend(self: MSPyBentleyGeom.DRange2d, extend: float) -> None
        
        Extends the coordinates of the range cube points in pRange so as to
        include the single additional point point.
        
        Parameter ``[in]``:
        point new point to be included in the range.
        
        7. Extend(self: MSPyBentleyGeom.DRange2d, rangeB: MSPyBentleyGeom.DRange2d) -> None
        
        Extends the coordinates of the range cube points in pRange so as to
        include the single additional point point.
        
        Parameter ``[in]``:
        point new point to be included in the range.
        """
        ...
    
    def ExtentSquared(*args, **kwargs):
        """
        ExtentSquared(self: MSPyBentleyGeom.DRange2d) -> float
        
        Returns:
        0 if null range (as decided by IsNull ()), otherwise sum of
        squared axis extents.
        """
        ...
    
    def FromUnitArcSweep(*args, **kwargs):
        """
        FromUnitArcSweep(theta0: float, sweep: float) -> MSPyBentleyGeom.DRange2d
        
        Initialize the range from an arc of the unit circle
        
        Parameter ``[in]``:
        theta0 start angle
        
        Parameter ``[in]``:
        sweep angular sweep
        """
        ...
    
    def Get4Corners(*args, **kwargs):
        """
        Get4Corners(self: MSPyBentleyGeom.DRange2d, box: MSPyBentleyGeom.DPoint2dArray) -> None
        
        Generates a 4 point box around around a range cube. Point ordering is
        by " x varies fastest " --- 00, 10, 01, 11 for the unit range.
        
        Parameter ``[out]``:
        box array of 4 points of the box
        """
        ...
    
    def Get4Lines(*args, **kwargs):
        """
        Get4Lines(self: MSPyBentleyGeom.DRange2d, originalArray: MSPyBentleyGeom.DPoint2dArray, normalArray: MSPyBentleyGeom.DPoint2dArray) -> None
        
        Extract the 4 bounding lines for a range rectangle, in origin normal
        form
        
        Parameter ``[out]``:
        originArray array of line origins
        
        Parameter ``[out]``:
        normalArray array of plane normals. Directions down, left, right,
        up.
        """
        ...
    
    def Init(*args, **kwargs):
        """
        Init(self: MSPyBentleyGeom.DRange2d) -> None
        
        Initializes a range cube with (inverted) large positive and negative
        values.
        """
        ...
    
    def InitFromUnitArcSweep(*args, **kwargs):
        """
        InitFromUnitArcSweep(self: MSPyBentleyGeom.DRange2d, theta0: float, sweep: float) -> None
        
        Initialize the range from an arc of the unit circle
        
        Parameter ``[in]``:
        theta0 start angle
        
        Parameter ``[in]``:
        sweep angular sweep
        """
        ...
    
    def IntersectRay(*args, **kwargs):
        """
        IntersectRay(self: MSPyBentleyGeom.DRange2d, start: MSPyBentleyGeom.DPoint2d, direction: MSPyBentleyGeom.DPoint2d) -> tuple
        
        Compute the intersection of a range cube and a ray.
        
        If there is not a finite intersection, both params are set to 0 and
        and both points to point0.
        
        Parameter ``[out]``:
        param0 ray parameter where cube is entered
        
        Parameter ``[out]``:
        param1 ray parameter where cube is left
        
        Parameter ``[out]``:
        point0 entry point
        
        Parameter ``[out]``:
        point1 exit point
        
        Parameter ``[in]``:
        start start point of ray
        
        Parameter ``[in]``:
        direction direction of ray
        
        Returns:
        true if non-empty intersection.
        """
        ...
    
    def IntersectionExtentSquared(*args, **kwargs):
        """
        IntersectionExtentSquared(self: MSPyBentleyGeom.DRange2d, range2: MSPyBentleyGeom.DRange2d) -> float
        
        Compute the intersection of given range with another range and return
        the extentSquared of the intersection range.
        
        Parameter ``[in]``:
        range2 second range
        
        Returns:
        extentSquared() for the intersection range.
        """
        ...
    
    def IntersectionOf(*args, **kwargs):
        """
        IntersectionOf(self: MSPyBentleyGeom.DRange2d, range1: MSPyBentleyGeom.DRange2d, range2: MSPyBentleyGeom.DRange2d) -> bool
        
        Compute the intersection of two ranges and test if it is nonempty. If
        empty (non overlap), result range null range.
        
        Remark:
        In earlier API (bsiDRange2d_intersect, DRange2d.intersectionOf
        (DRange2dCP, DRange2dCP) the result was uninitialized in the no-
        intersection case)
        
        Parameter ``[in]``:
        range1 first range
        
        Parameter ``[in]``:
        range2 second range
        
        Returns:
        same result as checkOverlap(range1,range2).
        """
        ...
    
    def IntersectsWith(*args, **kwargs):
        """
        IntersectsWith(self: MSPyBentleyGeom.DRange2d, range2: MSPyBentleyGeom.DRange2d) -> bool
        
        Test if two ranges have strictly non-null overlap (intersection)
        
        Parameter ``[in]``:
        range2 second range
        
        Returns:
        true if ranges overlap, false if not.
        """
        ...
    
    def IsContained(*args, **kwargs):
        """
        IsContained(self: MSPyBentleyGeom.DRange2d, outerRange: MSPyBentleyGeom.DRange2d) -> bool
        
        Test if the given range is a (possible improper) subset of outerRange.
        
        Parameter ``[in]``:
        outerRange outer range
        
        Returns:
        true if the given range is a (possibly improper) subset of
        outerRange.
        """
        ...
    
    def IsEmpty(*args, **kwargs):
        """
        IsEmpty(self: MSPyBentleyGeom.DRange2d) -> bool
        
        Test if high component is (strictly) less than low in any direction.
        Note that equal components do not indicate empty. returns true if any
        low component is less than the corresponding high component
        """
        ...
    
    def IsEqual(*args, **kwargs):
        """
        IsEqual(*args, **kwargs)
        Overloaded function.
        
        1. IsEqual(self: MSPyBentleyGeom.DRange2d, range1: MSPyBentleyGeom.DRange2d) -> bool
        
        Test if two ranges are exactly equal.
        
        Parameter ``[in]``:
        range1 second range
        
        Returns:
        true if ranges are identical in all components.
        
        2. IsEqual(self: MSPyBentleyGeom.DRange2d, range1: MSPyBentleyGeom.DRange2d, tolerance: float) -> bool
        
        Test if two ranges are exactly equal.
        
        Parameter ``[in]``:
        range1 second range
        
        Returns:
        true if ranges are identical in all components.
        """
        ...
    
    def IsNull(*args, **kwargs):
        """
        IsNull(self: MSPyBentleyGeom.DRange2d) -> bool
        
        Check if the range is exactly the same as the null ranges returned by
        bsiDRange2d_init. (Note that ranges with other values with low> high
        are not necessarily null by this condition.)
        """
        ...
    
    def IsPoint(*args, **kwargs):
        """
        IsPoint(self: MSPyBentleyGeom.DRange2d) -> bool
        
        Returns:
        true if high is less than or equal to low in every direction.
        """
        ...
    
    def MoveChangesIntersection(*args, **kwargs):
        """
        MoveChangesIntersection(self: MSPyBentleyGeom.DRange2d, newRange: MSPyBentleyGeom.DRange2d, outerRange: MSPyBentleyGeom.DRange2d) -> bool
        
        Test if a modification of the given (instance) range would have a
        different touching relationship with outerRange.
        
        Remark:
        This may only be meaningful in context of range tree tests where
        some prior relationship among ranges is known to apply.
        
        Parameter ``[in]``:
        newRange candidate for modified range relationship.
        
        Parameter ``[in]``:
        outerRange containing range
        
        Returns:
        true if touching condition occurs.
        """
        ...
    
    def NullRange(*args, **kwargs):
        """
        NullRange() -> MSPyBentleyGeom.DRange2d
        
        Initializes a range cube with (inverted) large positive and negative
        values.
        """
        ...
    
    def RestrictToMinMax(*args, **kwargs):
        """
        RestrictToMinMax(self: MSPyBentleyGeom.DRange2d, range0: MSPyBentleyGeom.DRange2d, minMax: MSPyBentleyGeom.DRange2d) -> None
        
        Returns a range which is the intersection of two ranges. The first
        range is treated as a signed range, i.e. decreasing values from low to
        high are a nonempty range, and the output will maintain the direction.
        In a direction where there is no overlap, pRange high and low values
        are identical and are at the limit of pRange1 that is nearer to the
        values in range0. (Intended use:range0 is the 'actual' stroking range
        of a surface i.e. may go 'backwards'. pRange1 is the nominal full
        surface range, i.e. is known a priori to be 'forwards'. The clipping
        restricts unreliable range0 to the nominal surface range pRange1.
        range0 and pRange may be the same address. minMax must be different.
        
        Parameter ``[in]``:
        range0 range to be restricted
        
        Parameter ``[in]``:
        minMax allowable minmax range. Assumed to have low<high
        """
        ...
    
    def TryFractionsToRangePoint(*args, **kwargs):
        """
        TryFractionsToRangePoint(self: MSPyBentleyGeom.DRange2d, fractions: MSPyBentleyGeom.DPoint2d, xy: MSPyBentleyGeom.DPoint2d) -> bool
        
        map a fractional point to the range coordinates. (0,0) is low point,
        (1,1) is high point.
        
        Parameter ``[in]``:
        fractions fractional coordinates
        
        Parameter ``[out]``:
        xy computed coordinates.
        
        Returns:
        false if range is null range.
        """
        ...
    
    def TryRangePointToFractions(*args, **kwargs):
        """
        TryRangePointToFractions(self: MSPyBentleyGeom.DRange2d, xy: MSPyBentleyGeom.DPoint2d, fractions: MSPyBentleyGeom.DPoint2d) -> bool
        
        map a range point to the fractional coordinates. (0,0) is low point,
        (1,1) is high point.
        
        Parameter ``[out]``:
        fractions fractional coordinates
        
        Parameter ``[in]``:
        xy computed coordinates.
        
        Returns:
        false if range is null range or single point.
        """
        ...
    
    def UnionOf(*args, **kwargs):
        """
        UnionOf(self: MSPyBentleyGeom.DRange2d, range1: MSPyBentleyGeom.DRange2d, range2: MSPyBentleyGeom.DRange2d) -> None
        
        Form the union of two ranges.
        
        Parameter ``[in]``:
        range1 first range.
        
        Parameter ``[in]``:
        range2 second range.
        """
        ...
    
    def XLength(*args, **kwargs):
        """
        XLength(self: MSPyBentleyGeom.DRange2d) -> float
        
        Returns difference of high and low in x direction -- 0 if high<low.
        """
        ...
    
    def YLength(*args, **kwargs):
        """
        YLength(self: MSPyBentleyGeom.DRange2d) -> float
        
        Returns difference of high and low in y direction -- 0 if high<low.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DRange2d) -> None
        
        2. __init__(self: MSPyBentleyGeom.DRange2d, arg0: MSPyBentleyGeom.DPoint2d) -> None
        
        point_a
        
        3. __init__(self: MSPyBentleyGeom.DRange2d, range: Bentley.DRange3d) -> None
        
        4. __init__(self: MSPyBentleyGeom.DRange2d, points: MSPyBentleyGeom.DPoint3dArray) -> None
        
        5. __init__(self: MSPyBentleyGeom.DRange2d, x: float, y: float) -> None
        
        6. __init__(self: MSPyBentleyGeom.DRange2d, point0: MSPyBentleyGeom.DPoint2d, point1: MSPyBentleyGeom.DPoint2d) -> None
        
        7. __init__(self: MSPyBentleyGeom.DRange2d, x0: float, y0: float, x1: float, y1: float) -> None
        
        8. __init__(self: MSPyBentleyGeom.DRange2d, point0: MSPyBentleyGeom.DPoint2d, point1: MSPyBentleyGeom.DPoint2d, point2: MSPyBentleyGeom.DPoint2d) -> None
        
        9. __init__(self: MSPyBentleyGeom.DRange2d, points: MSPyBentleyGeom.DPoint2dArray) -> None
        """
        ...
    
class DRange3d:
    """
    None
    """

    def DiagonalDistance(*args, **kwargs):
        """
        DiagonalDistance(self: MSPyBentleyGeom.DRange3d) -> float
        
        Returns the length of the xyz diagonal -- 0 if null range.
        """
        ...
    
    def DiagonalDistanceXY(*args, **kwargs):
        """
        DiagonalDistanceXY(self: MSPyBentleyGeom.DRange3d) -> float
        
        Returns the length of the xy diagonal -- 0 if null range.
        """
        ...
    
    def DiagonalVector(*args, **kwargs):
        """
        DiagonalVector(self: MSPyBentleyGeom.DRange3d) -> Bentley.DVec3d
        
        Returns the diagonal vector -- 000 if null range.
        """
        ...
    
    def DiagonalVectorXY(*args, **kwargs):
        """
        DiagonalVectorXY(self: MSPyBentleyGeom.DRange3d) -> Bentley.DVec3d
        
        Returns the XY part of the diagonal vector -- 000 if null range.
        """
        ...
    
    def DistanceOutside(*args, **kwargs):
        """
        DistanceOutside(self: MSPyBentleyGeom.DRange3d, xyz: MSPyBentleyGeom.DPoint3d) -> float
        
        Compute the smallest distance from xyz to the range. This
        is 0 for any point inside the range.
        
        Parameter ``[in]``:
        xyz space point.
        
        Returns:
        distance from xyz to closest point of the range.
        """
        ...
    
    def DistanceSquaredOutside(*args, **kwargs):
        """
        DistanceSquaredOutside(self: MSPyBentleyGeom.DRange3d, xyz: MSPyBentleyGeom.DPoint3d) -> float
        
        Compute the smallest distance squared from xyz to the
        range. This is 0 for any point inside the range.
        
        Parameter ``[in]``:
        xyz space point.
        
        Returns:
        distance squared from xyz to closest point of the range.
        """
        ...
    
    def DistanceSquaredTo(*args, **kwargs):
        """
        DistanceSquaredTo(self: MSPyBentleyGeom.DRange3d, other: MSPyBentleyGeom.DRange3d) -> float
        
        Compute the smallest distance to the other range. This is
        0 if the ranges overlap.
        
        Parameter ``[in]``:
        other second range
        
        Returns:
        distance between range cubes (i.e. edge to edge or vertex to edge)
        """
        ...
    
    def Extend(*args, **kwargs):
        """
        Extend(*args, **kwargs)
        Overloaded function.
        
        1. Extend(self: MSPyBentleyGeom.DRange3d, extend: float) -> None
        
        Extends the coordinates of the range cube points in
        pRange so as to include the single additional point point.
        
        Parameter ``[in]``:
        point new point to be included in the range.
        
        2. Extend(self: MSPyBentleyGeom.DRange3d, range1: MSPyBentleyGeom.DRange3d) -> None
        
        Extends the coordinates of the range cube points in
        pRange so as to include the single additional point point.
        
        Parameter ``[in]``:
        point new point to be included in the range.
        
        3. Extend(self: MSPyBentleyGeom.DRange3d, ellipse: MSPyBentleyGeom.DEllipse3d) -> None
        
        Extends the coordinates of the range cube points in
        pRange so as to include the single additional point point.
        
        Parameter ``[in]``:
        point new point to be included in the range.
        
        4. Extend(self: MSPyBentleyGeom.DRange3d, point: MSPyBentleyGeom.DPoint3d) -> None
        
        Extends the coordinates of the range cube points in
        pRange so as to include the single additional point point.
        
        Parameter ``[in]``:
        point new point to be included in the range.
        
        5. Extend(self: MSPyBentleyGeom.DRange3d, point: MSPyBentleyGeom.DPoint3d, weight: float) -> None
        
        Extends the coordinates of the range cube points in
        pRange so as to include the single additional point point.
        
        Parameter ``[in]``:
        point new point to be included in the range.
        
        6. Extend(self: MSPyBentleyGeom.DRange3d, point: MSPyBentleyGeom.DPoint4d) -> None
        
        Extends the coordinates of the range cube points in
        pRange so as to include the single additional point point.
        
        Parameter ``[in]``:
        point new point to be included in the range.
        
        7. Extend(self: MSPyBentleyGeom.DRange3d, x: float, y: float, z: float) -> None
        
        Extends the coordinates of the range cube points in
        pRange so as to include the single additional point point.
        
        Parameter ``[in]``:
        point new point to be included in the range.
        
        8. Extend(self: MSPyBentleyGeom.DRange3d, points: MSPyBentleyGeom.DPoint2dArray, zVal: float) -> None
        
        Extends the coordinates of the range cube points in
        pRange so as to include the single additional point point.
        
        Parameter ``[in]``:
        point new point to be included in the range.
        
        9. Extend(self: MSPyBentleyGeom.DRange3d, points: MSPyBentleyGeom.DPoint3dArray) -> None
        
        Extends the coordinates of the range cube points in
        pRange so as to include the single additional point point.
        
        Parameter ``[in]``:
        point new point to be included in the range.
        
        10. Extend(self: MSPyBentleyGeom.DRange3d, points: MSPyBentleyGeom.DPoint4dArray) -> None
        
        Extends the coordinates of the range cube points in
        pRange so as to include the single additional point point.
        
        Parameter ``[in]``:
        point new point to be included in the range.
        
        11. Extend(self: MSPyBentleyGeom.DRange3d, transform: Bentley.Transform, points: MSPyBentleyGeom.DPoint3dArray) -> None
        
        Extends the coordinates of the range cube points in
        pRange so as to include the single additional point point.
        
        Parameter ``[in]``:
        point new point to be included in the range.
        
        12. Extend(self: MSPyBentleyGeom.DRange3d, transform: Bentley.Transform, points: MSPyBentleyGeom.DPoint4dArray) -> None
        
        Extends the coordinates of the range cube points in
        pRange so as to include the single additional point point.
        
        Parameter ``[in]``:
        point new point to be included in the range.
        
        13. Extend(self: MSPyBentleyGeom.DRange3d, transform: Bentley.Transform, points: List[MSPyBentleyGeom.DPoint3d], weights: List[float]) -> None
        
        Extends the coordinates of the range cube points in
        pRange so as to include the single additional point point.
        
        Parameter ``[in]``:
        point new point to be included in the range.
        """
        ...
    
    def ExtendBySweep(*args, **kwargs):
        """
        ExtendBySweep(self: MSPyBentleyGeom.DRange3d, vector: Bentley.DVec3d) -> None
        
        Extend either low or high of each axis by corresponding
        vector entry for sweep of the range cube. Any axis with low> high is
        left unchanged.
        
        Parameter ``[in]``:
        vector sweep drection
        """
        ...
    
    def ExtentSquared(*args, **kwargs):
        """
        ExtentSquared(self: MSPyBentleyGeom.DRange3d) -> float
        
        returns 0 if the range is null (Range3dIsNull), otherwise
        sum of squared axis extents.
        
        Returns:
        squared magnitude of the diagonal vector.
        """
        ...
    
    def FromMinMax(*args, **kwargs):
        """
        FromMinMax(v0: float, v1: float) -> MSPyBentleyGeom.DRange3d
        
        Initialize the range.InitFrom given min and max in all
        directions. Given values will be swapped if needed.
        
        Parameter ``[in]``:
        v0 min (or max)
        
        Parameter ``[in]``:
        v1 max (or min)
        """
        ...
    
    def Get6Planes(*args, **kwargs):
        """
        Get6Planes(*args, **kwargs)
        Overloaded function.
        
        1. Get6Planes(self: MSPyBentleyGeom.DRange3d, planes: MSPyBentleyGeom.DPlane3dArray, normalLength: float = 1.0) -> None
        
        Generates 6 planes for the faces of the box.
        
        Parameter ``[out]``:
        planes array of 6 planes. (Declared and allocated by caller)
        
        Parameter ``[in]``:
        normalLength scale factor for plane normals. 1.0 is outward unit
        normals, -1.0 is inward unit normals
        
        2. Get6Planes(self: MSPyBentleyGeom.DRange3d, origins: MSPyBentleyGeom.DPoint3dArray, normals: MSPyBentleyGeom.DPoint3dArray = 1.0) -> None
        
        Generates 6 planes for the faces of the box.
        
        Parameter ``[out]``:
        planes array of 6 planes. (Declared and allocated by caller)
        
        Parameter ``[in]``:
        normalLength scale factor for plane normals. 1.0 is outward unit
        normals, -1.0 is inward unit normals
        """
        ...
    
    def Get8Corners(*args, **kwargs):
        """
        Get8Corners(self: MSPyBentleyGeom.DRange3d, box: MSPyBentleyGeom.DPoint3d) -> None
        
        Generates an 8point box around around a range cube. Point ordering is
        maintained from the cube.
        
        Parameter ``[out]``:
        box array of 8 points of the box
        """
        ...
    
    def GetComponentDRange1d(*args, **kwargs):
        """
        GetComponentDRange1d(self: MSPyBentleyGeom.DRange3d, index: int) -> MSPyBentleyGeom.DRange1d
        
        Extract a single component (x,y,z) as a DRange1d.
        
        Parameter ``[in]``:
        index component index interpretted cyclically.
        
        Returns:
        single component range. Ranges may be null independently.
        """
        ...
    
    def GetCornerRange(*args, **kwargs):
        """
        GetCornerRange(*args, **kwargs)
        Overloaded function.
        
        1. GetCornerRange(self: MSPyBentleyGeom.DRange3d, ray: Bentley.DRay3d) -> MSPyBentleyGeom.DRange1d
        
        Compute range of dot products of ray.direction with vectors from
        ray.origin to corners of the range. (The ray direction is NOT
        renormalized on each call)
        
        Parameter ``[in]``:
        ray origin and vector for dot products.
        
        2. GetCornerRange(self: MSPyBentleyGeom.DRange3d, plane: MSPyBentleyGeom.DPlane3d) -> MSPyBentleyGeom.DRange1d
        
        Compute range of dot products of ray.direction with vectors from
        ray.origin to corners of the range. (The ray direction is NOT
        renormalized on each call)
        
        Parameter ``[in]``:
        ray origin and vector for dot products.
        """
        ...
    
    def GetEdges(*args, **kwargs):
        """
        GetEdges(self: MSPyBentleyGeom.DRange3d, edges: Bentley.Bstdcxx.bvector<Bentley.DSegment3d,Bentley.BentleyAllocator<Bentley.DSegment3d> >) -> None
        
        Generates individual DSegment3d for the 12 edges of the box.
        
        Parameter ``[out]``:
        edges array of 12 edges
        """
        ...
    
    def IndexOfMaximalAxis(*args, **kwargs):
        """
        IndexOfMaximalAxis(self: MSPyBentleyGeom.DRange3d) -> int
        
        Return the index of the axis with largest absolute range.
        """
        ...
    
    def Init(*args, **kwargs):
        """
        Init(self: MSPyBentleyGeom.DRange3d) -> None
        
        Initializes a range cube with (inverted) large positive
        and negative values.
        """
        ...
    
    def InitFromMinMax(*args, **kwargs):
        """
        InitFromMinMax(self: MSPyBentleyGeom.DRange3d, v0: float, v1: float) -> None
        
        Initialize the range from given min and max in all
        directions. Given values will be swapped if needed.
        
        Parameter ``[in]``:
        v0 min (or max)
        
        Parameter ``[in]``:
        v1 max (or min)
        """
        ...
    
    def IntersectBounded(*args, **kwargs):
        """
        IntersectBounded(self: MSPyBentleyGeom.DRange3d, clipped: Bentley.DSegment3d, segment: Bentley.DSegment3d) -> tuple
        
        Compute the intersection of a range cube and a ray.
        
        If there is not a finite intersection, both params are set to 0 and
        and the output segment consists of only the start point.
        
        Parameter ``[out]``:
        param0 ray parameter where cube is entered
        
        Parameter ``[out]``:
        param1 ray parameter where cube is left
        
        Parameter ``[out]``:
        clipped clipped segment
        
        Parameter ``[out]``:
        segment line segment to intersect with range cube.
        
        Returns:
        true if non-empty intersection.
        """
        ...
    
    def IntersectIndependentComponentsOf(*args, **kwargs):
        """
        IntersectIndependentComponentsOf(self: MSPyBentleyGeom.DRange3d, range1: MSPyBentleyGeom.DRange3d, range2: MSPyBentleyGeom.DRange3d) -> None
        
        Compute intersection of x,y,z components independently.
        
        Parameter ``[in]``:
        range1 first range
        
        Parameter ``[in]``:
        range2 second range
        """
        ...
    
    def IntersectRay(*args, **kwargs):
        """
        IntersectRay(self: MSPyBentleyGeom.DRange3d, point0: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d, start: MSPyBentleyGeom.DPoint3d, direction: MSPyBentleyGeom.DPoint3d) -> tuple
        
        Compute the intersection of a range cube and a ray.
        
        If there is not a finite intersection, both params are set to 0 and
        and both points to point0.
        
        Parameter ``[out]``:
        param0 ray parameter where cube is entered
        
        Parameter ``[out]``:
        param1 ray parameter where cube is left
        
        Parameter ``[out]``:
        point0 entry point
        
        Parameter ``[out]``:
        point1 exit point
        
        Parameter ``[in]``:
        start start point of ray
        
        Parameter ``[in]``:
        direction direction of ray
        
        Returns:
        true if non-empty intersection.
        """
        ...
    
    def IntersectionExtentSquared(*args, **kwargs):
        """
        IntersectionExtentSquared(self: MSPyBentleyGeom.DRange3d, range2: MSPyBentleyGeom.DRange3d) -> float
        
        Compute the intersection of given range with another range and return
        the extentSquared of the intersection range.
        
        Parameter ``[in]``:
        range2 second range
        
        Returns:
        extentSquared() for the intersection range.
        """
        ...
    
    def IntersectionOf(*args, **kwargs):
        """
        IntersectionOf(self: MSPyBentleyGeom.DRange3d, range1: MSPyBentleyGeom.DRange3d, range2: MSPyBentleyGeom.DRange3d) -> None
        
        Compute the intersection of two ranges. If any direction has no
        intersection the result range is initialized to a null range. (Zero
        thickness intersection is null.)
        
        Parameter ``[in]``:
        range1 first range
        
        Parameter ``[in]``:
        range2 second range
        """
        ...
    
    def IntersectsWith(*args, **kwargs):
        """
        IntersectsWith(*args, **kwargs)
        Overloaded function.
        
        1. IntersectsWith(self: MSPyBentleyGeom.DRange3d, range2: MSPyBentleyGeom.DRange3d) -> bool
        
        Test if two ranges have strictly non-null overlap (intersection)
        
        Parameter ``[in]``:
        range2 second range
        
        Returns:
        true if ranges overlap, false if not.
        
        2. IntersectsWith(self: MSPyBentleyGeom.DRange3d, range2: MSPyBentleyGeom.DRange3d, numDimensions: int) -> bool
        
        Test if two ranges have strictly non-null overlap (intersection)
        
        Parameter ``[in]``:
        range2 second range
        
        Returns:
        true if ranges overlap, false if not.
        
        3. IntersectsWith(self: MSPyBentleyGeom.DRange3d, range2: MSPyBentleyGeom.DRange3d, gapSize: float, numDimensions: int) -> bool
        
        Test if two ranges have strictly non-null overlap (intersection)
        
        Parameter ``[in]``:
        range2 second range
        
        Returns:
        true if ranges overlap, false if not.
        """
        ...
    
    def IsAlmostZeroX(*args, **kwargs):
        """
        IsAlmostZeroX(self: MSPyBentleyGeom.DRange3d) -> bool
        
        Test if x size is small compared to y and z
        """
        ...
    
    def IsAlmostZeroY(*args, **kwargs):
        """
        IsAlmostZeroY(self: MSPyBentleyGeom.DRange3d) -> bool
        
        Test if y size is small compared to x and z
        """
        ...
    
    def IsAlmostZeroZ(*args, **kwargs):
        """
        IsAlmostZeroZ(self: MSPyBentleyGeom.DRange3d) -> bool
        
        Test if z size is small compared to x and y.
        """
        ...
    
    def IsContained(*args, **kwargs):
        """
        IsContained(*args, **kwargs)
        Overloaded function.
        
        1. IsContained(self: MSPyBentleyGeom.DRange3d, outerRange: MSPyBentleyGeom.DRange3d) -> bool
        
        Test if the first range is contained in the second range.
        
        Parameter ``[in]``:
        outerRange candidate outer range.
        
        Returns:
        true if the inner range is a (possibly improper) subset of the
        outer range.
        
        2. IsContained(self: MSPyBentleyGeom.DRange3d, point: MSPyBentleyGeom.DPoint3d) -> bool
        
        Test if the first range is contained in the second range.
        
        Parameter ``[in]``:
        outerRange candidate outer range.
        
        Returns:
        true if the inner range is a (possibly improper) subset of the
        outer range.
        
        3. IsContained(self: MSPyBentleyGeom.DRange3d, point: MSPyBentleyGeom.DPoint3d, numDistance: int) -> bool
        
        Test if the first range is contained in the second range.
        
        Parameter ``[in]``:
        outerRange candidate outer range.
        
        Returns:
        true if the inner range is a (possibly improper) subset of the
        outer range.
        
        4. IsContained(self: MSPyBentleyGeom.DRange3d, x: float, y: float, z: float) -> bool
        
        Test if the first range is contained in the second range.
        
        Parameter ``[in]``:
        outerRange candidate outer range.
        
        Returns:
        true if the inner range is a (possibly improper) subset of the
        outer range.
        """
        ...
    
    def IsContainedXY(*args, **kwargs):
        """
        IsContainedXY(self: MSPyBentleyGeom.DRange3d, point: MSPyBentleyGeom.DPoint3d) -> bool
        
        Test if a point is contained in a range, using only xy
        parts.
        
        Parameter ``[in]``:
        point point to test.
        
        Returns:
        true if the point is in (or on boundary of)
        """
        ...
    
    def IsEmpty(*args, **kwargs):
        """
        IsEmpty(self: MSPyBentleyGeom.DRange3d) -> bool
        
        Test if low component is (strictly) less than high in any direction.
        Note that equal components do not indicate empty. returns true if any
        low component is less than the corresponding high component
        """
        ...
    
    def IsEqual(*args, **kwargs):
        """
        IsEqual(*args, **kwargs)
        Overloaded function.
        
        1. IsEqual(self: MSPyBentleyGeom.DRange3d, range1: MSPyBentleyGeom.DRange3d) -> bool
        
        Test if two ranges are exactly equal.
        
        Parameter ``[in]``:
        range1 second range
        
        Returns:
        true if ranges are identical in all components.
        
        2. IsEqual(self: MSPyBentleyGeom.DRange3d, range1: MSPyBentleyGeom.DRange3d, tolerance: float) -> bool
        
        Test if two ranges are exactly equal.
        
        Parameter ``[in]``:
        range1 second range
        
        Returns:
        true if ranges are identical in all components.
        """
        ...
    
    def IsNull(*args, **kwargs):
        """
        IsNull(self: MSPyBentleyGeom.DRange3d) -> bool
        
        Check if the range is exactly the same as the null ranges
        of a just-initialized range.
        
        Returns:
        true if the range is null.
        """
        ...
    
    def IsPoint(*args, **kwargs):
        """
        IsPoint(self: MSPyBentleyGeom.DRange3d) -> bool
        
        Returns:
        true if high is exactly equal to low in every direction.
        """
        ...
    
    def IsStrictlyContainedXY(*args, **kwargs):
        """
        IsStrictlyContainedXY(self: MSPyBentleyGeom.DRange3d, outerRange: MSPyBentleyGeom.DRange3d) -> bool
        
        Test if the given range is a proper subset of outerRange, using only
        xy parts
        
        Parameter ``[in]``:
        outerRange outer range
        
        Returns:
        true if the given range is a proper subset of outerRange.
        """
        ...
    
    def LargestCoordinate(*args, **kwargs):
        """
        LargestCoordinate(self: MSPyBentleyGeom.DRange3d) -> float
        
        Returns:
        the largest individual coordinate value among (a) range min point,
        (b) range max point, and (c) range diagonal vector.
        """
        ...
    
    def LargestCoordinateXY(*args, **kwargs):
        """
        LargestCoordinateXY(self: MSPyBentleyGeom.DRange3d) -> float
        
        Returns:
        the largest individual XY coordinate value among (a) range min
        point, (b) range max point, and (c) range diagonal vector.
        """
        ...
    
    def LocalToGlobal(*args, **kwargs):
        """
        LocalToGlobal(self: MSPyBentleyGeom.DRange3d, xFraction: float, yFraction: float, zFraction: float) -> MSPyBentleyGeom.DPoint3d
        
        Convert fractional coordinates in x,y,z directions to global
        coordinates.
        
        Parameter ``[in]``:
        xFraction
        
        Parameter ``[in]``:
        yFraction
        
        Parameter ``[in]``:
        zFraction
        
        Returns:
        interpolated point.
        """
        ...
    
    def MaxAbs(*args, **kwargs):
        """
        MaxAbs(self: MSPyBentleyGeom.DRange3d) -> float
        
        Returns:
        the largest individual coordinate value among range low and high,
        zero if empty range.
        """
        ...
    
    def MoveChangesIntersection(*args, **kwargs):
        """
        MoveChangesIntersection(self: MSPyBentleyGeom.DRange3d, newRange: MSPyBentleyGeom.DRange3d, outerRange: MSPyBentleyGeom.DRange3d) -> bool
        
        Test if a modification of the given (instance) range would have a
        different touching relationship with outerRange.
        
        Remark:
        This may only be meaningful in context of range tree tests where
        some prior relationship among ranges is known to apply.
        
        Parameter ``[in]``:
        newRange candidate for modified range relationship.
        
        Parameter ``[in]``:
        outerRange containing range
        
        Returns:
        true if touching condition occurs.
        """
        ...
    
    def NullRange(*args, **kwargs):
        """
        NullRange() -> MSPyBentleyGeom.DRange3d
        
        Initializes a range cube with (inverted) large positive
        and negative values.
        """
        ...
    
    def RestrictToMinMax(*args, **kwargs):
        """
        RestrictToMinMax(self: MSPyBentleyGeom.DRange3d, range0: MSPyBentleyGeom.DRange3d, minMax: MSPyBentleyGeom.DRange3d) -> None
        
        Returns a range which is the intersection of two ranges. The first
        range is treated as a signed range, i.e. decreasing values from low to
        high are a nonempty range, and the output will maintain the direction.
        In a direction where there is no overlap, instance high and low values
        are identical and are at the limit of minMax that is nearer to the
        values in range0. (Intended use:range0 is the 'actual' stroking range
        of a surface i.e. may go 'backwards'. minMax is the nominal full
        surface range, i.e. is known a priori to be 'forwards'. The clipping
        restricts unreliable range0 to the nominal surface range pRange1.
        range0 and instance may be the same address. minMax must be different.
        
        Parameter ``[in]``:
        range0 range to be restricted
        
        Parameter ``[in]``:
        minMax allowable minmax range. Assumed to have low<high
        """
        ...
    
    def UnionOf(*args, **kwargs):
        """
        UnionOf(self: MSPyBentleyGeom.DRange3d, range0: MSPyBentleyGeom.DRange3d, range1: MSPyBentleyGeom.DRange3d) -> None
        
        returns the union of two ranges.
        
        Parameter ``[in]``:
        range0 first range
        
        Parameter ``[in]``:
        range1 second range
        """
        ...
    
    def Volume(*args, **kwargs):
        """
        Volume(self: MSPyBentleyGeom.DRange3d) -> float
        
        returns product of axis extents. No test for zero or negative axes.
        """
        ...
    
    def XLength(*args, **kwargs):
        """
        XLength(self: MSPyBentleyGeom.DRange3d) -> float
        
        Returns difference of high and low in x direction -- 0 if high<low.
        """
        ...
    
    def YLength(*args, **kwargs):
        """
        YLength(self: MSPyBentleyGeom.DRange3d) -> float
        
        Returns difference of high and low in y direction -- 0 if high<low.
        """
        ...
    
    def ZLength(*args, **kwargs):
        """
        ZLength(self: MSPyBentleyGeom.DRange3d) -> float
        
        Returns difference of high and low in z direction -- 0 if high<low.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DRange3d) -> None
        
        2. __init__(self: MSPyBentleyGeom.DRange3d, point: MSPyBentleyGeom.DPoint3d) -> None
        
        3. __init__(self: MSPyBentleyGeom.DRange3d, point0: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d) -> None
        
        4. __init__(self: MSPyBentleyGeom.DRange3d, point0: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d) -> None
        
        5. __init__(self: MSPyBentleyGeom.DRange3d, x: float, y: float, z: float) -> None
        
        6. __init__(self: MSPyBentleyGeom.DRange3d, x0: float, y0: float, z0: float, x1: float, y1: float, z1: float) -> None
        
        7. __init__(self: MSPyBentleyGeom.DRange3d, points: MSPyBentleyGeom.DPoint2dArray, zVal: float) -> None
        
        8. __init__(self: MSPyBentleyGeom.DRange3d, points: MSPyBentleyGeom.DPoint3dArray) -> None
        
        9. __init__(self: MSPyBentleyGeom.DRange3d, points: MSPyBentleyGeom.DPoint4dArray) -> None
        
        10. __init__(self: MSPyBentleyGeom.DRange3d, points: MSPyBentleyGeom.DPoint3dVecArray) -> None
        
        11. __init__(self: MSPyBentleyGeom.DRange3d, points: MSPyBentleyGeom.DPoint3dVecVecArray) -> None
        
        12. __init__(self: MSPyBentleyGeom.DRange3d, points: List[MSPyBentleyGeom.DPoint3d], weights: List[float]) -> None
        
        13. __init__(self: MSPyBentleyGeom.DRange3d, transform: Bentley.Transform, points: List[MSPyBentleyGeom.DPoint3d], weights: List[float]) -> None
        
        14. __init__(self: MSPyBentleyGeom.DRange3d, transform: Bentley.Transform, points: MSPyBentleyGeom.DPoint3dArray) -> None
        
        15. __init__(self: MSPyBentleyGeom.DRange3d, transform: Bentley.Transform, points: MSPyBentleyGeom.DPoint4dArray) -> None
        """
        ...
    
class DRange3dSizeSize:
    """
    None
    """

    def Get(*args, **kwargs):
        """
        Get(self: MSPyBentleyGeom.DRange3dSizeSize) -> MSPyBentleyGeom.DRange3d
        """
        ...
    
    def GetCR(*args, **kwargs):
        """
        GetCR(self: MSPyBentleyGeom.DRange3dSizeSize) -> MSPyBentleyGeom.DRange3d
        """
        ...
    
    def GetTag(*args, **kwargs):
        """
        GetTag(self: MSPyBentleyGeom.DRange3dSizeSize, tagA: bool) -> int
        """
        ...
    
    def GetTagA(*args, **kwargs):
        """
        GetTagA(self: MSPyBentleyGeom.DRange3dSizeSize) -> int
        """
        ...
    
    def GetTagB(*args, **kwargs):
        """
        GetTagB(self: MSPyBentleyGeom.DRange3dSizeSize) -> int
        """
        ...
    
    def Set(*args, **kwargs):
        """
        Set(self: MSPyBentleyGeom.DRange3dSizeSize, value: MSPyBentleyGeom.DRange3d) -> None
        """
        ...
    
    def SetTagA(*args, **kwargs):
        """
        SetTagA(self: MSPyBentleyGeom.DRange3dSizeSize, tag: int) -> None
        """
        ...
    
    def SetTagB(*args, **kwargs):
        """
        SetTagB(self: MSPyBentleyGeom.DRange3dSizeSize, tag: int) -> None
        """
        ...
    
    def SwapTags(*args, **kwargs):
        """
        SwapTags(self: MSPyBentleyGeom.DRange3dSizeSize) -> None
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DRange3dSizeSize) -> None
        
        2. __init__(self: MSPyBentleyGeom.DRange3dSizeSize, value: MSPyBentleyGeom.DRange3d, tagA: int, tagB: int) -> None
        """
        ...
    
class DRay3d:
    """
    None
    """

    def ClosestApproachUnboundedRayBoundedSegment(*args, **kwargs):
        """
        ClosestApproachUnboundedRayBoundedSegment(ray: MSPyBentleyGeom.DRay3d, segment: Bentley.DSegment3d) -> tuple
        
        Parameter ``[out]``:
        fractionRay computed fraction on (unbounded) ray
        
        Parameter ``[out]``:
        fractionSegment computed fraction on (bounded) segment
        
        Parameter ``[out]``:
        pointRay computed point on (unbounded) ray
        
        Parameter ``[out]``:
        pointSegment computed point on (bounded) segment
        
        Parameter ``[in]``:
        ray unbounded ray
        
        Parameter ``[in]``:
        segment bounded segment
        """
        ...
    
    def ClosestApproachUnboundedRayUnboundedRay(*args, **kwargs):
        """
        ClosestApproachUnboundedRayUnboundedRay(rayA: MSPyBentleyGeom.DRay3d, rayB: MSPyBentleyGeom.DRay3d) -> tuple
        
        Parameter ``[out]``:
        fractionA computed fraction on (unbounded) ray
        
        Parameter ``[out]``:
        fractionB computed fraction on (bounded) segment
        
        Parameter ``[out]``:
        pointA computed point on (unbounded) ray
        
        Parameter ``[out]``:
        pointB computed point on (bounded) segment
        
        Parameter ``[in]``:
        rayA unbounded ray
        
        Parameter ``[in]``:
        rayB bounded segment
        
        Returns:
        false (with rayA start projected to rayB) if parallel rays.
        """
        ...
    
    def DirectionDotVector(*args, **kwargs):
        """
        DirectionDotVector(self: MSPyBentleyGeom.DRay3d, vector: Bentley.DVec3d) -> float
        
        Parameter ``[in]``:
        vector
        
        Returns:
        dot product of (unnormalized) ray vector with input vector.
        """
        ...
    
    def DirectionDotVectorToTarget(*args, **kwargs):
        """
        DirectionDotVectorToTarget(self: MSPyBentleyGeom.DRay3d, target: MSPyBentleyGeom.DPoint3d) -> float
        
        Parameter ``[in]``:
        target
        
        Returns:
        dot product of (unnormalized) ray vector with vector from ray
        origin to given point.
        """
        ...
    
    def EvaluateEndPoints(*args, **kwargs):
        """
        EvaluateEndPoints(self: MSPyBentleyGeom.DRay3d, point0: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d) -> None
        
        Return the origin and target of the ray.
        """
        ...
    
    def FractionParameterToPoint(*args, **kwargs):
        """
        FractionParameterToPoint(self: MSPyBentleyGeom.DRay3d, param: float) -> MSPyBentleyGeom.DPoint3d
        
        Parameter ``[in]``:
        param fractional parameter
        
        Returns:
        evaluated point.
        """
        ...
    
    def FromIinterpolateWithScaledDifference(*args, **kwargs):
        """
        FromIinterpolateWithScaledDifference(point0: MSPyBentleyGeom.DPoint3d, fraction: float, point1: MSPyBentleyGeom.DPoint3d, vectorScale: float) -> MSPyBentleyGeom.DRay3d
        
        Return a ray with origin interpolated between points. The ray
        direction is the point0 to point1 vector scaled by vectorScale
        """
        ...
    
    def InitFrom(*args, **kwargs):
        """
        InitFrom(self: MSPyBentleyGeom.DRay3d, segment: Bentley.DSegment3d) -> None
        
        Initialize a ray from a segment.
        """
        ...
    
    def InitFromOriginAndTarget(*args, **kwargs):
        """
        InitFromOriginAndTarget(*args, **kwargs)
        Overloaded function.
        
        1. InitFromOriginAndTarget(self: MSPyBentleyGeom.DRay3d, point0: MSPyBentleyGeom.DPoint2d, point1: MSPyBentleyGeom.DPoint2d) -> None
        
        Initialize a ray from 2d endpoints
        
        2. InitFromOriginAndTarget(self: MSPyBentleyGeom.DRay3d, point0: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d) -> None
        
        Initialize a ray from 2d endpoints
        """
        ...
    
    def InitFromOriginAndVector(*args, **kwargs):
        """
        InitFromOriginAndVector(self: MSPyBentleyGeom.DRay3d, origin: MSPyBentleyGeom.DPoint3d, vector: Bentley.DVec3d) -> None
        
        Initialize a ray from origina and vector
        """
        ...
    
    def InitFromPlanePlaneIntersection(*args, **kwargs):
        """
        InitFromPlanePlaneIntersection(self: MSPyBentleyGeom.DRay3d, planeA: MSPyBentleyGeom.DPlane3d, planeB: MSPyBentleyGeom.DPlane3d) -> bool
        
        Initialize as intersection of two planes.
        
        Returns:
        false if planes are parallel.
        """
        ...
    
    def Intersect(*args, **kwargs):
        """
        Intersect(self: MSPyBentleyGeom.DRay3d, plane: MSPyBentleyGeom.DPlane3d) -> tuple
        
        Return the intersection of the (unbounded) ray with a plane.
        
        Parameter ``[out]``:
        intPoint intersection point
        
        Parameter ``[out]``:
        intParam parameter along the ray
        
        Parameter ``[in]``:
        plane plane (origin and normal)
        
        Returns:
        false if ray, plane are parallel.
        """
        ...
    
    def IntersectCircleXY(*args, **kwargs):
        """
        IntersectCircleXY(self: MSPyBentleyGeom.DRay3d, center: MSPyBentleyGeom.DPoint3d, radius: float) -> list
        """
        ...
    
    def IntersectZPlane(*args, **kwargs):
        """
        IntersectZPlane(self: MSPyBentleyGeom.DRay3d, frame: Bentley.Transform, localZ: float) -> tuple
        
        Return the intersection of this ray with a specified z plane of a
        coordinate frame.
        
        Parameter ``[in]``:
        frame coordinate frame, e.g. often called localWorldFrame for an
        object
        
        Parameter ``[in]``:
        localZ z coordinate in local frame (e.g. 0 for local xy plane
        pierce point.)
        
        Parameter ``[out]``:
        uvw local uvw coordinates. (w matches input z)
        
        Parameter ``[out]``:
        t parameter along ray.
        
        Returns:
        true if the ray is not parallel to the plane
        """
        ...
    
    def ProjectPointBounded(*args, **kwargs):
        """
        ProjectPointBounded(self: MSPyBentleyGeom.DRay3d, point: MSPyBentleyGeom.DPoint3d) -> tuple
        
        Project a point onto the bounded line in 3D. If nearest point of
        extended line is outside the 0..1 parameter range, returned values are
        for nearest endpoint.
        
        Parameter ``[out]``:
        closestPoint computed point
        
        Parameter ``[out]``:
        closestParam fraction parameter at closest point.
        
        Parameter ``[in]``:
        point space point
        """
        ...
    
    def ProjectPointUnBounded(*args, **kwargs):
        """
        ProjectPointUnBounded(self: MSPyBentleyGeom.DRay3d, point: MSPyBentleyGeom.DPoint3d) -> tuple
        """
        ...
    
    def ValidatedNormalize(*args, **kwargs):
        """
        ValidatedNormalize(self: MSPyBentleyGeom.DRay3d) -> MSPyBentleyGeom.ValidatedDRay3d
        
        Return a (validated) copy with normalized direction.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DRay3d) -> None
        
        2. __init__(self: MSPyBentleyGeom.DRay3d, segment: Bentley.DSegment3d) -> None
        
        3. __init__(self: MSPyBentleyGeom.DRay3d, origin: MSPyBentleyGeom.DPoint3d, vector: Bentley.DVec3d) -> None
        
        4. __init__(self: MSPyBentleyGeom.DRay3d, point0: MSPyBentleyGeom.DPoint2d, point1: MSPyBentleyGeom.DPoint2d) -> None
        
        5. __init__(self: MSPyBentleyGeom.DRay3d, point0: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d) -> None
        """
        ...
    
    @property
    def direction(self: MSPyBentleyGeom.DRay3d) -> Bentley.DVec3d:
        ...
    @direction.setter
    def direction(self: MSPyBentleyGeom.DRay3d, arg0: Bentley.DVec3d) -> None:
        ...
    
    @property
    def origin(self: MSPyBentleyGeom.DRay3d) -> MSPyBentleyGeom.DPoint3d:
        ...
    @origin.setter
    def origin(self: MSPyBentleyGeom.DRay3d, arg0: MSPyBentleyGeom.DPoint3d) -> None:
        ...
    
class DSPiral2dViennese:
    """
    None
    """

    class ASLSACollector:
        """
        None
        """
    
        def Collect(*args, **kwargs):
            """
            Collect(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector, centerA: MSPyBentleyGeom.DPoint3d, arcToSpiralA: MSPyBentleyGeom.DPoint3d, sprialA: MSPyBentleyGeom.DSpiral2dBase, sprialToLineA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, arcToSpiralB: MSPyBentleyGeom.DPoint3d, spiralB: MSPyBentleyGeom.DSpiral2dBase, spiralToLibeB: MSPyBentleyGeom.DPoint3d) -> None
            """
            ...
        
        def __init__(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> None:
            ...
        
    def ArcSpiralLineSpiralArcTransition(*args, **kwargs):
        """
        ArcSpiralLineSpiralArcTransition(centerA: MSPyBentleyGeom.DPoint3d, radiusA: float, lengthA: float, centerB: MSPyBentleyGeom.DPoint3d, radiusB: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, collector: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> int
        """
        ...
    
    def Clone(*args, **kwargs):
        """
        Clone(self: MSPyBentleyGeom.DSpiral2dBase) -> MSPyBentleyGeom.DSpiral2dBase
        """
        ...
    
    def ClosestPoint(*args, **kwargs):
        """
        ClosestPoint(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, spiralToWorld: Bentley.Transform, spacePoint: MSPyBentleyGeom.DPoint3d) -> tuple
        
        Compute the closest spiral point for a given space point.
        
        Parameter ``[in]``:
        spiral spiral to evaluate.
        
        Parameter ``[in]``:
        startFraction start fraction of search range
        
        Parameter ``[in]``:
        endFraction endFraction of search range
        
        Parameter ``[in]``:
        spiralToWorld transform placing the spiral local coordinates into
        the world coordinate system
        
        Parameter ``[in]``:
        spacePoint world coordinates of space point.
        
        Parameter ``[out]``:
        spiralPoint world coordinates of closest point on spiral
        
        Parameter ``[out]``:
        spiralFraction fractional coordinates of closest point on spiral
        
        Parameter ``[out]``:
        minDistance distance from space point to spiralPoint.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def CopyBaseParameters(*args, **kwargs):
        """
        CopyBaseParameters(self: MSPyBentleyGeom.DSpiral2dBase, pSource: MSPyBentleyGeom.DSpiral2dBase) -> None
        """
        ...
    
    def CreateBearingCurvatureBearingCurvature(*args, **kwargs):
        """
        CreateBearingCurvatureBearingCurvature(*args, **kwargs)
        Overloaded function.
        
        1. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float, extraData: MSPyBentley.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def CreateBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        CreateBearingCurvatureLengthCurvature(*args, **kwargs)
        Overloaded function.
        
        1. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float, extraData: MSPyBentley.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def DefaultStrokeAngle(*args, **kwargs):
        """
        DefaultStrokeAngle() -> float
        """
        ...
    
    def DistanceToCurvature(*args, **kwargs):
        """
        DistanceToCurvature(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToCurvatureDerivative(*args, **kwargs):
        """
        DistanceToCurvatureDerivative(self: MSPyBentleyGeom.DSpiral2dBase, arg0: float) -> float
        
        distance
        """
        ...
    
    def DistanceToFraction(*args, **kwargs):
        """
        DistanceToFraction(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToGlobalAngle(*args, **kwargs):
        """
        DistanceToGlobalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToLocalAngle(*args, **kwargs):
        """
        DistanceToLocalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(*args, **kwargs):
        """
        EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(s: float, length: float, curvature1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: Bentley.DVec2d, d2XY: Bentley.DVec2d, d3XY: Bentley.DVec2d) -> bool
        
        [in] distance for evaluation [in] nominal length. ASSUMED NONZERO [in]
        exit curvature. ASSUMED NONZERO [out] coordinates on spiral [out]
        first derivative wrt distance [out] second derivative wrt distance
        [out] third derivative wrt distance
        """
        ...
    
    def EvaluateVectorIntegrand(*args, **kwargs):
        """
        EvaluateVectorIntegrand(self: MSPyBentleyGeom.DSpiral2dBase, distance: float, pF: float) -> None
        """
        ...
    
    def FillExtraDataArray(*args, **kwargs):
        """
        FillExtraDataArray(extraData: MSPyBentley.DoubleArray, cant: float, h: float, e: float) -> None
        
        Return the extra data array for the parameters of a viennese spiral
        """
        ...
    
    def FractionToDerivatives(*args, **kwargs):
        """
        FractionToDerivatives(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float, dXdf: Bentley.DVec2d, ddXdfdf: Bentley.DVec2d, dddXdfdfdf: Bentley.DVec2d) -> bool
        """
        ...
    
    def FractionToDistance(*args, **kwargs):
        """
        FractionToDistance(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float) -> float
        """
        ...
    
    def GetExtraData(*args, **kwargs):
        """
        GetExtraData(self: MSPyBentleyGeom.DSpiral2dBase, extraData: MSPyBentley.DoubleArray) -> None
        
        Get the extra data for this spiral. REMARK:This should be a virtual,
        but is implemented as special cases because of API change restriction
        """
        ...
    
    def GetIntervalCount(*args, **kwargs):
        """
        GetIntervalCount(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, minInterval: int = 0, maxStrokeLength: float = 10000.0) -> int
        
        Return an interval count for stroking or integration. Except for
        degenerate single interval cases, the interval count is always even.
        That is the possible values are
        
        Parameter ``[in]``:
        spiral spiral being queried.
        
        Parameter ``[in]``:
        startFraction start of interval to stroke.
        
        Parameter ``[in]``:
        endFraction end of interval to stroke.
        
        Parameter ``[in]``:
        maxRadians max turn between strokes.
        
        Parameter ``[in]``:
        minInterval smallest number of intervals.
        
        Parameter ``[in]``:
        maxStrokeLength largest stroke size. Recommended 10 meters
        """
        ...
    
    def GetTransitionTypeCode(*args, **kwargs):
        """
        GetTransitionTypeCode(self: MSPyBentleyGeom.DSpiral2dBase) -> int
        """
        ...
    
    def GetVectorIntegrandCount(*args, **kwargs):
        """
        GetVectorIntegrandCount(self: MSPyBentleyGeom.DSpiral2dBase) -> int
        """
        ...
    
    def IsValidRLCombination(*args, **kwargs):
        """
        IsValidRLCombination(lengthFromInflection: float, radius: float, spiralType: int = 0) -> bool
        
        test if a length-from-inflection and final radius
        combination is " small enough " for reasonable use. Test depends on
        spiral type:
        
        * DSpiral2dBase.TransitionType_None indicates apply the strictest
        test (same as Czech and Italian)
        
        * DSpiral2dBase.TransitionType_Czech and
        DSpiral2dBase.TransitionType_Italian indicate a strict test L<2*R
        
        * other types have no restrictions.
        
        Parameter ``[in]``:
        lengthFromInflection [in] distance along spiral starting at
        inflection and ending at finalRadius.
        
        Parameter ``[in]``:
        finalRadius [in] final radius
        
        Parameter ``[in]``:
        spiralType [in] spiral type.
        
        Parameter ``[in]``:
        lengthFactor expansion or reduction factor to apply to the allowed
        length. +---------------+---------------+---------------+---------
        ------+------
        """
        ...
    
    def LineSpiralArcSpiralLineTransition(*args, **kwargs):
        """
        LineSpiralArcSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, radius: float, lengthA: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralAToArc: MSPyBentleyGeom.DPoint3d, spiralBToArc: MSPyBentleyGeom.DPoint3d, arc: MSPyBentleyGeom.DEllipse3d) -> bool
        
        compute spirals and arc to make a line-to-line
        transition.
        
        Parameter ``[in]``:
        lineAPoint point on line A.
        
        Parameter ``[in]``:
        lineBPoint point on line B.
        
        Parameter ``[in]``:
        lineLineIntersection intersection of lines.
        
        Parameter ``[in]``:
        radius radius for circular part of transition.
        
        Parameter ``[in]``:
        lengthA length of spiral from line A to circle.
        
        Parameter ``[in]``:
        lengthB length of spiral from line B to circle.
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        lineToSpiralA tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralAToArc tangency point from spiral to arc
        
        Parameter ``[out]``:
        lineToSpiralB tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralBToArc tangency point from spiral to arc
        
        Parameter ``[out]``:
        arc arc between spirals.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def ScaleInPlace(*args, **kwargs):
        """
        ScaleInPlace(self: MSPyBentleyGeom.DSpiral2dBase, s: float) -> bool
        """
        ...
    
    def SetBearingAndCurvatureLimits(*args, **kwargs):
        """
        SetBearingAndCurvatureLimits(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, theta1: float, curvature1: float) -> bool
        """
        ...
    
    def SetBearingCurvatureLengthBearing(*args, **kwargs):
        """
        SetBearingCurvatureLengthBearing(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, theta1: float) -> bool
        
        Set start bearing, start curvature, length, and end
        curvature. (Compute end bearing)
        
        Parameter ``[in]``:
        theta0 start bearing
        
        Parameter ``[in]``:
        curvature0 start curvature
        
        Parameter ``[in]``:
        length arc length
        
        Parameter ``[in]``:
        theta1 end bearing
        """
        ...
    
    def SetBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        SetBearingCurvatureLengthCurvature(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, curvature1: float) -> bool
        """
        ...
    
    def StringToTransitionType(*args, **kwargs):
        """
        StringToTransitionType(name: str) -> int
        
        return the integer code for the string name.
        """
        ...
    
    def Stroke(*args, **kwargs):
        """
        Stroke(*args, **kwargs)
        Overloaded function.
        
        1. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, pDXY: Bentley.DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        2. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, xyz0: MSPyBentleyGeom.DPoint3d, pXYZ: MSPyBentleyGeom.DPoint3d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        3. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: Bentley.DVec2d) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        4. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: Bentley.DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        5. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: Bentley.DVec2d, pFraction: float, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        6. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: Bentley.DVec2d, maxStrokeLength: float) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        7. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, uvPoints: Bentley.Bstdcxx.bvector<Bentley.DVec2d,Bentley.BentleyAllocator<Bentley.DVec2d> >, fractions: MSPyBentley.DoubleArray, maxStrokeLength: float = 10000.0) -> tuple
        """
        ...
    
    def StrokeToAnnouncer(*args, **kwargs):
        """
        StrokeToAnnouncer(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, F: MSPyBentleyGeom.AnnounceDoubleDPoint2d, minIndex: int = 0, maxStrokeLength: float = 10000.0) -> tuple
        
        Integrate the vector displacements of a clothoid over a
        fractional interval. This uses the angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        startFraction start fraction for integral.
        
        Parameter ``[in]``:
        endFraction end fraction for integral.
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points. A
        default is used if 0.0 is passed.
        
        Parameter ``[in]``:
        F object with a method F->Announce (f, uv) called to announce
        fraction and coordinate as computed.
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Parameter ``[out]``:
        minInterval smallest number of intervals allowed
        
        Parameter ``[out]``:
        maxStrokeLength maximum allowed stroke length
        
        Returns:
        false if point integration failed
        """
        ...
    
    def SymmetricLineSpiralSpiralLineTransition(*args, **kwargs):
        """
        SymmetricLineSpiralSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, length: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralToSpiral: MSPyBentleyGeom.DPoint3d) -> tuple
        
        compute spirals and arc to make a line-to-line
        transition.
        
        Parameter ``[in]``:
        lineAPoint point on line A.
        
        Parameter ``[in]``:
        lineBPoint point on line B.
        
        Parameter ``[in]``:
        lineLineIntersection intersection of lines.
        
        Parameter ``[in]``:
        length length of spiral from line A to junction
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        lineToSpiralA tangency point from line to spiral
        
        Parameter ``[out]``:
        lineToSpiralB tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralToSpiral tangency point from spiral to to spiral
        
        Parameter ``[out]``:
        junctionRadius radius at transition between the spirals.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def SymmetricPointShoulderTargetTransition(*args, **kwargs):
        """
        SymmetricPointShoulderTargetTransition(startPoint: MSPyBentleyGeom.DPoint2d, shoulderPoint: MSPyBentleyGeom.DPoint2d, targetPoint: MSPyBentleyGeom.DPoint2d, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, junctionPoint: MSPyBentleyGeom.DPoint2d, endPoint: MSPyBentleyGeom.DPoint2d) -> bool
        
        compute 2 spirals.
        
        Parameter ``[in]``:
        startPoint start point
        
        Parameter ``[in]``:
        shoulderPoint target point for first and last tangents
        
        Parameter ``[in]``:
        targetPoint target point for last tangent
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        junctionPoint transition between spirals. This is the max
        curvature point.
        
        Parameter ``[out]``:
        endPoint end of second spiral.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def TransitionTypeToString(*args, **kwargs):
        """
        TransitionTypeToString(type: int) -> str
        
        return the string name of the type
        """
        ...
    
    TransitionType_Arema: int
    
    TransitionType_AustralianRailCorp: int
    
    TransitionType_Biquadratic: int
    
    TransitionType_Bloss: int
    
    TransitionType_ChineseCubic: int
    
    TransitionType_Clothoid: int
    
    TransitionType_Cosine: int
    
    TransitionType_Czech: int
    
    TransitionType_CzechAlongTangent: int
    
    TransitionType_DirectHalfCosine: int
    
    TransitionType_FirstDirectEvaluate: int
    
    TransitionType_Italian: int
    
    TransitionType_JapaneseCubic: int
    
    TransitionType_MXCubicAlongArc: int
    
    TransitionType_MXCubicAlongTangent: int
    
    TransitionType_PolishCubic: int
    
    TransitionType_Sine: int
    
    TransitionType_Unknown: int
    
    TransitionType_Viennese: int
    
    TransitionType_WeightedViennese: int
    
    TransitionType_WesternAustralian: int
    
    def VectorIntegrandCount(*args, **kwargs):
        """
        VectorIntegrandCount(self: MSPyBentleyGeom.BSIVectorIntegrand) -> int
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.DSPiral2dViennese, cant: float, h: float, e: float) -> None:
        ...
    
class DSPiral2dWeightedViennese:
    """
    None
    """

    class ASLSACollector:
        """
        None
        """
    
        def Collect(*args, **kwargs):
            """
            Collect(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector, centerA: MSPyBentleyGeom.DPoint3d, arcToSpiralA: MSPyBentleyGeom.DPoint3d, sprialA: MSPyBentleyGeom.DSpiral2dBase, sprialToLineA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, arcToSpiralB: MSPyBentleyGeom.DPoint3d, spiralB: MSPyBentleyGeom.DSpiral2dBase, spiralToLibeB: MSPyBentleyGeom.DPoint3d) -> None
            """
            ...
        
        def __init__(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> None:
            ...
        
    def ArcSpiralLineSpiralArcTransition(*args, **kwargs):
        """
        ArcSpiralLineSpiralArcTransition(centerA: MSPyBentleyGeom.DPoint3d, radiusA: float, lengthA: float, centerB: MSPyBentleyGeom.DPoint3d, radiusB: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, collector: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> int
        """
        ...
    
    def Clone(*args, **kwargs):
        """
        Clone(self: MSPyBentleyGeom.DSpiral2dBase) -> MSPyBentleyGeom.DSpiral2dBase
        """
        ...
    
    def ClosestPoint(*args, **kwargs):
        """
        ClosestPoint(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, spiralToWorld: Bentley.Transform, spacePoint: MSPyBentleyGeom.DPoint3d) -> tuple
        
        Compute the closest spiral point for a given space point.
        
        Parameter ``[in]``:
        spiral spiral to evaluate.
        
        Parameter ``[in]``:
        startFraction start fraction of search range
        
        Parameter ``[in]``:
        endFraction endFraction of search range
        
        Parameter ``[in]``:
        spiralToWorld transform placing the spiral local coordinates into
        the world coordinate system
        
        Parameter ``[in]``:
        spacePoint world coordinates of space point.
        
        Parameter ``[out]``:
        spiralPoint world coordinates of closest point on spiral
        
        Parameter ``[out]``:
        spiralFraction fractional coordinates of closest point on spiral
        
        Parameter ``[out]``:
        minDistance distance from space point to spiralPoint.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def CopyBaseParameters(*args, **kwargs):
        """
        CopyBaseParameters(self: MSPyBentleyGeom.DSpiral2dBase, pSource: MSPyBentleyGeom.DSpiral2dBase) -> None
        """
        ...
    
    def CreateBearingCurvatureBearingCurvature(*args, **kwargs):
        """
        CreateBearingCurvatureBearingCurvature(*args, **kwargs)
        Overloaded function.
        
        1. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float, extraData: MSPyBentley.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def CreateBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        CreateBearingCurvatureLengthCurvature(*args, **kwargs)
        Overloaded function.
        
        1. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float, extraData: MSPyBentley.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def DefaultStrokeAngle(*args, **kwargs):
        """
        DefaultStrokeAngle() -> float
        """
        ...
    
    def DistanceToCurvature(*args, **kwargs):
        """
        DistanceToCurvature(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToCurvatureDerivative(*args, **kwargs):
        """
        DistanceToCurvatureDerivative(self: MSPyBentleyGeom.DSpiral2dBase, arg0: float) -> float
        
        distance
        """
        ...
    
    def DistanceToFraction(*args, **kwargs):
        """
        DistanceToFraction(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToGlobalAngle(*args, **kwargs):
        """
        DistanceToGlobalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToLocalAngle(*args, **kwargs):
        """
        DistanceToLocalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(*args, **kwargs):
        """
        EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(s: float, length: float, curvature1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: Bentley.DVec2d, d2XY: Bentley.DVec2d, d3XY: Bentley.DVec2d) -> bool
        
        [in] distance for evaluation [in] nominal length. ASSUMED NONZERO [in]
        exit curvature. ASSUMED NONZERO [out] coordinates on spiral [out]
        first derivative wrt distance [out] second derivative wrt distance
        [out] third derivative wrt distance
        """
        ...
    
    def EvaluateVectorIntegrand(*args, **kwargs):
        """
        EvaluateVectorIntegrand(self: MSPyBentleyGeom.DSpiral2dBase, distance: float, pF: float) -> None
        """
        ...
    
    def FillExtraDataArray(*args, **kwargs):
        """
        FillExtraDataArray(extraData: MSPyBentley.DoubleArray, cant: float, h: float, e: float, weight0: float, weight1: float) -> None
        
        Return the extra data array for the parameters of a weighted viennese
        spiral
        """
        ...
    
    def FractionToDerivatives(*args, **kwargs):
        """
        FractionToDerivatives(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float, dXdf: Bentley.DVec2d, ddXdfdf: Bentley.DVec2d, dddXdfdfdf: Bentley.DVec2d) -> bool
        """
        ...
    
    def FractionToDistance(*args, **kwargs):
        """
        FractionToDistance(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float) -> float
        """
        ...
    
    def GetExtraData(*args, **kwargs):
        """
        GetExtraData(self: MSPyBentleyGeom.DSpiral2dBase, extraData: MSPyBentley.DoubleArray) -> None
        
        Get the extra data for this spiral. REMARK:This should be a virtual,
        but is implemented as special cases because of API change restriction
        """
        ...
    
    def GetIntervalCount(*args, **kwargs):
        """
        GetIntervalCount(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, minInterval: int = 0, maxStrokeLength: float = 10000.0) -> int
        
        Return an interval count for stroking or integration. Except for
        degenerate single interval cases, the interval count is always even.
        That is the possible values are
        
        Parameter ``[in]``:
        spiral spiral being queried.
        
        Parameter ``[in]``:
        startFraction start of interval to stroke.
        
        Parameter ``[in]``:
        endFraction end of interval to stroke.
        
        Parameter ``[in]``:
        maxRadians max turn between strokes.
        
        Parameter ``[in]``:
        minInterval smallest number of intervals.
        
        Parameter ``[in]``:
        maxStrokeLength largest stroke size. Recommended 10 meters
        """
        ...
    
    def GetTransitionTypeCode(*args, **kwargs):
        """
        GetTransitionTypeCode(self: MSPyBentleyGeom.DSpiral2dBase) -> int
        """
        ...
    
    def GetVectorIntegrandCount(*args, **kwargs):
        """
        GetVectorIntegrandCount(self: MSPyBentleyGeom.DSpiral2dBase) -> int
        """
        ...
    
    def IsValidRLCombination(*args, **kwargs):
        """
        IsValidRLCombination(lengthFromInflection: float, radius: float, spiralType: int = 0) -> bool
        
        test if a length-from-inflection and final radius
        combination is " small enough " for reasonable use. Test depends on
        spiral type:
        
        * DSpiral2dBase.TransitionType_None indicates apply the strictest
        test (same as Czech and Italian)
        
        * DSpiral2dBase.TransitionType_Czech and
        DSpiral2dBase.TransitionType_Italian indicate a strict test L<2*R
        
        * other types have no restrictions.
        
        Parameter ``[in]``:
        lengthFromInflection [in] distance along spiral starting at
        inflection and ending at finalRadius.
        
        Parameter ``[in]``:
        finalRadius [in] final radius
        
        Parameter ``[in]``:
        spiralType [in] spiral type.
        
        Parameter ``[in]``:
        lengthFactor expansion or reduction factor to apply to the allowed
        length. +---------------+---------------+---------------+---------
        ------+------
        """
        ...
    
    def LineSpiralArcSpiralLineTransition(*args, **kwargs):
        """
        LineSpiralArcSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, radius: float, lengthA: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralAToArc: MSPyBentleyGeom.DPoint3d, spiralBToArc: MSPyBentleyGeom.DPoint3d, arc: MSPyBentleyGeom.DEllipse3d) -> bool
        
        compute spirals and arc to make a line-to-line
        transition.
        
        Parameter ``[in]``:
        lineAPoint point on line A.
        
        Parameter ``[in]``:
        lineBPoint point on line B.
        
        Parameter ``[in]``:
        lineLineIntersection intersection of lines.
        
        Parameter ``[in]``:
        radius radius for circular part of transition.
        
        Parameter ``[in]``:
        lengthA length of spiral from line A to circle.
        
        Parameter ``[in]``:
        lengthB length of spiral from line B to circle.
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        lineToSpiralA tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralAToArc tangency point from spiral to arc
        
        Parameter ``[out]``:
        lineToSpiralB tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralBToArc tangency point from spiral to arc
        
        Parameter ``[out]``:
        arc arc between spirals.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def ScaleInPlace(*args, **kwargs):
        """
        ScaleInPlace(self: MSPyBentleyGeom.DSpiral2dBase, s: float) -> bool
        """
        ...
    
    def SetBearingAndCurvatureLimits(*args, **kwargs):
        """
        SetBearingAndCurvatureLimits(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, theta1: float, curvature1: float) -> bool
        """
        ...
    
    def SetBearingCurvatureLengthBearing(*args, **kwargs):
        """
        SetBearingCurvatureLengthBearing(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, theta1: float) -> bool
        
        Set start bearing, start curvature, length, and end
        curvature. (Compute end bearing)
        
        Parameter ``[in]``:
        theta0 start bearing
        
        Parameter ``[in]``:
        curvature0 start curvature
        
        Parameter ``[in]``:
        length arc length
        
        Parameter ``[in]``:
        theta1 end bearing
        """
        ...
    
    def SetBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        SetBearingCurvatureLengthCurvature(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, curvature1: float) -> bool
        """
        ...
    
    def StringToTransitionType(*args, **kwargs):
        """
        StringToTransitionType(name: str) -> int
        
        return the integer code for the string name.
        """
        ...
    
    def Stroke(*args, **kwargs):
        """
        Stroke(*args, **kwargs)
        Overloaded function.
        
        1. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, pDXY: Bentley.DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        2. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, xyz0: MSPyBentleyGeom.DPoint3d, pXYZ: MSPyBentleyGeom.DPoint3d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        3. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: Bentley.DVec2d) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        4. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: Bentley.DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        5. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: Bentley.DVec2d, pFraction: float, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        6. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: Bentley.DVec2d, maxStrokeLength: float) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        7. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, uvPoints: Bentley.Bstdcxx.bvector<Bentley.DVec2d,Bentley.BentleyAllocator<Bentley.DVec2d> >, fractions: MSPyBentley.DoubleArray, maxStrokeLength: float = 10000.0) -> tuple
        """
        ...
    
    def StrokeToAnnouncer(*args, **kwargs):
        """
        StrokeToAnnouncer(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, F: MSPyBentleyGeom.AnnounceDoubleDPoint2d, minIndex: int = 0, maxStrokeLength: float = 10000.0) -> tuple
        
        Integrate the vector displacements of a clothoid over a
        fractional interval. This uses the angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        startFraction start fraction for integral.
        
        Parameter ``[in]``:
        endFraction end fraction for integral.
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points. A
        default is used if 0.0 is passed.
        
        Parameter ``[in]``:
        F object with a method F->Announce (f, uv) called to announce
        fraction and coordinate as computed.
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Parameter ``[out]``:
        minInterval smallest number of intervals allowed
        
        Parameter ``[out]``:
        maxStrokeLength maximum allowed stroke length
        
        Returns:
        false if point integration failed
        """
        ...
    
    def SymmetricLineSpiralSpiralLineTransition(*args, **kwargs):
        """
        SymmetricLineSpiralSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, length: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralToSpiral: MSPyBentleyGeom.DPoint3d) -> tuple
        
        compute spirals and arc to make a line-to-line
        transition.
        
        Parameter ``[in]``:
        lineAPoint point on line A.
        
        Parameter ``[in]``:
        lineBPoint point on line B.
        
        Parameter ``[in]``:
        lineLineIntersection intersection of lines.
        
        Parameter ``[in]``:
        length length of spiral from line A to junction
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        lineToSpiralA tangency point from line to spiral
        
        Parameter ``[out]``:
        lineToSpiralB tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralToSpiral tangency point from spiral to to spiral
        
        Parameter ``[out]``:
        junctionRadius radius at transition between the spirals.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def SymmetricPointShoulderTargetTransition(*args, **kwargs):
        """
        SymmetricPointShoulderTargetTransition(startPoint: MSPyBentleyGeom.DPoint2d, shoulderPoint: MSPyBentleyGeom.DPoint2d, targetPoint: MSPyBentleyGeom.DPoint2d, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, junctionPoint: MSPyBentleyGeom.DPoint2d, endPoint: MSPyBentleyGeom.DPoint2d) -> bool
        
        compute 2 spirals.
        
        Parameter ``[in]``:
        startPoint start point
        
        Parameter ``[in]``:
        shoulderPoint target point for first and last tangents
        
        Parameter ``[in]``:
        targetPoint target point for last tangent
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        junctionPoint transition between spirals. This is the max
        curvature point.
        
        Parameter ``[out]``:
        endPoint end of second spiral.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def TransitionTypeToString(*args, **kwargs):
        """
        TransitionTypeToString(type: int) -> str
        
        return the string name of the type
        """
        ...
    
    TransitionType_Arema: int
    
    TransitionType_AustralianRailCorp: int
    
    TransitionType_Biquadratic: int
    
    TransitionType_Bloss: int
    
    TransitionType_ChineseCubic: int
    
    TransitionType_Clothoid: int
    
    TransitionType_Cosine: int
    
    TransitionType_Czech: int
    
    TransitionType_CzechAlongTangent: int
    
    TransitionType_DirectHalfCosine: int
    
    TransitionType_FirstDirectEvaluate: int
    
    TransitionType_Italian: int
    
    TransitionType_JapaneseCubic: int
    
    TransitionType_MXCubicAlongArc: int
    
    TransitionType_MXCubicAlongTangent: int
    
    TransitionType_PolishCubic: int
    
    TransitionType_Sine: int
    
    TransitionType_Unknown: int
    
    TransitionType_Viennese: int
    
    TransitionType_WeightedViennese: int
    
    TransitionType_WesternAustralian: int
    
    def VectorIntegrandCount(*args, **kwargs):
        """
        VectorIntegrandCount(self: MSPyBentleyGeom.BSIVectorIntegrand) -> int
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.DSPiral2dWeightedViennese, cant: float, h: float, e: float, weight0: float, weight1: float) -> None:
        ...
    
class DSegment1d:
    """
    None
    """

    def BetweenFractions(*args, **kwargs):
        """
        BetweenFractions(self: MSPyBentleyGeom.DSegment1d, f0: float, f1: float) -> MSPyBentleyGeom.DSegment1d
        
        Return a segment with endpoints at fractions of input segment.
        """
        ...
    
    def Delta(*args, **kwargs):
        """
        Delta(self: MSPyBentleyGeom.DSegment1d) -> float
        
        Return signed distance from start to end
        """
        ...
    
    def DirectedOverlap(*args, **kwargs):
        """
        DirectedOverlap(primary: MSPyBentleyGeom.DSegment1d, clipper: MSPyBentleyGeom.DSegment1d, result: MSPyBentleyGeom.DSegment1d) -> bool
        
        Find overlap of primary with clipper. If empty, return false and
        primary unchanged. If nonempty, result maintains orientation of
        primary. Note that single point intersection is non-empty.
        """
        ...
    
    @property
    def End(arg0: MSPyBentleyGeom.DSegment1d) -> float:
        ...
    @End.setter
    def End(arg0: MSPyBentleyGeom.DSegment1d, arg1: float) -> None:
        ...
    
    def EndPointProduct(*args, **kwargs):
        """
        EndPointProduct(self: MSPyBentleyGeom.DSegment1d, x: float) -> float
        
        return (x-x0) * (x-x1). This is negative " inside " the interval
        """
        ...
    
    def FractionToPoint(*args, **kwargs):
        """
        FractionToPoint(self: MSPyBentleyGeom.DSegment1d, fraction: float) -> float
        
        Return coordinate at fractional parameter from start to end.
        """
        ...
    
    def GetEnd(*args, **kwargs):
        """
        GetEnd(self: MSPyBentleyGeom.DSegment1d) -> float
        
        Return end coordinate.
        """
        ...
    
    def GetStart(*args, **kwargs):
        """
        GetStart(self: MSPyBentleyGeom.DSegment1d) -> float
        
        Return start coordinate.
        """
        ...
    
    def IsEqual(*args, **kwargs):
        """
        IsEqual(self: MSPyBentleyGeom.DSegment1d, other: MSPyBentleyGeom.DSegment1d) -> bool
        
        Exact equality test.
        """
        ...
    
    def IsReversed(*args, **kwargs):
        """
        IsReversed(self: MSPyBentleyGeom.DSegment1d, other: MSPyBentleyGeom.DSegment1d) -> bool
        
        Exact equality test for reversed coordinates.
        """
        ...
    
    def IsStrictInterior(*args, **kwargs):
        """
        IsStrictInterior(self: MSPyBentleyGeom.DSegment1d, x: float) -> bool
        
        Test if the EndPointProduct is strictly negative
        """
        ...
    
    def Length(*args, **kwargs):
        """
        Length(self: MSPyBentleyGeom.DSegment1d) -> float
        
        Return absolute length of the segment.
        """
        ...
    
    def NonZeroDirectedOverlap(*args, **kwargs):
        """
        NonZeroDirectedOverlap(primary: MSPyBentleyGeom.DSegment1d, clipper: MSPyBentleyGeom.DSegment1d, result: MSPyBentleyGeom.DSegment1d) -> bool
        
        Find overlap of primary with clipper, treating single point
        intersection as empty. If empty or single point, return false and
        primary unchanged. If nonempty, result maintains orientation of
        primary.
        """
        ...
    
    def PointToFraction(*args, **kwargs):
        """
        PointToFraction(self: MSPyBentleyGeom.DSegment1d, point: float) -> tuple
        
        Find fractional parameter for specified coordinate.
        
        Returns:
        false if endpoints are identical.
        """
        ...
    
    def Reverse(*args, **kwargs):
        """
        Reverse(self: MSPyBentleyGeom.DSegment1d) -> MSPyBentleyGeom.DSegment1d
        
        return reverse of the instance
        """
        ...
    
    def ReverseInPlace(*args, **kwargs):
        """
        ReverseInPlace(self: MSPyBentleyGeom.DSegment1d) -> None
        
        reverse the instance in place
        """
        ...
    
    def SetEnd(*args, **kwargs):
        """
        SetEnd(self: MSPyBentleyGeom.DSegment1d, x: float) -> None
        
        Change end coordinate.
        """
        ...
    
    def SetStart(*args, **kwargs):
        """
        SetStart(self: MSPyBentleyGeom.DSegment1d, x: float) -> None
        
        Change start coordinate.
        """
        ...
    
    @property
    def Start(arg0: MSPyBentleyGeom.DSegment1d) -> float:
        ...
    @Start.setter
    def Start(arg0: MSPyBentleyGeom.DSegment1d, arg1: float) -> None:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DSegment1d) -> None
        
        2. __init__(self: MSPyBentleyGeom.DSegment1d, x: float) -> None
        
        3. __init__(self: MSPyBentleyGeom.DSegment1d, x0: float, x1: float) -> None
        """
        ...
    
class DSegment1dArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DSegment1dArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.DSegment1dArray, arg0: MSPyBentleyGeom.DSegment1dArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.DSegment1dArray, arg0: Iterable) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.DSegment1dArray, x: MSPyBentleyGeom.DSegment1d) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.DSegment1dArray) -> None
        
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.DSegment1dArray, L: MSPyBentleyGeom.DSegment1dArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.DSegment1dArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.DSegment1dArray, i: int, x: MSPyBentleyGeom.DSegment1d) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.DSegment1dArray) -> MSPyBentleyGeom.DSegment1d
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.DSegment1dArray, i: int) -> MSPyBentleyGeom.DSegment1d
        
        Remove and return the item at index ``i``
        """
        ...
    
class DSegment3d:
    """
    None
    """

    def ClosestApproachBounded(*args, **kwargs):
        """
        ClosestApproachBounded(segment0: MSPyBentleyGeom.DSegment3d, segment1: MSPyBentleyGeom.DSegment3d) -> tuple
        
        Find the closest approach of two bounded segments
        
        Parameter ``[out]``:
        fraction0 parameter on first segment.
        
        Parameter ``[out]``:
        fraction1 parameter on second segment.
        
        Parameter ``[out]``:
        point0 point on first ray.
        
        Parameter ``[out]``:
        point1 point on second ray.
        
        Parameter ``[out]``:
        segment0 first segment
        
        Parameter ``[out]``:
        segment1 second segment
        """
        ...
    
    def ClosestApproachBoundedXY(*args, **kwargs):
        """
        ClosestApproachBoundedXY(segment0: MSPyBentleyGeom.DSegment3d, segment1: MSPyBentleyGeom.DSegment3d) -> tuple
        
        Find the closest approach of two bounded segments, considering only xy
        parts of distance
        
        Parameter ``[out]``:
        fraction0 parameter on first segment
        
        Parameter ``[out]``:
        fraction1 parameter on second segment
        
        Parameter ``[out]``:
        point0 point on first ray.
        
        Parameter ``[out]``:
        point1 point on second ray.
        
        Parameter ``[out]``:
        segment0 first segment
        
        Parameter ``[out]``:
        segment1 second segment
        """
        ...
    
    def ClosestApproachUnbounded(*args, **kwargs):
        """
        ClosestApproachUnbounded(segment0: MSPyBentleyGeom.DSegment3d, segment1: MSPyBentleyGeom.DSegment3d) -> tuple
        
        Find the closest approach of two unbounded segments
        
        Parameter ``[out]``:
        fraction0 parameter on first segment.
        
        Parameter ``[out]``:
        fraction1 parameter on second segment.
        
        Parameter ``[out]``:
        point0 point on first ray.
        
        Parameter ``[out]``:
        point1 point on second ray.
        
        Parameter ``[out]``:
        segment0 first segment
        
        Parameter ``[out]``:
        segment1 second segment
        
        Returns:
        false if parallel segments
        """
        ...
    
    def ClosestPointBoundedXY(*args, **kwargs):
        """
        ClosestPointBoundedXY(*args, **kwargs)
        Overloaded function.
        
        1. ClosestPointBoundedXY(self: MSPyBentleyGeom.DSegment3d, spacePoint: MSPyBentleyGeom.DPoint3d, worldToLocal: MSPyBentleyGeom.DMatrix4d) -> tuple
        
        Find the closest point (projection or end), as viewed in xy plane,
        after applying optional transformation.
        
        Parameter ``[out]``:
        closePoint closest point, in coordinates of the input segment.
        
        Parameter ``[out]``:
        closeParam parameter at closest point
        
        Parameter ``[out]``:
        distanceXY distance in transformed coordinates
        
        Parameter ``[in]``:
        spacePoint world coordinates of test point.
        
        Parameter ``[in]``:
        worldToLocal optional transformation.
        
        2. ClosestPointBoundedXY(self: MSPyBentleyGeom.DSegment3d, spacePoint: MSPyBentleyGeom.DPoint3d, worldToLocal: MSPyBentleyGeom.DMatrix4d, extend0: bool, extend1: bool) -> tuple
        
        Find the closest point (projection or end), as viewed in xy plane,
        after applying optional transformation.
        
        Parameter ``[out]``:
        closePoint closest point, in coordinates of the input segment.
        
        Parameter ``[out]``:
        closeParam parameter at closest point
        
        Parameter ``[out]``:
        distanceXY distance in transformed coordinates
        
        Parameter ``[in]``:
        spacePoint world coordinates of test point.
        
        Parameter ``[in]``:
        worldToLocal optional transformation.
        """
        ...
    
    @property
    def EndPoint(arg0: MSPyBentleyGeom.DSegment3d) -> MSPyBentleyGeom.DPoint3d:
        ...
    @EndPoint.setter
    def EndPoint(arg0: MSPyBentleyGeom.DSegment3d, arg1: MSPyBentleyGeom.DPoint3d) -> None:
        ...
    
    def FractionParameterToPoint(*args, **kwargs):
        """
        FractionParameterToPoint(self: MSPyBentleyGeom.DSegment3d, point: MSPyBentleyGeom.DPoint3d, param: float) -> bool
        
        Parameter ``[out]``:
        point coordinates at fractional parameter.
        
        Parameter ``[in]``:
        param fractional parameter
        
        Remark:
        This is a deprecated form of FractionToPoint.
        """
        ...
    
    def FractionParameterToTangent(*args, **kwargs):
        """
        FractionParameterToTangent(self: MSPyBentleyGeom.DSegment3d, point: MSPyBentleyGeom.DPoint3d, tangent: Bentley.DVec3d, param: float) -> bool
        
        Parameter ``[out]``:
        point point on line at fractional parameter.
        
        Parameter ``[out]``:
        tangent tangent vector at fractional parameter.
        
        Parameter ``[in]``:
        param fractional parameter.
        """
        ...
    
    def FractionToLength(*args, **kwargs):
        """
        FractionToLength(self: MSPyBentleyGeom.DSegment3d, fraction0: float, fraction1: float) -> tuple
        
        Compute the (signed) arc length between specified fractional
        parameters.
        
        Parameter ``[out]``:
        arcLength computed arc length. Negative if fraction1<fraction0.
        
        Parameter ``[in]``:
        fraction0 start fraction for interval to measure.
        
        Parameter ``[in]``:
        fraction1 end fraction for interval to measure.
        
        Returns:
        true if the arc length was computed.
        """
        ...
    
    def FractionToPoint(*args, **kwargs):
        """
        FractionToPoint(self: MSPyBentleyGeom.DSegment3d, fraction: float) -> MSPyBentleyGeom.DPoint3d
        
        Returns:
        point coordinates at fractional parameter.
        
        Parameter ``[in]``:
        fraction fractional parameter
        """
        ...
    
    def GetEndPoint(*args, **kwargs):
        """
        GetEndPoint(self: MSPyBentleyGeom.DSegment3d, pt: MSPyBentleyGeom.DPoint3d) -> None
        
        Get end point from the line segment.
        
        Parameter ``[out]``:
        pt end point of object.
        """
        ...
    
    def GetEndPoints(*args, **kwargs):
        """
        GetEndPoints(self: MSPyBentleyGeom.DSegment3d, point0: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d) -> None
        
        Return the endpoints of the segment.
        
        Parameter ``[out]``:
        point0 start point
        
        Parameter ``[out]``:
        point1 end point
        """
        ...
    
    def GetPoint(*args, **kwargs):
        """
        GetPoint(self: MSPyBentleyGeom.DSegment3d, pt: MSPyBentleyGeom.DPoint3d, index: int) -> bool
        
        Parameter ``[out]``:
        pt returned point.
        
        Parameter ``[in]``:
        index index of point to return.
        """
        ...
    
    def GetRange(*args, **kwargs):
        """
        GetRange(self: MSPyBentleyGeom.DSegment3d, range: MSPyBentleyGeom.DRange3d) -> bool
        
        Parameter ``[out]``:
        range range of segment.
        
        Returns:
        always true
        """
        ...
    
    def GetStartPoint(*args, **kwargs):
        """
        GetStartPoint(self: MSPyBentleyGeom.DSegment3d, pt: MSPyBentleyGeom.DPoint3d) -> None
        
        Get start point from the line segment.
        
        Parameter ``[out]``:
        pt start point of object.
        """
        ...
    
    def InitProduct(*args, **kwargs):
        """
        InitProduct(self: MSPyBentleyGeom.DSegment3d, transform: Bentley.Transform, other: MSPyBentleyGeom.DSegment3d) -> None
        
        initialize as transform of other segment.
        """
        ...
    
    def InterpolateUniformArray(*args, **kwargs):
        """
        InterpolateUniformArray(self: MSPyBentleyGeom.DSegment3d, points: MSPyBentleyGeom.DPoint3dArray, numPoints: int) -> None
        
        Computes equidistant points along the segment.
        
        Parameter ``[out]``:
        points array of computed points
        
        Parameter ``[in]``:
        numPoints # points to compute.
        """
        ...
    
    def Intersect(*args, **kwargs):
        """
        Intersect(self: MSPyBentleyGeom.DSegment3d, point: MSPyBentleyGeom.DPlane3d) -> tuple
        
        Return the intersection of the (unbounded) segment with a plane.
        
        Parameter ``[in]``:
        intPoint intersection point
        
        Parameter ``[in]``:
        intParam parameter along the line
        
        Parameter ``[in]``:
        plane plane (origin and normal)
        
        Returns:
        false if line, plane are parallel.
        """
        ...
    
    def IntersectCircleXY(*args, **kwargs):
        """
        IntersectCircleXY(self: MSPyBentleyGeom.DSegment3d, center: MSPyBentleyGeom.DPoint3d, radius: float) -> list
        """
        ...
    
    def IntersectXY(*args, **kwargs):
        """
        IntersectXY(segment0: MSPyBentleyGeom.DSegment3d, segment1: MSPyBentleyGeom.DSegment3d) -> tuple
        
        Return the (simple, single point) intersection of two (unbounded)
        segments as viewed in XY. (z coordinates of the outputs pointA and
        pointB may differ)
        
        Parameter ``[out]``:
        fractionA fractional position on segmentA
        
        Parameter ``[out]``:
        fractionB fractional position on segmentB
        
        Parameter ``[out]``:
        pointA point on segmentA
        
        Parameter ``[out]``:
        pointB point on segmentB
        
        Parameter ``[in]``:
        segmentA first line segment.
        
        Parameter ``[in]``:
        segmentB second line segment.
        
        Returns:
        false if segments are parallel.
        """
        ...
    
    def IsAlmostEqual(*args, **kwargs):
        """
        IsAlmostEqual(self: MSPyBentleyGeom.DSegment3d, other: MSPyBentleyGeom.DSegment3d, tolerance: float) -> bool
        
        Returns:
        true if AlmostEqual endpoints
        """
        ...
    
    def IsAlmostSinglePoint(*args, **kwargs):
        """
        IsAlmostSinglePoint(self: MSPyBentleyGeom.DSegment3d) -> bool
        
        Returns:
        true if endpoint are AlmostEqual()
        """
        ...
    
    def IsSinglePoint(*args, **kwargs):
        """
        IsSinglePoint(self: MSPyBentleyGeom.DSegment3d) -> bool
        
        Returns:
        true if endpoint are identical (bitwise)
        """
        ...
    
    def Length(*args, **kwargs):
        """
        Length(self: MSPyBentleyGeom.DSegment3d) -> float
        
        Returns:
        line segment length.
        """
        ...
    
    def LengthSquared(*args, **kwargs):
        """
        LengthSquared(self: MSPyBentleyGeom.DSegment3d) -> float
        
        Returns:
        squared length of the segment.
        """
        ...
    
    def LengthToFraction(*args, **kwargs):
        """
        LengthToFraction(self: MSPyBentleyGeom.DSegment3d, fraction0: float, arcStep: float) -> tuple
        
        Compute the fraction parameter corresponding to a specified arc length
        away from a specified start fraction. (inverse of fractions to
        arcStep)
        
        Parameter ``[out]``:
        fraction1 fraction at end of interval.
        
        Parameter ``[in]``:
        fraction0 start fraction for interval to measure.
        
        Parameter ``[in]``:
        arcStep arc length to move. Negative arc length moves backwards.
        
        Returns:
        true if the fractional step was computed.
        """
        ...
    
    def PointToFractionParameter(*args, **kwargs):
        """
        PointToFractionParameter(self: MSPyBentleyGeom.DSegment3d, point: MSPyBentleyGeom.DPoint3d) -> tuple
        
        Returns the parameter at which a point projects to the
        *unbounded) line containing the segment. Parameters less than zero and
        greater than one mean the projection is outside the bounds of the line
        segment.
        
        Parameter ``[out]``:
        param fraction where point projects to the line.
        
        Parameter ``[in]``:
        point point to project to the line.
        """
        ...
    
    def ProjectPoint(*args, **kwargs):
        """
        ProjectPoint(self: MSPyBentleyGeom.DSegment3d, point: MSPyBentleyGeom.DPoint3d) -> tuple
        
        Project a point onto the extended line in 3D.
        
        Parameter ``[out]``:
        closestPoint point on extended line
        
        Parameter ``[out]``:
        closestParam parameter for closest point
        
        Parameter ``[in]``:
        point space point.
        """
        ...
    
    def ProjectPointBounded(*args, **kwargs):
        """
        ProjectPointBounded(*args, **kwargs)
        Overloaded function.
        
        1. ProjectPointBounded(self: MSPyBentleyGeom.DSegment3d, point: MSPyBentleyGeom.DPoint3d) -> tuple
        
        Project a point onto the bounded line in 3D. If nearest point of
        extended line is outside the 0..1 parameter range, returned values are
        optinally restricted to nearest endpoint.
        
        Parameter ``[out]``:
        closestPoint point on extended line
        
        Parameter ``[out]``:
        closestParam parameter for closest point
        
        Parameter ``[in]``:
        point space point.
        
        Parameter ``[in]``:
        extend0 true to extend backwards before 0
        
        Parameter ``[in]``:
        extend1 true to extend forwards from 1
        
        2. ProjectPointBounded(self: MSPyBentleyGeom.DSegment3d, point: MSPyBentleyGeom.DPoint3d, extend0: bool, extend1: bool) -> tuple
        
        Project a point onto the bounded line in 3D. If nearest point of
        extended line is outside the 0..1 parameter range, returned values are
        optinally restricted to nearest endpoint.
        
        Parameter ``[out]``:
        closestPoint point on extended line
        
        Parameter ``[out]``:
        closestParam parameter for closest point
        
        Parameter ``[in]``:
        point space point.
        
        Parameter ``[in]``:
        extend0 true to extend backwards before 0
        
        Parameter ``[in]``:
        extend1 true to extend forwards from 1
        """
        ...
    
    def ProjectPointXY(*args, **kwargs):
        """
        ProjectPointXY(self: MSPyBentleyGeom.DSegment3d, point: MSPyBentleyGeom.DPoint3d) -> tuple
        
        Project a point onto the extended line using only xy parts.
        
        Parameter ``[out]``:
        closestPoint point on extended line
        
        Parameter ``[out]``:
        closestParam parameter for closest point
        
        Parameter ``[in]``:
        point space point.
        """
        ...
    
    def ProjectedParameterRange(*args, **kwargs):
        """
        ProjectedParameterRange(self: MSPyBentleyGeom.DSegment3d, ray: MSPyBentleyGeom.DRay3d) -> MSPyBentleyGeom.DRange1d
        
        Returns:
        range when projected to fraction space of the ray
        
        Parameter ``[in]``:
        ray
        """
        ...
    
    def SetEndPoint(*args, **kwargs):
        """
        SetEndPoint(self: MSPyBentleyGeom.DSegment3d, point: MSPyBentleyGeom.DPoint3d) -> None
        
        Set the " end " point for the line segment.
        
        Parameter ``point``:
        new end point.
        """
        ...
    
    def SetPoint(*args, **kwargs):
        """
        SetPoint(self: MSPyBentleyGeom.DSegment3d, pt: MSPyBentleyGeom.DPoint3d, index: int) -> bool
        
        Parameter ``[out]``:
        pt returned point.
        
        Parameter ``[in]``:
        index index of point to return.
        """
        ...
    
    def SetStartPoint(*args, **kwargs):
        """
        SetStartPoint(self: MSPyBentleyGeom.DSegment3d, point: MSPyBentleyGeom.DPoint3d) -> None
        
        Set the " start " point for the line segment.
        
        Parameter ``point``:
        new start point.
        """
        ...
    
    @property
    def StartPoint(arg0: MSPyBentleyGeom.DSegment3d) -> MSPyBentleyGeom.DPoint3d:
        ...
    @StartPoint.setter
    def StartPoint(arg0: MSPyBentleyGeom.DSegment3d, arg1: MSPyBentleyGeom.DPoint3d) -> None:
        ...
    
    def WireCentroid(*args, **kwargs):
        """
        WireCentroid(self: MSPyBentleyGeom.DSegment3d, fraction0: float = 0.0, fraction1: float = 1.0) -> tuple
        
        Compute the length (unit density) and wire centroid. Note that a zero
        length line has zero length but the (single) coordinate is a well
        defined centroid.
        
        Parameter ``[out]``:
        length line length.
        
        Parameter ``[out]``:
        centroid centroid point.
        
        Parameter ``[in]``:
        fraction0 start fraction for interval to measure.
        
        Parameter ``[in]``:
        fraction1 end fraction for interval to measure.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DSegment3d) -> None
        
        2. __init__(self: MSPyBentleyGeom.DSegment3d, ray: MSPyBentleyGeom.DRay3d) -> None
        
        3. __init__(self: MSPyBentleyGeom.DSegment3d, x0: float, y0: float, z0: float, x1: float, y1: float, z1: float) -> None
        
        4. __init__(self: MSPyBentleyGeom.DSegment3d, point0: MSPyBentleyGeom.DPoint2d, point1: MSPyBentleyGeom.DPoint2d) -> None
        
        5. __init__(self: MSPyBentleyGeom.DSegment3d, point0: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d) -> None
        
        6. __init__(self: MSPyBentleyGeom.DSegment3d, point0: MSPyBentleyGeom.DPoint3d, tangent: MSPyBentleyGeom.DPoint3d) -> None
        
        7. __init__(self: MSPyBentleyGeom.DSegment3d, parent: MSPyBentleyGeom.DSegment3d, startFraction: float, endFraction: float) -> None
        
        8. __init__(self: MSPyBentleyGeom.DSegment3d, parent: MSPyBentleyGeom.DSegment3d, interval: MSPyBentleyGeom.DSegment1d) -> None
        """
        ...
    
    @property
    def point(arg0: MSPyBentleyGeom.DSegment3d) -> numpy.typing.NDArray:
        ...
    @point.setter
    def point(arg0: MSPyBentleyGeom.DSegment3d, arg1: numpy.typing.NDArray) -> None:
        ...
    
class DSegment3dArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DSegment3dArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.DSegment3dArray, arg0: MSPyBentleyGeom.DSegment3dArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.DSegment3dArray, arg0: Iterable) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.DSegment3dArray, x: MSPyBentleyGeom.DSegment3d) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.DSegment3dArray) -> None
        
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.DSegment3dArray, L: MSPyBentleyGeom.DSegment3dArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.DSegment3dArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.DSegment3dArray, i: int, x: MSPyBentleyGeom.DSegment3d) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.DSegment3dArray) -> MSPyBentleyGeom.DSegment3d
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.DSegment3dArray, i: int) -> MSPyBentleyGeom.DSegment3d
        
        Remove and return the item at index ``i``
        """
        ...
    
class DSpiral2dArema:
    """
    None
    """

    class ASLSACollector:
        """
        None
        """
    
        def Collect(*args, **kwargs):
            """
            Collect(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector, centerA: MSPyBentleyGeom.DPoint3d, arcToSpiralA: MSPyBentleyGeom.DPoint3d, sprialA: MSPyBentleyGeom.DSpiral2dBase, sprialToLineA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, arcToSpiralB: MSPyBentleyGeom.DPoint3d, spiralB: MSPyBentleyGeom.DSpiral2dBase, spiralToLibeB: MSPyBentleyGeom.DPoint3d) -> None
            """
            ...
        
        def __init__(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> None:
            ...
        
    def ApplyCCWRotation(*args, **kwargs):
        """
        ApplyCCWRotation(radians: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: Bentley.DVec2d, d2XYZ: Bentley.DVec2d, d3XYZ: Bentley.DVec2d) -> None
        
        rotate xy and optional derivatives by radians. (To be called by
        derived class EvaluateAtDistance when to rotate EvaluateAtDistance
        results from standard position)
        """
        ...
    
    def ArcSpiralLineSpiralArcTransition(*args, **kwargs):
        """
        ArcSpiralLineSpiralArcTransition(centerA: MSPyBentleyGeom.DPoint3d, radiusA: float, lengthA: float, centerB: MSPyBentleyGeom.DPoint3d, radiusB: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, collector: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> int
        """
        ...
    
    def Clone(*args, **kwargs):
        """
        Clone(self: MSPyBentleyGeom.DSpiral2dBase) -> MSPyBentleyGeom.DSpiral2dBase
        """
        ...
    
    def ClosestPoint(*args, **kwargs):
        """
        ClosestPoint(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, spiralToWorld: Bentley.Transform, spacePoint: MSPyBentleyGeom.DPoint3d) -> tuple
        
        Compute the closest spiral point for a given space point.
        
        Parameter ``[in]``:
        spiral spiral to evaluate.
        
        Parameter ``[in]``:
        startFraction start fraction of search range
        
        Parameter ``[in]``:
        endFraction endFraction of search range
        
        Parameter ``[in]``:
        spiralToWorld transform placing the spiral local coordinates into
        the world coordinate system
        
        Parameter ``[in]``:
        spacePoint world coordinates of space point.
        
        Parameter ``[out]``:
        spiralPoint world coordinates of closest point on spiral
        
        Parameter ``[out]``:
        spiralFraction fractional coordinates of closest point on spiral
        
        Parameter ``[out]``:
        minDistance distance from space point to spiralPoint.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def CopyBaseParameters(*args, **kwargs):
        """
        CopyBaseParameters(self: MSPyBentleyGeom.DSpiral2dBase, pSource: MSPyBentleyGeom.DSpiral2dBase) -> None
        """
        ...
    
    def CreateBearingCurvatureBearingCurvature(*args, **kwargs):
        """
        CreateBearingCurvatureBearingCurvature(*args, **kwargs)
        Overloaded function.
        
        1. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float, extraData: MSPyBentley.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def CreateBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        CreateBearingCurvatureLengthCurvature(*args, **kwargs)
        Overloaded function.
        
        1. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float, extraData: MSPyBentley.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def DefaultStrokeAngle(*args, **kwargs):
        """
        DefaultStrokeAngle() -> float
        """
        ...
    
    def DistanceToCurvature(*args, **kwargs):
        """
        DistanceToCurvature(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToCurvatureDerivative(*args, **kwargs):
        """
        DistanceToCurvatureDerivative(self: MSPyBentleyGeom.DSpiral2dBase, arg0: float) -> float
        
        distance
        """
        ...
    
    def DistanceToFraction(*args, **kwargs):
        """
        DistanceToFraction(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToGlobalAngle(*args, **kwargs):
        """
        DistanceToGlobalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToLocalAngle(*args, **kwargs):
        """
        DistanceToLocalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def EvaluateAtFraction(*args, **kwargs):
        """
        EvaluateAtFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: Bentley.DVec2d, d2XYZ: Bentley.DVec2d, d3XYZ: Bentley.DVec2d) -> bool
        
        Evaluate the spiral and derivatives at specified fractional position
        return true if valid evaluation. DSpiral2dDirectEvaluation default
        implementation returns false.
        """
        ...
    
    def EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(*args, **kwargs):
        """
        EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(s: float, length: float, curvature1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: Bentley.DVec2d, d2XY: Bentley.DVec2d, d3XY: Bentley.DVec2d) -> bool
        
        [in] distance for evaluation [in] nominal length. ASSUMED NONZERO [in]
        exit curvature. ASSUMED NONZERO [out] coordinates on spiral [out]
        first derivative wrt distance [out] second derivative wrt distance
        [out] third derivative wrt distance
        """
        ...
    
    def EvaluateVectorIntegrand(*args, **kwargs):
        """
        EvaluateVectorIntegrand(self: MSPyBentleyGeom.DSpiral2dBase, distance: float, pF: float) -> None
        """
        ...
    
    def FractionToCurvature(*args, **kwargs):
        """
        FractionToCurvature(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float
        
        Return the true curvature at fractional position. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDCurvatureDFraction(*args, **kwargs):
        """
        FractionToDCurvatureDFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> tuple
        
        Return the true curvature derivative wrt fraction. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDerivatives(*args, **kwargs):
        """
        FractionToDerivatives(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float, dXdf: Bentley.DVec2d, ddXdfdf: Bentley.DVec2d, dddXdfdfdf: Bentley.DVec2d) -> bool
        """
        ...
    
    def FractionToDistance(*args, **kwargs):
        """
        FractionToDistance(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float) -> float
        """
        ...
    
    def FractionToLocalAngle(*args, **kwargs):
        """
        FractionToLocalAngle(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float
        
        Return the tangent angle (in radians) in local coordinates
        """
        ...
    
    def FractionToVelocity(*args, **kwargs):
        """
        FractionToVelocity(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float
        
        Return the magnitude of the true derivative of position wrt fraction.
        Implemented in DSpiral2dDirectEvaluation, not individual classes.
        Assume EvaluateAtFraction.
        """
        ...
    
    def GetExtraData(*args, **kwargs):
        """
        GetExtraData(self: MSPyBentleyGeom.DSpiral2dBase, extraData: MSPyBentley.DoubleArray) -> None
        
        Get the extra data for this spiral. REMARK:This should be a virtual,
        but is implemented as special cases because of API change restriction
        """
        ...
    
    def GetIntervalCount(*args, **kwargs):
        """
        GetIntervalCount(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, minInterval: int = 0, maxStrokeLength: float = 10000.0) -> int
        
        Return an interval count for stroking or integration. Except for
        degenerate single interval cases, the interval count is always even.
        That is the possible values are
        
        Parameter ``[in]``:
        spiral spiral being queried.
        
        Parameter ``[in]``:
        startFraction start of interval to stroke.
        
        Parameter ``[in]``:
        endFraction end of interval to stroke.
        
        Parameter ``[in]``:
        maxRadians max turn between strokes.
        
        Parameter ``[in]``:
        minInterval smallest number of intervals.
        
        Parameter ``[in]``:
        maxStrokeLength largest stroke size. Recommended 10 meters
        """
        ...
    
    def GetTransitionTypeCode(*args, **kwargs):
        """
        GetTransitionTypeCode(self: MSPyBentleyGeom.DSpiral2dBase) -> int
        """
        ...
    
    def GetVectorIntegrandCount(*args, **kwargs):
        """
        GetVectorIntegrandCount(self: MSPyBentleyGeom.DSpiral2dBase) -> int
        """
        ...
    
    def IsValidRLCombination(*args, **kwargs):
        """
        IsValidRLCombination(lengthFromInflection: float, radius: float, spiralType: int = 0) -> bool
        
        test if a length-from-inflection and final radius
        combination is " small enough " for reasonable use. Test depends on
        spiral type:
        
        * DSpiral2dBase.TransitionType_None indicates apply the strictest
        test (same as Czech and Italian)
        
        * DSpiral2dBase.TransitionType_Czech and
        DSpiral2dBase.TransitionType_Italian indicate a strict test L<2*R
        
        * other types have no restrictions.
        
        Parameter ``[in]``:
        lengthFromInflection [in] distance along spiral starting at
        inflection and ending at finalRadius.
        
        Parameter ``[in]``:
        finalRadius [in] final radius
        
        Parameter ``[in]``:
        spiralType [in] spiral type.
        
        Parameter ``[in]``:
        lengthFactor expansion or reduction factor to apply to the allowed
        length. +---------------+---------------+---------------+---------
        ------+------
        """
        ...
    
    def LineSpiralArcSpiralLineTransition(*args, **kwargs):
        """
        LineSpiralArcSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, radius: float, lengthA: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralAToArc: MSPyBentleyGeom.DPoint3d, spiralBToArc: MSPyBentleyGeom.DPoint3d, arc: MSPyBentleyGeom.DEllipse3d) -> bool
        
        compute spirals and arc to make a line-to-line
        transition.
        
        Parameter ``[in]``:
        lineAPoint point on line A.
        
        Parameter ``[in]``:
        lineBPoint point on line B.
        
        Parameter ``[in]``:
        lineLineIntersection intersection of lines.
        
        Parameter ``[in]``:
        radius radius for circular part of transition.
        
        Parameter ``[in]``:
        lengthA length of spiral from line A to circle.
        
        Parameter ``[in]``:
        lengthB length of spiral from line B to circle.
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        lineToSpiralA tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralAToArc tangency point from spiral to arc
        
        Parameter ``[out]``:
        lineToSpiralB tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralBToArc tangency point from spiral to arc
        
        Parameter ``[out]``:
        arc arc between spirals.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def ScaleInPlace(*args, **kwargs):
        """
        ScaleInPlace(self: MSPyBentleyGeom.DSpiral2dBase, s: float) -> bool
        """
        ...
    
    def SetBearingAndCurvatureLimits(*args, **kwargs):
        """
        SetBearingAndCurvatureLimits(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, theta1: float, curvature1: float) -> bool
        """
        ...
    
    def SetBearingCurvatureLengthBearing(*args, **kwargs):
        """
        SetBearingCurvatureLengthBearing(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, theta1: float) -> bool
        
        Set start bearing, start curvature, length, and end
        curvature. (Compute end bearing)
        
        Parameter ``[in]``:
        theta0 start bearing
        
        Parameter ``[in]``:
        curvature0 start curvature
        
        Parameter ``[in]``:
        length arc length
        
        Parameter ``[in]``:
        theta1 end bearing
        """
        ...
    
    def SetBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        SetBearingCurvatureLengthCurvature(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, curvature1: float) -> bool
        """
        ...
    
    def StringToTransitionType(*args, **kwargs):
        """
        StringToTransitionType(name: str) -> int
        
        return the integer code for the string name.
        """
        ...
    
    def Stroke(*args, **kwargs):
        """
        Stroke(*args, **kwargs)
        Overloaded function.
        
        1. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, pDXY: Bentley.DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        2. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, xyz0: MSPyBentleyGeom.DPoint3d, pXYZ: MSPyBentleyGeom.DPoint3d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        3. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: Bentley.DVec2d) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        4. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: Bentley.DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        5. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: Bentley.DVec2d, pFraction: float, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        6. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: Bentley.DVec2d, maxStrokeLength: float) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        7. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, uvPoints: Bentley.Bstdcxx.bvector<Bentley.DVec2d,Bentley.BentleyAllocator<Bentley.DVec2d> >, fractions: MSPyBentley.DoubleArray, maxStrokeLength: float = 10000.0) -> tuple
        """
        ...
    
    def StrokeToAnnouncer(*args, **kwargs):
        """
        StrokeToAnnouncer(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, F: MSPyBentleyGeom.AnnounceDoubleDPoint2d, minIndex: int = 0, maxStrokeLength: float = 10000.0) -> tuple
        
        Integrate the vector displacements of a clothoid over a
        fractional interval. This uses the angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        startFraction start fraction for integral.
        
        Parameter ``[in]``:
        endFraction end fraction for integral.
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points. A
        default is used if 0.0 is passed.
        
        Parameter ``[in]``:
        F object with a method F->Announce (f, uv) called to announce
        fraction and coordinate as computed.
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Parameter ``[out]``:
        minInterval smallest number of intervals allowed
        
        Parameter ``[out]``:
        maxStrokeLength maximum allowed stroke length
        
        Returns:
        false if point integration failed
        """
        ...
    
    def SymmetricLineSpiralSpiralLineTransition(*args, **kwargs):
        """
        SymmetricLineSpiralSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, length: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralToSpiral: MSPyBentleyGeom.DPoint3d) -> tuple
        
        compute spirals and arc to make a line-to-line
        transition.
        
        Parameter ``[in]``:
        lineAPoint point on line A.
        
        Parameter ``[in]``:
        lineBPoint point on line B.
        
        Parameter ``[in]``:
        lineLineIntersection intersection of lines.
        
        Parameter ``[in]``:
        length length of spiral from line A to junction
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        lineToSpiralA tangency point from line to spiral
        
        Parameter ``[out]``:
        lineToSpiralB tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralToSpiral tangency point from spiral to to spiral
        
        Parameter ``[out]``:
        junctionRadius radius at transition between the spirals.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def SymmetricPointShoulderTargetTransition(*args, **kwargs):
        """
        SymmetricPointShoulderTargetTransition(startPoint: MSPyBentleyGeom.DPoint2d, shoulderPoint: MSPyBentleyGeom.DPoint2d, targetPoint: MSPyBentleyGeom.DPoint2d, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, junctionPoint: MSPyBentleyGeom.DPoint2d, endPoint: MSPyBentleyGeom.DPoint2d) -> bool
        
        compute 2 spirals.
        
        Parameter ``[in]``:
        startPoint start point
        
        Parameter ``[in]``:
        shoulderPoint target point for first and last tangents
        
        Parameter ``[in]``:
        targetPoint target point for last tangent
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        junctionPoint transition between spirals. This is the max
        curvature point.
        
        Parameter ``[out]``:
        endPoint end of second spiral.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def TransitionTypeToString(*args, **kwargs):
        """
        TransitionTypeToString(type: int) -> str
        
        return the string name of the type
        """
        ...
    
    TransitionType_Arema: int
    
    TransitionType_AustralianRailCorp: int
    
    TransitionType_Biquadratic: int
    
    TransitionType_Bloss: int
    
    TransitionType_ChineseCubic: int
    
    TransitionType_Clothoid: int
    
    TransitionType_Cosine: int
    
    TransitionType_Czech: int
    
    TransitionType_CzechAlongTangent: int
    
    TransitionType_DirectHalfCosine: int
    
    TransitionType_FirstDirectEvaluate: int
    
    TransitionType_Italian: int
    
    TransitionType_JapaneseCubic: int
    
    TransitionType_MXCubicAlongArc: int
    
    TransitionType_MXCubicAlongTangent: int
    
    TransitionType_PolishCubic: int
    
    TransitionType_Sine: int
    
    TransitionType_Unknown: int
    
    TransitionType_Viennese: int
    
    TransitionType_WeightedViennese: int
    
    TransitionType_WesternAustralian: int
    
    def VectorIntegrandCount(*args, **kwargs):
        """
        VectorIntegrandCount(self: MSPyBentleyGeom.BSIVectorIntegrand) -> int
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.DSpiral2dArema, nominalLength: float) -> None:
        ...
    
class DSpiral2dAustralianRailCorp:
    """
    None
    """

    class ASLSACollector:
        """
        None
        """
    
        def Collect(*args, **kwargs):
            """
            Collect(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector, centerA: MSPyBentleyGeom.DPoint3d, arcToSpiralA: MSPyBentleyGeom.DPoint3d, sprialA: MSPyBentleyGeom.DSpiral2dBase, sprialToLineA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, arcToSpiralB: MSPyBentleyGeom.DPoint3d, spiralB: MSPyBentleyGeom.DSpiral2dBase, spiralToLibeB: MSPyBentleyGeom.DPoint3d) -> None
            """
            ...
        
        def __init__(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> None:
            ...
        
    def ApplyCCWRotation(*args, **kwargs):
        """
        ApplyCCWRotation(radians: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: Bentley.DVec2d, d2XYZ: Bentley.DVec2d, d3XYZ: Bentley.DVec2d) -> None
        
        rotate xy and optional derivatives by radians. (To be called by
        derived class EvaluateAtDistance when to rotate EvaluateAtDistance
        results from standard position)
        """
        ...
    
    def ArcSpiralLineSpiralArcTransition(*args, **kwargs):
        """
        ArcSpiralLineSpiralArcTransition(centerA: MSPyBentleyGeom.DPoint3d, radiusA: float, lengthA: float, centerB: MSPyBentleyGeom.DPoint3d, radiusB: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, collector: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> int
        """
        ...
    
    def Clone(*args, **kwargs):
        """
        Clone(self: MSPyBentleyGeom.DSpiral2dBase) -> MSPyBentleyGeom.DSpiral2dBase
        """
        ...
    
    def ClosestPoint(*args, **kwargs):
        """
        ClosestPoint(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, spiralToWorld: Bentley.Transform, spacePoint: MSPyBentleyGeom.DPoint3d) -> tuple
        
        Compute the closest spiral point for a given space point.
        
        Parameter ``[in]``:
        spiral spiral to evaluate.
        
        Parameter ``[in]``:
        startFraction start fraction of search range
        
        Parameter ``[in]``:
        endFraction endFraction of search range
        
        Parameter ``[in]``:
        spiralToWorld transform placing the spiral local coordinates into
        the world coordinate system
        
        Parameter ``[in]``:
        spacePoint world coordinates of space point.
        
        Parameter ``[out]``:
        spiralPoint world coordinates of closest point on spiral
        
        Parameter ``[out]``:
        spiralFraction fractional coordinates of closest point on spiral
        
        Parameter ``[out]``:
        minDistance distance from space point to spiralPoint.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def CopyBaseParameters(*args, **kwargs):
        """
        CopyBaseParameters(self: MSPyBentleyGeom.DSpiral2dBase, pSource: MSPyBentleyGeom.DSpiral2dBase) -> None
        """
        ...
    
    def CreateBearingCurvatureBearingCurvature(*args, **kwargs):
        """
        CreateBearingCurvatureBearingCurvature(*args, **kwargs)
        Overloaded function.
        
        1. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float, extraData: MSPyBentley.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def CreateBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        CreateBearingCurvatureLengthCurvature(*args, **kwargs)
        Overloaded function.
        
        1. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float, extraData: MSPyBentley.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def DefaultStrokeAngle(*args, **kwargs):
        """
        DefaultStrokeAngle() -> float
        """
        ...
    
    def DistanceToCurvature(*args, **kwargs):
        """
        DistanceToCurvature(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToCurvatureDerivative(*args, **kwargs):
        """
        DistanceToCurvatureDerivative(self: MSPyBentleyGeom.DSpiral2dBase, arg0: float) -> float
        
        distance
        """
        ...
    
    def DistanceToFraction(*args, **kwargs):
        """
        DistanceToFraction(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToGlobalAngle(*args, **kwargs):
        """
        DistanceToGlobalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToLocalAngle(*args, **kwargs):
        """
        DistanceToLocalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def EvaluateAtFraction(*args, **kwargs):
        """
        EvaluateAtFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: Bentley.DVec2d, d2XYZ: Bentley.DVec2d, d3XYZ: Bentley.DVec2d) -> bool
        
        Evaluate the spiral and derivatives at specified fractional position
        return true if valid evaluation. DSpiral2dDirectEvaluation default
        implementation returns false.
        """
        ...
    
    def EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(*args, **kwargs):
        """
        EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(s: float, length: float, curvature1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: Bentley.DVec2d, d2XY: Bentley.DVec2d, d3XY: Bentley.DVec2d) -> bool
        
        [in] distance for evaluation [in] nominal length. ASSUMED NONZERO [in]
        exit curvature. ASSUMED NONZERO [out] coordinates on spiral [out]
        first derivative wrt distance [out] second derivative wrt distance
        [out] third derivative wrt distance
        """
        ...
    
    def EvaluateVectorIntegrand(*args, **kwargs):
        """
        EvaluateVectorIntegrand(self: MSPyBentleyGeom.DSpiral2dBase, distance: float, pF: float) -> None
        """
        ...
    
    def FractionToCurvature(*args, **kwargs):
        """
        FractionToCurvature(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float
        
        Return the true curvature at fractional position. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDCurvatureDFraction(*args, **kwargs):
        """
        FractionToDCurvatureDFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> tuple
        
        Return the true curvature derivative wrt fraction. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDerivatives(*args, **kwargs):
        """
        FractionToDerivatives(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float, dXdf: Bentley.DVec2d, ddXdfdf: Bentley.DVec2d, dddXdfdfdf: Bentley.DVec2d) -> bool
        """
        ...
    
    def FractionToDistance(*args, **kwargs):
        """
        FractionToDistance(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float) -> float
        """
        ...
    
    def FractionToLocalAngle(*args, **kwargs):
        """
        FractionToLocalAngle(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float
        
        Return the tangent angle (in radians) in local coordinates
        """
        ...
    
    def FractionToVelocity(*args, **kwargs):
        """
        FractionToVelocity(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float
        
        Return the magnitude of the true derivative of position wrt fraction.
        Implemented in DSpiral2dDirectEvaluation, not individual classes.
        Assume EvaluateAtFraction.
        """
        ...
    
    def GetExtraData(*args, **kwargs):
        """
        GetExtraData(self: MSPyBentleyGeom.DSpiral2dBase, extraData: MSPyBentley.DoubleArray) -> None
        
        Get the extra data for this spiral. REMARK:This should be a virtual,
        but is implemented as special cases because of API change restriction
        """
        ...
    
    def GetIntervalCount(*args, **kwargs):
        """
        GetIntervalCount(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, minInterval: int = 0, maxStrokeLength: float = 10000.0) -> int
        
        Return an interval count for stroking or integration. Except for
        degenerate single interval cases, the interval count is always even.
        That is the possible values are
        
        Parameter ``[in]``:
        spiral spiral being queried.
        
        Parameter ``[in]``:
        startFraction start of interval to stroke.
        
        Parameter ``[in]``:
        endFraction end of interval to stroke.
        
        Parameter ``[in]``:
        maxRadians max turn between strokes.
        
        Parameter ``[in]``:
        minInterval smallest number of intervals.
        
        Parameter ``[in]``:
        maxStrokeLength largest stroke size. Recommended 10 meters
        """
        ...
    
    def GetTransitionTypeCode(*args, **kwargs):
        """
        GetTransitionTypeCode(self: MSPyBentleyGeom.DSpiral2dBase) -> int
        """
        ...
    
    def GetVectorIntegrandCount(*args, **kwargs):
        """
        GetVectorIntegrandCount(self: MSPyBentleyGeom.DSpiral2dBase) -> int
        """
        ...
    
    def IsValidRLCombination(*args, **kwargs):
        """
        IsValidRLCombination(lengthFromInflection: float, radius: float, spiralType: int = 0) -> bool
        
        test if a length-from-inflection and final radius
        combination is " small enough " for reasonable use. Test depends on
        spiral type:
        
        * DSpiral2dBase.TransitionType_None indicates apply the strictest
        test (same as Czech and Italian)
        
        * DSpiral2dBase.TransitionType_Czech and
        DSpiral2dBase.TransitionType_Italian indicate a strict test L<2*R
        
        * other types have no restrictions.
        
        Parameter ``[in]``:
        lengthFromInflection [in] distance along spiral starting at
        inflection and ending at finalRadius.
        
        Parameter ``[in]``:
        finalRadius [in] final radius
        
        Parameter ``[in]``:
        spiralType [in] spiral type.
        
        Parameter ``[in]``:
        lengthFactor expansion or reduction factor to apply to the allowed
        length. +---------------+---------------+---------------+---------
        ------+------
        """
        ...
    
    def LineSpiralArcSpiralLineTransition(*args, **kwargs):
        """
        LineSpiralArcSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, radius: float, lengthA: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralAToArc: MSPyBentleyGeom.DPoint3d, spiralBToArc: MSPyBentleyGeom.DPoint3d, arc: MSPyBentleyGeom.DEllipse3d) -> bool
        
        compute spirals and arc to make a line-to-line
        transition.
        
        Parameter ``[in]``:
        lineAPoint point on line A.
        
        Parameter ``[in]``:
        lineBPoint point on line B.
        
        Parameter ``[in]``:
        lineLineIntersection intersection of lines.
        
        Parameter ``[in]``:
        radius radius for circular part of transition.
        
        Parameter ``[in]``:
        lengthA length of spiral from line A to circle.
        
        Parameter ``[in]``:
        lengthB length of spiral from line B to circle.
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        lineToSpiralA tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralAToArc tangency point from spiral to arc
        
        Parameter ``[out]``:
        lineToSpiralB tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralBToArc tangency point from spiral to arc
        
        Parameter ``[out]``:
        arc arc between spirals.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def ScaleInPlace(*args, **kwargs):
        """
        ScaleInPlace(self: MSPyBentleyGeom.DSpiral2dBase, s: float) -> bool
        """
        ...
    
    def SetBearingAndCurvatureLimits(*args, **kwargs):
        """
        SetBearingAndCurvatureLimits(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, theta1: float, curvature1: float) -> bool
        """
        ...
    
    def SetBearingCurvatureLengthBearing(*args, **kwargs):
        """
        SetBearingCurvatureLengthBearing(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, theta1: float) -> bool
        
        Set start bearing, start curvature, length, and end
        curvature. (Compute end bearing)
        
        Parameter ``[in]``:
        theta0 start bearing
        
        Parameter ``[in]``:
        curvature0 start curvature
        
        Parameter ``[in]``:
        length arc length
        
        Parameter ``[in]``:
        theta1 end bearing
        """
        ...
    
    def SetBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        SetBearingCurvatureLengthCurvature(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, curvature1: float) -> bool
        """
        ...
    
    def StringToTransitionType(*args, **kwargs):
        """
        StringToTransitionType(name: str) -> int
        
        return the integer code for the string name.
        """
        ...
    
    def Stroke(*args, **kwargs):
        """
        Stroke(*args, **kwargs)
        Overloaded function.
        
        1. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, pDXY: Bentley.DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        2. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, xyz0: MSPyBentleyGeom.DPoint3d, pXYZ: MSPyBentleyGeom.DPoint3d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        3. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: Bentley.DVec2d) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        4. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: Bentley.DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        5. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: Bentley.DVec2d, pFraction: float, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        6. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: Bentley.DVec2d, maxStrokeLength: float) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        7. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, uvPoints: Bentley.Bstdcxx.bvector<Bentley.DVec2d,Bentley.BentleyAllocator<Bentley.DVec2d> >, fractions: MSPyBentley.DoubleArray, maxStrokeLength: float = 10000.0) -> tuple
        """
        ...
    
    def StrokeToAnnouncer(*args, **kwargs):
        """
        StrokeToAnnouncer(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, F: MSPyBentleyGeom.AnnounceDoubleDPoint2d, minIndex: int = 0, maxStrokeLength: float = 10000.0) -> tuple
        
        Integrate the vector displacements of a clothoid over a
        fractional interval. This uses the angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        startFraction start fraction for integral.
        
        Parameter ``[in]``:
        endFraction end fraction for integral.
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points. A
        default is used if 0.0 is passed.
        
        Parameter ``[in]``:
        F object with a method F->Announce (f, uv) called to announce
        fraction and coordinate as computed.
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Parameter ``[out]``:
        minInterval smallest number of intervals allowed
        
        Parameter ``[out]``:
        maxStrokeLength maximum allowed stroke length
        
        Returns:
        false if point integration failed
        """
        ...
    
    def SymmetricLineSpiralSpiralLineTransition(*args, **kwargs):
        """
        SymmetricLineSpiralSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, length: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralToSpiral: MSPyBentleyGeom.DPoint3d) -> tuple
        
        compute spirals and arc to make a line-to-line
        transition.
        
        Parameter ``[in]``:
        lineAPoint point on line A.
        
        Parameter ``[in]``:
        lineBPoint point on line B.
        
        Parameter ``[in]``:
        lineLineIntersection intersection of lines.
        
        Parameter ``[in]``:
        length length of spiral from line A to junction
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        lineToSpiralA tangency point from line to spiral
        
        Parameter ``[out]``:
        lineToSpiralB tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralToSpiral tangency point from spiral to to spiral
        
        Parameter ``[out]``:
        junctionRadius radius at transition between the spirals.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def SymmetricPointShoulderTargetTransition(*args, **kwargs):
        """
        SymmetricPointShoulderTargetTransition(startPoint: MSPyBentleyGeom.DPoint2d, shoulderPoint: MSPyBentleyGeom.DPoint2d, targetPoint: MSPyBentleyGeom.DPoint2d, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, junctionPoint: MSPyBentleyGeom.DPoint2d, endPoint: MSPyBentleyGeom.DPoint2d) -> bool
        
        compute 2 spirals.
        
        Parameter ``[in]``:
        startPoint start point
        
        Parameter ``[in]``:
        shoulderPoint target point for first and last tangents
        
        Parameter ``[in]``:
        targetPoint target point for last tangent
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        junctionPoint transition between spirals. This is the max
        curvature point.
        
        Parameter ``[out]``:
        endPoint end of second spiral.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def TransitionTypeToString(*args, **kwargs):
        """
        TransitionTypeToString(type: int) -> str
        
        return the string name of the type
        """
        ...
    
    TransitionType_Arema: int
    
    TransitionType_AustralianRailCorp: int
    
    TransitionType_Biquadratic: int
    
    TransitionType_Bloss: int
    
    TransitionType_ChineseCubic: int
    
    TransitionType_Clothoid: int
    
    TransitionType_Cosine: int
    
    TransitionType_Czech: int
    
    TransitionType_CzechAlongTangent: int
    
    TransitionType_DirectHalfCosine: int
    
    TransitionType_FirstDirectEvaluate: int
    
    TransitionType_Italian: int
    
    TransitionType_JapaneseCubic: int
    
    TransitionType_MXCubicAlongArc: int
    
    TransitionType_MXCubicAlongTangent: int
    
    TransitionType_PolishCubic: int
    
    TransitionType_Sine: int
    
    TransitionType_Unknown: int
    
    TransitionType_Viennese: int
    
    TransitionType_WeightedViennese: int
    
    TransitionType_WesternAustralian: int
    
    def VectorIntegrandCount(*args, **kwargs):
        """
        VectorIntegrandCount(self: MSPyBentleyGeom.BSIVectorIntegrand) -> int
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.DSpiral2dAustralianRailCorp, nominalLength: float) -> None:
        ...
    
class DSpiral2dBase:
    """
    None
    """

    class ASLSACollector:
        """
        None
        """
    
        def Collect(*args, **kwargs):
            """
            Collect(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector, centerA: MSPyBentleyGeom.DPoint3d, arcToSpiralA: MSPyBentleyGeom.DPoint3d, sprialA: MSPyBentleyGeom.DSpiral2dBase, sprialToLineA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, arcToSpiralB: MSPyBentleyGeom.DPoint3d, spiralB: MSPyBentleyGeom.DSpiral2dBase, spiralToLibeB: MSPyBentleyGeom.DPoint3d) -> None
            """
            ...
        
        def __init__(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> None:
            ...
        
    def ArcSpiralLineSpiralArcTransition(*args, **kwargs):
        """
        ArcSpiralLineSpiralArcTransition(centerA: MSPyBentleyGeom.DPoint3d, radiusA: float, lengthA: float, centerB: MSPyBentleyGeom.DPoint3d, radiusB: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, collector: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> int
        """
        ...
    
    def Clone(*args, **kwargs):
        """
        Clone(self: MSPyBentleyGeom.DSpiral2dBase) -> MSPyBentleyGeom.DSpiral2dBase
        """
        ...
    
    def ClosestPoint(*args, **kwargs):
        """
        ClosestPoint(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, spiralToWorld: Bentley.Transform, spacePoint: MSPyBentleyGeom.DPoint3d) -> tuple
        
        Compute the closest spiral point for a given space point.
        
        Parameter ``[in]``:
        spiral spiral to evaluate.
        
        Parameter ``[in]``:
        startFraction start fraction of search range
        
        Parameter ``[in]``:
        endFraction endFraction of search range
        
        Parameter ``[in]``:
        spiralToWorld transform placing the spiral local coordinates into
        the world coordinate system
        
        Parameter ``[in]``:
        spacePoint world coordinates of space point.
        
        Parameter ``[out]``:
        spiralPoint world coordinates of closest point on spiral
        
        Parameter ``[out]``:
        spiralFraction fractional coordinates of closest point on spiral
        
        Parameter ``[out]``:
        minDistance distance from space point to spiralPoint.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def CopyBaseParameters(*args, **kwargs):
        """
        CopyBaseParameters(self: MSPyBentleyGeom.DSpiral2dBase, pSource: MSPyBentleyGeom.DSpiral2dBase) -> None
        """
        ...
    
    def CreateBearingCurvatureBearingCurvature(*args, **kwargs):
        """
        CreateBearingCurvatureBearingCurvature(*args, **kwargs)
        Overloaded function.
        
        1. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float, extraData: MSPyBentley.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def CreateBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        CreateBearingCurvatureLengthCurvature(*args, **kwargs)
        Overloaded function.
        
        1. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float, extraData: MSPyBentley.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def DefaultStrokeAngle(*args, **kwargs):
        """
        DefaultStrokeAngle() -> float
        """
        ...
    
    def DistanceToCurvature(*args, **kwargs):
        """
        DistanceToCurvature(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToCurvatureDerivative(*args, **kwargs):
        """
        DistanceToCurvatureDerivative(self: MSPyBentleyGeom.DSpiral2dBase, arg0: float) -> float
        
        distance
        """
        ...
    
    def DistanceToFraction(*args, **kwargs):
        """
        DistanceToFraction(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToGlobalAngle(*args, **kwargs):
        """
        DistanceToGlobalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToLocalAngle(*args, **kwargs):
        """
        DistanceToLocalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(*args, **kwargs):
        """
        EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(s: float, length: float, curvature1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: Bentley.DVec2d, d2XY: Bentley.DVec2d, d3XY: Bentley.DVec2d) -> bool
        
        [in] distance for evaluation [in] nominal length. ASSUMED NONZERO [in]
        exit curvature. ASSUMED NONZERO [out] coordinates on spiral [out]
        first derivative wrt distance [out] second derivative wrt distance
        [out] third derivative wrt distance
        """
        ...
    
    def EvaluateVectorIntegrand(*args, **kwargs):
        """
        EvaluateVectorIntegrand(self: MSPyBentleyGeom.DSpiral2dBase, distance: float, pF: float) -> None
        """
        ...
    
    def FractionToDerivatives(*args, **kwargs):
        """
        FractionToDerivatives(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float, dXdf: Bentley.DVec2d, ddXdfdf: Bentley.DVec2d, dddXdfdfdf: Bentley.DVec2d) -> bool
        """
        ...
    
    def FractionToDistance(*args, **kwargs):
        """
        FractionToDistance(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float) -> float
        """
        ...
    
    def GetExtraData(*args, **kwargs):
        """
        GetExtraData(self: MSPyBentleyGeom.DSpiral2dBase, extraData: MSPyBentley.DoubleArray) -> None
        
        Get the extra data for this spiral. REMARK:This should be a virtual,
        but is implemented as special cases because of API change restriction
        """
        ...
    
    def GetIntervalCount(*args, **kwargs):
        """
        GetIntervalCount(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, minInterval: int = 0, maxStrokeLength: float = 10000.0) -> int
        
        Return an interval count for stroking or integration. Except for
        degenerate single interval cases, the interval count is always even.
        That is the possible values are
        
        Parameter ``[in]``:
        spiral spiral being queried.
        
        Parameter ``[in]``:
        startFraction start of interval to stroke.
        
        Parameter ``[in]``:
        endFraction end of interval to stroke.
        
        Parameter ``[in]``:
        maxRadians max turn between strokes.
        
        Parameter ``[in]``:
        minInterval smallest number of intervals.
        
        Parameter ``[in]``:
        maxStrokeLength largest stroke size. Recommended 10 meters
        """
        ...
    
    def GetTransitionTypeCode(*args, **kwargs):
        """
        GetTransitionTypeCode(self: MSPyBentleyGeom.DSpiral2dBase) -> int
        """
        ...
    
    def GetVectorIntegrandCount(*args, **kwargs):
        """
        GetVectorIntegrandCount(self: MSPyBentleyGeom.DSpiral2dBase) -> int
        """
        ...
    
    def IsValidRLCombination(*args, **kwargs):
        """
        IsValidRLCombination(lengthFromInflection: float, radius: float, spiralType: int = 0) -> bool
        
        test if a length-from-inflection and final radius
        combination is " small enough " for reasonable use. Test depends on
        spiral type:
        
        * DSpiral2dBase.TransitionType_None indicates apply the strictest
        test (same as Czech and Italian)
        
        * DSpiral2dBase.TransitionType_Czech and
        DSpiral2dBase.TransitionType_Italian indicate a strict test L<2*R
        
        * other types have no restrictions.
        
        Parameter ``[in]``:
        lengthFromInflection [in] distance along spiral starting at
        inflection and ending at finalRadius.
        
        Parameter ``[in]``:
        finalRadius [in] final radius
        
        Parameter ``[in]``:
        spiralType [in] spiral type.
        
        Parameter ``[in]``:
        lengthFactor expansion or reduction factor to apply to the allowed
        length. +---------------+---------------+---------------+---------
        ------+------
        """
        ...
    
    def LineSpiralArcSpiralLineTransition(*args, **kwargs):
        """
        LineSpiralArcSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, radius: float, lengthA: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralAToArc: MSPyBentleyGeom.DPoint3d, spiralBToArc: MSPyBentleyGeom.DPoint3d, arc: MSPyBentleyGeom.DEllipse3d) -> bool
        
        compute spirals and arc to make a line-to-line
        transition.
        
        Parameter ``[in]``:
        lineAPoint point on line A.
        
        Parameter ``[in]``:
        lineBPoint point on line B.
        
        Parameter ``[in]``:
        lineLineIntersection intersection of lines.
        
        Parameter ``[in]``:
        radius radius for circular part of transition.
        
        Parameter ``[in]``:
        lengthA length of spiral from line A to circle.
        
        Parameter ``[in]``:
        lengthB length of spiral from line B to circle.
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        lineToSpiralA tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralAToArc tangency point from spiral to arc
        
        Parameter ``[out]``:
        lineToSpiralB tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralBToArc tangency point from spiral to arc
        
        Parameter ``[out]``:
        arc arc between spirals.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def ScaleInPlace(*args, **kwargs):
        """
        ScaleInPlace(self: MSPyBentleyGeom.DSpiral2dBase, s: float) -> bool
        """
        ...
    
    def SetBearingAndCurvatureLimits(*args, **kwargs):
        """
        SetBearingAndCurvatureLimits(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, theta1: float, curvature1: float) -> bool
        """
        ...
    
    def SetBearingCurvatureLengthBearing(*args, **kwargs):
        """
        SetBearingCurvatureLengthBearing(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, theta1: float) -> bool
        
        Set start bearing, start curvature, length, and end
        curvature. (Compute end bearing)
        
        Parameter ``[in]``:
        theta0 start bearing
        
        Parameter ``[in]``:
        curvature0 start curvature
        
        Parameter ``[in]``:
        length arc length
        
        Parameter ``[in]``:
        theta1 end bearing
        """
        ...
    
    def SetBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        SetBearingCurvatureLengthCurvature(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, curvature1: float) -> bool
        """
        ...
    
    def StringToTransitionType(*args, **kwargs):
        """
        StringToTransitionType(name: str) -> int
        
        return the integer code for the string name.
        """
        ...
    
    def Stroke(*args, **kwargs):
        """
        Stroke(*args, **kwargs)
        Overloaded function.
        
        1. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, pDXY: Bentley.DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        2. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, xyz0: MSPyBentleyGeom.DPoint3d, pXYZ: MSPyBentleyGeom.DPoint3d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        3. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: Bentley.DVec2d) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        4. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: Bentley.DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        5. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: Bentley.DVec2d, pFraction: float, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        6. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: Bentley.DVec2d, maxStrokeLength: float) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        7. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, uvPoints: Bentley.Bstdcxx.bvector<Bentley.DVec2d,Bentley.BentleyAllocator<Bentley.DVec2d> >, fractions: MSPyBentley.DoubleArray, maxStrokeLength: float = 10000.0) -> tuple
        """
        ...
    
    def StrokeToAnnouncer(*args, **kwargs):
        """
        StrokeToAnnouncer(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, F: MSPyBentleyGeom.AnnounceDoubleDPoint2d, minIndex: int = 0, maxStrokeLength: float = 10000.0) -> tuple
        
        Integrate the vector displacements of a clothoid over a
        fractional interval. This uses the angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        startFraction start fraction for integral.
        
        Parameter ``[in]``:
        endFraction end fraction for integral.
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points. A
        default is used if 0.0 is passed.
        
        Parameter ``[in]``:
        F object with a method F->Announce (f, uv) called to announce
        fraction and coordinate as computed.
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Parameter ``[out]``:
        minInterval smallest number of intervals allowed
        
        Parameter ``[out]``:
        maxStrokeLength maximum allowed stroke length
        
        Returns:
        false if point integration failed
        """
        ...
    
    def SymmetricLineSpiralSpiralLineTransition(*args, **kwargs):
        """
        SymmetricLineSpiralSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, length: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralToSpiral: MSPyBentleyGeom.DPoint3d) -> tuple
        
        compute spirals and arc to make a line-to-line
        transition.
        
        Parameter ``[in]``:
        lineAPoint point on line A.
        
        Parameter ``[in]``:
        lineBPoint point on line B.
        
        Parameter ``[in]``:
        lineLineIntersection intersection of lines.
        
        Parameter ``[in]``:
        length length of spiral from line A to junction
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        lineToSpiralA tangency point from line to spiral
        
        Parameter ``[out]``:
        lineToSpiralB tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralToSpiral tangency point from spiral to to spiral
        
        Parameter ``[out]``:
        junctionRadius radius at transition between the spirals.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def SymmetricPointShoulderTargetTransition(*args, **kwargs):
        """
        SymmetricPointShoulderTargetTransition(startPoint: MSPyBentleyGeom.DPoint2d, shoulderPoint: MSPyBentleyGeom.DPoint2d, targetPoint: MSPyBentleyGeom.DPoint2d, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, junctionPoint: MSPyBentleyGeom.DPoint2d, endPoint: MSPyBentleyGeom.DPoint2d) -> bool
        
        compute 2 spirals.
        
        Parameter ``[in]``:
        startPoint start point
        
        Parameter ``[in]``:
        shoulderPoint target point for first and last tangents
        
        Parameter ``[in]``:
        targetPoint target point for last tangent
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        junctionPoint transition between spirals. This is the max
        curvature point.
        
        Parameter ``[out]``:
        endPoint end of second spiral.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def TransitionTypeToString(*args, **kwargs):
        """
        TransitionTypeToString(type: int) -> str
        
        return the string name of the type
        """
        ...
    
    TransitionType_Arema: int
    
    TransitionType_AustralianRailCorp: int
    
    TransitionType_Biquadratic: int
    
    TransitionType_Bloss: int
    
    TransitionType_ChineseCubic: int
    
    TransitionType_Clothoid: int
    
    TransitionType_Cosine: int
    
    TransitionType_Czech: int
    
    TransitionType_CzechAlongTangent: int
    
    TransitionType_DirectHalfCosine: int
    
    TransitionType_FirstDirectEvaluate: int
    
    TransitionType_Italian: int
    
    TransitionType_JapaneseCubic: int
    
    TransitionType_MXCubicAlongArc: int
    
    TransitionType_MXCubicAlongTangent: int
    
    TransitionType_PolishCubic: int
    
    TransitionType_Sine: int
    
    TransitionType_Unknown: int
    
    TransitionType_Viennese: int
    
    TransitionType_WeightedViennese: int
    
    TransitionType_WesternAustralian: int
    
    def VectorIntegrandCount(*args, **kwargs):
        """
        VectorIntegrandCount(self: MSPyBentleyGeom.BSIVectorIntegrand) -> int
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DSpiral2dBase) -> None
        
        2. __init__(self: MSPyBentleyGeom.DSpiral2dBase, transitionType: int) -> None
        
        3. __init__(self: MSPyBentleyGeom.DSpiral2dBase, transitionType: int, extraData: MSPyBentley.DoubleArray) -> None
        
        4. __init__(self: MSPyBentleyGeom.DSpiral2dBase, transitionType: int, parameter: float) -> None
        """
        ...
    
class DSpiral2dBiQuadratic:
    """
    None
    """

    class ASLSACollector:
        """
        None
        """
    
        def Collect(*args, **kwargs):
            """
            Collect(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector, centerA: MSPyBentleyGeom.DPoint3d, arcToSpiralA: MSPyBentleyGeom.DPoint3d, sprialA: MSPyBentleyGeom.DSpiral2dBase, sprialToLineA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, arcToSpiralB: MSPyBentleyGeom.DPoint3d, spiralB: MSPyBentleyGeom.DSpiral2dBase, spiralToLibeB: MSPyBentleyGeom.DPoint3d) -> None
            """
            ...
        
        def __init__(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> None:
            ...
        
    def ArcSpiralLineSpiralArcTransition(*args, **kwargs):
        """
        ArcSpiralLineSpiralArcTransition(centerA: MSPyBentleyGeom.DPoint3d, radiusA: float, lengthA: float, centerB: MSPyBentleyGeom.DPoint3d, radiusB: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, collector: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> int
        """
        ...
    
    def Clone(*args, **kwargs):
        """
        Clone(self: MSPyBentleyGeom.DSpiral2dBase) -> MSPyBentleyGeom.DSpiral2dBase
        """
        ...
    
    def ClosestPoint(*args, **kwargs):
        """
        ClosestPoint(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, spiralToWorld: Bentley.Transform, spacePoint: MSPyBentleyGeom.DPoint3d) -> tuple
        
        Compute the closest spiral point for a given space point.
        
        Parameter ``[in]``:
        spiral spiral to evaluate.
        
        Parameter ``[in]``:
        startFraction start fraction of search range
        
        Parameter ``[in]``:
        endFraction endFraction of search range
        
        Parameter ``[in]``:
        spiralToWorld transform placing the spiral local coordinates into
        the world coordinate system
        
        Parameter ``[in]``:
        spacePoint world coordinates of space point.
        
        Parameter ``[out]``:
        spiralPoint world coordinates of closest point on spiral
        
        Parameter ``[out]``:
        spiralFraction fractional coordinates of closest point on spiral
        
        Parameter ``[out]``:
        minDistance distance from space point to spiralPoint.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def CopyBaseParameters(*args, **kwargs):
        """
        CopyBaseParameters(self: MSPyBentleyGeom.DSpiral2dBase, pSource: MSPyBentleyGeom.DSpiral2dBase) -> None
        """
        ...
    
    def CreateBearingCurvatureBearingCurvature(*args, **kwargs):
        """
        CreateBearingCurvatureBearingCurvature(*args, **kwargs)
        Overloaded function.
        
        1. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float, extraData: MSPyBentley.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def CreateBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        CreateBearingCurvatureLengthCurvature(*args, **kwargs)
        Overloaded function.
        
        1. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float, extraData: MSPyBentley.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def DefaultStrokeAngle(*args, **kwargs):
        """
        DefaultStrokeAngle() -> float
        """
        ...
    
    def DistanceToCurvature(*args, **kwargs):
        """
        DistanceToCurvature(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToCurvatureDerivative(*args, **kwargs):
        """
        DistanceToCurvatureDerivative(self: MSPyBentleyGeom.DSpiral2dBase, arg0: float) -> float
        
        distance
        """
        ...
    
    def DistanceToFraction(*args, **kwargs):
        """
        DistanceToFraction(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToGlobalAngle(*args, **kwargs):
        """
        DistanceToGlobalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToLocalAngle(*args, **kwargs):
        """
        DistanceToLocalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(*args, **kwargs):
        """
        EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(s: float, length: float, curvature1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: Bentley.DVec2d, d2XY: Bentley.DVec2d, d3XY: Bentley.DVec2d) -> bool
        
        [in] distance for evaluation [in] nominal length. ASSUMED NONZERO [in]
        exit curvature. ASSUMED NONZERO [out] coordinates on spiral [out]
        first derivative wrt distance [out] second derivative wrt distance
        [out] third derivative wrt distance
        """
        ...
    
    def EvaluateVectorIntegrand(*args, **kwargs):
        """
        EvaluateVectorIntegrand(self: MSPyBentleyGeom.DSpiral2dBase, distance: float, pF: float) -> None
        """
        ...
    
    def FractionToDerivatives(*args, **kwargs):
        """
        FractionToDerivatives(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float, dXdf: Bentley.DVec2d, ddXdfdf: Bentley.DVec2d, dddXdfdfdf: Bentley.DVec2d) -> bool
        """
        ...
    
    def FractionToDistance(*args, **kwargs):
        """
        FractionToDistance(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float) -> float
        """
        ...
    
    def GetExtraData(*args, **kwargs):
        """
        GetExtraData(self: MSPyBentleyGeom.DSpiral2dBase, extraData: MSPyBentley.DoubleArray) -> None
        
        Get the extra data for this spiral. REMARK:This should be a virtual,
        but is implemented as special cases because of API change restriction
        """
        ...
    
    def GetIntervalCount(*args, **kwargs):
        """
        GetIntervalCount(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, minInterval: int = 0, maxStrokeLength: float = 10000.0) -> int
        
        Return an interval count for stroking or integration. Except for
        degenerate single interval cases, the interval count is always even.
        That is the possible values are
        
        Parameter ``[in]``:
        spiral spiral being queried.
        
        Parameter ``[in]``:
        startFraction start of interval to stroke.
        
        Parameter ``[in]``:
        endFraction end of interval to stroke.
        
        Parameter ``[in]``:
        maxRadians max turn between strokes.
        
        Parameter ``[in]``:
        minInterval smallest number of intervals.
        
        Parameter ``[in]``:
        maxStrokeLength largest stroke size. Recommended 10 meters
        """
        ...
    
    def GetTransitionTypeCode(*args, **kwargs):
        """
        GetTransitionTypeCode(self: MSPyBentleyGeom.DSpiral2dBase) -> int
        """
        ...
    
    def GetVectorIntegrandCount(*args, **kwargs):
        """
        GetVectorIntegrandCount(self: MSPyBentleyGeom.DSpiral2dBase) -> int
        """
        ...
    
    def IsValidRLCombination(*args, **kwargs):
        """
        IsValidRLCombination(lengthFromInflection: float, radius: float, spiralType: int = 0) -> bool
        
        test if a length-from-inflection and final radius
        combination is " small enough " for reasonable use. Test depends on
        spiral type:
        
        * DSpiral2dBase.TransitionType_None indicates apply the strictest
        test (same as Czech and Italian)
        
        * DSpiral2dBase.TransitionType_Czech and
        DSpiral2dBase.TransitionType_Italian indicate a strict test L<2*R
        
        * other types have no restrictions.
        
        Parameter ``[in]``:
        lengthFromInflection [in] distance along spiral starting at
        inflection and ending at finalRadius.
        
        Parameter ``[in]``:
        finalRadius [in] final radius
        
        Parameter ``[in]``:
        spiralType [in] spiral type.
        
        Parameter ``[in]``:
        lengthFactor expansion or reduction factor to apply to the allowed
        length. +---------------+---------------+---------------+---------
        ------+------
        """
        ...
    
    def LineSpiralArcSpiralLineTransition(*args, **kwargs):
        """
        LineSpiralArcSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, radius: float, lengthA: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralAToArc: MSPyBentleyGeom.DPoint3d, spiralBToArc: MSPyBentleyGeom.DPoint3d, arc: MSPyBentleyGeom.DEllipse3d) -> bool
        
        compute spirals and arc to make a line-to-line
        transition.
        
        Parameter ``[in]``:
        lineAPoint point on line A.
        
        Parameter ``[in]``:
        lineBPoint point on line B.
        
        Parameter ``[in]``:
        lineLineIntersection intersection of lines.
        
        Parameter ``[in]``:
        radius radius for circular part of transition.
        
        Parameter ``[in]``:
        lengthA length of spiral from line A to circle.
        
        Parameter ``[in]``:
        lengthB length of spiral from line B to circle.
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        lineToSpiralA tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralAToArc tangency point from spiral to arc
        
        Parameter ``[out]``:
        lineToSpiralB tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralBToArc tangency point from spiral to arc
        
        Parameter ``[out]``:
        arc arc between spirals.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def ScaleInPlace(*args, **kwargs):
        """
        ScaleInPlace(self: MSPyBentleyGeom.DSpiral2dBase, s: float) -> bool
        """
        ...
    
    def SetBearingAndCurvatureLimits(*args, **kwargs):
        """
        SetBearingAndCurvatureLimits(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, theta1: float, curvature1: float) -> bool
        """
        ...
    
    def SetBearingCurvatureLengthBearing(*args, **kwargs):
        """
        SetBearingCurvatureLengthBearing(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, theta1: float) -> bool
        
        Set start bearing, start curvature, length, and end
        curvature. (Compute end bearing)
        
        Parameter ``[in]``:
        theta0 start bearing
        
        Parameter ``[in]``:
        curvature0 start curvature
        
        Parameter ``[in]``:
        length arc length
        
        Parameter ``[in]``:
        theta1 end bearing
        """
        ...
    
    def SetBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        SetBearingCurvatureLengthCurvature(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, curvature1: float) -> bool
        """
        ...
    
    def StringToTransitionType(*args, **kwargs):
        """
        StringToTransitionType(name: str) -> int
        
        return the integer code for the string name.
        """
        ...
    
    def Stroke(*args, **kwargs):
        """
        Stroke(*args, **kwargs)
        Overloaded function.
        
        1. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, pDXY: Bentley.DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        2. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, xyz0: MSPyBentleyGeom.DPoint3d, pXYZ: MSPyBentleyGeom.DPoint3d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        3. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: Bentley.DVec2d) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        4. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: Bentley.DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        5. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: Bentley.DVec2d, pFraction: float, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        6. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: Bentley.DVec2d, maxStrokeLength: float) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        7. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, uvPoints: Bentley.Bstdcxx.bvector<Bentley.DVec2d,Bentley.BentleyAllocator<Bentley.DVec2d> >, fractions: MSPyBentley.DoubleArray, maxStrokeLength: float = 10000.0) -> tuple
        """
        ...
    
    def StrokeToAnnouncer(*args, **kwargs):
        """
        StrokeToAnnouncer(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, F: MSPyBentleyGeom.AnnounceDoubleDPoint2d, minIndex: int = 0, maxStrokeLength: float = 10000.0) -> tuple
        
        Integrate the vector displacements of a clothoid over a
        fractional interval. This uses the angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        startFraction start fraction for integral.
        
        Parameter ``[in]``:
        endFraction end fraction for integral.
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points. A
        default is used if 0.0 is passed.
        
        Parameter ``[in]``:
        F object with a method F->Announce (f, uv) called to announce
        fraction and coordinate as computed.
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Parameter ``[out]``:
        minInterval smallest number of intervals allowed
        
        Parameter ``[out]``:
        maxStrokeLength maximum allowed stroke length
        
        Returns:
        false if point integration failed
        """
        ...
    
    def SymmetricLineSpiralSpiralLineTransition(*args, **kwargs):
        """
        SymmetricLineSpiralSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, length: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralToSpiral: MSPyBentleyGeom.DPoint3d) -> tuple
        
        compute spirals and arc to make a line-to-line
        transition.
        
        Parameter ``[in]``:
        lineAPoint point on line A.
        
        Parameter ``[in]``:
        lineBPoint point on line B.
        
        Parameter ``[in]``:
        lineLineIntersection intersection of lines.
        
        Parameter ``[in]``:
        length length of spiral from line A to junction
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        lineToSpiralA tangency point from line to spiral
        
        Parameter ``[out]``:
        lineToSpiralB tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralToSpiral tangency point from spiral to to spiral
        
        Parameter ``[out]``:
        junctionRadius radius at transition between the spirals.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def SymmetricPointShoulderTargetTransition(*args, **kwargs):
        """
        SymmetricPointShoulderTargetTransition(startPoint: MSPyBentleyGeom.DPoint2d, shoulderPoint: MSPyBentleyGeom.DPoint2d, targetPoint: MSPyBentleyGeom.DPoint2d, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, junctionPoint: MSPyBentleyGeom.DPoint2d, endPoint: MSPyBentleyGeom.DPoint2d) -> bool
        
        compute 2 spirals.
        
        Parameter ``[in]``:
        startPoint start point
        
        Parameter ``[in]``:
        shoulderPoint target point for first and last tangents
        
        Parameter ``[in]``:
        targetPoint target point for last tangent
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        junctionPoint transition between spirals. This is the max
        curvature point.
        
        Parameter ``[out]``:
        endPoint end of second spiral.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def TransitionTypeToString(*args, **kwargs):
        """
        TransitionTypeToString(type: int) -> str
        
        return the string name of the type
        """
        ...
    
    TransitionType_Arema: int
    
    TransitionType_AustralianRailCorp: int
    
    TransitionType_Biquadratic: int
    
    TransitionType_Bloss: int
    
    TransitionType_ChineseCubic: int
    
    TransitionType_Clothoid: int
    
    TransitionType_Cosine: int
    
    TransitionType_Czech: int
    
    TransitionType_CzechAlongTangent: int
    
    TransitionType_DirectHalfCosine: int
    
    TransitionType_FirstDirectEvaluate: int
    
    TransitionType_Italian: int
    
    TransitionType_JapaneseCubic: int
    
    TransitionType_MXCubicAlongArc: int
    
    TransitionType_MXCubicAlongTangent: int
    
    TransitionType_PolishCubic: int
    
    TransitionType_Sine: int
    
    TransitionType_Unknown: int
    
    TransitionType_Viennese: int
    
    TransitionType_WeightedViennese: int
    
    TransitionType_WesternAustralian: int
    
    def VectorIntegrandCount(*args, **kwargs):
        """
        VectorIntegrandCount(self: MSPyBentleyGeom.BSIVectorIntegrand) -> int
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.DSpiral2dBiQuadratic) -> None:
        ...
    
class DSpiral2dBloss:
    """
    None
    """

    class ASLSACollector:
        """
        None
        """
    
        def Collect(*args, **kwargs):
            """
            Collect(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector, centerA: MSPyBentleyGeom.DPoint3d, arcToSpiralA: MSPyBentleyGeom.DPoint3d, sprialA: MSPyBentleyGeom.DSpiral2dBase, sprialToLineA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, arcToSpiralB: MSPyBentleyGeom.DPoint3d, spiralB: MSPyBentleyGeom.DSpiral2dBase, spiralToLibeB: MSPyBentleyGeom.DPoint3d) -> None
            """
            ...
        
        def __init__(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> None:
            ...
        
    def ArcSpiralLineSpiralArcTransition(*args, **kwargs):
        """
        ArcSpiralLineSpiralArcTransition(centerA: MSPyBentleyGeom.DPoint3d, radiusA: float, lengthA: float, centerB: MSPyBentleyGeom.DPoint3d, radiusB: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, collector: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> int
        """
        ...
    
    def Clone(*args, **kwargs):
        """
        Clone(self: MSPyBentleyGeom.DSpiral2dBase) -> MSPyBentleyGeom.DSpiral2dBase
        """
        ...
    
    def ClosestPoint(*args, **kwargs):
        """
        ClosestPoint(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, spiralToWorld: Bentley.Transform, spacePoint: MSPyBentleyGeom.DPoint3d) -> tuple
        
        Compute the closest spiral point for a given space point.
        
        Parameter ``[in]``:
        spiral spiral to evaluate.
        
        Parameter ``[in]``:
        startFraction start fraction of search range
        
        Parameter ``[in]``:
        endFraction endFraction of search range
        
        Parameter ``[in]``:
        spiralToWorld transform placing the spiral local coordinates into
        the world coordinate system
        
        Parameter ``[in]``:
        spacePoint world coordinates of space point.
        
        Parameter ``[out]``:
        spiralPoint world coordinates of closest point on spiral
        
        Parameter ``[out]``:
        spiralFraction fractional coordinates of closest point on spiral
        
        Parameter ``[out]``:
        minDistance distance from space point to spiralPoint.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def CopyBaseParameters(*args, **kwargs):
        """
        CopyBaseParameters(self: MSPyBentleyGeom.DSpiral2dBase, pSource: MSPyBentleyGeom.DSpiral2dBase) -> None
        """
        ...
    
    def CreateBearingCurvatureBearingCurvature(*args, **kwargs):
        """
        CreateBearingCurvatureBearingCurvature(*args, **kwargs)
        Overloaded function.
        
        1. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float, extraData: MSPyBentley.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def CreateBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        CreateBearingCurvatureLengthCurvature(*args, **kwargs)
        Overloaded function.
        
        1. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float, extraData: MSPyBentley.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def DefaultStrokeAngle(*args, **kwargs):
        """
        DefaultStrokeAngle() -> float
        """
        ...
    
    def DistanceToCurvature(*args, **kwargs):
        """
        DistanceToCurvature(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToCurvatureDerivative(*args, **kwargs):
        """
        DistanceToCurvatureDerivative(self: MSPyBentleyGeom.DSpiral2dBase, arg0: float) -> float
        
        distance
        """
        ...
    
    def DistanceToFraction(*args, **kwargs):
        """
        DistanceToFraction(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToGlobalAngle(*args, **kwargs):
        """
        DistanceToGlobalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToLocalAngle(*args, **kwargs):
        """
        DistanceToLocalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(*args, **kwargs):
        """
        EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(s: float, length: float, curvature1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: Bentley.DVec2d, d2XY: Bentley.DVec2d, d3XY: Bentley.DVec2d) -> bool
        
        [in] distance for evaluation [in] nominal length. ASSUMED NONZERO [in]
        exit curvature. ASSUMED NONZERO [out] coordinates on spiral [out]
        first derivative wrt distance [out] second derivative wrt distance
        [out] third derivative wrt distance
        """
        ...
    
    def EvaluateVectorIntegrand(*args, **kwargs):
        """
        EvaluateVectorIntegrand(self: MSPyBentleyGeom.DSpiral2dBase, distance: float, pF: float) -> None
        """
        ...
    
    def FractionToDerivatives(*args, **kwargs):
        """
        FractionToDerivatives(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float, dXdf: Bentley.DVec2d, ddXdfdf: Bentley.DVec2d, dddXdfdfdf: Bentley.DVec2d) -> bool
        """
        ...
    
    def FractionToDistance(*args, **kwargs):
        """
        FractionToDistance(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float) -> float
        """
        ...
    
    def GetExtraData(*args, **kwargs):
        """
        GetExtraData(self: MSPyBentleyGeom.DSpiral2dBase, extraData: MSPyBentley.DoubleArray) -> None
        
        Get the extra data for this spiral. REMARK:This should be a virtual,
        but is implemented as special cases because of API change restriction
        """
        ...
    
    def GetIntervalCount(*args, **kwargs):
        """
        GetIntervalCount(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, minInterval: int = 0, maxStrokeLength: float = 10000.0) -> int
        
        Return an interval count for stroking or integration. Except for
        degenerate single interval cases, the interval count is always even.
        That is the possible values are
        
        Parameter ``[in]``:
        spiral spiral being queried.
        
        Parameter ``[in]``:
        startFraction start of interval to stroke.
        
        Parameter ``[in]``:
        endFraction end of interval to stroke.
        
        Parameter ``[in]``:
        maxRadians max turn between strokes.
        
        Parameter ``[in]``:
        minInterval smallest number of intervals.
        
        Parameter ``[in]``:
        maxStrokeLength largest stroke size. Recommended 10 meters
        """
        ...
    
    def GetTransitionTypeCode(*args, **kwargs):
        """
        GetTransitionTypeCode(self: MSPyBentleyGeom.DSpiral2dBase) -> int
        """
        ...
    
    def GetVectorIntegrandCount(*args, **kwargs):
        """
        GetVectorIntegrandCount(self: MSPyBentleyGeom.DSpiral2dBase) -> int
        """
        ...
    
    def IsValidRLCombination(*args, **kwargs):
        """
        IsValidRLCombination(lengthFromInflection: float, radius: float, spiralType: int = 0) -> bool
        
        test if a length-from-inflection and final radius
        combination is " small enough " for reasonable use. Test depends on
        spiral type:
        
        * DSpiral2dBase.TransitionType_None indicates apply the strictest
        test (same as Czech and Italian)
        
        * DSpiral2dBase.TransitionType_Czech and
        DSpiral2dBase.TransitionType_Italian indicate a strict test L<2*R
        
        * other types have no restrictions.
        
        Parameter ``[in]``:
        lengthFromInflection [in] distance along spiral starting at
        inflection and ending at finalRadius.
        
        Parameter ``[in]``:
        finalRadius [in] final radius
        
        Parameter ``[in]``:
        spiralType [in] spiral type.
        
        Parameter ``[in]``:
        lengthFactor expansion or reduction factor to apply to the allowed
        length. +---------------+---------------+---------------+---------
        ------+------
        """
        ...
    
    def LineSpiralArcSpiralLineTransition(*args, **kwargs):
        """
        LineSpiralArcSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, radius: float, lengthA: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralAToArc: MSPyBentleyGeom.DPoint3d, spiralBToArc: MSPyBentleyGeom.DPoint3d, arc: MSPyBentleyGeom.DEllipse3d) -> bool
        
        compute spirals and arc to make a line-to-line
        transition.
        
        Parameter ``[in]``:
        lineAPoint point on line A.
        
        Parameter ``[in]``:
        lineBPoint point on line B.
        
        Parameter ``[in]``:
        lineLineIntersection intersection of lines.
        
        Parameter ``[in]``:
        radius radius for circular part of transition.
        
        Parameter ``[in]``:
        lengthA length of spiral from line A to circle.
        
        Parameter ``[in]``:
        lengthB length of spiral from line B to circle.
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        lineToSpiralA tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralAToArc tangency point from spiral to arc
        
        Parameter ``[out]``:
        lineToSpiralB tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralBToArc tangency point from spiral to arc
        
        Parameter ``[out]``:
        arc arc between spirals.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def ScaleInPlace(*args, **kwargs):
        """
        ScaleInPlace(self: MSPyBentleyGeom.DSpiral2dBase, s: float) -> bool
        """
        ...
    
    def SetBearingAndCurvatureLimits(*args, **kwargs):
        """
        SetBearingAndCurvatureLimits(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, theta1: float, curvature1: float) -> bool
        """
        ...
    
    def SetBearingCurvatureLengthBearing(*args, **kwargs):
        """
        SetBearingCurvatureLengthBearing(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, theta1: float) -> bool
        
        Set start bearing, start curvature, length, and end
        curvature. (Compute end bearing)
        
        Parameter ``[in]``:
        theta0 start bearing
        
        Parameter ``[in]``:
        curvature0 start curvature
        
        Parameter ``[in]``:
        length arc length
        
        Parameter ``[in]``:
        theta1 end bearing
        """
        ...
    
    def SetBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        SetBearingCurvatureLengthCurvature(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, curvature1: float) -> bool
        """
        ...
    
    def StringToTransitionType(*args, **kwargs):
        """
        StringToTransitionType(name: str) -> int
        
        return the integer code for the string name.
        """
        ...
    
    def Stroke(*args, **kwargs):
        """
        Stroke(*args, **kwargs)
        Overloaded function.
        
        1. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, pDXY: Bentley.DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        2. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, xyz0: MSPyBentleyGeom.DPoint3d, pXYZ: MSPyBentleyGeom.DPoint3d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        3. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: Bentley.DVec2d) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        4. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: Bentley.DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        5. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: Bentley.DVec2d, pFraction: float, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        6. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: Bentley.DVec2d, maxStrokeLength: float) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        7. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, uvPoints: Bentley.Bstdcxx.bvector<Bentley.DVec2d,Bentley.BentleyAllocator<Bentley.DVec2d> >, fractions: MSPyBentley.DoubleArray, maxStrokeLength: float = 10000.0) -> tuple
        """
        ...
    
    def StrokeToAnnouncer(*args, **kwargs):
        """
        StrokeToAnnouncer(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, F: MSPyBentleyGeom.AnnounceDoubleDPoint2d, minIndex: int = 0, maxStrokeLength: float = 10000.0) -> tuple
        
        Integrate the vector displacements of a clothoid over a
        fractional interval. This uses the angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        startFraction start fraction for integral.
        
        Parameter ``[in]``:
        endFraction end fraction for integral.
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points. A
        default is used if 0.0 is passed.
        
        Parameter ``[in]``:
        F object with a method F->Announce (f, uv) called to announce
        fraction and coordinate as computed.
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Parameter ``[out]``:
        minInterval smallest number of intervals allowed
        
        Parameter ``[out]``:
        maxStrokeLength maximum allowed stroke length
        
        Returns:
        false if point integration failed
        """
        ...
    
    def SymmetricLineSpiralSpiralLineTransition(*args, **kwargs):
        """
        SymmetricLineSpiralSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, length: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralToSpiral: MSPyBentleyGeom.DPoint3d) -> tuple
        
        compute spirals and arc to make a line-to-line
        transition.
        
        Parameter ``[in]``:
        lineAPoint point on line A.
        
        Parameter ``[in]``:
        lineBPoint point on line B.
        
        Parameter ``[in]``:
        lineLineIntersection intersection of lines.
        
        Parameter ``[in]``:
        length length of spiral from line A to junction
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        lineToSpiralA tangency point from line to spiral
        
        Parameter ``[out]``:
        lineToSpiralB tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralToSpiral tangency point from spiral to to spiral
        
        Parameter ``[out]``:
        junctionRadius radius at transition between the spirals.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def SymmetricPointShoulderTargetTransition(*args, **kwargs):
        """
        SymmetricPointShoulderTargetTransition(startPoint: MSPyBentleyGeom.DPoint2d, shoulderPoint: MSPyBentleyGeom.DPoint2d, targetPoint: MSPyBentleyGeom.DPoint2d, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, junctionPoint: MSPyBentleyGeom.DPoint2d, endPoint: MSPyBentleyGeom.DPoint2d) -> bool
        
        compute 2 spirals.
        
        Parameter ``[in]``:
        startPoint start point
        
        Parameter ``[in]``:
        shoulderPoint target point for first and last tangents
        
        Parameter ``[in]``:
        targetPoint target point for last tangent
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        junctionPoint transition between spirals. This is the max
        curvature point.
        
        Parameter ``[out]``:
        endPoint end of second spiral.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def TransitionTypeToString(*args, **kwargs):
        """
        TransitionTypeToString(type: int) -> str
        
        return the string name of the type
        """
        ...
    
    TransitionType_Arema: int
    
    TransitionType_AustralianRailCorp: int
    
    TransitionType_Biquadratic: int
    
    TransitionType_Bloss: int
    
    TransitionType_ChineseCubic: int
    
    TransitionType_Clothoid: int
    
    TransitionType_Cosine: int
    
    TransitionType_Czech: int
    
    TransitionType_CzechAlongTangent: int
    
    TransitionType_DirectHalfCosine: int
    
    TransitionType_FirstDirectEvaluate: int
    
    TransitionType_Italian: int
    
    TransitionType_JapaneseCubic: int
    
    TransitionType_MXCubicAlongArc: int
    
    TransitionType_MXCubicAlongTangent: int
    
    TransitionType_PolishCubic: int
    
    TransitionType_Sine: int
    
    TransitionType_Unknown: int
    
    TransitionType_Viennese: int
    
    TransitionType_WeightedViennese: int
    
    TransitionType_WesternAustralian: int
    
    def VectorIntegrandCount(*args, **kwargs):
        """
        VectorIntegrandCount(self: MSPyBentleyGeom.BSIVectorIntegrand) -> int
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.DSpiral2dBloss) -> None:
        ...
    
class DSpiral2dChinese:
    """
    None
    """

    class ASLSACollector:
        """
        None
        """
    
        def Collect(*args, **kwargs):
            """
            Collect(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector, centerA: MSPyBentleyGeom.DPoint3d, arcToSpiralA: MSPyBentleyGeom.DPoint3d, sprialA: MSPyBentleyGeom.DSpiral2dBase, sprialToLineA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, arcToSpiralB: MSPyBentleyGeom.DPoint3d, spiralB: MSPyBentleyGeom.DSpiral2dBase, spiralToLibeB: MSPyBentleyGeom.DPoint3d) -> None
            """
            ...
        
        def __init__(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> None:
            ...
        
    def ApplyCCWRotation(*args, **kwargs):
        """
        ApplyCCWRotation(radians: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: Bentley.DVec2d, d2XYZ: Bentley.DVec2d, d3XYZ: Bentley.DVec2d) -> None
        
        rotate xy and optional derivatives by radians. (To be called by
        derived class EvaluateAtDistance when to rotate EvaluateAtDistance
        results from standard position)
        """
        ...
    
    def ArcSpiralLineSpiralArcTransition(*args, **kwargs):
        """
        ArcSpiralLineSpiralArcTransition(centerA: MSPyBentleyGeom.DPoint3d, radiusA: float, lengthA: float, centerB: MSPyBentleyGeom.DPoint3d, radiusB: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, collector: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> int
        """
        ...
    
    def Clone(*args, **kwargs):
        """
        Clone(self: MSPyBentleyGeom.DSpiral2dBase) -> MSPyBentleyGeom.DSpiral2dBase
        """
        ...
    
    def ClosestPoint(*args, **kwargs):
        """
        ClosestPoint(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, spiralToWorld: Bentley.Transform, spacePoint: MSPyBentleyGeom.DPoint3d) -> tuple
        
        Compute the closest spiral point for a given space point.
        
        Parameter ``[in]``:
        spiral spiral to evaluate.
        
        Parameter ``[in]``:
        startFraction start fraction of search range
        
        Parameter ``[in]``:
        endFraction endFraction of search range
        
        Parameter ``[in]``:
        spiralToWorld transform placing the spiral local coordinates into
        the world coordinate system
        
        Parameter ``[in]``:
        spacePoint world coordinates of space point.
        
        Parameter ``[out]``:
        spiralPoint world coordinates of closest point on spiral
        
        Parameter ``[out]``:
        spiralFraction fractional coordinates of closest point on spiral
        
        Parameter ``[out]``:
        minDistance distance from space point to spiralPoint.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def CopyBaseParameters(*args, **kwargs):
        """
        CopyBaseParameters(self: MSPyBentleyGeom.DSpiral2dBase, pSource: MSPyBentleyGeom.DSpiral2dBase) -> None
        """
        ...
    
    def CreateBearingCurvatureBearingCurvature(*args, **kwargs):
        """
        CreateBearingCurvatureBearingCurvature(*args, **kwargs)
        Overloaded function.
        
        1. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float, extraData: MSPyBentley.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def CreateBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        CreateBearingCurvatureLengthCurvature(*args, **kwargs)
        Overloaded function.
        
        1. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float, extraData: MSPyBentley.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def DefaultStrokeAngle(*args, **kwargs):
        """
        DefaultStrokeAngle() -> float
        """
        ...
    
    def DistanceToCurvature(*args, **kwargs):
        """
        DistanceToCurvature(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToCurvatureDerivative(*args, **kwargs):
        """
        DistanceToCurvatureDerivative(self: MSPyBentleyGeom.DSpiral2dBase, arg0: float) -> float
        
        distance
        """
        ...
    
    def DistanceToFraction(*args, **kwargs):
        """
        DistanceToFraction(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToGlobalAngle(*args, **kwargs):
        """
        DistanceToGlobalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToLocalAngle(*args, **kwargs):
        """
        DistanceToLocalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def EvaluateAtFraction(*args, **kwargs):
        """
        EvaluateAtFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: Bentley.DVec2d, d2XYZ: Bentley.DVec2d, d3XYZ: Bentley.DVec2d) -> bool
        
        Evaluate the spiral and derivatives at specified fractional position
        return true if valid evaluation. DSpiral2dDirectEvaluation default
        implementation returns false.
        """
        ...
    
    def EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(*args, **kwargs):
        """
        EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(s: float, length: float, curvature1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: Bentley.DVec2d, d2XY: Bentley.DVec2d, d3XY: Bentley.DVec2d) -> bool
        
        [in] distance for evaluation [in] nominal length. ASSUMED NONZERO [in]
        exit curvature. ASSUMED NONZERO [out] coordinates on spiral [out]
        first derivative wrt distance [out] second derivative wrt distance
        [out] third derivative wrt distance
        """
        ...
    
    def EvaluateVectorIntegrand(*args, **kwargs):
        """
        EvaluateVectorIntegrand(self: MSPyBentleyGeom.DSpiral2dBase, distance: float, pF: float) -> None
        """
        ...
    
    def FractionToCurvature(*args, **kwargs):
        """
        FractionToCurvature(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float
        
        Return the true curvature at fractional position. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDCurvatureDFraction(*args, **kwargs):
        """
        FractionToDCurvatureDFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> tuple
        
        Return the true curvature derivative wrt fraction. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDerivatives(*args, **kwargs):
        """
        FractionToDerivatives(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float, dXdf: Bentley.DVec2d, ddXdfdf: Bentley.DVec2d, dddXdfdfdf: Bentley.DVec2d) -> bool
        """
        ...
    
    def FractionToDistance(*args, **kwargs):
        """
        FractionToDistance(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float) -> float
        """
        ...
    
    def FractionToLocalAngle(*args, **kwargs):
        """
        FractionToLocalAngle(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float
        
        Return the tangent angle (in radians) in local coordinates
        """
        ...
    
    def FractionToVelocity(*args, **kwargs):
        """
        FractionToVelocity(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float
        
        Return the magnitude of the true derivative of position wrt fraction.
        Implemented in DSpiral2dDirectEvaluation, not individual classes.
        Assume EvaluateAtFraction.
        """
        ...
    
    def GetExtraData(*args, **kwargs):
        """
        GetExtraData(self: MSPyBentleyGeom.DSpiral2dBase, extraData: MSPyBentley.DoubleArray) -> None
        
        Get the extra data for this spiral. REMARK:This should be a virtual,
        but is implemented as special cases because of API change restriction
        """
        ...
    
    def GetIntervalCount(*args, **kwargs):
        """
        GetIntervalCount(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, minInterval: int = 0, maxStrokeLength: float = 10000.0) -> int
        
        Return an interval count for stroking or integration. Except for
        degenerate single interval cases, the interval count is always even.
        That is the possible values are
        
        Parameter ``[in]``:
        spiral spiral being queried.
        
        Parameter ``[in]``:
        startFraction start of interval to stroke.
        
        Parameter ``[in]``:
        endFraction end of interval to stroke.
        
        Parameter ``[in]``:
        maxRadians max turn between strokes.
        
        Parameter ``[in]``:
        minInterval smallest number of intervals.
        
        Parameter ``[in]``:
        maxStrokeLength largest stroke size. Recommended 10 meters
        """
        ...
    
    def GetTransitionTypeCode(*args, **kwargs):
        """
        GetTransitionTypeCode(self: MSPyBentleyGeom.DSpiral2dBase) -> int
        """
        ...
    
    def GetVectorIntegrandCount(*args, **kwargs):
        """
        GetVectorIntegrandCount(self: MSPyBentleyGeom.DSpiral2dBase) -> int
        """
        ...
    
    def IsValidRLCombination(*args, **kwargs):
        """
        IsValidRLCombination(lengthFromInflection: float, radius: float, spiralType: int = 0) -> bool
        
        test if a length-from-inflection and final radius
        combination is " small enough " for reasonable use. Test depends on
        spiral type:
        
        * DSpiral2dBase.TransitionType_None indicates apply the strictest
        test (same as Czech and Italian)
        
        * DSpiral2dBase.TransitionType_Czech and
        DSpiral2dBase.TransitionType_Italian indicate a strict test L<2*R
        
        * other types have no restrictions.
        
        Parameter ``[in]``:
        lengthFromInflection [in] distance along spiral starting at
        inflection and ending at finalRadius.
        
        Parameter ``[in]``:
        finalRadius [in] final radius
        
        Parameter ``[in]``:
        spiralType [in] spiral type.
        
        Parameter ``[in]``:
        lengthFactor expansion or reduction factor to apply to the allowed
        length. +---------------+---------------+---------------+---------
        ------+------
        """
        ...
    
    def LineSpiralArcSpiralLineTransition(*args, **kwargs):
        """
        LineSpiralArcSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, radius: float, lengthA: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralAToArc: MSPyBentleyGeom.DPoint3d, spiralBToArc: MSPyBentleyGeom.DPoint3d, arc: MSPyBentleyGeom.DEllipse3d) -> bool
        
        compute spirals and arc to make a line-to-line
        transition.
        
        Parameter ``[in]``:
        lineAPoint point on line A.
        
        Parameter ``[in]``:
        lineBPoint point on line B.
        
        Parameter ``[in]``:
        lineLineIntersection intersection of lines.
        
        Parameter ``[in]``:
        radius radius for circular part of transition.
        
        Parameter ``[in]``:
        lengthA length of spiral from line A to circle.
        
        Parameter ``[in]``:
        lengthB length of spiral from line B to circle.
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        lineToSpiralA tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralAToArc tangency point from spiral to arc
        
        Parameter ``[out]``:
        lineToSpiralB tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralBToArc tangency point from spiral to arc
        
        Parameter ``[out]``:
        arc arc between spirals.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def ScaleInPlace(*args, **kwargs):
        """
        ScaleInPlace(self: MSPyBentleyGeom.DSpiral2dBase, s: float) -> bool
        """
        ...
    
    def SetBearingAndCurvatureLimits(*args, **kwargs):
        """
        SetBearingAndCurvatureLimits(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, theta1: float, curvature1: float) -> bool
        """
        ...
    
    def SetBearingCurvatureLengthBearing(*args, **kwargs):
        """
        SetBearingCurvatureLengthBearing(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, theta1: float) -> bool
        
        Set start bearing, start curvature, length, and end
        curvature. (Compute end bearing)
        
        Parameter ``[in]``:
        theta0 start bearing
        
        Parameter ``[in]``:
        curvature0 start curvature
        
        Parameter ``[in]``:
        length arc length
        
        Parameter ``[in]``:
        theta1 end bearing
        """
        ...
    
    def SetBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        SetBearingCurvatureLengthCurvature(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, curvature1: float) -> bool
        """
        ...
    
    def StringToTransitionType(*args, **kwargs):
        """
        StringToTransitionType(name: str) -> int
        
        return the integer code for the string name.
        """
        ...
    
    def Stroke(*args, **kwargs):
        """
        Stroke(*args, **kwargs)
        Overloaded function.
        
        1. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, pDXY: Bentley.DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        2. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, xyz0: MSPyBentleyGeom.DPoint3d, pXYZ: MSPyBentleyGeom.DPoint3d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        3. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: Bentley.DVec2d) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        4. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: Bentley.DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        5. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: Bentley.DVec2d, pFraction: float, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        6. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: Bentley.DVec2d, maxStrokeLength: float) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        7. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, uvPoints: Bentley.Bstdcxx.bvector<Bentley.DVec2d,Bentley.BentleyAllocator<Bentley.DVec2d> >, fractions: MSPyBentley.DoubleArray, maxStrokeLength: float = 10000.0) -> tuple
        """
        ...
    
    def StrokeToAnnouncer(*args, **kwargs):
        """
        StrokeToAnnouncer(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, F: MSPyBentleyGeom.AnnounceDoubleDPoint2d, minIndex: int = 0, maxStrokeLength: float = 10000.0) -> tuple
        
        Integrate the vector displacements of a clothoid over a
        fractional interval. This uses the angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        startFraction start fraction for integral.
        
        Parameter ``[in]``:
        endFraction end fraction for integral.
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points. A
        default is used if 0.0 is passed.
        
        Parameter ``[in]``:
        F object with a method F->Announce (f, uv) called to announce
        fraction and coordinate as computed.
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Parameter ``[out]``:
        minInterval smallest number of intervals allowed
        
        Parameter ``[out]``:
        maxStrokeLength maximum allowed stroke length
        
        Returns:
        false if point integration failed
        """
        ...
    
    def SymmetricLineSpiralSpiralLineTransition(*args, **kwargs):
        """
        SymmetricLineSpiralSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, length: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralToSpiral: MSPyBentleyGeom.DPoint3d) -> tuple
        
        compute spirals and arc to make a line-to-line
        transition.
        
        Parameter ``[in]``:
        lineAPoint point on line A.
        
        Parameter ``[in]``:
        lineBPoint point on line B.
        
        Parameter ``[in]``:
        lineLineIntersection intersection of lines.
        
        Parameter ``[in]``:
        length length of spiral from line A to junction
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        lineToSpiralA tangency point from line to spiral
        
        Parameter ``[out]``:
        lineToSpiralB tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralToSpiral tangency point from spiral to to spiral
        
        Parameter ``[out]``:
        junctionRadius radius at transition between the spirals.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def SymmetricPointShoulderTargetTransition(*args, **kwargs):
        """
        SymmetricPointShoulderTargetTransition(startPoint: MSPyBentleyGeom.DPoint2d, shoulderPoint: MSPyBentleyGeom.DPoint2d, targetPoint: MSPyBentleyGeom.DPoint2d, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, junctionPoint: MSPyBentleyGeom.DPoint2d, endPoint: MSPyBentleyGeom.DPoint2d) -> bool
        
        compute 2 spirals.
        
        Parameter ``[in]``:
        startPoint start point
        
        Parameter ``[in]``:
        shoulderPoint target point for first and last tangents
        
        Parameter ``[in]``:
        targetPoint target point for last tangent
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        junctionPoint transition between spirals. This is the max
        curvature point.
        
        Parameter ``[out]``:
        endPoint end of second spiral.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def TransitionTypeToString(*args, **kwargs):
        """
        TransitionTypeToString(type: int) -> str
        
        return the string name of the type
        """
        ...
    
    TransitionType_Arema: int
    
    TransitionType_AustralianRailCorp: int
    
    TransitionType_Biquadratic: int
    
    TransitionType_Bloss: int
    
    TransitionType_ChineseCubic: int
    
    TransitionType_Clothoid: int
    
    TransitionType_Cosine: int
    
    TransitionType_Czech: int
    
    TransitionType_CzechAlongTangent: int
    
    TransitionType_DirectHalfCosine: int
    
    TransitionType_FirstDirectEvaluate: int
    
    TransitionType_Italian: int
    
    TransitionType_JapaneseCubic: int
    
    TransitionType_MXCubicAlongArc: int
    
    TransitionType_MXCubicAlongTangent: int
    
    TransitionType_PolishCubic: int
    
    TransitionType_Sine: int
    
    TransitionType_Unknown: int
    
    TransitionType_Viennese: int
    
    TransitionType_WeightedViennese: int
    
    TransitionType_WesternAustralian: int
    
    def VectorIntegrandCount(*args, **kwargs):
        """
        VectorIntegrandCount(self: MSPyBentleyGeom.BSIVectorIntegrand) -> int
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.DSpiral2dChinese, nominalLength: float) -> None:
        ...
    
class DSpiral2dClothoid:
    """
    None
    """

    class ASLSACollector:
        """
        None
        """
    
        def Collect(*args, **kwargs):
            """
            Collect(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector, centerA: MSPyBentleyGeom.DPoint3d, arcToSpiralA: MSPyBentleyGeom.DPoint3d, sprialA: MSPyBentleyGeom.DSpiral2dBase, sprialToLineA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, arcToSpiralB: MSPyBentleyGeom.DPoint3d, spiralB: MSPyBentleyGeom.DSpiral2dBase, spiralToLibeB: MSPyBentleyGeom.DPoint3d) -> None
            """
            ...
        
        def __init__(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> None:
            ...
        
    def ArcSpiralLineSpiralArcTransition(*args, **kwargs):
        """
        ArcSpiralLineSpiralArcTransition(centerA: MSPyBentleyGeom.DPoint3d, radiusA: float, lengthA: float, centerB: MSPyBentleyGeom.DPoint3d, radiusB: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, collector: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> int
        """
        ...
    
    def Clone(*args, **kwargs):
        """
        Clone(self: MSPyBentleyGeom.DSpiral2dBase) -> MSPyBentleyGeom.DSpiral2dBase
        """
        ...
    
    def ClosestPoint(*args, **kwargs):
        """
        ClosestPoint(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, spiralToWorld: Bentley.Transform, spacePoint: MSPyBentleyGeom.DPoint3d) -> tuple
        
        Compute the closest spiral point for a given space point.
        
        Parameter ``[in]``:
        spiral spiral to evaluate.
        
        Parameter ``[in]``:
        startFraction start fraction of search range
        
        Parameter ``[in]``:
        endFraction endFraction of search range
        
        Parameter ``[in]``:
        spiralToWorld transform placing the spiral local coordinates into
        the world coordinate system
        
        Parameter ``[in]``:
        spacePoint world coordinates of space point.
        
        Parameter ``[out]``:
        spiralPoint world coordinates of closest point on spiral
        
        Parameter ``[out]``:
        spiralFraction fractional coordinates of closest point on spiral
        
        Parameter ``[out]``:
        minDistance distance from space point to spiralPoint.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def CopyBaseParameters(*args, **kwargs):
        """
        CopyBaseParameters(self: MSPyBentleyGeom.DSpiral2dBase, pSource: MSPyBentleyGeom.DSpiral2dBase) -> None
        """
        ...
    
    def CreateBearingCurvatureBearingCurvature(*args, **kwargs):
        """
        CreateBearingCurvatureBearingCurvature(*args, **kwargs)
        Overloaded function.
        
        1. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float, extraData: MSPyBentley.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def CreateBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        CreateBearingCurvatureLengthCurvature(*args, **kwargs)
        Overloaded function.
        
        1. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float, extraData: MSPyBentley.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def DefaultStrokeAngle(*args, **kwargs):
        """
        DefaultStrokeAngle() -> float
        """
        ...
    
    def DistanceToCurvature(*args, **kwargs):
        """
        DistanceToCurvature(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToCurvatureDerivative(*args, **kwargs):
        """
        DistanceToCurvatureDerivative(self: MSPyBentleyGeom.DSpiral2dBase, arg0: float) -> float
        
        distance
        """
        ...
    
    def DistanceToFraction(*args, **kwargs):
        """
        DistanceToFraction(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToGlobalAngle(*args, **kwargs):
        """
        DistanceToGlobalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToLocalAngle(*args, **kwargs):
        """
        DistanceToLocalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(*args, **kwargs):
        """
        EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(s: float, length: float, curvature1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: Bentley.DVec2d, d2XY: Bentley.DVec2d, d3XY: Bentley.DVec2d) -> bool
        
        [in] distance for evaluation [in] nominal length. ASSUMED NONZERO [in]
        exit curvature. ASSUMED NONZERO [out] coordinates on spiral [out]
        first derivative wrt distance [out] second derivative wrt distance
        [out] third derivative wrt distance
        """
        ...
    
    def EvaluateVectorIntegrand(*args, **kwargs):
        """
        EvaluateVectorIntegrand(self: MSPyBentleyGeom.DSpiral2dBase, distance: float, pF: float) -> None
        """
        ...
    
    def FractionToDerivatives(*args, **kwargs):
        """
        FractionToDerivatives(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float, dXdf: Bentley.DVec2d, ddXdfdf: Bentley.DVec2d, dddXdfdfdf: Bentley.DVec2d) -> bool
        """
        ...
    
    def FractionToDistance(*args, **kwargs):
        """
        FractionToDistance(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float) -> float
        """
        ...
    
    def GetExtraData(*args, **kwargs):
        """
        GetExtraData(self: MSPyBentleyGeom.DSpiral2dBase, extraData: MSPyBentley.DoubleArray) -> None
        
        Get the extra data for this spiral. REMARK:This should be a virtual,
        but is implemented as special cases because of API change restriction
        """
        ...
    
    def GetIntervalCount(*args, **kwargs):
        """
        GetIntervalCount(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, minInterval: int = 0, maxStrokeLength: float = 10000.0) -> int
        
        Return an interval count for stroking or integration. Except for
        degenerate single interval cases, the interval count is always even.
        That is the possible values are
        
        Parameter ``[in]``:
        spiral spiral being queried.
        
        Parameter ``[in]``:
        startFraction start of interval to stroke.
        
        Parameter ``[in]``:
        endFraction end of interval to stroke.
        
        Parameter ``[in]``:
        maxRadians max turn between strokes.
        
        Parameter ``[in]``:
        minInterval smallest number of intervals.
        
        Parameter ``[in]``:
        maxStrokeLength largest stroke size. Recommended 10 meters
        """
        ...
    
    def GetTransitionTypeCode(*args, **kwargs):
        """
        GetTransitionTypeCode(self: MSPyBentleyGeom.DSpiral2dBase) -> int
        """
        ...
    
    def GetVectorIntegrandCount(*args, **kwargs):
        """
        GetVectorIntegrandCount(self: MSPyBentleyGeom.DSpiral2dBase) -> int
        """
        ...
    
    def IsValidRLCombination(*args, **kwargs):
        """
        IsValidRLCombination(lengthFromInflection: float, radius: float, spiralType: int = 0) -> bool
        
        test if a length-from-inflection and final radius
        combination is " small enough " for reasonable use. Test depends on
        spiral type:
        
        * DSpiral2dBase.TransitionType_None indicates apply the strictest
        test (same as Czech and Italian)
        
        * DSpiral2dBase.TransitionType_Czech and
        DSpiral2dBase.TransitionType_Italian indicate a strict test L<2*R
        
        * other types have no restrictions.
        
        Parameter ``[in]``:
        lengthFromInflection [in] distance along spiral starting at
        inflection and ending at finalRadius.
        
        Parameter ``[in]``:
        finalRadius [in] final radius
        
        Parameter ``[in]``:
        spiralType [in] spiral type.
        
        Parameter ``[in]``:
        lengthFactor expansion or reduction factor to apply to the allowed
        length. +---------------+---------------+---------------+---------
        ------+------
        """
        ...
    
    def LineSpiralArcSpiralLineTransition(*args, **kwargs):
        """
        LineSpiralArcSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, radius: float, lengthA: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralAToArc: MSPyBentleyGeom.DPoint3d, spiralBToArc: MSPyBentleyGeom.DPoint3d, arc: MSPyBentleyGeom.DEllipse3d) -> bool
        
        compute spirals and arc to make a line-to-line
        transition.
        
        Parameter ``[in]``:
        lineAPoint point on line A.
        
        Parameter ``[in]``:
        lineBPoint point on line B.
        
        Parameter ``[in]``:
        lineLineIntersection intersection of lines.
        
        Parameter ``[in]``:
        radius radius for circular part of transition.
        
        Parameter ``[in]``:
        lengthA length of spiral from line A to circle.
        
        Parameter ``[in]``:
        lengthB length of spiral from line B to circle.
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        lineToSpiralA tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralAToArc tangency point from spiral to arc
        
        Parameter ``[out]``:
        lineToSpiralB tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralBToArc tangency point from spiral to arc
        
        Parameter ``[out]``:
        arc arc between spirals.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def ScaleInPlace(*args, **kwargs):
        """
        ScaleInPlace(self: MSPyBentleyGeom.DSpiral2dBase, s: float) -> bool
        """
        ...
    
    def SetBearingAndCurvatureLimits(*args, **kwargs):
        """
        SetBearingAndCurvatureLimits(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, theta1: float, curvature1: float) -> bool
        """
        ...
    
    def SetBearingCurvatureLengthBearing(*args, **kwargs):
        """
        SetBearingCurvatureLengthBearing(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, theta1: float) -> bool
        
        Set start bearing, start curvature, length, and end
        curvature. (Compute end bearing)
        
        Parameter ``[in]``:
        theta0 start bearing
        
        Parameter ``[in]``:
        curvature0 start curvature
        
        Parameter ``[in]``:
        length arc length
        
        Parameter ``[in]``:
        theta1 end bearing
        """
        ...
    
    def SetBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        SetBearingCurvatureLengthCurvature(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, curvature1: float) -> bool
        """
        ...
    
    def StringToTransitionType(*args, **kwargs):
        """
        StringToTransitionType(name: str) -> int
        
        return the integer code for the string name.
        """
        ...
    
    def Stroke(*args, **kwargs):
        """
        Stroke(*args, **kwargs)
        Overloaded function.
        
        1. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, pDXY: Bentley.DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        2. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, xyz0: MSPyBentleyGeom.DPoint3d, pXYZ: MSPyBentleyGeom.DPoint3d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        3. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: Bentley.DVec2d) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        4. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: Bentley.DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        5. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: Bentley.DVec2d, pFraction: float, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        6. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: Bentley.DVec2d, maxStrokeLength: float) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        7. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, uvPoints: Bentley.Bstdcxx.bvector<Bentley.DVec2d,Bentley.BentleyAllocator<Bentley.DVec2d> >, fractions: MSPyBentley.DoubleArray, maxStrokeLength: float = 10000.0) -> tuple
        """
        ...
    
    def StrokeToAnnouncer(*args, **kwargs):
        """
        StrokeToAnnouncer(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, F: MSPyBentleyGeom.AnnounceDoubleDPoint2d, minIndex: int = 0, maxStrokeLength: float = 10000.0) -> tuple
        
        Integrate the vector displacements of a clothoid over a
        fractional interval. This uses the angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        startFraction start fraction for integral.
        
        Parameter ``[in]``:
        endFraction end fraction for integral.
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points. A
        default is used if 0.0 is passed.
        
        Parameter ``[in]``:
        F object with a method F->Announce (f, uv) called to announce
        fraction and coordinate as computed.
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Parameter ``[out]``:
        minInterval smallest number of intervals allowed
        
        Parameter ``[out]``:
        maxStrokeLength maximum allowed stroke length
        
        Returns:
        false if point integration failed
        """
        ...
    
    def SymmetricLineSpiralSpiralLineTransition(*args, **kwargs):
        """
        SymmetricLineSpiralSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, length: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralToSpiral: MSPyBentleyGeom.DPoint3d) -> tuple
        
        compute spirals and arc to make a line-to-line
        transition.
        
        Parameter ``[in]``:
        lineAPoint point on line A.
        
        Parameter ``[in]``:
        lineBPoint point on line B.
        
        Parameter ``[in]``:
        lineLineIntersection intersection of lines.
        
        Parameter ``[in]``:
        length length of spiral from line A to junction
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        lineToSpiralA tangency point from line to spiral
        
        Parameter ``[out]``:
        lineToSpiralB tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralToSpiral tangency point from spiral to to spiral
        
        Parameter ``[out]``:
        junctionRadius radius at transition between the spirals.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def SymmetricPointShoulderTargetTransition(*args, **kwargs):
        """
        SymmetricPointShoulderTargetTransition(startPoint: MSPyBentleyGeom.DPoint2d, shoulderPoint: MSPyBentleyGeom.DPoint2d, targetPoint: MSPyBentleyGeom.DPoint2d, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, junctionPoint: MSPyBentleyGeom.DPoint2d, endPoint: MSPyBentleyGeom.DPoint2d) -> bool
        
        compute 2 spirals.
        
        Parameter ``[in]``:
        startPoint start point
        
        Parameter ``[in]``:
        shoulderPoint target point for first and last tangents
        
        Parameter ``[in]``:
        targetPoint target point for last tangent
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        junctionPoint transition between spirals. This is the max
        curvature point.
        
        Parameter ``[out]``:
        endPoint end of second spiral.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def TransitionTypeToString(*args, **kwargs):
        """
        TransitionTypeToString(type: int) -> str
        
        return the string name of the type
        """
        ...
    
    TransitionType_Arema: int
    
    TransitionType_AustralianRailCorp: int
    
    TransitionType_Biquadratic: int
    
    TransitionType_Bloss: int
    
    TransitionType_ChineseCubic: int
    
    TransitionType_Clothoid: int
    
    TransitionType_Cosine: int
    
    TransitionType_Czech: int
    
    TransitionType_CzechAlongTangent: int
    
    TransitionType_DirectHalfCosine: int
    
    TransitionType_FirstDirectEvaluate: int
    
    TransitionType_Italian: int
    
    TransitionType_JapaneseCubic: int
    
    TransitionType_MXCubicAlongArc: int
    
    TransitionType_MXCubicAlongTangent: int
    
    TransitionType_PolishCubic: int
    
    TransitionType_Sine: int
    
    TransitionType_Unknown: int
    
    TransitionType_Viennese: int
    
    TransitionType_WeightedViennese: int
    
    TransitionType_WesternAustralian: int
    
    def VectorIntegrandCount(*args, **kwargs):
        """
        VectorIntegrandCount(self: MSPyBentleyGeom.BSIVectorIntegrand) -> int
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.DSpiral2dClothoid) -> None:
        ...
    
class DSpiral2dCosine:
    """
    None
    """

    class ASLSACollector:
        """
        None
        """
    
        def Collect(*args, **kwargs):
            """
            Collect(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector, centerA: MSPyBentleyGeom.DPoint3d, arcToSpiralA: MSPyBentleyGeom.DPoint3d, sprialA: MSPyBentleyGeom.DSpiral2dBase, sprialToLineA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, arcToSpiralB: MSPyBentleyGeom.DPoint3d, spiralB: MSPyBentleyGeom.DSpiral2dBase, spiralToLibeB: MSPyBentleyGeom.DPoint3d) -> None
            """
            ...
        
        def __init__(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> None:
            ...
        
    def ArcSpiralLineSpiralArcTransition(*args, **kwargs):
        """
        ArcSpiralLineSpiralArcTransition(centerA: MSPyBentleyGeom.DPoint3d, radiusA: float, lengthA: float, centerB: MSPyBentleyGeom.DPoint3d, radiusB: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, collector: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> int
        """
        ...
    
    def Clone(*args, **kwargs):
        """
        Clone(self: MSPyBentleyGeom.DSpiral2dBase) -> MSPyBentleyGeom.DSpiral2dBase
        """
        ...
    
    def ClosestPoint(*args, **kwargs):
        """
        ClosestPoint(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, spiralToWorld: Bentley.Transform, spacePoint: MSPyBentleyGeom.DPoint3d) -> tuple
        
        Compute the closest spiral point for a given space point.
        
        Parameter ``[in]``:
        spiral spiral to evaluate.
        
        Parameter ``[in]``:
        startFraction start fraction of search range
        
        Parameter ``[in]``:
        endFraction endFraction of search range
        
        Parameter ``[in]``:
        spiralToWorld transform placing the spiral local coordinates into
        the world coordinate system
        
        Parameter ``[in]``:
        spacePoint world coordinates of space point.
        
        Parameter ``[out]``:
        spiralPoint world coordinates of closest point on spiral
        
        Parameter ``[out]``:
        spiralFraction fractional coordinates of closest point on spiral
        
        Parameter ``[out]``:
        minDistance distance from space point to spiralPoint.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def CopyBaseParameters(*args, **kwargs):
        """
        CopyBaseParameters(self: MSPyBentleyGeom.DSpiral2dBase, pSource: MSPyBentleyGeom.DSpiral2dBase) -> None
        """
        ...
    
    def CreateBearingCurvatureBearingCurvature(*args, **kwargs):
        """
        CreateBearingCurvatureBearingCurvature(*args, **kwargs)
        Overloaded function.
        
        1. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float, extraData: MSPyBentley.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def CreateBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        CreateBearingCurvatureLengthCurvature(*args, **kwargs)
        Overloaded function.
        
        1. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float, extraData: MSPyBentley.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def DefaultStrokeAngle(*args, **kwargs):
        """
        DefaultStrokeAngle() -> float
        """
        ...
    
    def DistanceToCurvature(*args, **kwargs):
        """
        DistanceToCurvature(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToCurvatureDerivative(*args, **kwargs):
        """
        DistanceToCurvatureDerivative(self: MSPyBentleyGeom.DSpiral2dBase, arg0: float) -> float
        
        distance
        """
        ...
    
    def DistanceToFraction(*args, **kwargs):
        """
        DistanceToFraction(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToGlobalAngle(*args, **kwargs):
        """
        DistanceToGlobalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToLocalAngle(*args, **kwargs):
        """
        DistanceToLocalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(*args, **kwargs):
        """
        EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(s: float, length: float, curvature1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: Bentley.DVec2d, d2XY: Bentley.DVec2d, d3XY: Bentley.DVec2d) -> bool
        
        [in] distance for evaluation [in] nominal length. ASSUMED NONZERO [in]
        exit curvature. ASSUMED NONZERO [out] coordinates on spiral [out]
        first derivative wrt distance [out] second derivative wrt distance
        [out] third derivative wrt distance
        """
        ...
    
    def EvaluateVectorIntegrand(*args, **kwargs):
        """
        EvaluateVectorIntegrand(self: MSPyBentleyGeom.DSpiral2dBase, distance: float, pF: float) -> None
        """
        ...
    
    def FractionToDerivatives(*args, **kwargs):
        """
        FractionToDerivatives(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float, dXdf: Bentley.DVec2d, ddXdfdf: Bentley.DVec2d, dddXdfdfdf: Bentley.DVec2d) -> bool
        """
        ...
    
    def FractionToDistance(*args, **kwargs):
        """
        FractionToDistance(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float) -> float
        """
        ...
    
    def GetExtraData(*args, **kwargs):
        """
        GetExtraData(self: MSPyBentleyGeom.DSpiral2dBase, extraData: MSPyBentley.DoubleArray) -> None
        
        Get the extra data for this spiral. REMARK:This should be a virtual,
        but is implemented as special cases because of API change restriction
        """
        ...
    
    def GetIntervalCount(*args, **kwargs):
        """
        GetIntervalCount(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, minInterval: int = 0, maxStrokeLength: float = 10000.0) -> int
        
        Return an interval count for stroking or integration. Except for
        degenerate single interval cases, the interval count is always even.
        That is the possible values are
        
        Parameter ``[in]``:
        spiral spiral being queried.
        
        Parameter ``[in]``:
        startFraction start of interval to stroke.
        
        Parameter ``[in]``:
        endFraction end of interval to stroke.
        
        Parameter ``[in]``:
        maxRadians max turn between strokes.
        
        Parameter ``[in]``:
        minInterval smallest number of intervals.
        
        Parameter ``[in]``:
        maxStrokeLength largest stroke size. Recommended 10 meters
        """
        ...
    
    def GetTransitionTypeCode(*args, **kwargs):
        """
        GetTransitionTypeCode(self: MSPyBentleyGeom.DSpiral2dBase) -> int
        """
        ...
    
    def GetVectorIntegrandCount(*args, **kwargs):
        """
        GetVectorIntegrandCount(self: MSPyBentleyGeom.DSpiral2dBase) -> int
        """
        ...
    
    def IsValidRLCombination(*args, **kwargs):
        """
        IsValidRLCombination(lengthFromInflection: float, radius: float, spiralType: int = 0) -> bool
        
        test if a length-from-inflection and final radius
        combination is " small enough " for reasonable use. Test depends on
        spiral type:
        
        * DSpiral2dBase.TransitionType_None indicates apply the strictest
        test (same as Czech and Italian)
        
        * DSpiral2dBase.TransitionType_Czech and
        DSpiral2dBase.TransitionType_Italian indicate a strict test L<2*R
        
        * other types have no restrictions.
        
        Parameter ``[in]``:
        lengthFromInflection [in] distance along spiral starting at
        inflection and ending at finalRadius.
        
        Parameter ``[in]``:
        finalRadius [in] final radius
        
        Parameter ``[in]``:
        spiralType [in] spiral type.
        
        Parameter ``[in]``:
        lengthFactor expansion or reduction factor to apply to the allowed
        length. +---------------+---------------+---------------+---------
        ------+------
        """
        ...
    
    def LineSpiralArcSpiralLineTransition(*args, **kwargs):
        """
        LineSpiralArcSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, radius: float, lengthA: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralAToArc: MSPyBentleyGeom.DPoint3d, spiralBToArc: MSPyBentleyGeom.DPoint3d, arc: MSPyBentleyGeom.DEllipse3d) -> bool
        
        compute spirals and arc to make a line-to-line
        transition.
        
        Parameter ``[in]``:
        lineAPoint point on line A.
        
        Parameter ``[in]``:
        lineBPoint point on line B.
        
        Parameter ``[in]``:
        lineLineIntersection intersection of lines.
        
        Parameter ``[in]``:
        radius radius for circular part of transition.
        
        Parameter ``[in]``:
        lengthA length of spiral from line A to circle.
        
        Parameter ``[in]``:
        lengthB length of spiral from line B to circle.
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        lineToSpiralA tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralAToArc tangency point from spiral to arc
        
        Parameter ``[out]``:
        lineToSpiralB tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralBToArc tangency point from spiral to arc
        
        Parameter ``[out]``:
        arc arc between spirals.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def ScaleInPlace(*args, **kwargs):
        """
        ScaleInPlace(self: MSPyBentleyGeom.DSpiral2dBase, s: float) -> bool
        """
        ...
    
    def SetBearingAndCurvatureLimits(*args, **kwargs):
        """
        SetBearingAndCurvatureLimits(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, theta1: float, curvature1: float) -> bool
        """
        ...
    
    def SetBearingCurvatureLengthBearing(*args, **kwargs):
        """
        SetBearingCurvatureLengthBearing(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, theta1: float) -> bool
        
        Set start bearing, start curvature, length, and end
        curvature. (Compute end bearing)
        
        Parameter ``[in]``:
        theta0 start bearing
        
        Parameter ``[in]``:
        curvature0 start curvature
        
        Parameter ``[in]``:
        length arc length
        
        Parameter ``[in]``:
        theta1 end bearing
        """
        ...
    
    def SetBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        SetBearingCurvatureLengthCurvature(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, curvature1: float) -> bool
        """
        ...
    
    def StringToTransitionType(*args, **kwargs):
        """
        StringToTransitionType(name: str) -> int
        
        return the integer code for the string name.
        """
        ...
    
    def Stroke(*args, **kwargs):
        """
        Stroke(*args, **kwargs)
        Overloaded function.
        
        1. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, pDXY: Bentley.DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        2. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, xyz0: MSPyBentleyGeom.DPoint3d, pXYZ: MSPyBentleyGeom.DPoint3d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        3. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: Bentley.DVec2d) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        4. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: Bentley.DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        5. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: Bentley.DVec2d, pFraction: float, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        6. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: Bentley.DVec2d, maxStrokeLength: float) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        7. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, uvPoints: Bentley.Bstdcxx.bvector<Bentley.DVec2d,Bentley.BentleyAllocator<Bentley.DVec2d> >, fractions: MSPyBentley.DoubleArray, maxStrokeLength: float = 10000.0) -> tuple
        """
        ...
    
    def StrokeToAnnouncer(*args, **kwargs):
        """
        StrokeToAnnouncer(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, F: MSPyBentleyGeom.AnnounceDoubleDPoint2d, minIndex: int = 0, maxStrokeLength: float = 10000.0) -> tuple
        
        Integrate the vector displacements of a clothoid over a
        fractional interval. This uses the angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        startFraction start fraction for integral.
        
        Parameter ``[in]``:
        endFraction end fraction for integral.
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points. A
        default is used if 0.0 is passed.
        
        Parameter ``[in]``:
        F object with a method F->Announce (f, uv) called to announce
        fraction and coordinate as computed.
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Parameter ``[out]``:
        minInterval smallest number of intervals allowed
        
        Parameter ``[out]``:
        maxStrokeLength maximum allowed stroke length
        
        Returns:
        false if point integration failed
        """
        ...
    
    def SymmetricLineSpiralSpiralLineTransition(*args, **kwargs):
        """
        SymmetricLineSpiralSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, length: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralToSpiral: MSPyBentleyGeom.DPoint3d) -> tuple
        
        compute spirals and arc to make a line-to-line
        transition.
        
        Parameter ``[in]``:
        lineAPoint point on line A.
        
        Parameter ``[in]``:
        lineBPoint point on line B.
        
        Parameter ``[in]``:
        lineLineIntersection intersection of lines.
        
        Parameter ``[in]``:
        length length of spiral from line A to junction
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        lineToSpiralA tangency point from line to spiral
        
        Parameter ``[out]``:
        lineToSpiralB tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralToSpiral tangency point from spiral to to spiral
        
        Parameter ``[out]``:
        junctionRadius radius at transition between the spirals.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def SymmetricPointShoulderTargetTransition(*args, **kwargs):
        """
        SymmetricPointShoulderTargetTransition(startPoint: MSPyBentleyGeom.DPoint2d, shoulderPoint: MSPyBentleyGeom.DPoint2d, targetPoint: MSPyBentleyGeom.DPoint2d, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, junctionPoint: MSPyBentleyGeom.DPoint2d, endPoint: MSPyBentleyGeom.DPoint2d) -> bool
        
        compute 2 spirals.
        
        Parameter ``[in]``:
        startPoint start point
        
        Parameter ``[in]``:
        shoulderPoint target point for first and last tangents
        
        Parameter ``[in]``:
        targetPoint target point for last tangent
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        junctionPoint transition between spirals. This is the max
        curvature point.
        
        Parameter ``[out]``:
        endPoint end of second spiral.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def TransitionTypeToString(*args, **kwargs):
        """
        TransitionTypeToString(type: int) -> str
        
        return the string name of the type
        """
        ...
    
    TransitionType_Arema: int
    
    TransitionType_AustralianRailCorp: int
    
    TransitionType_Biquadratic: int
    
    TransitionType_Bloss: int
    
    TransitionType_ChineseCubic: int
    
    TransitionType_Clothoid: int
    
    TransitionType_Cosine: int
    
    TransitionType_Czech: int
    
    TransitionType_CzechAlongTangent: int
    
    TransitionType_DirectHalfCosine: int
    
    TransitionType_FirstDirectEvaluate: int
    
    TransitionType_Italian: int
    
    TransitionType_JapaneseCubic: int
    
    TransitionType_MXCubicAlongArc: int
    
    TransitionType_MXCubicAlongTangent: int
    
    TransitionType_PolishCubic: int
    
    TransitionType_Sine: int
    
    TransitionType_Unknown: int
    
    TransitionType_Viennese: int
    
    TransitionType_WeightedViennese: int
    
    TransitionType_WesternAustralian: int
    
    def VectorIntegrandCount(*args, **kwargs):
        """
        VectorIntegrandCount(self: MSPyBentleyGeom.BSIVectorIntegrand) -> int
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.DSpiral2dCosine) -> None:
        ...
    
class DSpiral2dCzech:
    """
    None
    """

    class ASLSACollector:
        """
        None
        """
    
        def Collect(*args, **kwargs):
            """
            Collect(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector, centerA: MSPyBentleyGeom.DPoint3d, arcToSpiralA: MSPyBentleyGeom.DPoint3d, sprialA: MSPyBentleyGeom.DSpiral2dBase, sprialToLineA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, arcToSpiralB: MSPyBentleyGeom.DPoint3d, spiralB: MSPyBentleyGeom.DSpiral2dBase, spiralToLibeB: MSPyBentleyGeom.DPoint3d) -> None
            """
            ...
        
        def __init__(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> None:
            ...
        
    def ApplyCCWRotation(*args, **kwargs):
        """
        ApplyCCWRotation(radians: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: Bentley.DVec2d, d2XYZ: Bentley.DVec2d, d3XYZ: Bentley.DVec2d) -> None
        
        rotate xy and optional derivatives by radians. (To be called by
        derived class EvaluateAtDistance when to rotate EvaluateAtDistance
        results from standard position)
        """
        ...
    
    def ArcSpiralLineSpiralArcTransition(*args, **kwargs):
        """
        ArcSpiralLineSpiralArcTransition(centerA: MSPyBentleyGeom.DPoint3d, radiusA: float, lengthA: float, centerB: MSPyBentleyGeom.DPoint3d, radiusB: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, collector: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> int
        """
        ...
    
    def Clone(*args, **kwargs):
        """
        Clone(self: MSPyBentleyGeom.DSpiral2dBase) -> MSPyBentleyGeom.DSpiral2dBase
        """
        ...
    
    def ClosestPoint(*args, **kwargs):
        """
        ClosestPoint(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, spiralToWorld: Bentley.Transform, spacePoint: MSPyBentleyGeom.DPoint3d) -> tuple
        
        Compute the closest spiral point for a given space point.
        
        Parameter ``[in]``:
        spiral spiral to evaluate.
        
        Parameter ``[in]``:
        startFraction start fraction of search range
        
        Parameter ``[in]``:
        endFraction endFraction of search range
        
        Parameter ``[in]``:
        spiralToWorld transform placing the spiral local coordinates into
        the world coordinate system
        
        Parameter ``[in]``:
        spacePoint world coordinates of space point.
        
        Parameter ``[out]``:
        spiralPoint world coordinates of closest point on spiral
        
        Parameter ``[out]``:
        spiralFraction fractional coordinates of closest point on spiral
        
        Parameter ``[out]``:
        minDistance distance from space point to spiralPoint.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def CopyBaseParameters(*args, **kwargs):
        """
        CopyBaseParameters(self: MSPyBentleyGeom.DSpiral2dBase, pSource: MSPyBentleyGeom.DSpiral2dBase) -> None
        """
        ...
    
    def CreateBearingCurvatureBearingCurvature(*args, **kwargs):
        """
        CreateBearingCurvatureBearingCurvature(*args, **kwargs)
        Overloaded function.
        
        1. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float, extraData: MSPyBentley.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def CreateBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        CreateBearingCurvatureLengthCurvature(*args, **kwargs)
        Overloaded function.
        
        1. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float, extraData: MSPyBentley.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def DefaultStrokeAngle(*args, **kwargs):
        """
        DefaultStrokeAngle() -> float
        """
        ...
    
    def DistanceToCurvature(*args, **kwargs):
        """
        DistanceToCurvature(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToCurvatureDerivative(*args, **kwargs):
        """
        DistanceToCurvatureDerivative(self: MSPyBentleyGeom.DSpiral2dBase, arg0: float) -> float
        
        distance
        """
        ...
    
    def DistanceToFraction(*args, **kwargs):
        """
        DistanceToFraction(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToGlobalAngle(*args, **kwargs):
        """
        DistanceToGlobalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToLocalAngle(*args, **kwargs):
        """
        DistanceToLocalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def EvaluateAtFraction(*args, **kwargs):
        """
        EvaluateAtFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: Bentley.DVec2d, d2XYZ: Bentley.DVec2d, d3XYZ: Bentley.DVec2d) -> bool
        
        Evaluate the spiral and derivatives at specified fractional position
        return true if valid evaluation. DSpiral2dDirectEvaluation default
        implementation returns false.
        """
        ...
    
    def EvaluateAtFractionOfNominalLengthInStandardOrientation(*args, **kwargs):
        """
        EvaluateAtFractionOfNominalLengthInStandardOrientation(fraction: float, Lx: float, Ls: float, radius1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: Bentley.DVec2d, d2XY: Bentley.DVec2d, d3XY: Bentley.DVec2d) -> bool
        
        Evaluate at distance a spiral in standard orientation -- zero
        curvature at origin.
        """
        ...
    
    def EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(*args, **kwargs):
        """
        EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(s: float, length: float, curvature1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: Bentley.DVec2d, d2XY: Bentley.DVec2d, d3XY: Bentley.DVec2d) -> bool
        
        [in] distance for evaluation [in] nominal length. ASSUMED NONZERO [in]
        exit curvature. ASSUMED NONZERO [out] coordinates on spiral [out]
        first derivative wrt distance [out] second derivative wrt distance
        [out] third derivative wrt distance
        """
        ...
    
    def EvaluateVectorIntegrand(*args, **kwargs):
        """
        EvaluateVectorIntegrand(self: MSPyBentleyGeom.DSpiral2dBase, distance: float, pF: float) -> None
        """
        ...
    
    def FractionToCurvature(*args, **kwargs):
        """
        FractionToCurvature(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float
        
        Return the true curvature at fractional position. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDCurvatureDFraction(*args, **kwargs):
        """
        FractionToDCurvatureDFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> tuple
        
        Return the true curvature derivative wrt fraction. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDerivatives(*args, **kwargs):
        """
        FractionToDerivatives(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float, dXdf: Bentley.DVec2d, ddXdfdf: Bentley.DVec2d, dddXdfdfdf: Bentley.DVec2d) -> bool
        """
        ...
    
    def FractionToDistance(*args, **kwargs):
        """
        FractionToDistance(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float) -> float
        """
        ...
    
    def FractionToLocalAngle(*args, **kwargs):
        """
        FractionToLocalAngle(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float
        
        Return the tangent angle (in radians) in local coordinates
        """
        ...
    
    def FractionToVelocity(*args, **kwargs):
        """
        FractionToVelocity(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float
        
        Return the magnitude of the true derivative of position wrt fraction.
        Implemented in DSpiral2dDirectEvaluation, not individual classes.
        Assume EvaluateAtFraction.
        """
        ...
    
    def GetExtraData(*args, **kwargs):
        """
        GetExtraData(self: MSPyBentleyGeom.DSpiral2dBase, extraData: MSPyBentley.DoubleArray) -> None
        
        Get the extra data for this spiral. REMARK:This should be a virtual,
        but is implemented as special cases because of API change restriction
        """
        ...
    
    def GetIntervalCount(*args, **kwargs):
        """
        GetIntervalCount(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, minInterval: int = 0, maxStrokeLength: float = 10000.0) -> int
        
        Return an interval count for stroking or integration. Except for
        degenerate single interval cases, the interval count is always even.
        That is the possible values are
        
        Parameter ``[in]``:
        spiral spiral being queried.
        
        Parameter ``[in]``:
        startFraction start of interval to stroke.
        
        Parameter ``[in]``:
        endFraction end of interval to stroke.
        
        Parameter ``[in]``:
        maxRadians max turn between strokes.
        
        Parameter ``[in]``:
        minInterval smallest number of intervals.
        
        Parameter ``[in]``:
        maxStrokeLength largest stroke size. Recommended 10 meters
        """
        ...
    
    def GetTransitionTypeCode(*args, **kwargs):
        """
        GetTransitionTypeCode(self: MSPyBentleyGeom.DSpiral2dBase) -> int
        """
        ...
    
    def GetVectorIntegrandCount(*args, **kwargs):
        """
        GetVectorIntegrandCount(self: MSPyBentleyGeom.DSpiral2dBase) -> int
        """
        ...
    
    def IsValidRLCombination(*args, **kwargs):
        """
        IsValidRLCombination(lengthFromInflection: float, radius: float, spiralType: int = 0) -> bool
        
        test if a length-from-inflection and final radius
        combination is " small enough " for reasonable use. Test depends on
        spiral type:
        
        * DSpiral2dBase.TransitionType_None indicates apply the strictest
        test (same as Czech and Italian)
        
        * DSpiral2dBase.TransitionType_Czech and
        DSpiral2dBase.TransitionType_Italian indicate a strict test L<2*R
        
        * other types have no restrictions.
        
        Parameter ``[in]``:
        lengthFromInflection [in] distance along spiral starting at
        inflection and ending at finalRadius.
        
        Parameter ``[in]``:
        finalRadius [in] final radius
        
        Parameter ``[in]``:
        spiralType [in] spiral type.
        
        Parameter ``[in]``:
        lengthFactor expansion or reduction factor to apply to the allowed
        length. +---------------+---------------+---------------+---------
        ------+------
        """
        ...
    
    def LineSpiralArcSpiralLineTransition(*args, **kwargs):
        """
        LineSpiralArcSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, radius: float, lengthA: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralAToArc: MSPyBentleyGeom.DPoint3d, spiralBToArc: MSPyBentleyGeom.DPoint3d, arc: MSPyBentleyGeom.DEllipse3d) -> bool
        
        compute spirals and arc to make a line-to-line
        transition.
        
        Parameter ``[in]``:
        lineAPoint point on line A.
        
        Parameter ``[in]``:
        lineBPoint point on line B.
        
        Parameter ``[in]``:
        lineLineIntersection intersection of lines.
        
        Parameter ``[in]``:
        radius radius for circular part of transition.
        
        Parameter ``[in]``:
        lengthA length of spiral from line A to circle.
        
        Parameter ``[in]``:
        lengthB length of spiral from line B to circle.
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        lineToSpiralA tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralAToArc tangency point from spiral to arc
        
        Parameter ``[out]``:
        lineToSpiralB tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralBToArc tangency point from spiral to arc
        
        Parameter ``[out]``:
        arc arc between spirals.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def ScaleInPlace(*args, **kwargs):
        """
        ScaleInPlace(self: MSPyBentleyGeom.DSpiral2dBase, s: float) -> bool
        """
        ...
    
    def SetBearingAndCurvatureLimits(*args, **kwargs):
        """
        SetBearingAndCurvatureLimits(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, theta1: float, curvature1: float) -> bool
        """
        ...
    
    def SetBearingCurvatureLengthBearing(*args, **kwargs):
        """
        SetBearingCurvatureLengthBearing(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, theta1: float) -> bool
        
        Set start bearing, start curvature, length, and end
        curvature. (Compute end bearing)
        
        Parameter ``[in]``:
        theta0 start bearing
        
        Parameter ``[in]``:
        curvature0 start curvature
        
        Parameter ``[in]``:
        length arc length
        
        Parameter ``[in]``:
        theta1 end bearing
        """
        ...
    
    def SetBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        SetBearingCurvatureLengthCurvature(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, curvature1: float) -> bool
        """
        ...
    
    def StringToTransitionType(*args, **kwargs):
        """
        StringToTransitionType(name: str) -> int
        
        return the integer code for the string name.
        """
        ...
    
    def Stroke(*args, **kwargs):
        """
        Stroke(*args, **kwargs)
        Overloaded function.
        
        1. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, pDXY: Bentley.DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        2. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, xyz0: MSPyBentleyGeom.DPoint3d, pXYZ: MSPyBentleyGeom.DPoint3d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        3. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: Bentley.DVec2d) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        4. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: Bentley.DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        5. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: Bentley.DVec2d, pFraction: float, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        6. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: Bentley.DVec2d, maxStrokeLength: float) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        7. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, uvPoints: Bentley.Bstdcxx.bvector<Bentley.DVec2d,Bentley.BentleyAllocator<Bentley.DVec2d> >, fractions: MSPyBentley.DoubleArray, maxStrokeLength: float = 10000.0) -> tuple
        """
        ...
    
    def StrokeToAnnouncer(*args, **kwargs):
        """
        StrokeToAnnouncer(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, F: MSPyBentleyGeom.AnnounceDoubleDPoint2d, minIndex: int = 0, maxStrokeLength: float = 10000.0) -> tuple
        
        Integrate the vector displacements of a clothoid over a
        fractional interval. This uses the angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        startFraction start fraction for integral.
        
        Parameter ``[in]``:
        endFraction end fraction for integral.
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points. A
        default is used if 0.0 is passed.
        
        Parameter ``[in]``:
        F object with a method F->Announce (f, uv) called to announce
        fraction and coordinate as computed.
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Parameter ``[out]``:
        minInterval smallest number of intervals allowed
        
        Parameter ``[out]``:
        maxStrokeLength maximum allowed stroke length
        
        Returns:
        false if point integration failed
        """
        ...
    
    def SymmetricLineSpiralSpiralLineTransition(*args, **kwargs):
        """
        SymmetricLineSpiralSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, length: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralToSpiral: MSPyBentleyGeom.DPoint3d) -> tuple
        
        compute spirals and arc to make a line-to-line
        transition.
        
        Parameter ``[in]``:
        lineAPoint point on line A.
        
        Parameter ``[in]``:
        lineBPoint point on line B.
        
        Parameter ``[in]``:
        lineLineIntersection intersection of lines.
        
        Parameter ``[in]``:
        length length of spiral from line A to junction
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        lineToSpiralA tangency point from line to spiral
        
        Parameter ``[out]``:
        lineToSpiralB tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralToSpiral tangency point from spiral to to spiral
        
        Parameter ``[out]``:
        junctionRadius radius at transition between the spirals.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def SymmetricPointShoulderTargetTransition(*args, **kwargs):
        """
        SymmetricPointShoulderTargetTransition(startPoint: MSPyBentleyGeom.DPoint2d, shoulderPoint: MSPyBentleyGeom.DPoint2d, targetPoint: MSPyBentleyGeom.DPoint2d, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, junctionPoint: MSPyBentleyGeom.DPoint2d, endPoint: MSPyBentleyGeom.DPoint2d) -> bool
        
        compute 2 spirals.
        
        Parameter ``[in]``:
        startPoint start point
        
        Parameter ``[in]``:
        shoulderPoint target point for first and last tangents
        
        Parameter ``[in]``:
        targetPoint target point for last tangent
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        junctionPoint transition between spirals. This is the max
        curvature point.
        
        Parameter ``[out]``:
        endPoint end of second spiral.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def TransitionTypeToString(*args, **kwargs):
        """
        TransitionTypeToString(type: int) -> str
        
        return the string name of the type
        """
        ...
    
    TransitionType_Arema: int
    
    TransitionType_AustralianRailCorp: int
    
    TransitionType_Biquadratic: int
    
    TransitionType_Bloss: int
    
    TransitionType_ChineseCubic: int
    
    TransitionType_Clothoid: int
    
    TransitionType_Cosine: int
    
    TransitionType_Czech: int
    
    TransitionType_CzechAlongTangent: int
    
    TransitionType_DirectHalfCosine: int
    
    TransitionType_FirstDirectEvaluate: int
    
    TransitionType_Italian: int
    
    TransitionType_JapaneseCubic: int
    
    TransitionType_MXCubicAlongArc: int
    
    TransitionType_MXCubicAlongTangent: int
    
    TransitionType_PolishCubic: int
    
    TransitionType_Sine: int
    
    TransitionType_Unknown: int
    
    TransitionType_Viennese: int
    
    TransitionType_WeightedViennese: int
    
    TransitionType_WesternAustralian: int
    
    def VectorIntegrandCount(*args, **kwargs):
        """
        VectorIntegrandCount(self: MSPyBentleyGeom.BSIVectorIntegrand) -> int
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.DSpiral2dCzech, nominalLength: float) -> None:
        ...
    
class DSpiral2dCzechAlongTangent:
    """
    None
    """

    class ASLSACollector:
        """
        None
        """
    
        def Collect(*args, **kwargs):
            """
            Collect(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector, centerA: MSPyBentleyGeom.DPoint3d, arcToSpiralA: MSPyBentleyGeom.DPoint3d, sprialA: MSPyBentleyGeom.DSpiral2dBase, sprialToLineA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, arcToSpiralB: MSPyBentleyGeom.DPoint3d, spiralB: MSPyBentleyGeom.DSpiral2dBase, spiralToLibeB: MSPyBentleyGeom.DPoint3d) -> None
            """
            ...
        
        def __init__(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> None:
            ...
        
    def ApplyCCWRotation(*args, **kwargs):
        """
        ApplyCCWRotation(radians: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: Bentley.DVec2d, d2XYZ: Bentley.DVec2d, d3XYZ: Bentley.DVec2d) -> None
        
        rotate xy and optional derivatives by radians. (To be called by
        derived class EvaluateAtDistance when to rotate EvaluateAtDistance
        results from standard position)
        """
        ...
    
    def ArcSpiralLineSpiralArcTransition(*args, **kwargs):
        """
        ArcSpiralLineSpiralArcTransition(centerA: MSPyBentleyGeom.DPoint3d, radiusA: float, lengthA: float, centerB: MSPyBentleyGeom.DPoint3d, radiusB: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, collector: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> int
        """
        ...
    
    def Clone(*args, **kwargs):
        """
        Clone(self: MSPyBentleyGeom.DSpiral2dBase) -> MSPyBentleyGeom.DSpiral2dBase
        """
        ...
    
    def ClosestPoint(*args, **kwargs):
        """
        ClosestPoint(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, spiralToWorld: Bentley.Transform, spacePoint: MSPyBentleyGeom.DPoint3d) -> tuple
        
        Compute the closest spiral point for a given space point.
        
        Parameter ``[in]``:
        spiral spiral to evaluate.
        
        Parameter ``[in]``:
        startFraction start fraction of search range
        
        Parameter ``[in]``:
        endFraction endFraction of search range
        
        Parameter ``[in]``:
        spiralToWorld transform placing the spiral local coordinates into
        the world coordinate system
        
        Parameter ``[in]``:
        spacePoint world coordinates of space point.
        
        Parameter ``[out]``:
        spiralPoint world coordinates of closest point on spiral
        
        Parameter ``[out]``:
        spiralFraction fractional coordinates of closest point on spiral
        
        Parameter ``[out]``:
        minDistance distance from space point to spiralPoint.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def CopyBaseParameters(*args, **kwargs):
        """
        CopyBaseParameters(self: MSPyBentleyGeom.DSpiral2dBase, pSource: MSPyBentleyGeom.DSpiral2dBase) -> None
        """
        ...
    
    def CreateBearingCurvatureBearingCurvature(*args, **kwargs):
        """
        CreateBearingCurvatureBearingCurvature(*args, **kwargs)
        Overloaded function.
        
        1. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float, extraData: MSPyBentley.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def CreateBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        CreateBearingCurvatureLengthCurvature(*args, **kwargs)
        Overloaded function.
        
        1. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float, extraData: MSPyBentley.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def DefaultStrokeAngle(*args, **kwargs):
        """
        DefaultStrokeAngle() -> float
        """
        ...
    
    def DistanceToCurvature(*args, **kwargs):
        """
        DistanceToCurvature(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToCurvatureDerivative(*args, **kwargs):
        """
        DistanceToCurvatureDerivative(self: MSPyBentleyGeom.DSpiral2dBase, arg0: float) -> float
        
        distance
        """
        ...
    
    def DistanceToFraction(*args, **kwargs):
        """
        DistanceToFraction(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToGlobalAngle(*args, **kwargs):
        """
        DistanceToGlobalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToLocalAngle(*args, **kwargs):
        """
        DistanceToLocalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def EvaluateAtFraction(*args, **kwargs):
        """
        EvaluateAtFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: Bentley.DVec2d, d2XYZ: Bentley.DVec2d, d3XYZ: Bentley.DVec2d) -> bool
        
        Evaluate the spiral and derivatives at specified fractional position
        return true if valid evaluation. DSpiral2dDirectEvaluation default
        implementation returns false.
        """
        ...
    
    def EvaluateAtFractionAlongTangentInStandardOrientation(*args, **kwargs):
        """
        EvaluateAtFractionAlongTangentInStandardOrientation(fraction: float, axisLength: float, radius1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: Bentley.DVec2d, d2XY: Bentley.DVec2d, d3XY: Bentley.DVec2d) -> bool
        
        Evaluate at distance a spiral in standard orientation -- zero
        curvature at origin.
        """
        ...
    
    def EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(*args, **kwargs):
        """
        EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(s: float, length: float, curvature1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: Bentley.DVec2d, d2XY: Bentley.DVec2d, d3XY: Bentley.DVec2d) -> bool
        
        [in] distance for evaluation [in] nominal length. ASSUMED NONZERO [in]
        exit curvature. ASSUMED NONZERO [out] coordinates on spiral [out]
        first derivative wrt distance [out] second derivative wrt distance
        [out] third derivative wrt distance
        """
        ...
    
    def EvaluateVectorIntegrand(*args, **kwargs):
        """
        EvaluateVectorIntegrand(self: MSPyBentleyGeom.DSpiral2dBase, distance: float, pF: float) -> None
        """
        ...
    
    def FractionToCurvature(*args, **kwargs):
        """
        FractionToCurvature(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float
        
        Return the true curvature at fractional position. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDCurvatureDFraction(*args, **kwargs):
        """
        FractionToDCurvatureDFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> tuple
        
        Return the true curvature derivative wrt fraction. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDerivatives(*args, **kwargs):
        """
        FractionToDerivatives(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float, dXdf: Bentley.DVec2d, ddXdfdf: Bentley.DVec2d, dddXdfdfdf: Bentley.DVec2d) -> bool
        """
        ...
    
    def FractionToDistance(*args, **kwargs):
        """
        FractionToDistance(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float) -> float
        """
        ...
    
    def FractionToLocalAngle(*args, **kwargs):
        """
        FractionToLocalAngle(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float
        
        Return the tangent angle (in radians) in local coordinates
        """
        ...
    
    def FractionToVelocity(*args, **kwargs):
        """
        FractionToVelocity(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float
        
        Return the magnitude of the true derivative of position wrt fraction.
        Implemented in DSpiral2dDirectEvaluation, not individual classes.
        Assume EvaluateAtFraction.
        """
        ...
    
    def GetBezierPoles(*args, **kwargs):
        """
        GetBezierPoles(self: MSPyBentleyGeom.DSpiral2dCzechAlongTangent, poles: MSPyBentleyGeom.DPoint3dArray, startFraction: float, endFraction: float) -> bool
        
        Return poles for preferred representation as a bezier curve These are
        in the local coordinates of the standard orientation
        """
        ...
    
    def GetExtraData(*args, **kwargs):
        """
        GetExtraData(self: MSPyBentleyGeom.DSpiral2dBase, extraData: MSPyBentley.DoubleArray) -> None
        
        Get the extra data for this spiral. REMARK:This should be a virtual,
        but is implemented as special cases because of API change restriction
        """
        ...
    
    def GetIntervalCount(*args, **kwargs):
        """
        GetIntervalCount(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, minInterval: int = 0, maxStrokeLength: float = 10000.0) -> int
        
        Return an interval count for stroking or integration. Except for
        degenerate single interval cases, the interval count is always even.
        That is the possible values are
        
        Parameter ``[in]``:
        spiral spiral being queried.
        
        Parameter ``[in]``:
        startFraction start of interval to stroke.
        
        Parameter ``[in]``:
        endFraction end of interval to stroke.
        
        Parameter ``[in]``:
        maxRadians max turn between strokes.
        
        Parameter ``[in]``:
        minInterval smallest number of intervals.
        
        Parameter ``[in]``:
        maxStrokeLength largest stroke size. Recommended 10 meters
        """
        ...
    
    def GetTransitionTypeCode(*args, **kwargs):
        """
        GetTransitionTypeCode(self: MSPyBentleyGeom.DSpiral2dBase) -> int
        """
        ...
    
    def GetVectorIntegrandCount(*args, **kwargs):
        """
        GetVectorIntegrandCount(self: MSPyBentleyGeom.DSpiral2dBase) -> int
        """
        ...
    
    def IsValidRLCombination(*args, **kwargs):
        """
        IsValidRLCombination(lengthFromInflection: float, radius: float, spiralType: int = 0) -> bool
        
        test if a length-from-inflection and final radius
        combination is " small enough " for reasonable use. Test depends on
        spiral type:
        
        * DSpiral2dBase.TransitionType_None indicates apply the strictest
        test (same as Czech and Italian)
        
        * DSpiral2dBase.TransitionType_Czech and
        DSpiral2dBase.TransitionType_Italian indicate a strict test L<2*R
        
        * other types have no restrictions.
        
        Parameter ``[in]``:
        lengthFromInflection [in] distance along spiral starting at
        inflection and ending at finalRadius.
        
        Parameter ``[in]``:
        finalRadius [in] final radius
        
        Parameter ``[in]``:
        spiralType [in] spiral type.
        
        Parameter ``[in]``:
        lengthFactor expansion or reduction factor to apply to the allowed
        length. +---------------+---------------+---------------+---------
        ------+------
        """
        ...
    
    def LineSpiralArcSpiralLineTransition(*args, **kwargs):
        """
        LineSpiralArcSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, radius: float, lengthA: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralAToArc: MSPyBentleyGeom.DPoint3d, spiralBToArc: MSPyBentleyGeom.DPoint3d, arc: MSPyBentleyGeom.DEllipse3d) -> bool
        
        compute spirals and arc to make a line-to-line
        transition.
        
        Parameter ``[in]``:
        lineAPoint point on line A.
        
        Parameter ``[in]``:
        lineBPoint point on line B.
        
        Parameter ``[in]``:
        lineLineIntersection intersection of lines.
        
        Parameter ``[in]``:
        radius radius for circular part of transition.
        
        Parameter ``[in]``:
        lengthA length of spiral from line A to circle.
        
        Parameter ``[in]``:
        lengthB length of spiral from line B to circle.
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        lineToSpiralA tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralAToArc tangency point from spiral to arc
        
        Parameter ``[out]``:
        lineToSpiralB tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralBToArc tangency point from spiral to arc
        
        Parameter ``[out]``:
        arc arc between spirals.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def ScaleInPlace(*args, **kwargs):
        """
        ScaleInPlace(self: MSPyBentleyGeom.DSpiral2dBase, s: float) -> bool
        """
        ...
    
    def SetBearingAndCurvatureLimits(*args, **kwargs):
        """
        SetBearingAndCurvatureLimits(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, theta1: float, curvature1: float) -> bool
        """
        ...
    
    def SetBearingCurvatureLengthBearing(*args, **kwargs):
        """
        SetBearingCurvatureLengthBearing(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, theta1: float) -> bool
        
        Set start bearing, start curvature, length, and end
        curvature. (Compute end bearing)
        
        Parameter ``[in]``:
        theta0 start bearing
        
        Parameter ``[in]``:
        curvature0 start curvature
        
        Parameter ``[in]``:
        length arc length
        
        Parameter ``[in]``:
        theta1 end bearing
        """
        ...
    
    def SetBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        SetBearingCurvatureLengthCurvature(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, curvature1: float) -> bool
        """
        ...
    
    def StringToTransitionType(*args, **kwargs):
        """
        StringToTransitionType(name: str) -> int
        
        return the integer code for the string name.
        """
        ...
    
    def Stroke(*args, **kwargs):
        """
        Stroke(*args, **kwargs)
        Overloaded function.
        
        1. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, pDXY: Bentley.DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        2. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, xyz0: MSPyBentleyGeom.DPoint3d, pXYZ: MSPyBentleyGeom.DPoint3d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        3. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: Bentley.DVec2d) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        4. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: Bentley.DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        5. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: Bentley.DVec2d, pFraction: float, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        6. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: Bentley.DVec2d, maxStrokeLength: float) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        7. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, uvPoints: Bentley.Bstdcxx.bvector<Bentley.DVec2d,Bentley.BentleyAllocator<Bentley.DVec2d> >, fractions: MSPyBentley.DoubleArray, maxStrokeLength: float = 10000.0) -> tuple
        """
        ...
    
    def StrokeToAnnouncer(*args, **kwargs):
        """
        StrokeToAnnouncer(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, F: MSPyBentleyGeom.AnnounceDoubleDPoint2d, minIndex: int = 0, maxStrokeLength: float = 10000.0) -> tuple
        
        Integrate the vector displacements of a clothoid over a
        fractional interval. This uses the angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        startFraction start fraction for integral.
        
        Parameter ``[in]``:
        endFraction end fraction for integral.
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points. A
        default is used if 0.0 is passed.
        
        Parameter ``[in]``:
        F object with a method F->Announce (f, uv) called to announce
        fraction and coordinate as computed.
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Parameter ``[out]``:
        minInterval smallest number of intervals allowed
        
        Parameter ``[out]``:
        maxStrokeLength maximum allowed stroke length
        
        Returns:
        false if point integration failed
        """
        ...
    
    def SymmetricLineSpiralSpiralLineTransition(*args, **kwargs):
        """
        SymmetricLineSpiralSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, length: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralToSpiral: MSPyBentleyGeom.DPoint3d) -> tuple
        
        compute spirals and arc to make a line-to-line
        transition.
        
        Parameter ``[in]``:
        lineAPoint point on line A.
        
        Parameter ``[in]``:
        lineBPoint point on line B.
        
        Parameter ``[in]``:
        lineLineIntersection intersection of lines.
        
        Parameter ``[in]``:
        length length of spiral from line A to junction
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        lineToSpiralA tangency point from line to spiral
        
        Parameter ``[out]``:
        lineToSpiralB tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralToSpiral tangency point from spiral to to spiral
        
        Parameter ``[out]``:
        junctionRadius radius at transition between the spirals.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def SymmetricPointShoulderTargetTransition(*args, **kwargs):
        """
        SymmetricPointShoulderTargetTransition(startPoint: MSPyBentleyGeom.DPoint2d, shoulderPoint: MSPyBentleyGeom.DPoint2d, targetPoint: MSPyBentleyGeom.DPoint2d, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, junctionPoint: MSPyBentleyGeom.DPoint2d, endPoint: MSPyBentleyGeom.DPoint2d) -> bool
        
        compute 2 spirals.
        
        Parameter ``[in]``:
        startPoint start point
        
        Parameter ``[in]``:
        shoulderPoint target point for first and last tangents
        
        Parameter ``[in]``:
        targetPoint target point for last tangent
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        junctionPoint transition between spirals. This is the max
        curvature point.
        
        Parameter ``[out]``:
        endPoint end of second spiral.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def TransitionTypeToString(*args, **kwargs):
        """
        TransitionTypeToString(type: int) -> str
        
        return the string name of the type
        """
        ...
    
    TransitionType_Arema: int
    
    TransitionType_AustralianRailCorp: int
    
    TransitionType_Biquadratic: int
    
    TransitionType_Bloss: int
    
    TransitionType_ChineseCubic: int
    
    TransitionType_Clothoid: int
    
    TransitionType_Cosine: int
    
    TransitionType_Czech: int
    
    TransitionType_CzechAlongTangent: int
    
    TransitionType_DirectHalfCosine: int
    
    TransitionType_FirstDirectEvaluate: int
    
    TransitionType_Italian: int
    
    TransitionType_JapaneseCubic: int
    
    TransitionType_MXCubicAlongArc: int
    
    TransitionType_MXCubicAlongTangent: int
    
    TransitionType_PolishCubic: int
    
    TransitionType_Sine: int
    
    TransitionType_Unknown: int
    
    TransitionType_Viennese: int
    
    TransitionType_WeightedViennese: int
    
    TransitionType_WesternAustralian: int
    
    def VectorIntegrandCount(*args, **kwargs):
        """
        VectorIntegrandCount(self: MSPyBentleyGeom.BSIVectorIntegrand) -> int
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.DSpiral2dCzechAlongTangent, nominalLength: float) -> None:
        ...
    
class DSpiral2dDirectEvaluation:
    """
    None
    """

    class ASLSACollector:
        """
        None
        """
    
        def Collect(*args, **kwargs):
            """
            Collect(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector, centerA: MSPyBentleyGeom.DPoint3d, arcToSpiralA: MSPyBentleyGeom.DPoint3d, sprialA: MSPyBentleyGeom.DSpiral2dBase, sprialToLineA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, arcToSpiralB: MSPyBentleyGeom.DPoint3d, spiralB: MSPyBentleyGeom.DSpiral2dBase, spiralToLibeB: MSPyBentleyGeom.DPoint3d) -> None
            """
            ...
        
        def __init__(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> None:
            ...
        
    def ApplyCCWRotation(*args, **kwargs):
        """
        ApplyCCWRotation(radians: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: Bentley.DVec2d, d2XYZ: Bentley.DVec2d, d3XYZ: Bentley.DVec2d) -> None
        
        rotate xy and optional derivatives by radians. (To be called by
        derived class EvaluateAtDistance when to rotate EvaluateAtDistance
        results from standard position)
        """
        ...
    
    def ArcSpiralLineSpiralArcTransition(*args, **kwargs):
        """
        ArcSpiralLineSpiralArcTransition(centerA: MSPyBentleyGeom.DPoint3d, radiusA: float, lengthA: float, centerB: MSPyBentleyGeom.DPoint3d, radiusB: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, collector: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> int
        """
        ...
    
    def Clone(*args, **kwargs):
        """
        Clone(self: MSPyBentleyGeom.DSpiral2dBase) -> MSPyBentleyGeom.DSpiral2dBase
        """
        ...
    
    def ClosestPoint(*args, **kwargs):
        """
        ClosestPoint(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, spiralToWorld: Bentley.Transform, spacePoint: MSPyBentleyGeom.DPoint3d) -> tuple
        
        Compute the closest spiral point for a given space point.
        
        Parameter ``[in]``:
        spiral spiral to evaluate.
        
        Parameter ``[in]``:
        startFraction start fraction of search range
        
        Parameter ``[in]``:
        endFraction endFraction of search range
        
        Parameter ``[in]``:
        spiralToWorld transform placing the spiral local coordinates into
        the world coordinate system
        
        Parameter ``[in]``:
        spacePoint world coordinates of space point.
        
        Parameter ``[out]``:
        spiralPoint world coordinates of closest point on spiral
        
        Parameter ``[out]``:
        spiralFraction fractional coordinates of closest point on spiral
        
        Parameter ``[out]``:
        minDistance distance from space point to spiralPoint.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def CopyBaseParameters(*args, **kwargs):
        """
        CopyBaseParameters(self: MSPyBentleyGeom.DSpiral2dBase, pSource: MSPyBentleyGeom.DSpiral2dBase) -> None
        """
        ...
    
    def CreateBearingCurvatureBearingCurvature(*args, **kwargs):
        """
        CreateBearingCurvatureBearingCurvature(*args, **kwargs)
        Overloaded function.
        
        1. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float, extraData: MSPyBentley.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def CreateBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        CreateBearingCurvatureLengthCurvature(*args, **kwargs)
        Overloaded function.
        
        1. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float, extraData: MSPyBentley.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def DefaultStrokeAngle(*args, **kwargs):
        """
        DefaultStrokeAngle() -> float
        """
        ...
    
    def DistanceToCurvature(*args, **kwargs):
        """
        DistanceToCurvature(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToCurvatureDerivative(*args, **kwargs):
        """
        DistanceToCurvatureDerivative(self: MSPyBentleyGeom.DSpiral2dBase, arg0: float) -> float
        
        distance
        """
        ...
    
    def DistanceToFraction(*args, **kwargs):
        """
        DistanceToFraction(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToGlobalAngle(*args, **kwargs):
        """
        DistanceToGlobalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToLocalAngle(*args, **kwargs):
        """
        DistanceToLocalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def EvaluateAtFraction(*args, **kwargs):
        """
        EvaluateAtFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: Bentley.DVec2d, d2XYZ: Bentley.DVec2d, d3XYZ: Bentley.DVec2d) -> bool
        
        Evaluate the spiral and derivatives at specified fractional position
        return true if valid evaluation. DSpiral2dDirectEvaluation default
        implementation returns false.
        """
        ...
    
    def EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(*args, **kwargs):
        """
        EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(s: float, length: float, curvature1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: Bentley.DVec2d, d2XY: Bentley.DVec2d, d3XY: Bentley.DVec2d) -> bool
        
        [in] distance for evaluation [in] nominal length. ASSUMED NONZERO [in]
        exit curvature. ASSUMED NONZERO [out] coordinates on spiral [out]
        first derivative wrt distance [out] second derivative wrt distance
        [out] third derivative wrt distance
        """
        ...
    
    def EvaluateVectorIntegrand(*args, **kwargs):
        """
        EvaluateVectorIntegrand(self: MSPyBentleyGeom.DSpiral2dBase, distance: float, pF: float) -> None
        """
        ...
    
    def FractionToCurvature(*args, **kwargs):
        """
        FractionToCurvature(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float
        
        Return the true curvature at fractional position. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDCurvatureDFraction(*args, **kwargs):
        """
        FractionToDCurvatureDFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> tuple
        
        Return the true curvature derivative wrt fraction. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDerivatives(*args, **kwargs):
        """
        FractionToDerivatives(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float, dXdf: Bentley.DVec2d, ddXdfdf: Bentley.DVec2d, dddXdfdfdf: Bentley.DVec2d) -> bool
        """
        ...
    
    def FractionToDistance(*args, **kwargs):
        """
        FractionToDistance(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float) -> float
        """
        ...
    
    def FractionToLocalAngle(*args, **kwargs):
        """
        FractionToLocalAngle(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float
        
        Return the tangent angle (in radians) in local coordinates
        """
        ...
    
    def FractionToVelocity(*args, **kwargs):
        """
        FractionToVelocity(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float
        
        Return the magnitude of the true derivative of position wrt fraction.
        Implemented in DSpiral2dDirectEvaluation, not individual classes.
        Assume EvaluateAtFraction.
        """
        ...
    
    def GetExtraData(*args, **kwargs):
        """
        GetExtraData(self: MSPyBentleyGeom.DSpiral2dBase, extraData: MSPyBentley.DoubleArray) -> None
        
        Get the extra data for this spiral. REMARK:This should be a virtual,
        but is implemented as special cases because of API change restriction
        """
        ...
    
    def GetIntervalCount(*args, **kwargs):
        """
        GetIntervalCount(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, minInterval: int = 0, maxStrokeLength: float = 10000.0) -> int
        
        Return an interval count for stroking or integration. Except for
        degenerate single interval cases, the interval count is always even.
        That is the possible values are
        
        Parameter ``[in]``:
        spiral spiral being queried.
        
        Parameter ``[in]``:
        startFraction start of interval to stroke.
        
        Parameter ``[in]``:
        endFraction end of interval to stroke.
        
        Parameter ``[in]``:
        maxRadians max turn between strokes.
        
        Parameter ``[in]``:
        minInterval smallest number of intervals.
        
        Parameter ``[in]``:
        maxStrokeLength largest stroke size. Recommended 10 meters
        """
        ...
    
    def GetTransitionTypeCode(*args, **kwargs):
        """
        GetTransitionTypeCode(self: MSPyBentleyGeom.DSpiral2dBase) -> int
        """
        ...
    
    def GetVectorIntegrandCount(*args, **kwargs):
        """
        GetVectorIntegrandCount(self: MSPyBentleyGeom.DSpiral2dBase) -> int
        """
        ...
    
    def IsValidRLCombination(*args, **kwargs):
        """
        IsValidRLCombination(lengthFromInflection: float, radius: float, spiralType: int = 0) -> bool
        
        test if a length-from-inflection and final radius
        combination is " small enough " for reasonable use. Test depends on
        spiral type:
        
        * DSpiral2dBase.TransitionType_None indicates apply the strictest
        test (same as Czech and Italian)
        
        * DSpiral2dBase.TransitionType_Czech and
        DSpiral2dBase.TransitionType_Italian indicate a strict test L<2*R
        
        * other types have no restrictions.
        
        Parameter ``[in]``:
        lengthFromInflection [in] distance along spiral starting at
        inflection and ending at finalRadius.
        
        Parameter ``[in]``:
        finalRadius [in] final radius
        
        Parameter ``[in]``:
        spiralType [in] spiral type.
        
        Parameter ``[in]``:
        lengthFactor expansion or reduction factor to apply to the allowed
        length. +---------------+---------------+---------------+---------
        ------+------
        """
        ...
    
    def LineSpiralArcSpiralLineTransition(*args, **kwargs):
        """
        LineSpiralArcSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, radius: float, lengthA: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralAToArc: MSPyBentleyGeom.DPoint3d, spiralBToArc: MSPyBentleyGeom.DPoint3d, arc: MSPyBentleyGeom.DEllipse3d) -> bool
        
        compute spirals and arc to make a line-to-line
        transition.
        
        Parameter ``[in]``:
        lineAPoint point on line A.
        
        Parameter ``[in]``:
        lineBPoint point on line B.
        
        Parameter ``[in]``:
        lineLineIntersection intersection of lines.
        
        Parameter ``[in]``:
        radius radius for circular part of transition.
        
        Parameter ``[in]``:
        lengthA length of spiral from line A to circle.
        
        Parameter ``[in]``:
        lengthB length of spiral from line B to circle.
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        lineToSpiralA tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralAToArc tangency point from spiral to arc
        
        Parameter ``[out]``:
        lineToSpiralB tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralBToArc tangency point from spiral to arc
        
        Parameter ``[out]``:
        arc arc between spirals.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def ScaleInPlace(*args, **kwargs):
        """
        ScaleInPlace(self: MSPyBentleyGeom.DSpiral2dBase, s: float) -> bool
        """
        ...
    
    def SetBearingAndCurvatureLimits(*args, **kwargs):
        """
        SetBearingAndCurvatureLimits(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, theta1: float, curvature1: float) -> bool
        """
        ...
    
    def SetBearingCurvatureLengthBearing(*args, **kwargs):
        """
        SetBearingCurvatureLengthBearing(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, theta1: float) -> bool
        
        Set start bearing, start curvature, length, and end
        curvature. (Compute end bearing)
        
        Parameter ``[in]``:
        theta0 start bearing
        
        Parameter ``[in]``:
        curvature0 start curvature
        
        Parameter ``[in]``:
        length arc length
        
        Parameter ``[in]``:
        theta1 end bearing
        """
        ...
    
    def SetBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        SetBearingCurvatureLengthCurvature(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, curvature1: float) -> bool
        """
        ...
    
    def StringToTransitionType(*args, **kwargs):
        """
        StringToTransitionType(name: str) -> int
        
        return the integer code for the string name.
        """
        ...
    
    def Stroke(*args, **kwargs):
        """
        Stroke(*args, **kwargs)
        Overloaded function.
        
        1. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, pDXY: Bentley.DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        2. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, xyz0: MSPyBentleyGeom.DPoint3d, pXYZ: MSPyBentleyGeom.DPoint3d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        3. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: Bentley.DVec2d) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        4. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: Bentley.DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        5. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: Bentley.DVec2d, pFraction: float, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        6. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: Bentley.DVec2d, maxStrokeLength: float) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        7. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, uvPoints: Bentley.Bstdcxx.bvector<Bentley.DVec2d,Bentley.BentleyAllocator<Bentley.DVec2d> >, fractions: MSPyBentley.DoubleArray, maxStrokeLength: float = 10000.0) -> tuple
        """
        ...
    
    def StrokeToAnnouncer(*args, **kwargs):
        """
        StrokeToAnnouncer(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, F: MSPyBentleyGeom.AnnounceDoubleDPoint2d, minIndex: int = 0, maxStrokeLength: float = 10000.0) -> tuple
        
        Integrate the vector displacements of a clothoid over a
        fractional interval. This uses the angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        startFraction start fraction for integral.
        
        Parameter ``[in]``:
        endFraction end fraction for integral.
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points. A
        default is used if 0.0 is passed.
        
        Parameter ``[in]``:
        F object with a method F->Announce (f, uv) called to announce
        fraction and coordinate as computed.
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Parameter ``[out]``:
        minInterval smallest number of intervals allowed
        
        Parameter ``[out]``:
        maxStrokeLength maximum allowed stroke length
        
        Returns:
        false if point integration failed
        """
        ...
    
    def SymmetricLineSpiralSpiralLineTransition(*args, **kwargs):
        """
        SymmetricLineSpiralSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, length: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralToSpiral: MSPyBentleyGeom.DPoint3d) -> tuple
        
        compute spirals and arc to make a line-to-line
        transition.
        
        Parameter ``[in]``:
        lineAPoint point on line A.
        
        Parameter ``[in]``:
        lineBPoint point on line B.
        
        Parameter ``[in]``:
        lineLineIntersection intersection of lines.
        
        Parameter ``[in]``:
        length length of spiral from line A to junction
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        lineToSpiralA tangency point from line to spiral
        
        Parameter ``[out]``:
        lineToSpiralB tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralToSpiral tangency point from spiral to to spiral
        
        Parameter ``[out]``:
        junctionRadius radius at transition between the spirals.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def SymmetricPointShoulderTargetTransition(*args, **kwargs):
        """
        SymmetricPointShoulderTargetTransition(startPoint: MSPyBentleyGeom.DPoint2d, shoulderPoint: MSPyBentleyGeom.DPoint2d, targetPoint: MSPyBentleyGeom.DPoint2d, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, junctionPoint: MSPyBentleyGeom.DPoint2d, endPoint: MSPyBentleyGeom.DPoint2d) -> bool
        
        compute 2 spirals.
        
        Parameter ``[in]``:
        startPoint start point
        
        Parameter ``[in]``:
        shoulderPoint target point for first and last tangents
        
        Parameter ``[in]``:
        targetPoint target point for last tangent
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        junctionPoint transition between spirals. This is the max
        curvature point.
        
        Parameter ``[out]``:
        endPoint end of second spiral.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def TransitionTypeToString(*args, **kwargs):
        """
        TransitionTypeToString(type: int) -> str
        
        return the string name of the type
        """
        ...
    
    TransitionType_Arema: int
    
    TransitionType_AustralianRailCorp: int
    
    TransitionType_Biquadratic: int
    
    TransitionType_Bloss: int
    
    TransitionType_ChineseCubic: int
    
    TransitionType_Clothoid: int
    
    TransitionType_Cosine: int
    
    TransitionType_Czech: int
    
    TransitionType_CzechAlongTangent: int
    
    TransitionType_DirectHalfCosine: int
    
    TransitionType_FirstDirectEvaluate: int
    
    TransitionType_Italian: int
    
    TransitionType_JapaneseCubic: int
    
    TransitionType_MXCubicAlongArc: int
    
    TransitionType_MXCubicAlongTangent: int
    
    TransitionType_PolishCubic: int
    
    TransitionType_Sine: int
    
    TransitionType_Unknown: int
    
    TransitionType_Viennese: int
    
    TransitionType_WeightedViennese: int
    
    TransitionType_WesternAustralian: int
    
    def VectorIntegrandCount(*args, **kwargs):
        """
        VectorIntegrandCount(self: MSPyBentleyGeom.BSIVectorIntegrand) -> int
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, nominalLength: float) -> None:
        ...
    
class DSpiral2dDirectHalfCosine:
    """
    None
    """

    class ASLSACollector:
        """
        None
        """
    
        def Collect(*args, **kwargs):
            """
            Collect(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector, centerA: MSPyBentleyGeom.DPoint3d, arcToSpiralA: MSPyBentleyGeom.DPoint3d, sprialA: MSPyBentleyGeom.DSpiral2dBase, sprialToLineA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, arcToSpiralB: MSPyBentleyGeom.DPoint3d, spiralB: MSPyBentleyGeom.DSpiral2dBase, spiralToLibeB: MSPyBentleyGeom.DPoint3d) -> None
            """
            ...
        
        def __init__(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> None:
            ...
        
    def ApplyCCWRotation(*args, **kwargs):
        """
        ApplyCCWRotation(radians: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: Bentley.DVec2d, d2XYZ: Bentley.DVec2d, d3XYZ: Bentley.DVec2d) -> None
        
        rotate xy and optional derivatives by radians. (To be called by
        derived class EvaluateAtDistance when to rotate EvaluateAtDistance
        results from standard position)
        """
        ...
    
    def ArcSpiralLineSpiralArcTransition(*args, **kwargs):
        """
        ArcSpiralLineSpiralArcTransition(centerA: MSPyBentleyGeom.DPoint3d, radiusA: float, lengthA: float, centerB: MSPyBentleyGeom.DPoint3d, radiusB: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, collector: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> int
        """
        ...
    
    def Clone(*args, **kwargs):
        """
        Clone(self: MSPyBentleyGeom.DSpiral2dBase) -> MSPyBentleyGeom.DSpiral2dBase
        """
        ...
    
    def ClosestPoint(*args, **kwargs):
        """
        ClosestPoint(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, spiralToWorld: Bentley.Transform, spacePoint: MSPyBentleyGeom.DPoint3d) -> tuple
        
        Compute the closest spiral point for a given space point.
        
        Parameter ``[in]``:
        spiral spiral to evaluate.
        
        Parameter ``[in]``:
        startFraction start fraction of search range
        
        Parameter ``[in]``:
        endFraction endFraction of search range
        
        Parameter ``[in]``:
        spiralToWorld transform placing the spiral local coordinates into
        the world coordinate system
        
        Parameter ``[in]``:
        spacePoint world coordinates of space point.
        
        Parameter ``[out]``:
        spiralPoint world coordinates of closest point on spiral
        
        Parameter ``[out]``:
        spiralFraction fractional coordinates of closest point on spiral
        
        Parameter ``[out]``:
        minDistance distance from space point to spiralPoint.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def CopyBaseParameters(*args, **kwargs):
        """
        CopyBaseParameters(self: MSPyBentleyGeom.DSpiral2dBase, pSource: MSPyBentleyGeom.DSpiral2dBase) -> None
        """
        ...
    
    def CreateBearingCurvatureBearingCurvature(*args, **kwargs):
        """
        CreateBearingCurvatureBearingCurvature(*args, **kwargs)
        Overloaded function.
        
        1. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float, extraData: MSPyBentley.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def CreateBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        CreateBearingCurvatureLengthCurvature(*args, **kwargs)
        Overloaded function.
        
        1. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float, extraData: MSPyBentley.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def DefaultStrokeAngle(*args, **kwargs):
        """
        DefaultStrokeAngle() -> float
        """
        ...
    
    def DistanceToCurvature(*args, **kwargs):
        """
        DistanceToCurvature(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToCurvatureDerivative(*args, **kwargs):
        """
        DistanceToCurvatureDerivative(self: MSPyBentleyGeom.DSpiral2dBase, arg0: float) -> float
        
        distance
        """
        ...
    
    def DistanceToFraction(*args, **kwargs):
        """
        DistanceToFraction(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToGlobalAngle(*args, **kwargs):
        """
        DistanceToGlobalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToLocalAngle(*args, **kwargs):
        """
        DistanceToLocalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def EvaluateAtFraction(*args, **kwargs):
        """
        EvaluateAtFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: Bentley.DVec2d, d2XYZ: Bentley.DVec2d, d3XYZ: Bentley.DVec2d) -> bool
        
        Evaluate the spiral and derivatives at specified fractional position
        return true if valid evaluation. DSpiral2dDirectEvaluation default
        implementation returns false.
        """
        ...
    
    def EvaluateAtFractionInStandardOrientation(*args, **kwargs):
        """
        EvaluateAtFractionInStandardOrientation(s: float, axisLength: float, radius1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: Bentley.DVec2d, d2XY: Bentley.DVec2d, d3XY: Bentley.DVec2d) -> bool
        
        Evaluate at distance a spiral in standard orientation -- zero
        curvature at origin.
        """
        ...
    
    def EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(*args, **kwargs):
        """
        EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(s: float, length: float, curvature1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: Bentley.DVec2d, d2XY: Bentley.DVec2d, d3XY: Bentley.DVec2d) -> bool
        
        [in] distance for evaluation [in] nominal length. ASSUMED NONZERO [in]
        exit curvature. ASSUMED NONZERO [out] coordinates on spiral [out]
        first derivative wrt distance [out] second derivative wrt distance
        [out] third derivative wrt distance
        """
        ...
    
    def EvaluateVectorIntegrand(*args, **kwargs):
        """
        EvaluateVectorIntegrand(self: MSPyBentleyGeom.DSpiral2dBase, distance: float, pF: float) -> None
        """
        ...
    
    def FractionToCurvature(*args, **kwargs):
        """
        FractionToCurvature(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float
        
        Return the true curvature at fractional position. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDCurvatureDFraction(*args, **kwargs):
        """
        FractionToDCurvatureDFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> tuple
        
        Return the true curvature derivative wrt fraction. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDerivatives(*args, **kwargs):
        """
        FractionToDerivatives(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float, dXdf: Bentley.DVec2d, ddXdfdf: Bentley.DVec2d, dddXdfdfdf: Bentley.DVec2d) -> bool
        """
        ...
    
    def FractionToDistance(*args, **kwargs):
        """
        FractionToDistance(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float) -> float
        """
        ...
    
    def FractionToLocalAngle(*args, **kwargs):
        """
        FractionToLocalAngle(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float
        
        Return the tangent angle (in radians) in local coordinates
        """
        ...
    
    def FractionToVelocity(*args, **kwargs):
        """
        FractionToVelocity(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float
        
        Return the magnitude of the true derivative of position wrt fraction.
        Implemented in DSpiral2dDirectEvaluation, not individual classes.
        Assume EvaluateAtFraction.
        """
        ...
    
    def GetExtraData(*args, **kwargs):
        """
        GetExtraData(self: MSPyBentleyGeom.DSpiral2dBase, extraData: MSPyBentley.DoubleArray) -> None
        
        Get the extra data for this spiral. REMARK:This should be a virtual,
        but is implemented as special cases because of API change restriction
        """
        ...
    
    def GetIntervalCount(*args, **kwargs):
        """
        GetIntervalCount(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, minInterval: int = 0, maxStrokeLength: float = 10000.0) -> int
        
        Return an interval count for stroking or integration. Except for
        degenerate single interval cases, the interval count is always even.
        That is the possible values are
        
        Parameter ``[in]``:
        spiral spiral being queried.
        
        Parameter ``[in]``:
        startFraction start of interval to stroke.
        
        Parameter ``[in]``:
        endFraction end of interval to stroke.
        
        Parameter ``[in]``:
        maxRadians max turn between strokes.
        
        Parameter ``[in]``:
        minInterval smallest number of intervals.
        
        Parameter ``[in]``:
        maxStrokeLength largest stroke size. Recommended 10 meters
        """
        ...
    
    def GetTransitionTypeCode(*args, **kwargs):
        """
        GetTransitionTypeCode(self: MSPyBentleyGeom.DSpiral2dBase) -> int
        """
        ...
    
    def GetVectorIntegrandCount(*args, **kwargs):
        """
        GetVectorIntegrandCount(self: MSPyBentleyGeom.DSpiral2dBase) -> int
        """
        ...
    
    def IsValidRLCombination(*args, **kwargs):
        """
        IsValidRLCombination(lengthFromInflection: float, radius: float, spiralType: int = 0) -> bool
        
        test if a length-from-inflection and final radius
        combination is " small enough " for reasonable use. Test depends on
        spiral type:
        
        * DSpiral2dBase.TransitionType_None indicates apply the strictest
        test (same as Czech and Italian)
        
        * DSpiral2dBase.TransitionType_Czech and
        DSpiral2dBase.TransitionType_Italian indicate a strict test L<2*R
        
        * other types have no restrictions.
        
        Parameter ``[in]``:
        lengthFromInflection [in] distance along spiral starting at
        inflection and ending at finalRadius.
        
        Parameter ``[in]``:
        finalRadius [in] final radius
        
        Parameter ``[in]``:
        spiralType [in] spiral type.
        
        Parameter ``[in]``:
        lengthFactor expansion or reduction factor to apply to the allowed
        length. +---------------+---------------+---------------+---------
        ------+------
        """
        ...
    
    def LineSpiralArcSpiralLineTransition(*args, **kwargs):
        """
        LineSpiralArcSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, radius: float, lengthA: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralAToArc: MSPyBentleyGeom.DPoint3d, spiralBToArc: MSPyBentleyGeom.DPoint3d, arc: MSPyBentleyGeom.DEllipse3d) -> bool
        
        compute spirals and arc to make a line-to-line
        transition.
        
        Parameter ``[in]``:
        lineAPoint point on line A.
        
        Parameter ``[in]``:
        lineBPoint point on line B.
        
        Parameter ``[in]``:
        lineLineIntersection intersection of lines.
        
        Parameter ``[in]``:
        radius radius for circular part of transition.
        
        Parameter ``[in]``:
        lengthA length of spiral from line A to circle.
        
        Parameter ``[in]``:
        lengthB length of spiral from line B to circle.
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        lineToSpiralA tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralAToArc tangency point from spiral to arc
        
        Parameter ``[out]``:
        lineToSpiralB tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralBToArc tangency point from spiral to arc
        
        Parameter ``[out]``:
        arc arc between spirals.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def ScaleInPlace(*args, **kwargs):
        """
        ScaleInPlace(self: MSPyBentleyGeom.DSpiral2dBase, s: float) -> bool
        """
        ...
    
    def SetBearingAndCurvatureLimits(*args, **kwargs):
        """
        SetBearingAndCurvatureLimits(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, theta1: float, curvature1: float) -> bool
        """
        ...
    
    def SetBearingCurvatureLengthBearing(*args, **kwargs):
        """
        SetBearingCurvatureLengthBearing(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, theta1: float) -> bool
        
        Set start bearing, start curvature, length, and end
        curvature. (Compute end bearing)
        
        Parameter ``[in]``:
        theta0 start bearing
        
        Parameter ``[in]``:
        curvature0 start curvature
        
        Parameter ``[in]``:
        length arc length
        
        Parameter ``[in]``:
        theta1 end bearing
        """
        ...
    
    def SetBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        SetBearingCurvatureLengthCurvature(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, curvature1: float) -> bool
        """
        ...
    
    def StringToTransitionType(*args, **kwargs):
        """
        StringToTransitionType(name: str) -> int
        
        return the integer code for the string name.
        """
        ...
    
    def Stroke(*args, **kwargs):
        """
        Stroke(*args, **kwargs)
        Overloaded function.
        
        1. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, pDXY: Bentley.DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        2. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, xyz0: MSPyBentleyGeom.DPoint3d, pXYZ: MSPyBentleyGeom.DPoint3d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        3. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: Bentley.DVec2d) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        4. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: Bentley.DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        5. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: Bentley.DVec2d, pFraction: float, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        6. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: Bentley.DVec2d, maxStrokeLength: float) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        7. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, uvPoints: Bentley.Bstdcxx.bvector<Bentley.DVec2d,Bentley.BentleyAllocator<Bentley.DVec2d> >, fractions: MSPyBentley.DoubleArray, maxStrokeLength: float = 10000.0) -> tuple
        """
        ...
    
    def StrokeToAnnouncer(*args, **kwargs):
        """
        StrokeToAnnouncer(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, F: MSPyBentleyGeom.AnnounceDoubleDPoint2d, minIndex: int = 0, maxStrokeLength: float = 10000.0) -> tuple
        
        Integrate the vector displacements of a clothoid over a
        fractional interval. This uses the angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        startFraction start fraction for integral.
        
        Parameter ``[in]``:
        endFraction end fraction for integral.
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points. A
        default is used if 0.0 is passed.
        
        Parameter ``[in]``:
        F object with a method F->Announce (f, uv) called to announce
        fraction and coordinate as computed.
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Parameter ``[out]``:
        minInterval smallest number of intervals allowed
        
        Parameter ``[out]``:
        maxStrokeLength maximum allowed stroke length
        
        Returns:
        false if point integration failed
        """
        ...
    
    def SymmetricLineSpiralSpiralLineTransition(*args, **kwargs):
        """
        SymmetricLineSpiralSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, length: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralToSpiral: MSPyBentleyGeom.DPoint3d) -> tuple
        
        compute spirals and arc to make a line-to-line
        transition.
        
        Parameter ``[in]``:
        lineAPoint point on line A.
        
        Parameter ``[in]``:
        lineBPoint point on line B.
        
        Parameter ``[in]``:
        lineLineIntersection intersection of lines.
        
        Parameter ``[in]``:
        length length of spiral from line A to junction
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        lineToSpiralA tangency point from line to spiral
        
        Parameter ``[out]``:
        lineToSpiralB tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralToSpiral tangency point from spiral to to spiral
        
        Parameter ``[out]``:
        junctionRadius radius at transition between the spirals.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def SymmetricPointShoulderTargetTransition(*args, **kwargs):
        """
        SymmetricPointShoulderTargetTransition(startPoint: MSPyBentleyGeom.DPoint2d, shoulderPoint: MSPyBentleyGeom.DPoint2d, targetPoint: MSPyBentleyGeom.DPoint2d, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, junctionPoint: MSPyBentleyGeom.DPoint2d, endPoint: MSPyBentleyGeom.DPoint2d) -> bool
        
        compute 2 spirals.
        
        Parameter ``[in]``:
        startPoint start point
        
        Parameter ``[in]``:
        shoulderPoint target point for first and last tangents
        
        Parameter ``[in]``:
        targetPoint target point for last tangent
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        junctionPoint transition between spirals. This is the max
        curvature point.
        
        Parameter ``[out]``:
        endPoint end of second spiral.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def TransitionTypeToString(*args, **kwargs):
        """
        TransitionTypeToString(type: int) -> str
        
        return the string name of the type
        """
        ...
    
    TransitionType_Arema: int
    
    TransitionType_AustralianRailCorp: int
    
    TransitionType_Biquadratic: int
    
    TransitionType_Bloss: int
    
    TransitionType_ChineseCubic: int
    
    TransitionType_Clothoid: int
    
    TransitionType_Cosine: int
    
    TransitionType_Czech: int
    
    TransitionType_CzechAlongTangent: int
    
    TransitionType_DirectHalfCosine: int
    
    TransitionType_FirstDirectEvaluate: int
    
    TransitionType_Italian: int
    
    TransitionType_JapaneseCubic: int
    
    TransitionType_MXCubicAlongArc: int
    
    TransitionType_MXCubicAlongTangent: int
    
    TransitionType_PolishCubic: int
    
    TransitionType_Sine: int
    
    TransitionType_Unknown: int
    
    TransitionType_Viennese: int
    
    TransitionType_WeightedViennese: int
    
    TransitionType_WesternAustralian: int
    
    def VectorIntegrandCount(*args, **kwargs):
        """
        VectorIntegrandCount(self: MSPyBentleyGeom.BSIVectorIntegrand) -> int
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.DSpiral2dDirectHalfCosine, axisLength: float) -> None:
        ...
    
class DSpiral2dItalian:
    """
    None
    """

    class ASLSACollector:
        """
        None
        """
    
        def Collect(*args, **kwargs):
            """
            Collect(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector, centerA: MSPyBentleyGeom.DPoint3d, arcToSpiralA: MSPyBentleyGeom.DPoint3d, sprialA: MSPyBentleyGeom.DSpiral2dBase, sprialToLineA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, arcToSpiralB: MSPyBentleyGeom.DPoint3d, spiralB: MSPyBentleyGeom.DSpiral2dBase, spiralToLibeB: MSPyBentleyGeom.DPoint3d) -> None
            """
            ...
        
        def __init__(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> None:
            ...
        
    def ApplyCCWRotation(*args, **kwargs):
        """
        ApplyCCWRotation(radians: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: Bentley.DVec2d, d2XYZ: Bentley.DVec2d, d3XYZ: Bentley.DVec2d) -> None
        
        rotate xy and optional derivatives by radians. (To be called by
        derived class EvaluateAtDistance when to rotate EvaluateAtDistance
        results from standard position)
        """
        ...
    
    def ArcSpiralLineSpiralArcTransition(*args, **kwargs):
        """
        ArcSpiralLineSpiralArcTransition(centerA: MSPyBentleyGeom.DPoint3d, radiusA: float, lengthA: float, centerB: MSPyBentleyGeom.DPoint3d, radiusB: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, collector: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> int
        """
        ...
    
    def Clone(*args, **kwargs):
        """
        Clone(self: MSPyBentleyGeom.DSpiral2dBase) -> MSPyBentleyGeom.DSpiral2dBase
        """
        ...
    
    def ClosestPoint(*args, **kwargs):
        """
        ClosestPoint(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, spiralToWorld: Bentley.Transform, spacePoint: MSPyBentleyGeom.DPoint3d) -> tuple
        
        Compute the closest spiral point for a given space point.
        
        Parameter ``[in]``:
        spiral spiral to evaluate.
        
        Parameter ``[in]``:
        startFraction start fraction of search range
        
        Parameter ``[in]``:
        endFraction endFraction of search range
        
        Parameter ``[in]``:
        spiralToWorld transform placing the spiral local coordinates into
        the world coordinate system
        
        Parameter ``[in]``:
        spacePoint world coordinates of space point.
        
        Parameter ``[out]``:
        spiralPoint world coordinates of closest point on spiral
        
        Parameter ``[out]``:
        spiralFraction fractional coordinates of closest point on spiral
        
        Parameter ``[out]``:
        minDistance distance from space point to spiralPoint.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def CopyBaseParameters(*args, **kwargs):
        """
        CopyBaseParameters(self: MSPyBentleyGeom.DSpiral2dBase, pSource: MSPyBentleyGeom.DSpiral2dBase) -> None
        """
        ...
    
    def CreateBearingCurvatureBearingCurvature(*args, **kwargs):
        """
        CreateBearingCurvatureBearingCurvature(*args, **kwargs)
        Overloaded function.
        
        1. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float, extraData: MSPyBentley.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def CreateBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        CreateBearingCurvatureLengthCurvature(*args, **kwargs)
        Overloaded function.
        
        1. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float, extraData: MSPyBentley.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def DefaultStrokeAngle(*args, **kwargs):
        """
        DefaultStrokeAngle() -> float
        """
        ...
    
    def DistanceToCurvature(*args, **kwargs):
        """
        DistanceToCurvature(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToCurvatureDerivative(*args, **kwargs):
        """
        DistanceToCurvatureDerivative(self: MSPyBentleyGeom.DSpiral2dBase, arg0: float) -> float
        
        distance
        """
        ...
    
    def DistanceToFraction(*args, **kwargs):
        """
        DistanceToFraction(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToGlobalAngle(*args, **kwargs):
        """
        DistanceToGlobalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToLocalAngle(*args, **kwargs):
        """
        DistanceToLocalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def EvaluateAtFraction(*args, **kwargs):
        """
        EvaluateAtFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: Bentley.DVec2d, d2XYZ: Bentley.DVec2d, d3XYZ: Bentley.DVec2d) -> bool
        
        Evaluate the spiral and derivatives at specified fractional position
        return true if valid evaluation. DSpiral2dDirectEvaluation default
        implementation returns false.
        """
        ...
    
    def EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(*args, **kwargs):
        """
        EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(s: float, length: float, curvature1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: Bentley.DVec2d, d2XY: Bentley.DVec2d, d3XY: Bentley.DVec2d) -> bool
        
        [in] distance for evaluation [in] nominal length. ASSUMED NONZERO [in]
        exit curvature. ASSUMED NONZERO [out] coordinates on spiral [out]
        first derivative wrt distance [out] second derivative wrt distance
        [out] third derivative wrt distance
        """
        ...
    
    def EvaluateVectorIntegrand(*args, **kwargs):
        """
        EvaluateVectorIntegrand(self: MSPyBentleyGeom.DSpiral2dBase, distance: float, pF: float) -> None
        """
        ...
    
    def FractionToCurvature(*args, **kwargs):
        """
        FractionToCurvature(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float
        
        Return the true curvature at fractional position. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDCurvatureDFraction(*args, **kwargs):
        """
        FractionToDCurvatureDFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> tuple
        
        Return the true curvature derivative wrt fraction. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDerivatives(*args, **kwargs):
        """
        FractionToDerivatives(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float, dXdf: Bentley.DVec2d, ddXdfdf: Bentley.DVec2d, dddXdfdfdf: Bentley.DVec2d) -> bool
        """
        ...
    
    def FractionToDistance(*args, **kwargs):
        """
        FractionToDistance(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float) -> float
        """
        ...
    
    def FractionToLocalAngle(*args, **kwargs):
        """
        FractionToLocalAngle(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float
        
        Return the tangent angle (in radians) in local coordinates
        """
        ...
    
    def FractionToVelocity(*args, **kwargs):
        """
        FractionToVelocity(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float
        
        Return the magnitude of the true derivative of position wrt fraction.
        Implemented in DSpiral2dDirectEvaluation, not individual classes.
        Assume EvaluateAtFraction.
        """
        ...
    
    def GetExtraData(*args, **kwargs):
        """
        GetExtraData(self: MSPyBentleyGeom.DSpiral2dBase, extraData: MSPyBentley.DoubleArray) -> None
        
        Get the extra data for this spiral. REMARK:This should be a virtual,
        but is implemented as special cases because of API change restriction
        """
        ...
    
    def GetIntervalCount(*args, **kwargs):
        """
        GetIntervalCount(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, minInterval: int = 0, maxStrokeLength: float = 10000.0) -> int
        
        Return an interval count for stroking or integration. Except for
        degenerate single interval cases, the interval count is always even.
        That is the possible values are
        
        Parameter ``[in]``:
        spiral spiral being queried.
        
        Parameter ``[in]``:
        startFraction start of interval to stroke.
        
        Parameter ``[in]``:
        endFraction end of interval to stroke.
        
        Parameter ``[in]``:
        maxRadians max turn between strokes.
        
        Parameter ``[in]``:
        minInterval smallest number of intervals.
        
        Parameter ``[in]``:
        maxStrokeLength largest stroke size. Recommended 10 meters
        """
        ...
    
    def GetTransitionTypeCode(*args, **kwargs):
        """
        GetTransitionTypeCode(self: MSPyBentleyGeom.DSpiral2dBase) -> int
        """
        ...
    
    def GetVectorIntegrandCount(*args, **kwargs):
        """
        GetVectorIntegrandCount(self: MSPyBentleyGeom.DSpiral2dBase) -> int
        """
        ...
    
    def IsValidRLCombination(*args, **kwargs):
        """
        IsValidRLCombination(lengthFromInflection: float, radius: float, spiralType: int = 0) -> bool
        
        test if a length-from-inflection and final radius
        combination is " small enough " for reasonable use. Test depends on
        spiral type:
        
        * DSpiral2dBase.TransitionType_None indicates apply the strictest
        test (same as Czech and Italian)
        
        * DSpiral2dBase.TransitionType_Czech and
        DSpiral2dBase.TransitionType_Italian indicate a strict test L<2*R
        
        * other types have no restrictions.
        
        Parameter ``[in]``:
        lengthFromInflection [in] distance along spiral starting at
        inflection and ending at finalRadius.
        
        Parameter ``[in]``:
        finalRadius [in] final radius
        
        Parameter ``[in]``:
        spiralType [in] spiral type.
        
        Parameter ``[in]``:
        lengthFactor expansion or reduction factor to apply to the allowed
        length. +---------------+---------------+---------------+---------
        ------+------
        """
        ...
    
    def LineSpiralArcSpiralLineTransition(*args, **kwargs):
        """
        LineSpiralArcSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, radius: float, lengthA: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralAToArc: MSPyBentleyGeom.DPoint3d, spiralBToArc: MSPyBentleyGeom.DPoint3d, arc: MSPyBentleyGeom.DEllipse3d) -> bool
        
        compute spirals and arc to make a line-to-line
        transition.
        
        Parameter ``[in]``:
        lineAPoint point on line A.
        
        Parameter ``[in]``:
        lineBPoint point on line B.
        
        Parameter ``[in]``:
        lineLineIntersection intersection of lines.
        
        Parameter ``[in]``:
        radius radius for circular part of transition.
        
        Parameter ``[in]``:
        lengthA length of spiral from line A to circle.
        
        Parameter ``[in]``:
        lengthB length of spiral from line B to circle.
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        lineToSpiralA tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralAToArc tangency point from spiral to arc
        
        Parameter ``[out]``:
        lineToSpiralB tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralBToArc tangency point from spiral to arc
        
        Parameter ``[out]``:
        arc arc between spirals.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def ScaleInPlace(*args, **kwargs):
        """
        ScaleInPlace(self: MSPyBentleyGeom.DSpiral2dBase, s: float) -> bool
        """
        ...
    
    def SetBearingAndCurvatureLimits(*args, **kwargs):
        """
        SetBearingAndCurvatureLimits(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, theta1: float, curvature1: float) -> bool
        """
        ...
    
    def SetBearingCurvatureLengthBearing(*args, **kwargs):
        """
        SetBearingCurvatureLengthBearing(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, theta1: float) -> bool
        
        Set start bearing, start curvature, length, and end
        curvature. (Compute end bearing)
        
        Parameter ``[in]``:
        theta0 start bearing
        
        Parameter ``[in]``:
        curvature0 start curvature
        
        Parameter ``[in]``:
        length arc length
        
        Parameter ``[in]``:
        theta1 end bearing
        """
        ...
    
    def SetBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        SetBearingCurvatureLengthCurvature(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, curvature1: float) -> bool
        """
        ...
    
    def StringToTransitionType(*args, **kwargs):
        """
        StringToTransitionType(name: str) -> int
        
        return the integer code for the string name.
        """
        ...
    
    def Stroke(*args, **kwargs):
        """
        Stroke(*args, **kwargs)
        Overloaded function.
        
        1. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, pDXY: Bentley.DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        2. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, xyz0: MSPyBentleyGeom.DPoint3d, pXYZ: MSPyBentleyGeom.DPoint3d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        3. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: Bentley.DVec2d) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        4. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: Bentley.DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        5. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: Bentley.DVec2d, pFraction: float, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        6. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: Bentley.DVec2d, maxStrokeLength: float) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        7. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, uvPoints: Bentley.Bstdcxx.bvector<Bentley.DVec2d,Bentley.BentleyAllocator<Bentley.DVec2d> >, fractions: MSPyBentley.DoubleArray, maxStrokeLength: float = 10000.0) -> tuple
        """
        ...
    
    def StrokeToAnnouncer(*args, **kwargs):
        """
        StrokeToAnnouncer(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, F: MSPyBentleyGeom.AnnounceDoubleDPoint2d, minIndex: int = 0, maxStrokeLength: float = 10000.0) -> tuple
        
        Integrate the vector displacements of a clothoid over a
        fractional interval. This uses the angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        startFraction start fraction for integral.
        
        Parameter ``[in]``:
        endFraction end fraction for integral.
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points. A
        default is used if 0.0 is passed.
        
        Parameter ``[in]``:
        F object with a method F->Announce (f, uv) called to announce
        fraction and coordinate as computed.
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Parameter ``[out]``:
        minInterval smallest number of intervals allowed
        
        Parameter ``[out]``:
        maxStrokeLength maximum allowed stroke length
        
        Returns:
        false if point integration failed
        """
        ...
    
    def SymmetricLineSpiralSpiralLineTransition(*args, **kwargs):
        """
        SymmetricLineSpiralSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, length: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralToSpiral: MSPyBentleyGeom.DPoint3d) -> tuple
        
        compute spirals and arc to make a line-to-line
        transition.
        
        Parameter ``[in]``:
        lineAPoint point on line A.
        
        Parameter ``[in]``:
        lineBPoint point on line B.
        
        Parameter ``[in]``:
        lineLineIntersection intersection of lines.
        
        Parameter ``[in]``:
        length length of spiral from line A to junction
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        lineToSpiralA tangency point from line to spiral
        
        Parameter ``[out]``:
        lineToSpiralB tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralToSpiral tangency point from spiral to to spiral
        
        Parameter ``[out]``:
        junctionRadius radius at transition between the spirals.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def SymmetricPointShoulderTargetTransition(*args, **kwargs):
        """
        SymmetricPointShoulderTargetTransition(startPoint: MSPyBentleyGeom.DPoint2d, shoulderPoint: MSPyBentleyGeom.DPoint2d, targetPoint: MSPyBentleyGeom.DPoint2d, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, junctionPoint: MSPyBentleyGeom.DPoint2d, endPoint: MSPyBentleyGeom.DPoint2d) -> bool
        
        compute 2 spirals.
        
        Parameter ``[in]``:
        startPoint start point
        
        Parameter ``[in]``:
        shoulderPoint target point for first and last tangents
        
        Parameter ``[in]``:
        targetPoint target point for last tangent
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        junctionPoint transition between spirals. This is the max
        curvature point.
        
        Parameter ``[out]``:
        endPoint end of second spiral.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def TransitionTypeToString(*args, **kwargs):
        """
        TransitionTypeToString(type: int) -> str
        
        return the string name of the type
        """
        ...
    
    TransitionType_Arema: int
    
    TransitionType_AustralianRailCorp: int
    
    TransitionType_Biquadratic: int
    
    TransitionType_Bloss: int
    
    TransitionType_ChineseCubic: int
    
    TransitionType_Clothoid: int
    
    TransitionType_Cosine: int
    
    TransitionType_Czech: int
    
    TransitionType_CzechAlongTangent: int
    
    TransitionType_DirectHalfCosine: int
    
    TransitionType_FirstDirectEvaluate: int
    
    TransitionType_Italian: int
    
    TransitionType_JapaneseCubic: int
    
    TransitionType_MXCubicAlongArc: int
    
    TransitionType_MXCubicAlongTangent: int
    
    TransitionType_PolishCubic: int
    
    TransitionType_Sine: int
    
    TransitionType_Unknown: int
    
    TransitionType_Viennese: int
    
    TransitionType_WeightedViennese: int
    
    TransitionType_WesternAustralian: int
    
    def VectorIntegrandCount(*args, **kwargs):
        """
        VectorIntegrandCount(self: MSPyBentleyGeom.BSIVectorIntegrand) -> int
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.DSpiral2dItalian, pseudoLength: float) -> None:
        ...
    
class DSpiral2dJapaneseCubic:
    """
    None
    """

    class ASLSACollector:
        """
        None
        """
    
        def Collect(*args, **kwargs):
            """
            Collect(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector, centerA: MSPyBentleyGeom.DPoint3d, arcToSpiralA: MSPyBentleyGeom.DPoint3d, sprialA: MSPyBentleyGeom.DSpiral2dBase, sprialToLineA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, arcToSpiralB: MSPyBentleyGeom.DPoint3d, spiralB: MSPyBentleyGeom.DSpiral2dBase, spiralToLibeB: MSPyBentleyGeom.DPoint3d) -> None
            """
            ...
        
        def __init__(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> None:
            ...
        
    def ApplyCCWRotation(*args, **kwargs):
        """
        ApplyCCWRotation(radians: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: Bentley.DVec2d, d2XYZ: Bentley.DVec2d, d3XYZ: Bentley.DVec2d) -> None
        
        rotate xy and optional derivatives by radians. (To be called by
        derived class EvaluateAtDistance when to rotate EvaluateAtDistance
        results from standard position)
        """
        ...
    
    def ArcSpiralLineSpiralArcTransition(*args, **kwargs):
        """
        ArcSpiralLineSpiralArcTransition(centerA: MSPyBentleyGeom.DPoint3d, radiusA: float, lengthA: float, centerB: MSPyBentleyGeom.DPoint3d, radiusB: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, collector: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> int
        """
        ...
    
    def Clone(*args, **kwargs):
        """
        Clone(self: MSPyBentleyGeom.DSpiral2dBase) -> MSPyBentleyGeom.DSpiral2dBase
        """
        ...
    
    def ClosestPoint(*args, **kwargs):
        """
        ClosestPoint(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, spiralToWorld: Bentley.Transform, spacePoint: MSPyBentleyGeom.DPoint3d) -> tuple
        
        Compute the closest spiral point for a given space point.
        
        Parameter ``[in]``:
        spiral spiral to evaluate.
        
        Parameter ``[in]``:
        startFraction start fraction of search range
        
        Parameter ``[in]``:
        endFraction endFraction of search range
        
        Parameter ``[in]``:
        spiralToWorld transform placing the spiral local coordinates into
        the world coordinate system
        
        Parameter ``[in]``:
        spacePoint world coordinates of space point.
        
        Parameter ``[out]``:
        spiralPoint world coordinates of closest point on spiral
        
        Parameter ``[out]``:
        spiralFraction fractional coordinates of closest point on spiral
        
        Parameter ``[out]``:
        minDistance distance from space point to spiralPoint.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def CopyBaseParameters(*args, **kwargs):
        """
        CopyBaseParameters(self: MSPyBentleyGeom.DSpiral2dBase, pSource: MSPyBentleyGeom.DSpiral2dBase) -> None
        """
        ...
    
    def CreateBearingCurvatureBearingCurvature(*args, **kwargs):
        """
        CreateBearingCurvatureBearingCurvature(*args, **kwargs)
        Overloaded function.
        
        1. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float, extraData: MSPyBentley.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def CreateBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        CreateBearingCurvatureLengthCurvature(*args, **kwargs)
        Overloaded function.
        
        1. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float, extraData: MSPyBentley.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def DefaultStrokeAngle(*args, **kwargs):
        """
        DefaultStrokeAngle() -> float
        """
        ...
    
    def DistanceToCurvature(*args, **kwargs):
        """
        DistanceToCurvature(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToCurvatureDerivative(*args, **kwargs):
        """
        DistanceToCurvatureDerivative(self: MSPyBentleyGeom.DSpiral2dBase, arg0: float) -> float
        
        distance
        """
        ...
    
    def DistanceToFraction(*args, **kwargs):
        """
        DistanceToFraction(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToGlobalAngle(*args, **kwargs):
        """
        DistanceToGlobalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToLocalAngle(*args, **kwargs):
        """
        DistanceToLocalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def EvaluateAtFraction(*args, **kwargs):
        """
        EvaluateAtFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: Bentley.DVec2d, d2XYZ: Bentley.DVec2d, d3XYZ: Bentley.DVec2d) -> bool
        
        Evaluate the spiral and derivatives at specified fractional position
        return true if valid evaluation. DSpiral2dDirectEvaluation default
        implementation returns false.
        """
        ...
    
    def EvaluateAtFractionInStandardOrientation(*args, **kwargs):
        """
        EvaluateAtFractionInStandardOrientation(s: float, axisLength: float, radius1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: Bentley.DVec2d, d2XY: Bentley.DVec2d, d3XY: Bentley.DVec2d) -> bool
        
        Evaluate at distance a spiral in standard orientation -- zero
        curvature at origin.
        """
        ...
    
    def EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(*args, **kwargs):
        """
        EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(s: float, length: float, curvature1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: Bentley.DVec2d, d2XY: Bentley.DVec2d, d3XY: Bentley.DVec2d) -> bool
        
        [in] distance for evaluation [in] nominal length. ASSUMED NONZERO [in]
        exit curvature. ASSUMED NONZERO [out] coordinates on spiral [out]
        first derivative wrt distance [out] second derivative wrt distance
        [out] third derivative wrt distance
        """
        ...
    
    def EvaluateVectorIntegrand(*args, **kwargs):
        """
        EvaluateVectorIntegrand(self: MSPyBentleyGeom.DSpiral2dBase, distance: float, pF: float) -> None
        """
        ...
    
    def FractionToCurvature(*args, **kwargs):
        """
        FractionToCurvature(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float
        
        Return the true curvature at fractional position. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDCurvatureDFraction(*args, **kwargs):
        """
        FractionToDCurvatureDFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> tuple
        
        Return the true curvature derivative wrt fraction. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDerivatives(*args, **kwargs):
        """
        FractionToDerivatives(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float, dXdf: Bentley.DVec2d, ddXdfdf: Bentley.DVec2d, dddXdfdfdf: Bentley.DVec2d) -> bool
        """
        ...
    
    def FractionToDistance(*args, **kwargs):
        """
        FractionToDistance(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float) -> float
        """
        ...
    
    def FractionToLocalAngle(*args, **kwargs):
        """
        FractionToLocalAngle(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float
        
        Return the tangent angle (in radians) in local coordinates
        """
        ...
    
    def FractionToVelocity(*args, **kwargs):
        """
        FractionToVelocity(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float
        
        Return the magnitude of the true derivative of position wrt fraction.
        Implemented in DSpiral2dDirectEvaluation, not individual classes.
        Assume EvaluateAtFraction.
        """
        ...
    
    def GetExtraData(*args, **kwargs):
        """
        GetExtraData(self: MSPyBentleyGeom.DSpiral2dBase, extraData: MSPyBentley.DoubleArray) -> None
        
        Get the extra data for this spiral. REMARK:This should be a virtual,
        but is implemented as special cases because of API change restriction
        """
        ...
    
    def GetIntervalCount(*args, **kwargs):
        """
        GetIntervalCount(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, minInterval: int = 0, maxStrokeLength: float = 10000.0) -> int
        
        Return an interval count for stroking or integration. Except for
        degenerate single interval cases, the interval count is always even.
        That is the possible values are
        
        Parameter ``[in]``:
        spiral spiral being queried.
        
        Parameter ``[in]``:
        startFraction start of interval to stroke.
        
        Parameter ``[in]``:
        endFraction end of interval to stroke.
        
        Parameter ``[in]``:
        maxRadians max turn between strokes.
        
        Parameter ``[in]``:
        minInterval smallest number of intervals.
        
        Parameter ``[in]``:
        maxStrokeLength largest stroke size. Recommended 10 meters
        """
        ...
    
    def GetTransitionTypeCode(*args, **kwargs):
        """
        GetTransitionTypeCode(self: MSPyBentleyGeom.DSpiral2dBase) -> int
        """
        ...
    
    def GetVectorIntegrandCount(*args, **kwargs):
        """
        GetVectorIntegrandCount(self: MSPyBentleyGeom.DSpiral2dBase) -> int
        """
        ...
    
    def IsValidRLCombination(*args, **kwargs):
        """
        IsValidRLCombination(lengthFromInflection: float, radius: float, spiralType: int = 0) -> bool
        
        test if a length-from-inflection and final radius
        combination is " small enough " for reasonable use. Test depends on
        spiral type:
        
        * DSpiral2dBase.TransitionType_None indicates apply the strictest
        test (same as Czech and Italian)
        
        * DSpiral2dBase.TransitionType_Czech and
        DSpiral2dBase.TransitionType_Italian indicate a strict test L<2*R
        
        * other types have no restrictions.
        
        Parameter ``[in]``:
        lengthFromInflection [in] distance along spiral starting at
        inflection and ending at finalRadius.
        
        Parameter ``[in]``:
        finalRadius [in] final radius
        
        Parameter ``[in]``:
        spiralType [in] spiral type.
        
        Parameter ``[in]``:
        lengthFactor expansion or reduction factor to apply to the allowed
        length. +---------------+---------------+---------------+---------
        ------+------
        """
        ...
    
    def LineSpiralArcSpiralLineTransition(*args, **kwargs):
        """
        LineSpiralArcSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, radius: float, lengthA: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralAToArc: MSPyBentleyGeom.DPoint3d, spiralBToArc: MSPyBentleyGeom.DPoint3d, arc: MSPyBentleyGeom.DEllipse3d) -> bool
        
        compute spirals and arc to make a line-to-line
        transition.
        
        Parameter ``[in]``:
        lineAPoint point on line A.
        
        Parameter ``[in]``:
        lineBPoint point on line B.
        
        Parameter ``[in]``:
        lineLineIntersection intersection of lines.
        
        Parameter ``[in]``:
        radius radius for circular part of transition.
        
        Parameter ``[in]``:
        lengthA length of spiral from line A to circle.
        
        Parameter ``[in]``:
        lengthB length of spiral from line B to circle.
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        lineToSpiralA tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralAToArc tangency point from spiral to arc
        
        Parameter ``[out]``:
        lineToSpiralB tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralBToArc tangency point from spiral to arc
        
        Parameter ``[out]``:
        arc arc between spirals.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def ScaleInPlace(*args, **kwargs):
        """
        ScaleInPlace(self: MSPyBentleyGeom.DSpiral2dBase, s: float) -> bool
        """
        ...
    
    def SetBearingAndCurvatureLimits(*args, **kwargs):
        """
        SetBearingAndCurvatureLimits(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, theta1: float, curvature1: float) -> bool
        """
        ...
    
    def SetBearingCurvatureLengthBearing(*args, **kwargs):
        """
        SetBearingCurvatureLengthBearing(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, theta1: float) -> bool
        
        Set start bearing, start curvature, length, and end
        curvature. (Compute end bearing)
        
        Parameter ``[in]``:
        theta0 start bearing
        
        Parameter ``[in]``:
        curvature0 start curvature
        
        Parameter ``[in]``:
        length arc length
        
        Parameter ``[in]``:
        theta1 end bearing
        """
        ...
    
    def SetBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        SetBearingCurvatureLengthCurvature(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, curvature1: float) -> bool
        """
        ...
    
    def StringToTransitionType(*args, **kwargs):
        """
        StringToTransitionType(name: str) -> int
        
        return the integer code for the string name.
        """
        ...
    
    def Stroke(*args, **kwargs):
        """
        Stroke(*args, **kwargs)
        Overloaded function.
        
        1. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, pDXY: Bentley.DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        2. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, xyz0: MSPyBentleyGeom.DPoint3d, pXYZ: MSPyBentleyGeom.DPoint3d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        3. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: Bentley.DVec2d) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        4. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: Bentley.DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        5. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: Bentley.DVec2d, pFraction: float, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        6. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: Bentley.DVec2d, maxStrokeLength: float) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        7. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, uvPoints: Bentley.Bstdcxx.bvector<Bentley.DVec2d,Bentley.BentleyAllocator<Bentley.DVec2d> >, fractions: MSPyBentley.DoubleArray, maxStrokeLength: float = 10000.0) -> tuple
        """
        ...
    
    def StrokeToAnnouncer(*args, **kwargs):
        """
        StrokeToAnnouncer(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, F: MSPyBentleyGeom.AnnounceDoubleDPoint2d, minIndex: int = 0, maxStrokeLength: float = 10000.0) -> tuple
        
        Integrate the vector displacements of a clothoid over a
        fractional interval. This uses the angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        startFraction start fraction for integral.
        
        Parameter ``[in]``:
        endFraction end fraction for integral.
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points. A
        default is used if 0.0 is passed.
        
        Parameter ``[in]``:
        F object with a method F->Announce (f, uv) called to announce
        fraction and coordinate as computed.
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Parameter ``[out]``:
        minInterval smallest number of intervals allowed
        
        Parameter ``[out]``:
        maxStrokeLength maximum allowed stroke length
        
        Returns:
        false if point integration failed
        """
        ...
    
    def SymmetricLineSpiralSpiralLineTransition(*args, **kwargs):
        """
        SymmetricLineSpiralSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, length: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralToSpiral: MSPyBentleyGeom.DPoint3d) -> tuple
        
        compute spirals and arc to make a line-to-line
        transition.
        
        Parameter ``[in]``:
        lineAPoint point on line A.
        
        Parameter ``[in]``:
        lineBPoint point on line B.
        
        Parameter ``[in]``:
        lineLineIntersection intersection of lines.
        
        Parameter ``[in]``:
        length length of spiral from line A to junction
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        lineToSpiralA tangency point from line to spiral
        
        Parameter ``[out]``:
        lineToSpiralB tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralToSpiral tangency point from spiral to to spiral
        
        Parameter ``[out]``:
        junctionRadius radius at transition between the spirals.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def SymmetricPointShoulderTargetTransition(*args, **kwargs):
        """
        SymmetricPointShoulderTargetTransition(startPoint: MSPyBentleyGeom.DPoint2d, shoulderPoint: MSPyBentleyGeom.DPoint2d, targetPoint: MSPyBentleyGeom.DPoint2d, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, junctionPoint: MSPyBentleyGeom.DPoint2d, endPoint: MSPyBentleyGeom.DPoint2d) -> bool
        
        compute 2 spirals.
        
        Parameter ``[in]``:
        startPoint start point
        
        Parameter ``[in]``:
        shoulderPoint target point for first and last tangents
        
        Parameter ``[in]``:
        targetPoint target point for last tangent
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        junctionPoint transition between spirals. This is the max
        curvature point.
        
        Parameter ``[out]``:
        endPoint end of second spiral.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def TransitionTypeToString(*args, **kwargs):
        """
        TransitionTypeToString(type: int) -> str
        
        return the string name of the type
        """
        ...
    
    TransitionType_Arema: int
    
    TransitionType_AustralianRailCorp: int
    
    TransitionType_Biquadratic: int
    
    TransitionType_Bloss: int
    
    TransitionType_ChineseCubic: int
    
    TransitionType_Clothoid: int
    
    TransitionType_Cosine: int
    
    TransitionType_Czech: int
    
    TransitionType_CzechAlongTangent: int
    
    TransitionType_DirectHalfCosine: int
    
    TransitionType_FirstDirectEvaluate: int
    
    TransitionType_Italian: int
    
    TransitionType_JapaneseCubic: int
    
    TransitionType_MXCubicAlongArc: int
    
    TransitionType_MXCubicAlongTangent: int
    
    TransitionType_PolishCubic: int
    
    TransitionType_Sine: int
    
    TransitionType_Unknown: int
    
    TransitionType_Viennese: int
    
    TransitionType_WeightedViennese: int
    
    TransitionType_WesternAustralian: int
    
    def VectorIntegrandCount(*args, **kwargs):
        """
        VectorIntegrandCount(self: MSPyBentleyGeom.BSIVectorIntegrand) -> int
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.DSpiral2dJapaneseCubic, axisLength: float) -> None:
        ...
    
class DSpiral2dMXCubicAlongArc:
    """
    None
    """

    class ASLSACollector:
        """
        None
        """
    
        def Collect(*args, **kwargs):
            """
            Collect(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector, centerA: MSPyBentleyGeom.DPoint3d, arcToSpiralA: MSPyBentleyGeom.DPoint3d, sprialA: MSPyBentleyGeom.DSpiral2dBase, sprialToLineA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, arcToSpiralB: MSPyBentleyGeom.DPoint3d, spiralB: MSPyBentleyGeom.DSpiral2dBase, spiralToLibeB: MSPyBentleyGeom.DPoint3d) -> None
            """
            ...
        
        def __init__(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> None:
            ...
        
    def ApplyCCWRotation(*args, **kwargs):
        """
        ApplyCCWRotation(radians: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: Bentley.DVec2d, d2XYZ: Bentley.DVec2d, d3XYZ: Bentley.DVec2d) -> None
        
        rotate xy and optional derivatives by radians. (To be called by
        derived class EvaluateAtDistance when to rotate EvaluateAtDistance
        results from standard position)
        """
        ...
    
    def ArcSpiralLineSpiralArcTransition(*args, **kwargs):
        """
        ArcSpiralLineSpiralArcTransition(centerA: MSPyBentleyGeom.DPoint3d, radiusA: float, lengthA: float, centerB: MSPyBentleyGeom.DPoint3d, radiusB: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, collector: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> int
        """
        ...
    
    def Clone(*args, **kwargs):
        """
        Clone(self: MSPyBentleyGeom.DSpiral2dBase) -> MSPyBentleyGeom.DSpiral2dBase
        """
        ...
    
    def ClosestPoint(*args, **kwargs):
        """
        ClosestPoint(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, spiralToWorld: Bentley.Transform, spacePoint: MSPyBentleyGeom.DPoint3d) -> tuple
        
        Compute the closest spiral point for a given space point.
        
        Parameter ``[in]``:
        spiral spiral to evaluate.
        
        Parameter ``[in]``:
        startFraction start fraction of search range
        
        Parameter ``[in]``:
        endFraction endFraction of search range
        
        Parameter ``[in]``:
        spiralToWorld transform placing the spiral local coordinates into
        the world coordinate system
        
        Parameter ``[in]``:
        spacePoint world coordinates of space point.
        
        Parameter ``[out]``:
        spiralPoint world coordinates of closest point on spiral
        
        Parameter ``[out]``:
        spiralFraction fractional coordinates of closest point on spiral
        
        Parameter ``[out]``:
        minDistance distance from space point to spiralPoint.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def CopyBaseParameters(*args, **kwargs):
        """
        CopyBaseParameters(self: MSPyBentleyGeom.DSpiral2dBase, pSource: MSPyBentleyGeom.DSpiral2dBase) -> None
        """
        ...
    
    def CreateBearingCurvatureBearingCurvature(*args, **kwargs):
        """
        CreateBearingCurvatureBearingCurvature(*args, **kwargs)
        Overloaded function.
        
        1. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float, extraData: MSPyBentley.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def CreateBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        CreateBearingCurvatureLengthCurvature(*args, **kwargs)
        Overloaded function.
        
        1. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float, extraData: MSPyBentley.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def DefaultStrokeAngle(*args, **kwargs):
        """
        DefaultStrokeAngle() -> float
        """
        ...
    
    def DistanceToCurvature(*args, **kwargs):
        """
        DistanceToCurvature(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToCurvatureDerivative(*args, **kwargs):
        """
        DistanceToCurvatureDerivative(self: MSPyBentleyGeom.DSpiral2dBase, arg0: float) -> float
        
        distance
        """
        ...
    
    def DistanceToFraction(*args, **kwargs):
        """
        DistanceToFraction(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToGlobalAngle(*args, **kwargs):
        """
        DistanceToGlobalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToLocalAngle(*args, **kwargs):
        """
        DistanceToLocalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def EvaluateAtFraction(*args, **kwargs):
        """
        EvaluateAtFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: Bentley.DVec2d, d2XYZ: Bentley.DVec2d, d3XYZ: Bentley.DVec2d) -> bool
        
        Evaluate the spiral and derivatives at specified fractional position
        return true if valid evaluation. DSpiral2dDirectEvaluation default
        implementation returns false.
        """
        ...
    
    def EvaluateAtFractionInStandardOrientation(*args, **kwargs):
        """
        EvaluateAtFractionInStandardOrientation(fraction: float, length: float, curvature1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: Bentley.DVec2d, d2XY: Bentley.DVec2d, d3XY: Bentley.DVec2d) -> bool
        
        Evaluate at fraction standard orientation -- zero curvature at origin.
        """
        ...
    
    def EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(*args, **kwargs):
        """
        EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(s: float, length: float, curvature1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: Bentley.DVec2d, d2XY: Bentley.DVec2d, d3XY: Bentley.DVec2d) -> bool
        
        [in] distance for evaluation [in] nominal length. ASSUMED NONZERO [in]
        exit curvature. ASSUMED NONZERO [out] coordinates on spiral [out]
        first derivative wrt distance [out] second derivative wrt distance
        [out] third derivative wrt distance
        """
        ...
    
    def EvaluateVectorIntegrand(*args, **kwargs):
        """
        EvaluateVectorIntegrand(self: MSPyBentleyGeom.DSpiral2dBase, distance: float, pF: float) -> None
        """
        ...
    
    def FractionToCurvature(*args, **kwargs):
        """
        FractionToCurvature(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float
        
        Return the true curvature at fractional position. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDCurvatureDFraction(*args, **kwargs):
        """
        FractionToDCurvatureDFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> tuple
        
        Return the true curvature derivative wrt fraction. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDerivatives(*args, **kwargs):
        """
        FractionToDerivatives(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float, dXdf: Bentley.DVec2d, ddXdfdf: Bentley.DVec2d, dddXdfdfdf: Bentley.DVec2d) -> bool
        """
        ...
    
    def FractionToDistance(*args, **kwargs):
        """
        FractionToDistance(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float) -> float
        """
        ...
    
    def FractionToLocalAngle(*args, **kwargs):
        """
        FractionToLocalAngle(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float
        
        Return the tangent angle (in radians) in local coordinates
        """
        ...
    
    def FractionToVelocity(*args, **kwargs):
        """
        FractionToVelocity(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float
        
        Return the magnitude of the true derivative of position wrt fraction.
        Implemented in DSpiral2dDirectEvaluation, not individual classes.
        Assume EvaluateAtFraction.
        """
        ...
    
    def GetExtraData(*args, **kwargs):
        """
        GetExtraData(self: MSPyBentleyGeom.DSpiral2dBase, extraData: MSPyBentley.DoubleArray) -> None
        
        Get the extra data for this spiral. REMARK:This should be a virtual,
        but is implemented as special cases because of API change restriction
        """
        ...
    
    def GetIntervalCount(*args, **kwargs):
        """
        GetIntervalCount(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, minInterval: int = 0, maxStrokeLength: float = 10000.0) -> int
        
        Return an interval count for stroking or integration. Except for
        degenerate single interval cases, the interval count is always even.
        That is the possible values are
        
        Parameter ``[in]``:
        spiral spiral being queried.
        
        Parameter ``[in]``:
        startFraction start of interval to stroke.
        
        Parameter ``[in]``:
        endFraction end of interval to stroke.
        
        Parameter ``[in]``:
        maxRadians max turn between strokes.
        
        Parameter ``[in]``:
        minInterval smallest number of intervals.
        
        Parameter ``[in]``:
        maxStrokeLength largest stroke size. Recommended 10 meters
        """
        ...
    
    def GetTransitionTypeCode(*args, **kwargs):
        """
        GetTransitionTypeCode(self: MSPyBentleyGeom.DSpiral2dBase) -> int
        """
        ...
    
    def GetVectorIntegrandCount(*args, **kwargs):
        """
        GetVectorIntegrandCount(self: MSPyBentleyGeom.DSpiral2dBase) -> int
        """
        ...
    
    def IsValidRLCombination(*args, **kwargs):
        """
        IsValidRLCombination(lengthFromInflection: float, radius: float, spiralType: int = 0) -> bool
        
        test if a length-from-inflection and final radius
        combination is " small enough " for reasonable use. Test depends on
        spiral type:
        
        * DSpiral2dBase.TransitionType_None indicates apply the strictest
        test (same as Czech and Italian)
        
        * DSpiral2dBase.TransitionType_Czech and
        DSpiral2dBase.TransitionType_Italian indicate a strict test L<2*R
        
        * other types have no restrictions.
        
        Parameter ``[in]``:
        lengthFromInflection [in] distance along spiral starting at
        inflection and ending at finalRadius.
        
        Parameter ``[in]``:
        finalRadius [in] final radius
        
        Parameter ``[in]``:
        spiralType [in] spiral type.
        
        Parameter ``[in]``:
        lengthFactor expansion or reduction factor to apply to the allowed
        length. +---------------+---------------+---------------+---------
        ------+------
        """
        ...
    
    def LineSpiralArcSpiralLineTransition(*args, **kwargs):
        """
        LineSpiralArcSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, radius: float, lengthA: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralAToArc: MSPyBentleyGeom.DPoint3d, spiralBToArc: MSPyBentleyGeom.DPoint3d, arc: MSPyBentleyGeom.DEllipse3d) -> bool
        
        compute spirals and arc to make a line-to-line
        transition.
        
        Parameter ``[in]``:
        lineAPoint point on line A.
        
        Parameter ``[in]``:
        lineBPoint point on line B.
        
        Parameter ``[in]``:
        lineLineIntersection intersection of lines.
        
        Parameter ``[in]``:
        radius radius for circular part of transition.
        
        Parameter ``[in]``:
        lengthA length of spiral from line A to circle.
        
        Parameter ``[in]``:
        lengthB length of spiral from line B to circle.
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        lineToSpiralA tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralAToArc tangency point from spiral to arc
        
        Parameter ``[out]``:
        lineToSpiralB tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralBToArc tangency point from spiral to arc
        
        Parameter ``[out]``:
        arc arc between spirals.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def ScaleInPlace(*args, **kwargs):
        """
        ScaleInPlace(self: MSPyBentleyGeom.DSpiral2dBase, s: float) -> bool
        """
        ...
    
    def SetBearingAndCurvatureLimits(*args, **kwargs):
        """
        SetBearingAndCurvatureLimits(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, theta1: float, curvature1: float) -> bool
        """
        ...
    
    def SetBearingCurvatureLengthBearing(*args, **kwargs):
        """
        SetBearingCurvatureLengthBearing(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, theta1: float) -> bool
        
        Set start bearing, start curvature, length, and end
        curvature. (Compute end bearing)
        
        Parameter ``[in]``:
        theta0 start bearing
        
        Parameter ``[in]``:
        curvature0 start curvature
        
        Parameter ``[in]``:
        length arc length
        
        Parameter ``[in]``:
        theta1 end bearing
        """
        ...
    
    def SetBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        SetBearingCurvatureLengthCurvature(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, curvature1: float) -> bool
        """
        ...
    
    def StringToTransitionType(*args, **kwargs):
        """
        StringToTransitionType(name: str) -> int
        
        return the integer code for the string name.
        """
        ...
    
    def Stroke(*args, **kwargs):
        """
        Stroke(*args, **kwargs)
        Overloaded function.
        
        1. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, pDXY: Bentley.DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        2. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, xyz0: MSPyBentleyGeom.DPoint3d, pXYZ: MSPyBentleyGeom.DPoint3d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        3. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: Bentley.DVec2d) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        4. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: Bentley.DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        5. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: Bentley.DVec2d, pFraction: float, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        6. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: Bentley.DVec2d, maxStrokeLength: float) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        7. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, uvPoints: Bentley.Bstdcxx.bvector<Bentley.DVec2d,Bentley.BentleyAllocator<Bentley.DVec2d> >, fractions: MSPyBentley.DoubleArray, maxStrokeLength: float = 10000.0) -> tuple
        """
        ...
    
    def StrokeToAnnouncer(*args, **kwargs):
        """
        StrokeToAnnouncer(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, F: MSPyBentleyGeom.AnnounceDoubleDPoint2d, minIndex: int = 0, maxStrokeLength: float = 10000.0) -> tuple
        
        Integrate the vector displacements of a clothoid over a
        fractional interval. This uses the angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        startFraction start fraction for integral.
        
        Parameter ``[in]``:
        endFraction end fraction for integral.
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points. A
        default is used if 0.0 is passed.
        
        Parameter ``[in]``:
        F object with a method F->Announce (f, uv) called to announce
        fraction and coordinate as computed.
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Parameter ``[out]``:
        minInterval smallest number of intervals allowed
        
        Parameter ``[out]``:
        maxStrokeLength maximum allowed stroke length
        
        Returns:
        false if point integration failed
        """
        ...
    
    def SymmetricLineSpiralSpiralLineTransition(*args, **kwargs):
        """
        SymmetricLineSpiralSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, length: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralToSpiral: MSPyBentleyGeom.DPoint3d) -> tuple
        
        compute spirals and arc to make a line-to-line
        transition.
        
        Parameter ``[in]``:
        lineAPoint point on line A.
        
        Parameter ``[in]``:
        lineBPoint point on line B.
        
        Parameter ``[in]``:
        lineLineIntersection intersection of lines.
        
        Parameter ``[in]``:
        length length of spiral from line A to junction
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        lineToSpiralA tangency point from line to spiral
        
        Parameter ``[out]``:
        lineToSpiralB tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralToSpiral tangency point from spiral to to spiral
        
        Parameter ``[out]``:
        junctionRadius radius at transition between the spirals.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def SymmetricPointShoulderTargetTransition(*args, **kwargs):
        """
        SymmetricPointShoulderTargetTransition(startPoint: MSPyBentleyGeom.DPoint2d, shoulderPoint: MSPyBentleyGeom.DPoint2d, targetPoint: MSPyBentleyGeom.DPoint2d, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, junctionPoint: MSPyBentleyGeom.DPoint2d, endPoint: MSPyBentleyGeom.DPoint2d) -> bool
        
        compute 2 spirals.
        
        Parameter ``[in]``:
        startPoint start point
        
        Parameter ``[in]``:
        shoulderPoint target point for first and last tangents
        
        Parameter ``[in]``:
        targetPoint target point for last tangent
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        junctionPoint transition between spirals. This is the max
        curvature point.
        
        Parameter ``[out]``:
        endPoint end of second spiral.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def TransitionTypeToString(*args, **kwargs):
        """
        TransitionTypeToString(type: int) -> str
        
        return the string name of the type
        """
        ...
    
    TransitionType_Arema: int
    
    TransitionType_AustralianRailCorp: int
    
    TransitionType_Biquadratic: int
    
    TransitionType_Bloss: int
    
    TransitionType_ChineseCubic: int
    
    TransitionType_Clothoid: int
    
    TransitionType_Cosine: int
    
    TransitionType_Czech: int
    
    TransitionType_CzechAlongTangent: int
    
    TransitionType_DirectHalfCosine: int
    
    TransitionType_FirstDirectEvaluate: int
    
    TransitionType_Italian: int
    
    TransitionType_JapaneseCubic: int
    
    TransitionType_MXCubicAlongArc: int
    
    TransitionType_MXCubicAlongTangent: int
    
    TransitionType_PolishCubic: int
    
    TransitionType_Sine: int
    
    TransitionType_Unknown: int
    
    TransitionType_Viennese: int
    
    TransitionType_WeightedViennese: int
    
    TransitionType_WesternAustralian: int
    
    def VectorIntegrandCount(*args, **kwargs):
        """
        VectorIntegrandCount(self: MSPyBentleyGeom.BSIVectorIntegrand) -> int
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.DSpiral2dMXCubicAlongArc, nominalLength: float) -> None:
        ...
    
class DSpiral2dPlacement:
    """
    None
    """

    def ActiveFractionToDerivatives(*args, **kwargs):
        """
        ActiveFractionToDerivatives(self: MSPyBentleyGeom.DSpiral2dPlacement, fraction: float) -> Bentley.RotMatrix
        
        return xyz first, second, third derivatives as columns, scaled for
        active interval.
        """
        ...
    
    def ActiveFractionToFrenetFrame(*args, **kwargs):
        """
        ActiveFractionToFrenetFrame(self: MSPyBentleyGeom.DSpiral2dPlacement, fraction: float) -> Bentley.Transform
        """
        ...
    
    def ActiveFractionToGlobalFraction(*args, **kwargs):
        """
        ActiveFractionToGlobalFraction(self: MSPyBentleyGeom.DSpiral2dPlacement, activeFraction: float) -> float
        """
        ...
    
    def ActiveFractionToPoint(*args, **kwargs):
        """
        ActiveFractionToPoint(self: MSPyBentleyGeom.DSpiral2dPlacement, fraction: float) -> MSPyBentleyGeom.DPoint3d
        """
        ...
    
    def AlmostEqual(*args, **kwargs):
        """
        AlmostEqual(self: MSPyBentleyGeom.DSpiral2dPlacement, other: MSPyBentleyGeom.DSpiral2dPlacement, tolerance: float = 0.0) -> bool
        
        Apply AlmostEqual to all components
        """
        ...
    
    def AlmostEqual01(*args, **kwargs):
        """
        AlmostEqual01(self: MSPyBentleyGeom.DSpiral2dPlacement, other: MSPyBentleyGeom.DSpiral2dPlacement, tolerance: float = 0.0) -> bool
        
        Apply AlmostEqual to all components except fractions
        """
        ...
    
    def Clone(*args, **kwargs):
        """
        Clone(self: MSPyBentleyGeom.DSpiral2dPlacement, source: MSPyBentleyGeom.DSpiral2dPlacement) -> MSPyBentleyGeom.DSpiral2dPlacement
        
        Return a clone.
        """
        ...
    
    def DisplacementBetweenActiveFractions(*args, **kwargs):
        """
        DisplacementBetweenActiveFractions(self: MSPyBentleyGeom.DSpiral2dPlacement, g0: float, g1: float) -> Bentley.DVec3d
        """
        ...
    
    def DisplacementBetweenFractions(*args, **kwargs):
        """
        DisplacementBetweenFractions(self: MSPyBentleyGeom.DSpiral2dPlacement, f0: float, f1: float) -> Bentley.DVec3d
        
        return the displacement between fractions. Having a close f0 is much
        faster than FractionToPoint with no starter fraction.
        """
        ...
    
    def FractionInterval(*args, **kwargs):
        """
        FractionInterval(self: MSPyBentleyGeom.DSpiral2dPlacement) -> MSPyBentleyGeom.DSegment1d
        """
        ...
    
    def FractionToDerivatives(*args, **kwargs):
        """
        FractionToDerivatives(self: MSPyBentleyGeom.DSpiral2dPlacement, fraction: float) -> Bentley.RotMatrix
        
        return xyz first, second, third derivatives as columns.
        """
        ...
    
    def FractionToFrenetFrame(*args, **kwargs):
        """
        FractionToFrenetFrame(self: MSPyBentleyGeom.DSpiral2dPlacement, fraction: float) -> Bentley.Transform
        """
        ...
    
    def FractionToPoint(*args, **kwargs):
        """
        FractionToPoint(self: MSPyBentleyGeom.DSpiral2dPlacement, fraction: float) -> MSPyBentleyGeom.DPoint3d
        """
        ...
    
    def FractionToPointAndDerivative(*args, **kwargs):
        """
        FractionToPointAndDerivative(self: MSPyBentleyGeom.DSpiral2dPlacement, fraction: float) -> MSPyBentleyGeom.DRay3d
        """
        ...
    
    def FractionToPointAndUnitTangent(*args, **kwargs):
        """
        FractionToPointAndUnitTangent(self: MSPyBentleyGeom.DSpiral2dPlacement, fraction: float) -> MSPyBentleyGeom.DRay3d
        """
        ...
    
    def GlobalFractionToActiveFraction(*args, **kwargs):
        """
        GlobalFractionToActiveFraction(self: MSPyBentleyGeom.DSpiral2dPlacement, globalFraction: float) -> float
        """
        ...
    
    def MappedSpiralLengthActiveInterval(*args, **kwargs):
        """
        MappedSpiralLengthActiveInterval(self: MSPyBentleyGeom.DSpiral2dPlacement, matrix: Bentley.RotMatrix) -> float
        
        Length of the spiral after mapping by matrix*frame.matrix
        """
        ...
    
    def ReplaceSpiral(*args, **kwargs):
        """
        ReplaceSpiral(self: MSPyBentleyGeom.DSpiral2dPlacement, callerSpiral: MSPyBentleyGeom.DSpiral2dBase) -> None
        
        Free the current spiral pointer and replace by (possibly NULL) arg.
        """
        ...
    
    def ReverseInPlace(*args, **kwargs):
        """
        ReverseInPlace(self: MSPyBentleyGeom.DSpiral2dPlacement) -> bool
        
        Reverse the fractions !!
        """
        ...
    
    def SpiralLength01(*args, **kwargs):
        """
        SpiralLength01(self: MSPyBentleyGeom.DSpiral2dPlacement) -> float
        
        absolute length of the reference spiral (between 0 and 1)
        """
        ...
    
    def SpiralLengthActiveInterval(*args, **kwargs):
        """
        SpiralLengthActiveInterval(self: MSPyBentleyGeom.DSpiral2dPlacement) -> float
        
        absolute length of the partial spiral (between start and end
        fractions)
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DSpiral2dPlacement) -> None
        
        2. __init__(self: MSPyBentleyGeom.DSpiral2dPlacement, source: MSPyBentleyGeom.DSpiral2dBase, frame: Bentley.Transform, fractionA: float, fractionB: float) -> None
        """
        ...
    
    @property
    def fractionA(self: MSPyBentleyGeom.DSpiral2dPlacement) -> float:
        ...
    @fractionA.setter
    def fractionA(self: MSPyBentleyGeom.DSpiral2dPlacement, arg0: float) -> None:
        ...
    
    @property
    def fractionB(self: MSPyBentleyGeom.DSpiral2dPlacement) -> float:
        ...
    @fractionB.setter
    def fractionB(self: MSPyBentleyGeom.DSpiral2dPlacement, arg0: float) -> None:
        ...
    
    @property
    def frame(self: MSPyBentleyGeom.DSpiral2dPlacement) -> Bentley.Transform:
        ...
    @frame.setter
    def frame(self: MSPyBentleyGeom.DSpiral2dPlacement, arg0: Bentley.Transform) -> None:
        ...
    
    @property
    def spiral(self: MSPyBentleyGeom.DSpiral2dPlacement) -> MSPyBentleyGeom.DSpiral2dBase:
        ...
    @spiral.setter
    def spiral(self: MSPyBentleyGeom.DSpiral2dPlacement, arg0: MSPyBentleyGeom.DSpiral2dBase) -> None:
        ...
    
class DSpiral2dPolish:
    """
    None
    """

    class ASLSACollector:
        """
        None
        """
    
        def Collect(*args, **kwargs):
            """
            Collect(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector, centerA: MSPyBentleyGeom.DPoint3d, arcToSpiralA: MSPyBentleyGeom.DPoint3d, sprialA: MSPyBentleyGeom.DSpiral2dBase, sprialToLineA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, arcToSpiralB: MSPyBentleyGeom.DPoint3d, spiralB: MSPyBentleyGeom.DSpiral2dBase, spiralToLibeB: MSPyBentleyGeom.DPoint3d) -> None
            """
            ...
        
        def __init__(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> None:
            ...
        
    def ApplyCCWRotation(*args, **kwargs):
        """
        ApplyCCWRotation(radians: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: Bentley.DVec2d, d2XYZ: Bentley.DVec2d, d3XYZ: Bentley.DVec2d) -> None
        
        rotate xy and optional derivatives by radians. (To be called by
        derived class EvaluateAtDistance when to rotate EvaluateAtDistance
        results from standard position)
        """
        ...
    
    def ArcSpiralLineSpiralArcTransition(*args, **kwargs):
        """
        ArcSpiralLineSpiralArcTransition(centerA: MSPyBentleyGeom.DPoint3d, radiusA: float, lengthA: float, centerB: MSPyBentleyGeom.DPoint3d, radiusB: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, collector: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> int
        """
        ...
    
    def Clone(*args, **kwargs):
        """
        Clone(self: MSPyBentleyGeom.DSpiral2dBase) -> MSPyBentleyGeom.DSpiral2dBase
        """
        ...
    
    def ClosestPoint(*args, **kwargs):
        """
        ClosestPoint(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, spiralToWorld: Bentley.Transform, spacePoint: MSPyBentleyGeom.DPoint3d) -> tuple
        
        Compute the closest spiral point for a given space point.
        
        Parameter ``[in]``:
        spiral spiral to evaluate.
        
        Parameter ``[in]``:
        startFraction start fraction of search range
        
        Parameter ``[in]``:
        endFraction endFraction of search range
        
        Parameter ``[in]``:
        spiralToWorld transform placing the spiral local coordinates into
        the world coordinate system
        
        Parameter ``[in]``:
        spacePoint world coordinates of space point.
        
        Parameter ``[out]``:
        spiralPoint world coordinates of closest point on spiral
        
        Parameter ``[out]``:
        spiralFraction fractional coordinates of closest point on spiral
        
        Parameter ``[out]``:
        minDistance distance from space point to spiralPoint.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def CopyBaseParameters(*args, **kwargs):
        """
        CopyBaseParameters(self: MSPyBentleyGeom.DSpiral2dBase, pSource: MSPyBentleyGeom.DSpiral2dBase) -> None
        """
        ...
    
    def CreateBearingCurvatureBearingCurvature(*args, **kwargs):
        """
        CreateBearingCurvatureBearingCurvature(*args, **kwargs)
        Overloaded function.
        
        1. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float, extraData: MSPyBentley.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def CreateBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        CreateBearingCurvatureLengthCurvature(*args, **kwargs)
        Overloaded function.
        
        1. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float, extraData: MSPyBentley.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def DefaultStrokeAngle(*args, **kwargs):
        """
        DefaultStrokeAngle() -> float
        """
        ...
    
    def DistanceToCurvature(*args, **kwargs):
        """
        DistanceToCurvature(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToCurvatureDerivative(*args, **kwargs):
        """
        DistanceToCurvatureDerivative(self: MSPyBentleyGeom.DSpiral2dBase, arg0: float) -> float
        
        distance
        """
        ...
    
    def DistanceToFraction(*args, **kwargs):
        """
        DistanceToFraction(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToGlobalAngle(*args, **kwargs):
        """
        DistanceToGlobalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToLocalAngle(*args, **kwargs):
        """
        DistanceToLocalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def EvaluateAtFraction(*args, **kwargs):
        """
        EvaluateAtFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: Bentley.DVec2d, d2XYZ: Bentley.DVec2d, d3XYZ: Bentley.DVec2d) -> bool
        
        Evaluate the spiral and derivatives at specified fractional position
        return true if valid evaluation. DSpiral2dDirectEvaluation default
        implementation returns false.
        """
        ...
    
    def EvaluateAtFractionOfAxisLengthInStandardOrientation(*args, **kwargs):
        """
        EvaluateAtFractionOfAxisLengthInStandardOrientation(fraction: float, Ls: float, radius1: float, mapDerivativesWRTSeriesDistance: bool, xy: MSPyBentleyGeom.DPoint2d, d1XY: Bentley.DVec2d, d2XY: Bentley.DVec2d, d3XY: Bentley.DVec2d) -> Tuple[bool, float]
        
        Evaluate at distance a spiral in standard orientation -- zero
        curvature at origin.
        """
        ...
    
    def EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(*args, **kwargs):
        """
        EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(s: float, length: float, curvature1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: Bentley.DVec2d, d2XY: Bentley.DVec2d, d3XY: Bentley.DVec2d) -> bool
        
        [in] distance for evaluation [in] nominal length. ASSUMED NONZERO [in]
        exit curvature. ASSUMED NONZERO [out] coordinates on spiral [out]
        first derivative wrt distance [out] second derivative wrt distance
        [out] third derivative wrt distance
        """
        ...
    
    def EvaluateVectorIntegrand(*args, **kwargs):
        """
        EvaluateVectorIntegrand(self: MSPyBentleyGeom.DSpiral2dBase, distance: float, pF: float) -> None
        """
        ...
    
    def FractionToCurvature(*args, **kwargs):
        """
        FractionToCurvature(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float
        
        Return the true curvature at fractional position. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDCurvatureDFraction(*args, **kwargs):
        """
        FractionToDCurvatureDFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> tuple
        
        Return the true curvature derivative wrt fraction. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDerivatives(*args, **kwargs):
        """
        FractionToDerivatives(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float, dXdf: Bentley.DVec2d, ddXdfdf: Bentley.DVec2d, dddXdfdfdf: Bentley.DVec2d) -> bool
        """
        ...
    
    def FractionToDistance(*args, **kwargs):
        """
        FractionToDistance(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float) -> float
        """
        ...
    
    def FractionToLocalAngle(*args, **kwargs):
        """
        FractionToLocalAngle(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float
        
        Return the tangent angle (in radians) in local coordinates
        """
        ...
    
    def FractionToVelocity(*args, **kwargs):
        """
        FractionToVelocity(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float
        
        Return the magnitude of the true derivative of position wrt fraction.
        Implemented in DSpiral2dDirectEvaluation, not individual classes.
        Assume EvaluateAtFraction.
        """
        ...
    
    def GetBezierPoles(*args, **kwargs):
        """
        GetBezierPoles(self: MSPyBentleyGeom.DSpiral2dPolish, poles: MSPyBentleyGeom.DPoint3dArray, startFraction: float, endFraction: float) -> bool
        
        Return poles for preferred representation as a bezier curve These are
        in the local coordinates of the standard orientation
        """
        ...
    
    def GetExtraData(*args, **kwargs):
        """
        GetExtraData(self: MSPyBentleyGeom.DSpiral2dBase, extraData: MSPyBentley.DoubleArray) -> None
        
        Get the extra data for this spiral. REMARK:This should be a virtual,
        but is implemented as special cases because of API change restriction
        """
        ...
    
    def GetIntervalCount(*args, **kwargs):
        """
        GetIntervalCount(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, minInterval: int = 0, maxStrokeLength: float = 10000.0) -> int
        
        Return an interval count for stroking or integration. Except for
        degenerate single interval cases, the interval count is always even.
        That is the possible values are
        
        Parameter ``[in]``:
        spiral spiral being queried.
        
        Parameter ``[in]``:
        startFraction start of interval to stroke.
        
        Parameter ``[in]``:
        endFraction end of interval to stroke.
        
        Parameter ``[in]``:
        maxRadians max turn between strokes.
        
        Parameter ``[in]``:
        minInterval smallest number of intervals.
        
        Parameter ``[in]``:
        maxStrokeLength largest stroke size. Recommended 10 meters
        """
        ...
    
    def GetTransitionTypeCode(*args, **kwargs):
        """
        GetTransitionTypeCode(self: MSPyBentleyGeom.DSpiral2dBase) -> int
        """
        ...
    
    def GetVectorIntegrandCount(*args, **kwargs):
        """
        GetVectorIntegrandCount(self: MSPyBentleyGeom.DSpiral2dBase) -> int
        """
        ...
    
    def IsValidRLCombination(*args, **kwargs):
        """
        IsValidRLCombination(lengthFromInflection: float, radius: float, spiralType: int = 0) -> bool
        
        test if a length-from-inflection and final radius
        combination is " small enough " for reasonable use. Test depends on
        spiral type:
        
        * DSpiral2dBase.TransitionType_None indicates apply the strictest
        test (same as Czech and Italian)
        
        * DSpiral2dBase.TransitionType_Czech and
        DSpiral2dBase.TransitionType_Italian indicate a strict test L<2*R
        
        * other types have no restrictions.
        
        Parameter ``[in]``:
        lengthFromInflection [in] distance along spiral starting at
        inflection and ending at finalRadius.
        
        Parameter ``[in]``:
        finalRadius [in] final radius
        
        Parameter ``[in]``:
        spiralType [in] spiral type.
        
        Parameter ``[in]``:
        lengthFactor expansion or reduction factor to apply to the allowed
        length. +---------------+---------------+---------------+---------
        ------+------
        """
        ...
    
    def LineSpiralArcSpiralLineTransition(*args, **kwargs):
        """
        LineSpiralArcSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, radius: float, lengthA: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralAToArc: MSPyBentleyGeom.DPoint3d, spiralBToArc: MSPyBentleyGeom.DPoint3d, arc: MSPyBentleyGeom.DEllipse3d) -> bool
        
        compute spirals and arc to make a line-to-line
        transition.
        
        Parameter ``[in]``:
        lineAPoint point on line A.
        
        Parameter ``[in]``:
        lineBPoint point on line B.
        
        Parameter ``[in]``:
        lineLineIntersection intersection of lines.
        
        Parameter ``[in]``:
        radius radius for circular part of transition.
        
        Parameter ``[in]``:
        lengthA length of spiral from line A to circle.
        
        Parameter ``[in]``:
        lengthB length of spiral from line B to circle.
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        lineToSpiralA tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralAToArc tangency point from spiral to arc
        
        Parameter ``[out]``:
        lineToSpiralB tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralBToArc tangency point from spiral to arc
        
        Parameter ``[out]``:
        arc arc between spirals.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def ScaleInPlace(*args, **kwargs):
        """
        ScaleInPlace(self: MSPyBentleyGeom.DSpiral2dBase, s: float) -> bool
        """
        ...
    
    def SetBearingAndCurvatureLimits(*args, **kwargs):
        """
        SetBearingAndCurvatureLimits(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, theta1: float, curvature1: float) -> bool
        """
        ...
    
    def SetBearingCurvatureLengthBearing(*args, **kwargs):
        """
        SetBearingCurvatureLengthBearing(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, theta1: float) -> bool
        
        Set start bearing, start curvature, length, and end
        curvature. (Compute end bearing)
        
        Parameter ``[in]``:
        theta0 start bearing
        
        Parameter ``[in]``:
        curvature0 start curvature
        
        Parameter ``[in]``:
        length arc length
        
        Parameter ``[in]``:
        theta1 end bearing
        """
        ...
    
    def SetBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        SetBearingCurvatureLengthCurvature(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, curvature1: float) -> bool
        """
        ...
    
    def StringToTransitionType(*args, **kwargs):
        """
        StringToTransitionType(name: str) -> int
        
        return the integer code for the string name.
        """
        ...
    
    def Stroke(*args, **kwargs):
        """
        Stroke(*args, **kwargs)
        Overloaded function.
        
        1. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, pDXY: Bentley.DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        2. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, xyz0: MSPyBentleyGeom.DPoint3d, pXYZ: MSPyBentleyGeom.DPoint3d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        3. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: Bentley.DVec2d) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        4. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: Bentley.DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        5. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: Bentley.DVec2d, pFraction: float, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        6. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: Bentley.DVec2d, maxStrokeLength: float) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        7. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, uvPoints: Bentley.Bstdcxx.bvector<Bentley.DVec2d,Bentley.BentleyAllocator<Bentley.DVec2d> >, fractions: MSPyBentley.DoubleArray, maxStrokeLength: float = 10000.0) -> tuple
        """
        ...
    
    def StrokeToAnnouncer(*args, **kwargs):
        """
        StrokeToAnnouncer(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, F: MSPyBentleyGeom.AnnounceDoubleDPoint2d, minIndex: int = 0, maxStrokeLength: float = 10000.0) -> tuple
        
        Integrate the vector displacements of a clothoid over a
        fractional interval. This uses the angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        startFraction start fraction for integral.
        
        Parameter ``[in]``:
        endFraction end fraction for integral.
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points. A
        default is used if 0.0 is passed.
        
        Parameter ``[in]``:
        F object with a method F->Announce (f, uv) called to announce
        fraction and coordinate as computed.
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Parameter ``[out]``:
        minInterval smallest number of intervals allowed
        
        Parameter ``[out]``:
        maxStrokeLength maximum allowed stroke length
        
        Returns:
        false if point integration failed
        """
        ...
    
    def SymmetricLineSpiralSpiralLineTransition(*args, **kwargs):
        """
        SymmetricLineSpiralSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, length: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralToSpiral: MSPyBentleyGeom.DPoint3d) -> tuple
        
        compute spirals and arc to make a line-to-line
        transition.
        
        Parameter ``[in]``:
        lineAPoint point on line A.
        
        Parameter ``[in]``:
        lineBPoint point on line B.
        
        Parameter ``[in]``:
        lineLineIntersection intersection of lines.
        
        Parameter ``[in]``:
        length length of spiral from line A to junction
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        lineToSpiralA tangency point from line to spiral
        
        Parameter ``[out]``:
        lineToSpiralB tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralToSpiral tangency point from spiral to to spiral
        
        Parameter ``[out]``:
        junctionRadius radius at transition between the spirals.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def SymmetricPointShoulderTargetTransition(*args, **kwargs):
        """
        SymmetricPointShoulderTargetTransition(startPoint: MSPyBentleyGeom.DPoint2d, shoulderPoint: MSPyBentleyGeom.DPoint2d, targetPoint: MSPyBentleyGeom.DPoint2d, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, junctionPoint: MSPyBentleyGeom.DPoint2d, endPoint: MSPyBentleyGeom.DPoint2d) -> bool
        
        compute 2 spirals.
        
        Parameter ``[in]``:
        startPoint start point
        
        Parameter ``[in]``:
        shoulderPoint target point for first and last tangents
        
        Parameter ``[in]``:
        targetPoint target point for last tangent
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        junctionPoint transition between spirals. This is the max
        curvature point.
        
        Parameter ``[out]``:
        endPoint end of second spiral.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def TransitionTypeToString(*args, **kwargs):
        """
        TransitionTypeToString(type: int) -> str
        
        return the string name of the type
        """
        ...
    
    TransitionType_Arema: int
    
    TransitionType_AustralianRailCorp: int
    
    TransitionType_Biquadratic: int
    
    TransitionType_Bloss: int
    
    TransitionType_ChineseCubic: int
    
    TransitionType_Clothoid: int
    
    TransitionType_Cosine: int
    
    TransitionType_Czech: int
    
    TransitionType_CzechAlongTangent: int
    
    TransitionType_DirectHalfCosine: int
    
    TransitionType_FirstDirectEvaluate: int
    
    TransitionType_Italian: int
    
    TransitionType_JapaneseCubic: int
    
    TransitionType_MXCubicAlongArc: int
    
    TransitionType_MXCubicAlongTangent: int
    
    TransitionType_PolishCubic: int
    
    TransitionType_Sine: int
    
    TransitionType_Unknown: int
    
    TransitionType_Viennese: int
    
    TransitionType_WeightedViennese: int
    
    TransitionType_WesternAustralian: int
    
    def ValidateSeriesInversion(*args, **kwargs):
        """
        ValidateSeriesInversion() -> float
        
        Execute unit test of the series inversion logic.
        """
        ...
    
    def VectorIntegrandCount(*args, **kwargs):
        """
        VectorIntegrandCount(self: MSPyBentleyGeom.BSIVectorIntegrand) -> int
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.DSpiral2dPolish, nominalLength: float) -> None:
        ...
    
class DSpiral2dSine:
    """
    None
    """

    class ASLSACollector:
        """
        None
        """
    
        def Collect(*args, **kwargs):
            """
            Collect(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector, centerA: MSPyBentleyGeom.DPoint3d, arcToSpiralA: MSPyBentleyGeom.DPoint3d, sprialA: MSPyBentleyGeom.DSpiral2dBase, sprialToLineA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, arcToSpiralB: MSPyBentleyGeom.DPoint3d, spiralB: MSPyBentleyGeom.DSpiral2dBase, spiralToLibeB: MSPyBentleyGeom.DPoint3d) -> None
            """
            ...
        
        def __init__(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> None:
            ...
        
    def ArcSpiralLineSpiralArcTransition(*args, **kwargs):
        """
        ArcSpiralLineSpiralArcTransition(centerA: MSPyBentleyGeom.DPoint3d, radiusA: float, lengthA: float, centerB: MSPyBentleyGeom.DPoint3d, radiusB: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, collector: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> int
        """
        ...
    
    def Clone(*args, **kwargs):
        """
        Clone(self: MSPyBentleyGeom.DSpiral2dBase) -> MSPyBentleyGeom.DSpiral2dBase
        """
        ...
    
    def ClosestPoint(*args, **kwargs):
        """
        ClosestPoint(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, spiralToWorld: Bentley.Transform, spacePoint: MSPyBentleyGeom.DPoint3d) -> tuple
        
        Compute the closest spiral point for a given space point.
        
        Parameter ``[in]``:
        spiral spiral to evaluate.
        
        Parameter ``[in]``:
        startFraction start fraction of search range
        
        Parameter ``[in]``:
        endFraction endFraction of search range
        
        Parameter ``[in]``:
        spiralToWorld transform placing the spiral local coordinates into
        the world coordinate system
        
        Parameter ``[in]``:
        spacePoint world coordinates of space point.
        
        Parameter ``[out]``:
        spiralPoint world coordinates of closest point on spiral
        
        Parameter ``[out]``:
        spiralFraction fractional coordinates of closest point on spiral
        
        Parameter ``[out]``:
        minDistance distance from space point to spiralPoint.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def CopyBaseParameters(*args, **kwargs):
        """
        CopyBaseParameters(self: MSPyBentleyGeom.DSpiral2dBase, pSource: MSPyBentleyGeom.DSpiral2dBase) -> None
        """
        ...
    
    def CreateBearingCurvatureBearingCurvature(*args, **kwargs):
        """
        CreateBearingCurvatureBearingCurvature(*args, **kwargs)
        Overloaded function.
        
        1. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float, extraData: MSPyBentley.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def CreateBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        CreateBearingCurvatureLengthCurvature(*args, **kwargs)
        Overloaded function.
        
        1. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float, extraData: MSPyBentley.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def DefaultStrokeAngle(*args, **kwargs):
        """
        DefaultStrokeAngle() -> float
        """
        ...
    
    def DistanceToCurvature(*args, **kwargs):
        """
        DistanceToCurvature(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToCurvatureDerivative(*args, **kwargs):
        """
        DistanceToCurvatureDerivative(self: MSPyBentleyGeom.DSpiral2dBase, arg0: float) -> float
        
        distance
        """
        ...
    
    def DistanceToFraction(*args, **kwargs):
        """
        DistanceToFraction(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToGlobalAngle(*args, **kwargs):
        """
        DistanceToGlobalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToLocalAngle(*args, **kwargs):
        """
        DistanceToLocalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(*args, **kwargs):
        """
        EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(s: float, length: float, curvature1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: Bentley.DVec2d, d2XY: Bentley.DVec2d, d3XY: Bentley.DVec2d) -> bool
        
        [in] distance for evaluation [in] nominal length. ASSUMED NONZERO [in]
        exit curvature. ASSUMED NONZERO [out] coordinates on spiral [out]
        first derivative wrt distance [out] second derivative wrt distance
        [out] third derivative wrt distance
        """
        ...
    
    def EvaluateVectorIntegrand(*args, **kwargs):
        """
        EvaluateVectorIntegrand(self: MSPyBentleyGeom.DSpiral2dBase, distance: float, pF: float) -> None
        """
        ...
    
    def FractionToDerivatives(*args, **kwargs):
        """
        FractionToDerivatives(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float, dXdf: Bentley.DVec2d, ddXdfdf: Bentley.DVec2d, dddXdfdfdf: Bentley.DVec2d) -> bool
        """
        ...
    
    def FractionToDistance(*args, **kwargs):
        """
        FractionToDistance(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float) -> float
        """
        ...
    
    def GetExtraData(*args, **kwargs):
        """
        GetExtraData(self: MSPyBentleyGeom.DSpiral2dBase, extraData: MSPyBentley.DoubleArray) -> None
        
        Get the extra data for this spiral. REMARK:This should be a virtual,
        but is implemented as special cases because of API change restriction
        """
        ...
    
    def GetIntervalCount(*args, **kwargs):
        """
        GetIntervalCount(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, minInterval: int = 0, maxStrokeLength: float = 10000.0) -> int
        
        Return an interval count for stroking or integration. Except for
        degenerate single interval cases, the interval count is always even.
        That is the possible values are
        
        Parameter ``[in]``:
        spiral spiral being queried.
        
        Parameter ``[in]``:
        startFraction start of interval to stroke.
        
        Parameter ``[in]``:
        endFraction end of interval to stroke.
        
        Parameter ``[in]``:
        maxRadians max turn between strokes.
        
        Parameter ``[in]``:
        minInterval smallest number of intervals.
        
        Parameter ``[in]``:
        maxStrokeLength largest stroke size. Recommended 10 meters
        """
        ...
    
    def GetTransitionTypeCode(*args, **kwargs):
        """
        GetTransitionTypeCode(self: MSPyBentleyGeom.DSpiral2dBase) -> int
        """
        ...
    
    def GetVectorIntegrandCount(*args, **kwargs):
        """
        GetVectorIntegrandCount(self: MSPyBentleyGeom.DSpiral2dBase) -> int
        """
        ...
    
    def IsValidRLCombination(*args, **kwargs):
        """
        IsValidRLCombination(lengthFromInflection: float, radius: float, spiralType: int = 0) -> bool
        
        test if a length-from-inflection and final radius
        combination is " small enough " for reasonable use. Test depends on
        spiral type:
        
        * DSpiral2dBase.TransitionType_None indicates apply the strictest
        test (same as Czech and Italian)
        
        * DSpiral2dBase.TransitionType_Czech and
        DSpiral2dBase.TransitionType_Italian indicate a strict test L<2*R
        
        * other types have no restrictions.
        
        Parameter ``[in]``:
        lengthFromInflection [in] distance along spiral starting at
        inflection and ending at finalRadius.
        
        Parameter ``[in]``:
        finalRadius [in] final radius
        
        Parameter ``[in]``:
        spiralType [in] spiral type.
        
        Parameter ``[in]``:
        lengthFactor expansion or reduction factor to apply to the allowed
        length. +---------------+---------------+---------------+---------
        ------+------
        """
        ...
    
    def LineSpiralArcSpiralLineTransition(*args, **kwargs):
        """
        LineSpiralArcSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, radius: float, lengthA: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralAToArc: MSPyBentleyGeom.DPoint3d, spiralBToArc: MSPyBentleyGeom.DPoint3d, arc: MSPyBentleyGeom.DEllipse3d) -> bool
        
        compute spirals and arc to make a line-to-line
        transition.
        
        Parameter ``[in]``:
        lineAPoint point on line A.
        
        Parameter ``[in]``:
        lineBPoint point on line B.
        
        Parameter ``[in]``:
        lineLineIntersection intersection of lines.
        
        Parameter ``[in]``:
        radius radius for circular part of transition.
        
        Parameter ``[in]``:
        lengthA length of spiral from line A to circle.
        
        Parameter ``[in]``:
        lengthB length of spiral from line B to circle.
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        lineToSpiralA tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralAToArc tangency point from spiral to arc
        
        Parameter ``[out]``:
        lineToSpiralB tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralBToArc tangency point from spiral to arc
        
        Parameter ``[out]``:
        arc arc between spirals.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def ScaleInPlace(*args, **kwargs):
        """
        ScaleInPlace(self: MSPyBentleyGeom.DSpiral2dBase, s: float) -> bool
        """
        ...
    
    def SetBearingAndCurvatureLimits(*args, **kwargs):
        """
        SetBearingAndCurvatureLimits(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, theta1: float, curvature1: float) -> bool
        """
        ...
    
    def SetBearingCurvatureLengthBearing(*args, **kwargs):
        """
        SetBearingCurvatureLengthBearing(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, theta1: float) -> bool
        
        Set start bearing, start curvature, length, and end
        curvature. (Compute end bearing)
        
        Parameter ``[in]``:
        theta0 start bearing
        
        Parameter ``[in]``:
        curvature0 start curvature
        
        Parameter ``[in]``:
        length arc length
        
        Parameter ``[in]``:
        theta1 end bearing
        """
        ...
    
    def SetBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        SetBearingCurvatureLengthCurvature(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, curvature1: float) -> bool
        """
        ...
    
    def StringToTransitionType(*args, **kwargs):
        """
        StringToTransitionType(name: str) -> int
        
        return the integer code for the string name.
        """
        ...
    
    def Stroke(*args, **kwargs):
        """
        Stroke(*args, **kwargs)
        Overloaded function.
        
        1. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, pDXY: Bentley.DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        2. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, xyz0: MSPyBentleyGeom.DPoint3d, pXYZ: MSPyBentleyGeom.DPoint3d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        3. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: Bentley.DVec2d) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        4. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: Bentley.DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        5. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: Bentley.DVec2d, pFraction: float, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        6. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: Bentley.DVec2d, maxStrokeLength: float) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        7. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, uvPoints: Bentley.Bstdcxx.bvector<Bentley.DVec2d,Bentley.BentleyAllocator<Bentley.DVec2d> >, fractions: MSPyBentley.DoubleArray, maxStrokeLength: float = 10000.0) -> tuple
        """
        ...
    
    def StrokeToAnnouncer(*args, **kwargs):
        """
        StrokeToAnnouncer(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, F: MSPyBentleyGeom.AnnounceDoubleDPoint2d, minIndex: int = 0, maxStrokeLength: float = 10000.0) -> tuple
        
        Integrate the vector displacements of a clothoid over a
        fractional interval. This uses the angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        startFraction start fraction for integral.
        
        Parameter ``[in]``:
        endFraction end fraction for integral.
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points. A
        default is used if 0.0 is passed.
        
        Parameter ``[in]``:
        F object with a method F->Announce (f, uv) called to announce
        fraction and coordinate as computed.
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Parameter ``[out]``:
        minInterval smallest number of intervals allowed
        
        Parameter ``[out]``:
        maxStrokeLength maximum allowed stroke length
        
        Returns:
        false if point integration failed
        """
        ...
    
    def SymmetricLineSpiralSpiralLineTransition(*args, **kwargs):
        """
        SymmetricLineSpiralSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, length: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralToSpiral: MSPyBentleyGeom.DPoint3d) -> tuple
        
        compute spirals and arc to make a line-to-line
        transition.
        
        Parameter ``[in]``:
        lineAPoint point on line A.
        
        Parameter ``[in]``:
        lineBPoint point on line B.
        
        Parameter ``[in]``:
        lineLineIntersection intersection of lines.
        
        Parameter ``[in]``:
        length length of spiral from line A to junction
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        lineToSpiralA tangency point from line to spiral
        
        Parameter ``[out]``:
        lineToSpiralB tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralToSpiral tangency point from spiral to to spiral
        
        Parameter ``[out]``:
        junctionRadius radius at transition between the spirals.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def SymmetricPointShoulderTargetTransition(*args, **kwargs):
        """
        SymmetricPointShoulderTargetTransition(startPoint: MSPyBentleyGeom.DPoint2d, shoulderPoint: MSPyBentleyGeom.DPoint2d, targetPoint: MSPyBentleyGeom.DPoint2d, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, junctionPoint: MSPyBentleyGeom.DPoint2d, endPoint: MSPyBentleyGeom.DPoint2d) -> bool
        
        compute 2 spirals.
        
        Parameter ``[in]``:
        startPoint start point
        
        Parameter ``[in]``:
        shoulderPoint target point for first and last tangents
        
        Parameter ``[in]``:
        targetPoint target point for last tangent
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        junctionPoint transition between spirals. This is the max
        curvature point.
        
        Parameter ``[out]``:
        endPoint end of second spiral.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def TransitionTypeToString(*args, **kwargs):
        """
        TransitionTypeToString(type: int) -> str
        
        return the string name of the type
        """
        ...
    
    TransitionType_Arema: int
    
    TransitionType_AustralianRailCorp: int
    
    TransitionType_Biquadratic: int
    
    TransitionType_Bloss: int
    
    TransitionType_ChineseCubic: int
    
    TransitionType_Clothoid: int
    
    TransitionType_Cosine: int
    
    TransitionType_Czech: int
    
    TransitionType_CzechAlongTangent: int
    
    TransitionType_DirectHalfCosine: int
    
    TransitionType_FirstDirectEvaluate: int
    
    TransitionType_Italian: int
    
    TransitionType_JapaneseCubic: int
    
    TransitionType_MXCubicAlongArc: int
    
    TransitionType_MXCubicAlongTangent: int
    
    TransitionType_PolishCubic: int
    
    TransitionType_Sine: int
    
    TransitionType_Unknown: int
    
    TransitionType_Viennese: int
    
    TransitionType_WeightedViennese: int
    
    TransitionType_WesternAustralian: int
    
    def VectorIntegrandCount(*args, **kwargs):
        """
        VectorIntegrandCount(self: MSPyBentleyGeom.BSIVectorIntegrand) -> int
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.DSpiral2dSine) -> None:
        ...
    
class DSpiral2dWesternAustralian:
    """
    None
    """

    class ASLSACollector:
        """
        None
        """
    
        def Collect(*args, **kwargs):
            """
            Collect(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector, centerA: MSPyBentleyGeom.DPoint3d, arcToSpiralA: MSPyBentleyGeom.DPoint3d, sprialA: MSPyBentleyGeom.DSpiral2dBase, sprialToLineA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, arcToSpiralB: MSPyBentleyGeom.DPoint3d, spiralB: MSPyBentleyGeom.DSpiral2dBase, spiralToLibeB: MSPyBentleyGeom.DPoint3d) -> None
            """
            ...
        
        def __init__(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> None:
            ...
        
    def ApplyCCWRotation(*args, **kwargs):
        """
        ApplyCCWRotation(radians: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: Bentley.DVec2d, d2XYZ: Bentley.DVec2d, d3XYZ: Bentley.DVec2d) -> None
        
        rotate xy and optional derivatives by radians. (To be called by
        derived class EvaluateAtDistance when to rotate EvaluateAtDistance
        results from standard position)
        """
        ...
    
    def ArcSpiralLineSpiralArcTransition(*args, **kwargs):
        """
        ArcSpiralLineSpiralArcTransition(centerA: MSPyBentleyGeom.DPoint3d, radiusA: float, lengthA: float, centerB: MSPyBentleyGeom.DPoint3d, radiusB: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, collector: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> int
        """
        ...
    
    def Clone(*args, **kwargs):
        """
        Clone(self: MSPyBentleyGeom.DSpiral2dBase) -> MSPyBentleyGeom.DSpiral2dBase
        """
        ...
    
    def ClosestPoint(*args, **kwargs):
        """
        ClosestPoint(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, spiralToWorld: Bentley.Transform, spacePoint: MSPyBentleyGeom.DPoint3d) -> tuple
        
        Compute the closest spiral point for a given space point.
        
        Parameter ``[in]``:
        spiral spiral to evaluate.
        
        Parameter ``[in]``:
        startFraction start fraction of search range
        
        Parameter ``[in]``:
        endFraction endFraction of search range
        
        Parameter ``[in]``:
        spiralToWorld transform placing the spiral local coordinates into
        the world coordinate system
        
        Parameter ``[in]``:
        spacePoint world coordinates of space point.
        
        Parameter ``[out]``:
        spiralPoint world coordinates of closest point on spiral
        
        Parameter ``[out]``:
        spiralFraction fractional coordinates of closest point on spiral
        
        Parameter ``[out]``:
        minDistance distance from space point to spiralPoint.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def CopyBaseParameters(*args, **kwargs):
        """
        CopyBaseParameters(self: MSPyBentleyGeom.DSpiral2dBase, pSource: MSPyBentleyGeom.DSpiral2dBase) -> None
        """
        ...
    
    def CreateBearingCurvatureBearingCurvature(*args, **kwargs):
        """
        CreateBearingCurvatureBearingCurvature(*args, **kwargs)
        Overloaded function.
        
        1. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float, extraData: MSPyBentley.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def CreateBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        CreateBearingCurvatureLengthCurvature(*args, **kwargs)
        Overloaded function.
        
        1. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float, extraData: MSPyBentley.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def DefaultStrokeAngle(*args, **kwargs):
        """
        DefaultStrokeAngle() -> float
        """
        ...
    
    def DistanceToCurvature(*args, **kwargs):
        """
        DistanceToCurvature(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToCurvatureDerivative(*args, **kwargs):
        """
        DistanceToCurvatureDerivative(self: MSPyBentleyGeom.DSpiral2dBase, arg0: float) -> float
        
        distance
        """
        ...
    
    def DistanceToFraction(*args, **kwargs):
        """
        DistanceToFraction(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToGlobalAngle(*args, **kwargs):
        """
        DistanceToGlobalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def DistanceToLocalAngle(*args, **kwargs):
        """
        DistanceToLocalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float
        """
        ...
    
    def EvaluateAtFraction(*args, **kwargs):
        """
        EvaluateAtFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: Bentley.DVec2d, d2XYZ: Bentley.DVec2d, d3XYZ: Bentley.DVec2d) -> bool
        
        Evaluate the spiral and derivatives at specified fractional position
        return true if valid evaluation. DSpiral2dDirectEvaluation default
        implementation returns false.
        """
        ...
    
    def EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(*args, **kwargs):
        """
        EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(s: float, length: float, curvature1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: Bentley.DVec2d, d2XY: Bentley.DVec2d, d3XY: Bentley.DVec2d) -> bool
        
        [in] distance for evaluation [in] nominal length. ASSUMED NONZERO [in]
        exit curvature. ASSUMED NONZERO [out] coordinates on spiral [out]
        first derivative wrt distance [out] second derivative wrt distance
        [out] third derivative wrt distance
        """
        ...
    
    def EvaluateVectorIntegrand(*args, **kwargs):
        """
        EvaluateVectorIntegrand(self: MSPyBentleyGeom.DSpiral2dBase, distance: float, pF: float) -> None
        """
        ...
    
    def FractionToCurvature(*args, **kwargs):
        """
        FractionToCurvature(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float
        
        Return the true curvature at fractional position. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDCurvatureDFraction(*args, **kwargs):
        """
        FractionToDCurvatureDFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> tuple
        
        Return the true curvature derivative wrt fraction. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDerivatives(*args, **kwargs):
        """
        FractionToDerivatives(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float, dXdf: Bentley.DVec2d, ddXdfdf: Bentley.DVec2d, dddXdfdfdf: Bentley.DVec2d) -> bool
        """
        ...
    
    def FractionToDistance(*args, **kwargs):
        """
        FractionToDistance(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float) -> float
        """
        ...
    
    def FractionToLocalAngle(*args, **kwargs):
        """
        FractionToLocalAngle(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float
        
        Return the tangent angle (in radians) in local coordinates
        """
        ...
    
    def FractionToVelocity(*args, **kwargs):
        """
        FractionToVelocity(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float
        
        Return the magnitude of the true derivative of position wrt fraction.
        Implemented in DSpiral2dDirectEvaluation, not individual classes.
        Assume EvaluateAtFraction.
        """
        ...
    
    def GetExtraData(*args, **kwargs):
        """
        GetExtraData(self: MSPyBentleyGeom.DSpiral2dBase, extraData: MSPyBentley.DoubleArray) -> None
        
        Get the extra data for this spiral. REMARK:This should be a virtual,
        but is implemented as special cases because of API change restriction
        """
        ...
    
    def GetIntervalCount(*args, **kwargs):
        """
        GetIntervalCount(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, minInterval: int = 0, maxStrokeLength: float = 10000.0) -> int
        
        Return an interval count for stroking or integration. Except for
        degenerate single interval cases, the interval count is always even.
        That is the possible values are
        
        Parameter ``[in]``:
        spiral spiral being queried.
        
        Parameter ``[in]``:
        startFraction start of interval to stroke.
        
        Parameter ``[in]``:
        endFraction end of interval to stroke.
        
        Parameter ``[in]``:
        maxRadians max turn between strokes.
        
        Parameter ``[in]``:
        minInterval smallest number of intervals.
        
        Parameter ``[in]``:
        maxStrokeLength largest stroke size. Recommended 10 meters
        """
        ...
    
    def GetTransitionTypeCode(*args, **kwargs):
        """
        GetTransitionTypeCode(self: MSPyBentleyGeom.DSpiral2dBase) -> int
        """
        ...
    
    def GetVectorIntegrandCount(*args, **kwargs):
        """
        GetVectorIntegrandCount(self: MSPyBentleyGeom.DSpiral2dBase) -> int
        """
        ...
    
    def IsValidRLCombination(*args, **kwargs):
        """
        IsValidRLCombination(lengthFromInflection: float, radius: float, spiralType: int = 0) -> bool
        
        test if a length-from-inflection and final radius
        combination is " small enough " for reasonable use. Test depends on
        spiral type:
        
        * DSpiral2dBase.TransitionType_None indicates apply the strictest
        test (same as Czech and Italian)
        
        * DSpiral2dBase.TransitionType_Czech and
        DSpiral2dBase.TransitionType_Italian indicate a strict test L<2*R
        
        * other types have no restrictions.
        
        Parameter ``[in]``:
        lengthFromInflection [in] distance along spiral starting at
        inflection and ending at finalRadius.
        
        Parameter ``[in]``:
        finalRadius [in] final radius
        
        Parameter ``[in]``:
        spiralType [in] spiral type.
        
        Parameter ``[in]``:
        lengthFactor expansion or reduction factor to apply to the allowed
        length. +---------------+---------------+---------------+---------
        ------+------
        """
        ...
    
    def LineSpiralArcSpiralLineTransition(*args, **kwargs):
        """
        LineSpiralArcSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, radius: float, lengthA: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralAToArc: MSPyBentleyGeom.DPoint3d, spiralBToArc: MSPyBentleyGeom.DPoint3d, arc: MSPyBentleyGeom.DEllipse3d) -> bool
        
        compute spirals and arc to make a line-to-line
        transition.
        
        Parameter ``[in]``:
        lineAPoint point on line A.
        
        Parameter ``[in]``:
        lineBPoint point on line B.
        
        Parameter ``[in]``:
        lineLineIntersection intersection of lines.
        
        Parameter ``[in]``:
        radius radius for circular part of transition.
        
        Parameter ``[in]``:
        lengthA length of spiral from line A to circle.
        
        Parameter ``[in]``:
        lengthB length of spiral from line B to circle.
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        lineToSpiralA tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralAToArc tangency point from spiral to arc
        
        Parameter ``[out]``:
        lineToSpiralB tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralBToArc tangency point from spiral to arc
        
        Parameter ``[out]``:
        arc arc between spirals.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def ScaleInPlace(*args, **kwargs):
        """
        ScaleInPlace(self: MSPyBentleyGeom.DSpiral2dBase, s: float) -> bool
        """
        ...
    
    def SetBearingAndCurvatureLimits(*args, **kwargs):
        """
        SetBearingAndCurvatureLimits(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, theta1: float, curvature1: float) -> bool
        """
        ...
    
    def SetBearingCurvatureLengthBearing(*args, **kwargs):
        """
        SetBearingCurvatureLengthBearing(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, theta1: float) -> bool
        
        Set start bearing, start curvature, length, and end
        curvature. (Compute end bearing)
        
        Parameter ``[in]``:
        theta0 start bearing
        
        Parameter ``[in]``:
        curvature0 start curvature
        
        Parameter ``[in]``:
        length arc length
        
        Parameter ``[in]``:
        theta1 end bearing
        """
        ...
    
    def SetBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        SetBearingCurvatureLengthCurvature(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, curvature1: float) -> bool
        """
        ...
    
    def StringToTransitionType(*args, **kwargs):
        """
        StringToTransitionType(name: str) -> int
        
        return the integer code for the string name.
        """
        ...
    
    def Stroke(*args, **kwargs):
        """
        Stroke(*args, **kwargs)
        Overloaded function.
        
        1. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, pDXY: Bentley.DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        2. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, xyz0: MSPyBentleyGeom.DPoint3d, pXYZ: MSPyBentleyGeom.DPoint3d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        3. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: Bentley.DVec2d) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        4. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: Bentley.DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        5. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: Bentley.DVec2d, pFraction: float, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        6. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: Bentley.DVec2d, maxStrokeLength: float) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        Parameter ``[in,out]``:
        pDXY buffer to receive points.
        
        Parameter ``[out]``:
        numDXY number of points computed.
        
        Parameter ``[in]``:
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Returns:
        false if point buffer exceeded.
        
        7. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, uvPoints: Bentley.Bstdcxx.bvector<Bentley.DVec2d,Bentley.BentleyAllocator<Bentley.DVec2d> >, fractions: MSPyBentley.DoubleArray, maxStrokeLength: float = 10000.0) -> tuple
        """
        ...
    
    def StrokeToAnnouncer(*args, **kwargs):
        """
        StrokeToAnnouncer(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, F: MSPyBentleyGeom.AnnounceDoubleDPoint2d, minIndex: int = 0, maxStrokeLength: float = 10000.0) -> tuple
        
        Integrate the vector displacements of a clothoid over a
        fractional interval. This uses the angles, curvatures, and length.
        
        Parameter ``[in]``:
        spiral spiral to stroke
        
        Parameter ``[in]``:
        startFraction start fraction for integral.
        
        Parameter ``[in]``:
        endFraction end fraction for integral.
        
        Parameter ``[in]``:
        maxRadians maximum bearing change between computed points. A
        default is used if 0.0 is passed.
        
        Parameter ``[in]``:
        F object with a method F->Announce (f, uv) called to announce
        fraction and coordinate as computed.
        
        Parameter ``[out]``:
        errorBound estimated bound on error.
        
        Parameter ``[out]``:
        minInterval smallest number of intervals allowed
        
        Parameter ``[out]``:
        maxStrokeLength maximum allowed stroke length
        
        Returns:
        false if point integration failed
        """
        ...
    
    def SymmetricLineSpiralSpiralLineTransition(*args, **kwargs):
        """
        SymmetricLineSpiralSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, length: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralToSpiral: MSPyBentleyGeom.DPoint3d) -> tuple
        
        compute spirals and arc to make a line-to-line
        transition.
        
        Parameter ``[in]``:
        lineAPoint point on line A.
        
        Parameter ``[in]``:
        lineBPoint point on line B.
        
        Parameter ``[in]``:
        lineLineIntersection intersection of lines.
        
        Parameter ``[in]``:
        length length of spiral from line A to junction
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        lineToSpiralA tangency point from line to spiral
        
        Parameter ``[out]``:
        lineToSpiralB tangency point from line to spiral
        
        Parameter ``[out]``:
        spiralToSpiral tangency point from spiral to to spiral
        
        Parameter ``[out]``:
        junctionRadius radius at transition between the spirals.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def SymmetricPointShoulderTargetTransition(*args, **kwargs):
        """
        SymmetricPointShoulderTargetTransition(startPoint: MSPyBentleyGeom.DPoint2d, shoulderPoint: MSPyBentleyGeom.DPoint2d, targetPoint: MSPyBentleyGeom.DPoint2d, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, junctionPoint: MSPyBentleyGeom.DPoint2d, endPoint: MSPyBentleyGeom.DPoint2d) -> bool
        
        compute 2 spirals.
        
        Parameter ``[in]``:
        startPoint start point
        
        Parameter ``[in]``:
        shoulderPoint target point for first and last tangents
        
        Parameter ``[in]``:
        targetPoint target point for last tangent
        
        Parameter ``[in,out]``:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[in,out]``:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        Parameter ``[out]``:
        junctionPoint transition between spirals. This is the max
        curvature point.
        
        Parameter ``[out]``:
        endPoint end of second spiral.
        
        Returns:
        false if unable to construct
        """
        ...
    
    def TransitionTypeToString(*args, **kwargs):
        """
        TransitionTypeToString(type: int) -> str
        
        return the string name of the type
        """
        ...
    
    TransitionType_Arema: int
    
    TransitionType_AustralianRailCorp: int
    
    TransitionType_Biquadratic: int
    
    TransitionType_Bloss: int
    
    TransitionType_ChineseCubic: int
    
    TransitionType_Clothoid: int
    
    TransitionType_Cosine: int
    
    TransitionType_Czech: int
    
    TransitionType_CzechAlongTangent: int
    
    TransitionType_DirectHalfCosine: int
    
    TransitionType_FirstDirectEvaluate: int
    
    TransitionType_Italian: int
    
    TransitionType_JapaneseCubic: int
    
    TransitionType_MXCubicAlongArc: int
    
    TransitionType_MXCubicAlongTangent: int
    
    TransitionType_PolishCubic: int
    
    TransitionType_Sine: int
    
    TransitionType_Unknown: int
    
    TransitionType_Viennese: int
    
    TransitionType_WeightedViennese: int
    
    TransitionType_WesternAustralian: int
    
    def VectorIntegrandCount(*args, **kwargs):
        """
        VectorIntegrandCount(self: MSPyBentleyGeom.BSIVectorIntegrand) -> int
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.DSpiral2dWesternAustralian, arg0: float) -> None:
        ...
    
class DTriangle3d:
    """
    None
    """

    def AspectRatio(*args, **kwargs):
        """
        AspectRatio(self: MSPyBentleyGeom.DTriangle3d) -> float
        
        Return a measure of triangle quality. The value is 0 for a 0 area
        triangle, increases as aspect angles become more equal.
        """
        ...
    
    def ClosestPointUnbounded(*args, **kwargs):
        """
        ClosestPointUnbounded(*args, **kwargs)
        Overloaded function.
        
        1. ClosestPointUnbounded(self: MSPyBentleyGeom.DTriangle3d, spacePoint: MSPyBentleyGeom.DPoint3d, uv: MSPyBentleyGeom.DPoint2d, xyz: MSPyBentleyGeom.DPoint3d) -> bool
        
        return uv and xyz coordinates of the projection to the unbounded plane
        of the triangle.
        
        Returns:
        false if axes are not independent.
        
        2. ClosestPointUnbounded(self: MSPyBentleyGeom.DTriangle3d, spacePoint: MSPyBentleyGeom.DPoint3d, uv: MSPyBentleyGeom.DPoint2d) -> bool
        
        return uv and xyz coordinates of the projection to the unbounded plane
        of the triangle.
        
        Returns:
        false if axes are not independent.
        """
        ...
    
    def CrossVectorsFromOrigin(*args, **kwargs):
        """
        CrossVectorsFromOrigin(self: MSPyBentleyGeom.DTriangle3d) -> Bentley.DVec3d
        
        Return the cross product of VectorsFromOrigin
        """
        ...
    
    def Evaluate(*args, **kwargs):
        """
        Evaluate(*args, **kwargs)
        Overloaded function.
        
        1. Evaluate(self: MSPyBentleyGeom.DTriangle3d, u: float, v: float) -> MSPyBentleyGeom.DPoint3d
        
        Return surface coordinates at u,v parameters
        
        2. Evaluate(self: MSPyBentleyGeom.DTriangle3d, u: float, v: float, xyz: MSPyBentleyGeom.DPoint3d, dXdu: Bentley.DVec3d, dXdv: Bentley.DVec3d) -> None
        
        Return surface coordinates at u,v parameters
        """
        ...
    
    def EvaluateNormal(*args, **kwargs):
        """
        EvaluateNormal(self: MSPyBentleyGeom.DTriangle3d, u: float, v: float, xyz: MSPyBentleyGeom.DPoint3d, unitNormal: Bentley.DVec3d) -> None
        
        Return surface coordinates and unit normal at u,v parameters
        """
        ...
    
    def GetCCWEdgeDRay3d(*args, **kwargs):
        """
        GetCCWEdgeDRay3d(self: MSPyBentleyGeom.DTriangle3d, i: int) -> MSPyBentleyGeom.DRay3d
        
        Return specified edge as a ray. Edge order is:bottom, diagonal, left
        with CCW loop direction.
        """
        ...
    
    def GetCCWEdgeDSegment3d(*args, **kwargs):
        """
        GetCCWEdgeDSegment3d(self: MSPyBentleyGeom.DTriangle3d, i: int) -> MSPyBentleyGeom.DSegment3d
        
        Return specified edge as a line segment. Edge order is:bottom,
        diagonal, left with CCW loop direction.
        """
        ...
    
    def GetCCWEdgeDVec3d(*args, **kwargs):
        """
        GetCCWEdgeDVec3d(self: MSPyBentleyGeom.DTriangle3d, i: int) -> Bentley.DVec3d
        
        Return specified edge as a vector Edge order is:bottom, diagonal,
        left with CCW loop direction.
        """
        ...
    
    def GetVectorsFromOrigin(*args, **kwargs):
        """
        GetVectorsFromOrigin(self: MSPyBentleyGeom.DTriangle3d, vectorU: Bentley.DVec3d, vectorV: Bentley.DVec3d) -> None
        
        Return the two edge vectors outward from the origin.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DTriangle3d) -> None
        
        2. __init__(self: MSPyBentleyGeom.DTriangle3d, xyz0: MSPyBentleyGeom.DPoint3d, xyz10: MSPyBentleyGeom.DPoint3d, xyz01: MSPyBentleyGeom.DPoint3d) -> None
        
        3. __init__(self: MSPyBentleyGeom.DTriangle3d, xyz0: MSPyBentleyGeom.DPoint2d, xyz10: MSPyBentleyGeom.DPoint2d, xyz01: MSPyBentleyGeom.DPoint2d) -> None
        """
        ...
    
class DTriangle3dArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DTriangle3dArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.DTriangle3dArray, arg0: MSPyBentleyGeom.DTriangle3dArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.DTriangle3dArray, arg0: Iterable) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.DTriangle3dArray, x: MSPyBentleyGeom.DTriangle3d) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.DTriangle3dArray) -> None
        
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.DTriangle3dArray, L: MSPyBentleyGeom.DTriangle3dArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.DTriangle3dArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.DTriangle3dArray, i: int, x: MSPyBentleyGeom.DTriangle3d) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.DTriangle3dArray) -> MSPyBentleyGeom.DTriangle3d
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.DTriangle3dArray, i: int) -> MSPyBentleyGeom.DTriangle3d
        
        Remove and return the item at index ``i``
        """
        ...
    
class DVec2d:
    """
    None
    """

    def Add(*args, **kwargs):
        """
        Add(self: MSPyBentleyGeom.DVec2d, vector: MSPyBentleyGeom.DVec2d) -> None
        
        Adds a vector to a pointer or vector, returns the result
        in place.
        
        Parameter ``[in]``:
        vector The vector to add.
        """
        ...
    
    def AlmostEqual(*args, **kwargs):
        """
        AlmostEqual(self: MSPyBentleyGeom.DVec2d, vector2: MSPyBentleyGeom.DVec2d) -> bool
        
        test if two points are equal. Uses library " small angle " as both
        absolute and relative tolerance. points are equal if squared distance
        between is less than (squared abstol) plus (squared relTol) * sum of
        cmponent squares
        
        Parameter ``[in]``:
        dataB second DVec2d
        
        Returns:
        true if within tolerance.
        """
        ...
    
    def AngleTo(*args, **kwargs):
        """
        AngleTo(self: MSPyBentleyGeom.DVec2d, vector2: MSPyBentleyGeom.DVec2d) -> float
        
        Returns the angle between two vectors. This angle is
        between 0 and pi. Rotating the first vector by this angle around the
        cross product between the vectors aligns it with the second vector.
        
        Parameter ``[in]``:
        vector2 The second vector
        
        Returns:
        The angle between the vectors.
        """
        ...
    
    def CrossProduct(*args, **kwargs):
        """
        CrossProduct(self: MSPyBentleyGeom.DVec2d, vector2: MSPyBentleyGeom.DVec2d) -> float
        
        Returns the (vector) cross product of two vectors.
        
        Parameter ``[in]``:
        vector2 The second vector
        """
        ...
    
    def CrossProductSquared(*args, **kwargs):
        """
        CrossProductSquared(self: MSPyBentleyGeom.DVec2d, vector2: MSPyBentleyGeom.DVec2d) -> float
        
        Returns the (vector) cross product of two vectors.
        
        Parameter ``[in]``:
        vector2 The second vector
        """
        ...
    
    def CrossProductToPoints(*args, **kwargs):
        """
        CrossProductToPoints(self: MSPyBentleyGeom.DPoint2d, target1: MSPyBentleyGeom.DPoint2d, target2: MSPyBentleyGeom.DPoint2d) -> float
        
        Returns the (scalar) cross product of two vectors. The
        vectors are computed from the Origin to Target1 and Target2.
        
        Parameter ``[in]``:
        target1 target of first vector
        
        Parameter ``[in]``:
        target2 target of second vector
        """
        ...
    
    def DifferenceOf(*args, **kwargs):
        """
        DifferenceOf(*args, **kwargs)
        Overloaded function.
        
        1. DifferenceOf(self: MSPyBentleyGeom.DVec2d, vector1: MSPyBentleyGeom.DVec2d, vector2: MSPyBentleyGeom.DVec2d) -> None
        
        Subtract coordinates of two vectors. (Compute Vector1 -
        Vector2)
        
        Parameter ``[in]``:
        vector1 The first vector
        
        Parameter ``[in]``:
        vector2 The second (subtracted) vector
        
        2. DifferenceOf(self: MSPyBentleyGeom.DVec2d, target: MSPyBentleyGeom.DPoint2d, base: MSPyBentleyGeom.DPoint2d) -> None
        
        Subtract coordinates of two vectors. (Compute Vector1 -
        Vector2)
        
        Parameter ``[in]``:
        vector1 The first vector
        
        Parameter ``[in]``:
        vector2 The second (subtracted) vector
        """
        ...
    
    def Distance(*args, **kwargs):
        """
        Distance(self: MSPyBentleyGeom.DVec2d, vector2: MSPyBentleyGeom.DVec2d) -> float
        
        Computes the (cartesian) distance between two vectors
        
        Parameter ``[in]``:
        vector2 The second vector
        
        Returns:
        The distance between vector.
        """
        ...
    
    def DistanceSquared(*args, **kwargs):
        """
        DistanceSquared(self: MSPyBentleyGeom.DVec2d, vector2: MSPyBentleyGeom.DVec2d) -> float
        
        Computes the squared distance between two vectors.
        
        Parameter ``[in]``:
        vector2 The second vector.
        
        Returns:
        The squared distance between the vectors.
        """
        ...
    
    def DotProduct(*args, **kwargs):
        """
        DotProduct(*args, **kwargs)
        Overloaded function.
        
        1. DotProduct(self: MSPyBentleyGeom.DVec2d, vector2: MSPyBentleyGeom.DVec2d) -> float
        
        Returns the (scalar) dot product of two vectors.
        
        Parameter ``[in]``:
        vector2 The second vector
        
        Returns:
        The dot product of the two vectors
        
        2. DotProduct(self: MSPyBentleyGeom.DVec2d, ax: float, ay: float) -> float
        
        Returns the (scalar) dot product of two vectors.
        
        Parameter ``[in]``:
        vector2 The second vector
        
        Returns:
        The dot product of the two vectors
        
        3. DotProduct(self: MSPyBentleyGeom.DVec2d, point2: MSPyBentleyGeom.DPoint2d) -> float
        
        Returns the (scalar) dot product of two vectors.
        
        Parameter ``[in]``:
        vector2 The second vector
        
        Returns:
        The dot product of the two vectors
        """
        ...
    
    def DotProductToPoints(*args, **kwargs):
        """
        DotProductToPoints(self: MSPyBentleyGeom.DPoint2d, target1: MSPyBentleyGeom.DPoint2d, target2: MSPyBentleyGeom.DPoint2d) -> float
        
        Returns the (scalar) dot product of two vectors. The
        vectors are computed from the Origin to Target1 and Target2.
        
        Parameter ``[in]``:
        target1 target of first vector
        
        Parameter ``[in]``:
        target2 target of second vector
        """
        ...
    
    def From(*args, **kwargs):
        """
        From(ax: float, ay: float) -> MSPyBentleyGeom.DVec2d
        """
        ...
    
    def FromInterpolate(*args, **kwargs):
        """
        FromInterpolate(point0: MSPyBentleyGeom.DPoint2d, fraction: float, point1: MSPyBentleyGeom.DPoint2d) -> MSPyBentleyGeom.DPoint2d
        
        Returns an interpolated point.
        
        Parameter ``[in]``:
        point0 point at fraction 0
        
        Parameter ``[in]``:
        fraction fraction from interpolation.
        
        Parameter ``[in]``:
        point1 point at fraction 1
        """
        ...
    
    def FromInterpolateBilinear(*args, **kwargs):
        """
        FromInterpolateBilinear(point00: MSPyBentleyGeom.DPoint2d, point10: MSPyBentleyGeom.DPoint2d, point01: MSPyBentleyGeom.DPoint2d, point11: MSPyBentleyGeom.DPoint2d, u: float, v: float) -> MSPyBentleyGeom.DPoint2d
        
        Returns a bilinear interpolation from corners
        (00)(10)(01)(11)
        
        Parameter ``[in]``:
        point00 point at (0,0)
        
        Parameter ``[in]``:
        point10 point at (1,0)
        
        Parameter ``[in]``:
        point01 point at (0,1)
        
        Parameter ``[in]``:
        point11 point at (1,1)
        
        Parameter ``[in]``:
        u interpolation fraction for edges (point00,point10) and
        (point01,point11)
        
        Parameter ``[in]``:
        v interpolation fraction for edges (point00,point10) and
        (point10,point11)
        """
        ...
    
    def FromOne(*args, **kwargs):
        """
        FromOne() -> MSPyBentleyGeom.DPoint2d
        
        Return a DPoint2d with xy = 1.
        """
        ...
    
    def FromScale(*args, **kwargs):
        """
        FromScale(point: MSPyBentleyGeom.DPoint2d, scale: float) -> MSPyBentleyGeom.DPoint2d
        
        Returns a scalar multiple of a DPoint2d
        
        Parameter ``[in]``:
        point input point
        
        Parameter ``[in]``:
        scale scale factor
        """
        ...
    
    def FromSumOf(*args, **kwargs):
        """
        FromSumOf(*args, **kwargs)
        Overloaded function.
        
        1. FromSumOf(vector0: MSPyBentleyGeom.DVec2d, scale0: float, vector1: MSPyBentleyGeom.DVec2d, scale1: float) -> MSPyBentleyGeom.DVec2d
        
        Returns a linear combination of vectors
        
        Parameter ``[in]``:
        vector0 first vector
        
        Parameter ``[in]``:
        scale0 first scale
        
        Parameter ``[in]``:
        vector1 second vector
        
        Parameter ``[in]``:
        scale1 second scale
        
        2. FromSumOf(vector0: MSPyBentleyGeom.DVec2d, scale0: float, vector1: MSPyBentleyGeom.DVec2d, scale1: float, vector2: MSPyBentleyGeom.DVec2d, scale2: float) -> MSPyBentleyGeom.DVec2d
        
        Returns a linear combination of vectors
        
        Parameter ``[in]``:
        vector0 first vector
        
        Parameter ``[in]``:
        scale0 first scale
        
        Parameter ``[in]``:
        vector1 second vector
        
        Parameter ``[in]``:
        scale1 second scale
        """
        ...
    
    def FromZero(*args, **kwargs):
        """
        FromZero() -> MSPyBentleyGeom.DPoint2d
        
        Return a DPoint2d with xy = 0.
        """
        ...
    
    def GetComponent(*args, **kwargs):
        """
        GetComponent(self: MSPyBentleyGeom.DVec2d, index: int) -> float
        
        Gets a single component of a vector. If the index is out
        of range 0,1 it is interpretted cyclically.
        
        Parameter ``[in]``:
        index Indicates which component is accessed. The values are 0=x,
        1=y Other values are treated cyclically.
        
        Returns:
        The specified component of the vector.
        """
        ...
    
    def GetComponents(*args, **kwargs):
        """
        GetComponents(self: MSPyBentleyGeom.DVec2d) -> tuple
        """
        ...
    
    def Init(*args, **kwargs):
        """
        Init(*args, **kwargs)
        Overloaded function.
        
        1. Init(self: MSPyBentleyGeom.DVec2d, point: MSPyBentleyGeom.DPoint2d) -> None
        
        2. Init(self: MSPyBentleyGeom.DVec2d, x: float, y: float) -> None
        """
        ...
    
    def InitDisconnect(*args, **kwargs):
        """
        InitDisconnect(self: MSPyBentleyGeom.DPoint2d) -> None
        
        Initialize a point with all coordinates as the disconnect value.
        """
        ...
    
    def Interpolate(*args, **kwargs):
        """
        Interpolate(self: MSPyBentleyGeom.DVec2d, vector0: MSPyBentleyGeom.DVec2d, fractionParameter: float, vector1: MSPyBentleyGeom.DVec2d) -> None
        
        Computes a vector whose position is given by a fractional
        argument and two vectors.
        
        Parameter ``[in]``:
        vector0 The vector corresponding to fractionParameter of 0.
        
        Parameter ``[in]``:
        fractionParameter The fractional parametric coordinate. 0.0 is the
        start of the segment, 1.0 is the end, 0.5 is middle
        
        Parameter ``[in]``:
        vector1 The vector corresponding to fractionParameter of 1.
        """
        ...
    
    def IsConvexPair(*args, **kwargs):
        """
        IsConvexPair(self: MSPyBentleyGeom.DPoint2d) -> bool
        
        return true if the point has x, y, and x+1 all between 0 and 1
        (inclusive).
        """
        ...
    
    def IsDisconnect(*args, **kwargs):
        """
        IsDisconnect(self: MSPyBentleyGeom.DPoint2d) -> bool
        
        Returns:
        true if the point has coordinates which indicate it is a
        disconnect (separator) ponit.
        """
        ...
    
    def IsEqual(*args, **kwargs):
        """
        IsEqual(*args, **kwargs)
        Overloaded function.
        
        1. IsEqual(self: MSPyBentleyGeom.DVec2d, vector2: MSPyBentleyGeom.DVec2d) -> bool
        
        Test for exact equality between all components of two
        vectors.
        
        Parameter ``[in]``:
        vector2 The second vector
        
        Returns:
        true if the vectors are identical.
        
        2. IsEqual(self: MSPyBentleyGeom.DVec2d, vector2: MSPyBentleyGeom.DVec2d, tolerance: float) -> bool
        
        Test for exact equality between all components of two
        vectors.
        
        Parameter ``[in]``:
        vector2 The second vector
        
        Returns:
        true if the vectors are identical.
        """
        ...
    
    def IsParallelTo(*args, **kwargs):
        """
        IsParallelTo(self: MSPyBentleyGeom.DVec2d, vector2: MSPyBentleyGeom.DVec2d) -> bool
        
        Tests if two vectors are parallel.
        
        Parameter ``[in]``:
        vector2 The second vector
        
        Returns:
        true if the vectors are parallel within tolerance
        """
        ...
    
    def IsPerpendicularTo(*args, **kwargs):
        """
        IsPerpendicularTo(self: MSPyBentleyGeom.DVec2d, vector2: MSPyBentleyGeom.DVec2d) -> bool
        
        Tests if two vectors are perpendicular.
        
        Parameter ``[in]``:
        vector2 The second vector
        
        Returns:
        true if vectors are perpendicular within tolerance
        """
        ...
    
    def IsVectorInCCWSector(*args, **kwargs):
        """
        IsVectorInCCWSector(self: MSPyBentleyGeom.DVec2d, vector0: MSPyBentleyGeom.DVec2d, vector1: MSPyBentleyGeom.DVec2d) -> bool
        
        test if the instance is " between " vector0 and vector1
        when vector0 is rotated counterclockwise towards vector1.
        
        Parameter ``[in]``:
        vector0 start vector for CCW sweep.
        
        Parameter ``[in]``:
        vector1 end vector for CCW sweep.
        """
        ...
    
    def IsVectorInSmallerSector(*args, **kwargs):
        """
        IsVectorInSmallerSector(self: MSPyBentleyGeom.DVec2d, vector0: MSPyBentleyGeom.DVec2d, vector1: MSPyBentleyGeom.DVec2d) -> bool
        
        Test a vector is " between " vector0 and vector1. If the
        vectors are coplanar and vector0 is neither parallel nor antiparallel
        to vector1, betweenness has the expected meaning:there are two angles
        between vector0 and vector1; one is less than 180; the test vector is
        tested to see if it is in the smaller angle. If the vectors are not
        coplanar, the test is based on the projection of the test vector into
        the plane of the other two vectors.
        
        Zero testing is untoleranced, and is biased to all parallel conditions
        " false ". That is, if any pair of the input vectors is parallel or
        antiparallel, the mathematical answer is false. Floating point
        tolerances will cause " nearby " cases to be unpredictable. It is
        assumed that if the caller considers the " parallel " cases important
        they will be checked explicitly.
        
        Parameter ``[in]``:
        vector0 The first boundary vector.
        
        Parameter ``[in]``:
        vector1 The second boundary vector.
        
        Returns:
        true if the test vector is within the angle.
        """
        ...
    
    def Magnitude(*args, **kwargs):
        """
        Magnitude(self: MSPyBentleyGeom.DVec2d) -> float
        
        Computes the magnitude of a vector.
        
        Returns:
        The length of the vector
        """
        ...
    
    def MagnitudeSquared(*args, **kwargs):
        """
        MagnitudeSquared(self: MSPyBentleyGeom.DVec2d) -> float
        
        Computes the squared magnitude of a vector.
        
        Returns:
        The squared magnitude of the vector.
        """
        ...
    
    def MaxAbs(*args, **kwargs):
        """
        MaxAbs(self: MSPyBentleyGeom.DVec2d) -> float
        
        Finds the largest absolute value among the components of
        a vector.
        
        Returns:
        The largest absolute value among vector coordinates.
        """
        ...
    
    def Negate(*args, **kwargs):
        """
        Negate(*args, **kwargs)
        Overloaded function.
        
        1. Negate(self: MSPyBentleyGeom.DVec2d, vector: MSPyBentleyGeom.DVec2d) -> None
        
        Computes a negated (opposite) vector.
        
        Parameter ``[in]``:
        vector The vector to be negated.
        
        2. Negate(self: MSPyBentleyGeom.DVec2d) -> None
        
        Computes a negated (opposite) vector.
        
        Parameter ``[in]``:
        vector The vector to be negated.
        """
        ...
    
    def Normalize(*args, **kwargs):
        """
        Normalize(*args, **kwargs)
        Overloaded function.
        
        1. Normalize(self: MSPyBentleyGeom.DVec2d, vector: MSPyBentleyGeom.DVec2d) -> float
        
        Normalizes (scales) a vector to length 1.
        
        Remark:
        In the 0-length error case, the vector is set to (1,0) in the
        legacy microstation style.
        
        Parameter ``[in]``:
        vector The vector to be normalized.
        
        Returns:
        The length prior to normalization
        
        2. Normalize(self: MSPyBentleyGeom.DVec2d) -> float
        
        Normalizes (scales) a vector to length 1.
        
        Remark:
        In the 0-length error case, the vector is set to (1,0) in the
        legacy microstation style.
        
        Parameter ``[in]``:
        vector The vector to be normalized.
        
        Returns:
        The length prior to normalization
        """
        ...
    
    def NormalizedDifference(*args, **kwargs):
        """
        NormalizedDifference(self: MSPyBentleyGeom.DVec2d, target: MSPyBentleyGeom.DPoint2d, origin: MSPyBentleyGeom.DPoint2d) -> float
        
        Computes a unit vector in the direction of the difference
        of the vectors or vectors (Second parameter vector is subtracted from
        the first parameter vector, exactly as in the subtract function.)
        
        Remark:
        In the 0-length error case, the vector is set to (1,0) in the
        legacy microstation style.
        
        Parameter ``[in]``:
        target The target point.
        
        Parameter ``[in]``:
        origin The origin point.
        
        Returns:
        The length of original difference vector.
        """
        ...
    
    def NormalizedDifferenceOf(*args, **kwargs):
        """
        NormalizedDifferenceOf(self: MSPyBentleyGeom.DPoint2d, point1: MSPyBentleyGeom.DPoint2d, point2: MSPyBentleyGeom.DPoint2d) -> float
        
        Sets pNormal to the unit vector in the direction of point1 point2
        
        Parameter ``[in]``:
        point1 point 1
        
        Parameter ``[in]``:
        point2 point 2
        
        Returns:
        double distance between input points
        """
        ...
    
    def One(*args, **kwargs):
        """
        One(self: MSPyBentleyGeom.DVec2d) -> None
        
        Returns a vector with all components 1.0.
        """
        ...
    
    def Rotate90(*args, **kwargs):
        """
        Rotate90(self: MSPyBentleyGeom.DPoint2d, vec: MSPyBentleyGeom.DPoint2d) -> None
        
        Parameter ``[in]``:
        vec original vector
        """
        ...
    
    def RotateCCW(*args, **kwargs):
        """
        RotateCCW(*args, **kwargs)
        Overloaded function.
        
        1. RotateCCW(self: MSPyBentleyGeom.DVec2d, vector: MSPyBentleyGeom.DVec2d, theta: float) -> None
        
        Rotate a vector COUNTERCLOCKWISE around the z axis.
        
        Parameter ``[in]``:
        vector vector to rotate.
        
        Parameter ``[in]``:
        theta The rotation angle.
        
        2. RotateCCW(self: MSPyBentleyGeom.DVec2d, theta: float) -> None
        
        Rotate a vector COUNTERCLOCKWISE around the z axis.
        
        Parameter ``[in]``:
        vector vector to rotate.
        
        Parameter ``[in]``:
        theta The rotation angle.
        """
        ...
    
    def SafeDivide(*args, **kwargs):
        """
        SafeDivide(self: MSPyBentleyGeom.DVec2d, vector: MSPyBentleyGeom.DVec2d, denominator: float) -> bool
        
        Try to divide each component of a vector by a scalar. If
        the denominator near zero compared to any numerator component, return
        the original vector.
        
        Parameter ``[in]``:
        vector The initial vector.
        
        Parameter ``[in]``:
        denominator The divisor.
        
        Returns:
        true if division is numerically safe.
        """
        ...
    
    def Scale(*args, **kwargs):
        """
        Scale(*args, **kwargs)
        Overloaded function.
        
        1. Scale(self: MSPyBentleyGeom.DVec2d, vector: MSPyBentleyGeom.DVec2d, scale: float) -> None
        
        Multiplies a vector by a scale factor.
        
        Parameter ``[in]``:
        vector The vector to be scaled.
        
        Parameter ``[in]``:
        scale The scale factor.
        
        2. Scale(self: MSPyBentleyGeom.DVec2d, scale: float) -> None
        
        Multiplies a vector by a scale factor.
        
        Parameter ``[in]``:
        vector The vector to be scaled.
        
        Parameter ``[in]``:
        scale The scale factor.
        """
        ...
    
    def ScaleToLength(*args, **kwargs):
        """
        ScaleToLength(*args, **kwargs)
        Overloaded function.
        
        1. ScaleToLength(self: MSPyBentleyGeom.DVec2d, vector: MSPyBentleyGeom.DVec2d, length: float) -> float
        
        Scales a vector to specified length.
        
        Remark:
        In the 0-length error case, the vector is set to (1,0) in the
        legacy microstation style.
        
        Parameter ``[in]``:
        vector The original vector.
        
        Parameter ``[in]``:
        length The requested length.
        
        Returns:
        The length prior to scaling.
        
        2. ScaleToLength(self: MSPyBentleyGeom.DVec2d, length: float) -> float
        
        Scales a vector to specified length.
        
        Remark:
        In the 0-length error case, the vector is set to (1,0) in the
        legacy microstation style.
        
        Parameter ``[in]``:
        vector The original vector.
        
        Parameter ``[in]``:
        length The requested length.
        
        Returns:
        The length prior to scaling.
        """
        ...
    
    def SetComponent(*args, **kwargs):
        """
        SetComponent(self: MSPyBentleyGeom.DVec2d, a: float, index: int) -> None
        
        Set one of three components (x,y) of the vector.
        
        Parameter ``[in]``:
        a The component value.
        
        Parameter ``[in]``:
        index Selects the the axis:0=x, 1=y
        """
        ...
    
    def SmallerUnorientedAngleTo(*args, **kwargs):
        """
        SmallerUnorientedAngleTo(self: MSPyBentleyGeom.DVec2d, vector2: MSPyBentleyGeom.DVec2d) -> float
        
        Returns the angle between two vectors, choosing the
        smaller of the two possible angles when both the vectors and their
        negations are considered. This angle is between 0 and pi/2.
        
        Parameter ``[in]``:
        vector2 The second vector
        
        Returns:
        The angle between the vectors.
        """
        ...
    
    def Subtract(*args, **kwargs):
        """
        Subtract(self: MSPyBentleyGeom.DVec2d, vector2: MSPyBentleyGeom.DVec2d) -> None
        
        Subtract two vectors, and return the result in place of
        the first.
        
        Parameter ``[in]``:
        vector2 The vector to subtract.
        """
        ...
    
    def SumOf(*args, **kwargs):
        """
        SumOf(*args, **kwargs)
        Overloaded function.
        
        1. SumOf(self: MSPyBentleyGeom.DVec2d, vector1: MSPyBentleyGeom.DVec2d, vector2: MSPyBentleyGeom.DVec2d) -> None
        
        Compute the sum of two vectors or vectors.
        
        Parameter ``[in]``:
        vector1 The the first vector
        
        Parameter ``[in]``:
        vector2 The second vector
        
        2. SumOf(self: MSPyBentleyGeom.DVec2d, vector1: MSPyBentleyGeom.DVec2d, vector2: MSPyBentleyGeom.DVec2d, scale: float) -> None
        
        Compute the sum of two vectors or vectors.
        
        Parameter ``[in]``:
        vector1 The the first vector
        
        Parameter ``[in]``:
        vector2 The second vector
        
        3. SumOf(self: MSPyBentleyGeom.DVec2d, origin: MSPyBentleyGeom.DVec2d, vector1: MSPyBentleyGeom.DVec2d, scale1: float, vector2: MSPyBentleyGeom.DVec2d, scale2: float) -> None
        
        Compute the sum of two vectors or vectors.
        
        Parameter ``[in]``:
        vector1 The the first vector
        
        Parameter ``[in]``:
        vector2 The second vector
        
        4. SumOf(self: MSPyBentleyGeom.DVec2d, origin: MSPyBentleyGeom.DVec2d, vector1: MSPyBentleyGeom.DVec2d, scale1: float, vector2: MSPyBentleyGeom.DVec2d, scale2: float, vector3: MSPyBentleyGeom.DVec2d, scale3: float) -> None
        
        Compute the sum of two vectors or vectors.
        
        Parameter ``[in]``:
        vector1 The the first vector
        
        Parameter ``[in]``:
        vector2 The second vector
        """
        ...
    
    def Swap(*args, **kwargs):
        """
        Swap(self: MSPyBentleyGeom.DPoint2d, other: MSPyBentleyGeom.DPoint2d) -> None
        
        Swap contents of instance, other.
        
        Parameter ``[in,out]``:
        other second point.
        """
        ...
    
    def UnitPerpendicular(*args, **kwargs):
        """
        UnitPerpendicular(self: MSPyBentleyGeom.DVec2d, vector: MSPyBentleyGeom.DVec2d) -> bool
        
        Compute a unit vector perpendicular given vector.
        
        Remark:
        s Input may equal output.
        
        Parameter ``[in]``:
        vector The source vector
        
        Returns:
        true if the input vector has nonzero length
        """
        ...
    
    def XyOf(*args, **kwargs):
        """
        XyOf(self: MSPyBentleyGeom.DVec2d, hPoint: MSPyBentleyGeom.DPoint4d) -> None
        
        Sets the x,y, and z components of a DVec2d structure from
        the corresponding parts of a DPoint4d. Weight part of DPoint4d is not
        used.
        
        Parameter ``[in]``:
        hPoint The homogeneous point
        """
        ...
    
    def Zero(*args, **kwargs):
        """
        Zero(self: MSPyBentleyGeom.DVec2d) -> None
        
        Sets all components of a vector to zero.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DVec2d) -> None
        
        2. __init__(self: MSPyBentleyGeom.DVec2d, x: float, y: float) -> None
        
        3. __init__(self: MSPyBentleyGeom.DVec2d, point: MSPyBentleyGeom.DPoint2d) -> None
        
        4. __init__(self: MSPyBentleyGeom.DVec2d, start: MSPyBentleyGeom.DPoint2d, end: MSPyBentleyGeom.DPoint2d) -> None
        
        5. __init__(self: MSPyBentleyGeom.DVec2d, vector: MSPyBentleyGeom.DVec2d, scale: float) -> None
        """
        ...
    
    @property
    def x(self: MSPyBentleyGeom.DPoint2d) -> float:
        ...
    @x.setter
    def x(self: MSPyBentleyGeom.DPoint2d, arg0: float) -> None:
        ...
    
    @property
    def y(self: MSPyBentleyGeom.DPoint2d) -> float:
        ...
    @y.setter
    def y(self: MSPyBentleyGeom.DPoint2d, arg0: float) -> None:
        ...
    
class DVec2dArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DVec2dArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.DVec2dArray, arg0: MSPyBentleyGeom.DVec2dArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.DVec2dArray, arg0: Iterable) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.DVec2dArray, x: MSPyBentleyGeom.DVec2d) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.DVec2dArray) -> None
        
        Clear the contents
        """
        ...
    
    def count(*args, **kwargs):
        """
        count(self: MSPyBentleyGeom.DVec2dArray, x: MSPyBentleyGeom.DVec2d) -> int
        
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.DVec2dArray, L: MSPyBentleyGeom.DVec2dArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.DVec2dArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.DVec2dArray, i: int, x: MSPyBentleyGeom.DVec2d) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.DVec2dArray) -> MSPyBentleyGeom.DVec2d
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.DVec2dArray, i: int) -> MSPyBentleyGeom.DVec2d
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(*args, **kwargs):
        """
        remove(self: MSPyBentleyGeom.DVec2dArray, x: MSPyBentleyGeom.DVec2d) -> None
        
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class DVec3d:
    """
    None
    """

    def Add(*args, **kwargs):
        """
        Add(self: MSPyBentleyGeom.DVec3d, vector: MSPyBentleyGeom.DVec3d) -> None
        
        Adds a vector to a pointer or vector, returns the result
        in place.
        
        Parameter ``[in]``:
        vector The vector to add.
        """
        ...
    
    def AddToArray(*args, **kwargs):
        """
        AddToArray(points: MSPyBentleyGeom.DPoint3dArray, delta: MSPyBentleyGeom.DPoint3d) -> None
        
        Add translation to all points.
        """
        ...
    
    def AlmostEqual(*args, **kwargs):
        """
        AlmostEqual(self: MSPyBentleyGeom.DVec3d, dataB: MSPyBentleyGeom.DVec3d) -> bool
        
        test if two points are equal. Uses library " small angle " as both
        absolute and relative tolerance. points are equal if squared distance
        between is less than (squared abstol) plus (squared relTol) * sum of
        cmponent squares
        
        Parameter ``[in]``:
        dataB second DVec3d
        
        Returns:
        true if within tolerance.
        """
        ...
    
    def AlmostEqualXY(*args, **kwargs):
        """
        AlmostEqualXY(*args, **kwargs)
        Overloaded function.
        
        1. AlmostEqualXY(self: MSPyBentleyGeom.DPoint3d, dataB: MSPyBentleyGeom.DPoint3d) -> bool
        
        test if two points are equal. Uses library " small angle " as both
        absolute and relative tolerance. points are equal if squared distance
        between is less than (squared abstol) plus (squared relTol) * sum of
        cmponent squares
        
        Parameter ``[in]``:
        dataB second DPoint3d
        
        Returns:
        true if within tolerance.
        
        2. AlmostEqualXY(self: MSPyBentleyGeom.DPoint3d, dataB: MSPyBentleyGeom.DPoint3d, abstol: float) -> bool
        
        test if two points are equal. Uses library " small angle " as both
        absolute and relative tolerance. points are equal if squared distance
        between is less than (squared abstol) plus (squared relTol) * sum of
        cmponent squares
        
        Parameter ``[in]``:
        dataB second DPoint3d
        
        Returns:
        true if within tolerance.
        """
        ...
    
    def AngleAndAxisOfRotationFromVectorToVector(*args, **kwargs):
        """
        AngleAndAxisOfRotationFromVectorToVector(self: MSPyBentleyGeom.DVec3d, target: MSPyBentleyGeom.DVec3d, axis: MSPyBentleyGeom.DVec3d) -> tuple
        
        Compute an axis and angle to rotate from the instance vector to a
        target.
        
        Parameter ``[out]``:
        target direction that the instance is to rotate towards.
        
        Parameter ``[out]``:
        axis returned axis of rotation
        
        Parameter ``[out]``:
        radians returned rotation angle
        
        Returns:
        true if both vectors are nonzero.
        """
        ...
    
    def AngleFromPerpendicular(*args, **kwargs):
        """
        AngleFromPerpendicular(self: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d) -> float
        
        Returns the angle that two vectors deviate from being
        perpendicular.
        """
        ...
    
    def AngleTo(*args, **kwargs):
        """
        AngleTo(self: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d) -> float
        
        Returns the angle between two vectors. This angle is
        between 0 and pi. Rotating the first vector by this angle around the
        cross product between the vectors aligns it with the second vector.
        
        Parameter ``[in]``:
        vector2 The second vector
        
        Returns:
        The angle between the vectors.
        """
        ...
    
    def AngleToXY(*args, **kwargs):
        """
        AngleToXY(self: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d) -> float
        
        Returns the angle from Vector1 to Vector2 using only xy
        parts. This angle is between -pi and +pi.
        
        Parameter ``[in]``:
        vector2 The second vector
        
        Returns:
        The angle between vectors.
        """
        ...
    
    def AngleXY(*args, **kwargs):
        """
        AngleXY(self: MSPyBentleyGeom.DPoint3d) -> float
        
        @description Computes the (signed) angle from xy axis to the vector,
        using only xy parts.
        """
        ...
    
    def ComponentRange(*args, **kwargs):
        """
        ComponentRange(self: MSPyBentleyGeom.DPoint3d) -> Bentley.DRange1d
        
        Returns:
        min and max of componetns.
        """
        ...
    
    def CrossProduct(*args, **kwargs):
        """
        CrossProduct(*args, **kwargs)
        Overloaded function.
        
        1. CrossProduct(self: MSPyBentleyGeom.DVec3d, vector1: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d) -> None
        
        Returns the (vector) cross product of two vectors.
        
        Parameter ``[in]``:
        vector1 The first vector
        
        Parameter ``[in]``:
        vector2 The second vector
        
        2. CrossProduct(self: MSPyBentleyGeom.DVec3d, vector1: MSPyBentleyGeom.DVec3d, point2: MSPyBentleyGeom.DPoint3d) -> None
        
        Returns the (vector) cross product of two vectors.
        
        Parameter ``[in]``:
        vector1 The first vector
        
        Parameter ``[in]``:
        vector2 The second vector
        
        3. CrossProduct(self: MSPyBentleyGeom.DVec3d, point1: MSPyBentleyGeom.DPoint3d, vector2: MSPyBentleyGeom.DVec3d) -> None
        
        Returns the (vector) cross product of two vectors.
        
        Parameter ``[in]``:
        vector1 The first vector
        
        Parameter ``[in]``:
        vector2 The second vector
        """
        ...
    
    def CrossProductMagnitude(*args, **kwargs):
        """
        CrossProductMagnitude(self: MSPyBentleyGeom.DVec3d, other: MSPyBentleyGeom.DVec3d) -> float
        
        Compute the cross product with other and return is magnitude (but the
        cross product is not returned)
        
        Parameter ``[in]``:
        other second vector of cross product
        """
        ...
    
    def CrossProductToPoints(*args, **kwargs):
        """
        CrossProductToPoints(self: MSPyBentleyGeom.DVec3d, origin: MSPyBentleyGeom.DPoint3d, target1: MSPyBentleyGeom.DPoint3d, arget2: MSPyBentleyGeom.DPoint3d) -> None
        
        Sets the instance to the (vector) cross product of two
        vectors. The vectors are computed from the Origin to Target1 and
        Target2.
        
        Parameter ``[in]``:
        origin The base point for computing vectors.
        
        Parameter ``[in]``:
        target1 The target point for the first vector.
        
        Parameter ``[in]``:
        target2 The target point for the second vector.
        """
        ...
    
    def CrossProductToPointsXY(*args, **kwargs):
        """
        CrossProductToPointsXY(self: MSPyBentleyGeom.DPoint3d, target1: MSPyBentleyGeom.DPoint3d, target2: MSPyBentleyGeom.DPoint3d) -> float
        
        @description Returns the (scalar) cross product of the xy parts of two
        vectors. The vectors are computed from the Origin to target1 and
        target2.
        
        Parameter ``[in]``:
        target1 The target point for the first vector.
        
        Parameter ``[in]``:
        target2 The target point for the second vector.
        """
        ...
    
    def CrossProductXY(*args, **kwargs):
        """
        CrossProductXY(self: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d) -> float
        
        Return the (scalar) cross product of the xy parts of two
        vectors.
        
        Parameter ``[in]``:
        vector2 The second vector
        
        Returns:
        The 2d cross product.
        """
        ...
    
    def DifferenceOf(*args, **kwargs):
        """
        DifferenceOf(*args, **kwargs)
        Overloaded function.
        
        1. DifferenceOf(self: MSPyBentleyGeom.DVec3d, vector1: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d) -> None
        
        Subtract coordinates of two vectors. (Compute Vector1 -
        Vector2)
        
        Parameter ``[in]``:
        vector1 The first vector
        
        Parameter ``[in]``:
        vector2 The second (subtracted) vector
        
        2. DifferenceOf(self: MSPyBentleyGeom.DVec3d, target: MSPyBentleyGeom.DPoint3d, base: MSPyBentleyGeom.DPoint3d) -> None
        
        Subtract coordinates of two vectors. (Compute Vector1 -
        Vector2)
        
        Parameter ``[in]``:
        vector1 The first vector
        
        Parameter ``[in]``:
        vector2 The second (subtracted) vector
        """
        ...
    
    def Distance(*args, **kwargs):
        """
        Distance(self: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d) -> float
        
        Computes the (cartesian) distance between two vectors
        
        Parameter ``[in]``:
        vector2 The second vector
        
        Returns:
        The distance between vector.
        """
        ...
    
    def DistanceSquared(*args, **kwargs):
        """
        DistanceSquared(self: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d) -> float
        
        Computes the squared distance between two vectors.
        
        Parameter ``[in]``:
        vector2 The second vector.
        
        Returns:
        The squared distance between the vectors.
        """
        ...
    
    def DistanceSquaredXY(*args, **kwargs):
        """
        DistanceSquaredXY(self: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d) -> float
        
        Computes the squared distance between two vectors, using
        only the xy parts.
        
        Parameter ``[in]``:
        vector2 The second vector
        
        Returns:
        The squared distance between the XY projections of the two
        vectors. (i.e. any z difference is ignored)
        """
        ...
    
    def DistanceXY(*args, **kwargs):
        """
        DistanceXY(self: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d) -> float
        
        Computes the distance between two vectors, using only x
        and y components.
        
        Parameter ``[in]``:
        vector2 The second vector
        
        Returns:
        The distance between the XY projections of the two vectors. (i.e.
        any z difference is ignored)
        """
        ...
    
    def DivideArrayByScales(*args, **kwargs):
        """
        DivideArrayByScales(outPoints: MSPyBentleyGeom.DPoint3dArray, inPoints: MSPyBentleyGeom.DPoint3dArray, scales: MSPyBentley.DoubleArray) -> None
        
        @description Divide each point in an array by its corresponding scale
        factor. Leave any point with near zero weight unchanged.
        
        Parameter ``[out]``:
        pDest destination array.
        
        Parameter ``[in]``:
        pSource source array.
        
        Parameter ``[in]``:
        pScales scale factors
        
        Parameter ``[in]``:
        n number of points.
        """
        ...
    
    def DotDifference(*args, **kwargs):
        """
        DotDifference(self: MSPyBentleyGeom.DPoint3d, origin: MSPyBentleyGeom.DPoint3d, vector: Bentley.DVec3d) -> float
        
        @description Returns the (scalar) dot product of a two vectors. One
        vector is computed internally as the difference of the TargetPoint and
        Origin. (TargetPoint-Origin) The other is given directly as a single
        argument.
        
        Parameter ``[in]``:
        origin The start (orign) point of the first vector of the cross
        product.
        
        Parameter ``[in]``:
        vector The second
        """
        ...
    
    def DotProduct(*args, **kwargs):
        """
        DotProduct(*args, **kwargs)
        Overloaded function.
        
        1. DotProduct(self: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d) -> float
        
        Returns the (scalar) dot product of two vectors.
        
        Parameter ``[in]``:
        vector2 The second vector
        
        Returns:
        The dot product of the two vectors
        
        2. DotProduct(self: MSPyBentleyGeom.DVec3d, az: float, ay: float, az: float) -> float
        
        Returns the (scalar) dot product of two vectors.
        
        Parameter ``[in]``:
        vector2 The second vector
        
        Returns:
        The dot product of the two vectors
        
        3. DotProduct(self: MSPyBentleyGeom.DVec3d, point2: MSPyBentleyGeom.DPoint3d) -> float
        
        Returns the (scalar) dot product of two vectors.
        
        Parameter ``[in]``:
        vector2 The second vector
        
        Returns:
        The dot product of the two vectors
        """
        ...
    
    def DotProductColumn(*args, **kwargs):
        """
        DotProductColumn(self: MSPyBentleyGeom.DVec3d, matrix: Bentley.RotMatrix, index: int) -> float
        
        Returns the (scalar) dot product of this vector and a
        column of a matrix.
        
        Parameter ``[in]``:
        matrix
        
        Parameter ``[in]``:
        index column index.
        
        Returns:
        The dot product of the two vectors
        """
        ...
    
    def DotProductMatrixColumn(*args, **kwargs):
        """
        DotProductMatrixColumn(self: MSPyBentleyGeom.DVec3d, matrix: Bentley.Transform, index: int) -> float
        
        Returns the (scalar) dot product of this vector and a column of the
        matrix part of the transform.
        
        Parameter ``[in]``:
        matrix
        
        Parameter ``[in]``:
        index column index.
        
        Returns:
        The dot product of the two vectors
        """
        ...
    
    def DotProductMatrixRow(*args, **kwargs):
        """
        DotProductMatrixRow(self: MSPyBentleyGeom.DVec3d, matrix: Bentley.Transform, index: int) -> float
        
        Returns the (scalar) dot product of this vector and a row of the
        matrix part of the transform.
        
        Parameter ``[in]``:
        matrix
        
        Parameter ``[in]``:
        index row index.
        
        Returns:
        The dot product of the two vectors
        """
        ...
    
    def DotProductRow(*args, **kwargs):
        """
        DotProductRow(self: MSPyBentleyGeom.DVec3d, matrix: Bentley.RotMatrix, index: int) -> float
        
        Returns the (scalar) dot product of this vector and a row of a matrix.
        
        Parameter ``[in]``:
        matrix
        
        Parameter ``[in]``:
        index row index.
        
        Returns:
        The dot product of the two vectors
        """
        ...
    
    def DotProductToPoints(*args, **kwargs):
        """
        DotProductToPoints(self: MSPyBentleyGeom.DPoint3d, target1: MSPyBentleyGeom.DPoint3d, target2: MSPyBentleyGeom.DPoint3d) -> float
        
        @description Returns the (scalar) dot product of two vectors. The
        vectors are computed from the Origin to target1 and target2.
        
        Parameter ``[in]``:
        target1 The target point for the first vector.
        
        Parameter ``[in]``:
        target2 The target point for the second vector.
        """
        ...
    
    def DotProductToPointsXY(*args, **kwargs):
        """
        DotProductToPointsXY(self: MSPyBentleyGeom.DPoint3d, target1: MSPyBentleyGeom.DPoint3d, target2: MSPyBentleyGeom.DPoint3d) -> float
        
        @description Returns the (scalar) dot product of xy parts of two
        vectors. The vectors are computed from the BasePoint to target1 and
        target2.
        
        Parameter ``[in]``:
        target1 The target point for the first vector.
        
        Parameter ``[in]``:
        target2 The target point for the second vector.
        """
        ...
    
    def DotProductXY(*args, **kwargs):
        """
        DotProductXY(self: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d) -> float
        
        Returns the (scalar) dot product of xy parts of two
        vectors.
        
        Parameter ``[in]``:
        vector2 The second vector
        
        Returns:
        The dot product of the xy parts of the two vectors
        """
        ...
    
    def From(*args, **kwargs):
        """
        From(*args, **kwargs)
        Overloaded function.
        
        1. From(point: MSPyBentleyGeom.DPoint3d) -> MSPyBentleyGeom.DVec3d
        
        2. From(vector: MSPyBentleyGeom.DVec2d) -> MSPyBentleyGeom.DVec3d
        
        3. From(az: float, ay: float, az: float = 0.0) -> MSPyBentleyGeom.DVec3d
        """
        ...
    
    def FromCCWPerpendicularXY(*args, **kwargs):
        """
        FromCCWPerpendicularXY(source: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.DVec3d
        
        return a vector same length as source but rotate 90
        degrees CCW
        """
        ...
    
    def FromColumn(*args, **kwargs):
        """
        FromColumn(matrix: Bentley.RotMatrix, i: int) -> MSPyBentleyGeom.DVec3d
        
        return a (cyclically indexed) column of the matrix.
        
        Parameter ``[in]``:
        matrix source
        
        Parameter ``[in]``:
        i column index
        """
        ...
    
    def FromColumnCrossProduct(*args, **kwargs):
        """
        FromColumnCrossProduct(matrix: Bentley.RotMatrix, i: int, j: int) -> MSPyBentleyGeom.DVec3d
        
        return the cross product of vectors found in columns a
        matrix
        
        Parameter ``[in]``:
        matrix source transform
        
        Parameter ``[in]``:
        i first column index
        
        Parameter ``[in]``:
        j second column index
        """
        ...
    
    def FromCrossProduct(*args, **kwargs):
        """
        FromCrossProduct(*args, **kwargs)
        Overloaded function.
        
        1. FromCrossProduct(vector0: MSPyBentleyGeom.DVec3d, vector1: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.DVec3d
        
        return the cross product of vectors
        
        Parameter ``[in]``:
        vector0 first vector
        
        Parameter ``[in]``:
        vector1 second vector
        
        2. FromCrossProduct(x0: float, y0: float, z0: float, x1: float, y1: float, z1: float) -> MSPyBentleyGeom.DVec3d
        
        return the cross product of vectors
        
        Parameter ``[in]``:
        vector0 first vector
        
        Parameter ``[in]``:
        vector1 second vector
        """
        ...
    
    def FromCrossProductToPoints(*args, **kwargs):
        """
        FromCrossProductToPoints(origin: MSPyBentleyGeom.DPoint3d, target1: MSPyBentleyGeom.DPoint3d, arget2: MSPyBentleyGeom.DPoint3d) -> MSPyBentleyGeom.DVec3d
        
        Returns the (vector) cross product of two vectors. The
        vectors are computed from the Origin to Target1 and Target2.
        
        Parameter ``[in]``:
        origin The base point for computing vectors.
        
        Parameter ``[in]``:
        target1 The target point for the first vector.
        
        Parameter ``[in]``:
        target2 The target point for the second vector.
        """
        ...
    
    def FromInterpolate(*args, **kwargs):
        """
        FromInterpolate(vector0: MSPyBentleyGeom.DVec3d, fraction: float, vector1: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.DVec3d
        
        Returns an interpolated vector.
        
        Parameter ``[in]``:
        vector0 vector at fraction 0
        
        Parameter ``[in]``:
        fraction fraction from interpolation.
        
        Parameter ``[in]``:
        vector1 vector at fraction 1
        """
        ...
    
    def FromInterpolateAndPerpendicularXY(*args, **kwargs):
        """
        FromInterpolateAndPerpendicularXY(pointA: MSPyBentleyGeom.DPoint3d, fraction: float, pointB: MSPyBentleyGeom.DPoint3d, fractionXYPerp: float) -> MSPyBentleyGeom.DPoint3d
        
        interpolate between points. Then add a shift in the xy plane by a
        fraction of the XY projection perpendicular
        
        Parameter ``[in]``:
        pointA start point
        
        Parameter ``[in]``:
        fraction fractional parameter along the line from A to B
        
        Parameter ``[in]``:
        pointB end point
        
        Parameter ``[in]``:
        fractionXYPerp fractional parameter applied to vector that is the
        XY parts of (B-A), rotated CCW in plane.
        """
        ...
    
    def FromInterpolateBilinear(*args, **kwargs):
        """
        FromInterpolateBilinear(vector00: MSPyBentleyGeom.DVec3d, vector10: MSPyBentleyGeom.DVec3d, vector01: MSPyBentleyGeom.DVec3d, vector11: MSPyBentleyGeom.DVec3d, u: float, v: float) -> MSPyBentleyGeom.DVec3d
        
        Returns a bilinear interpolation from corners
        (00)(10)(01)(11)
        
        Parameter ``[in]``:
        vector00 vector at (0,0)
        
        Parameter ``[in]``:
        vector10 vector at (1,0)
        
        Parameter ``[in]``:
        vector01 vector at (0,1)
        
        Parameter ``[in]``:
        vector11 vector at (1,1)
        
        Parameter ``[in]``:
        u interpolation fraction for edges (vector00,vector10) and
        (vector01,vector11)
        
        Parameter ``[in]``:
        v interpolation fraction for edges (vector00,vector10) and
        (vector10,vector11)
        """
        ...
    
    def FromMatrixColumn(*args, **kwargs):
        """
        FromMatrixColumn(transform: Bentley.Transform, i: int) -> MSPyBentleyGeom.DVec3d
        
        return a (cyclically indexed) column of the matrix part
        of a transform.
        
        Parameter ``[in]``:
        transform source transform
        
        Parameter ``[in]``:
        i column index
        """
        ...
    
    def FromMatrixColumnCrossProduct(*args, **kwargs):
        """
        FromMatrixColumnCrossProduct(transform: Bentley.Transform, i: int, j: int) -> MSPyBentleyGeom.DVec3d
        
        return the cross product of vectors found in columns of
        (the matrix part of) a transform.
        
        Parameter ``[in]``:
        transform source transform
        
        Parameter ``[in]``:
        i first column index
        
        Parameter ``[in]``:
        j second column index
        """
        ...
    
    def FromMatrixRow(*args, **kwargs):
        """
        FromMatrixRow(transform: Bentley.Transform, i: int) -> MSPyBentleyGeom.DVec3d
        
        return a (cyclically indexed) row of the matrix part of a
        transform.
        
        Parameter ``[in]``:
        transform source transform
        
        Parameter ``[in]``:
        i row index
        """
        ...
    
    def FromNormalizedCrossProduct(*args, **kwargs):
        """
        FromNormalizedCrossProduct(vector0: MSPyBentleyGeom.DVec3d, vector1: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.DVec3d
        
        return the normalized cross product of vectors
        
        Parameter ``[in]``:
        vector0 first vector
        
        Parameter ``[in]``:
        vector1 second vector
        """
        ...
    
    def FromNormalizedCrossProductToPoints(*args, **kwargs):
        """
        FromNormalizedCrossProductToPoints(origin: MSPyBentleyGeom.DPoint3d, target1: MSPyBentleyGeom.DPoint3d, arget2: MSPyBentleyGeom.DPoint3d) -> MSPyBentleyGeom.DVec3d
        
        Returns the (normalized vector) cross product of two
        vectors. The vectors are computed from the Origin to Target1 and
        Target2. If the cross product is zero, a zero vector is returned.
        
        Parameter ``[in]``:
        origin The base point for computing vectors.
        
        Parameter ``[in]``:
        target1 The target point for the first vector.
        
        Parameter ``[in]``:
        target2 The target point for the second vector.
        """
        ...
    
    def FromOne(*args, **kwargs):
        """
        FromOne() -> MSPyBentleyGeom.DPoint3d
        
        Return a DPoint3d with xyz = 1.
        """
        ...
    
    def FromProduct(*args, **kwargs):
        """
        FromProduct(*args, **kwargs)
        Overloaded function.
        
        1. FromProduct(transform: Bentley.Transform, x: float, y: float, z: float) -> MSPyBentleyGeom.DPoint3d
        
        return product of transform times point given as components.
        
        Parameter ``[in]``:
        transform affine transform.
        
        Parameter ``[in]``:
        x x component
        
        Parameter ``[in]``:
        y y component
        
        Parameter ``[in]``:
        z z component
        
        2. FromProduct(transform: Bentley.Transform, point: MSPyBentleyGeom.DPoint3d) -> MSPyBentleyGeom.DPoint3d
        
        return product of transform times point given as components.
        
        Parameter ``[in]``:
        transform affine transform.
        
        Parameter ``[in]``:
        x x component
        
        Parameter ``[in]``:
        y y component
        
        Parameter ``[in]``:
        z z component
        
        3. FromProduct(point: MSPyBentleyGeom.DPoint3d, matrix: Bentley.RotMatrix, x: float, y: float, z: float) -> MSPyBentleyGeom.DPoint3d
        
        return product of transform times point given as components.
        
        Parameter ``[in]``:
        transform affine transform.
        
        Parameter ``[in]``:
        x x component
        
        Parameter ``[in]``:
        y y component
        
        Parameter ``[in]``:
        z z component
        
        4. FromProduct(point: MSPyBentleyGeom.DPoint3d, matrix: Bentley.RotMatrix, vector: Bentley.DVec3d) -> MSPyBentleyGeom.DPoint3d
        
        return product of transform times point given as components.
        
        Parameter ``[in]``:
        transform affine transform.
        
        Parameter ``[in]``:
        x x component
        
        Parameter ``[in]``:
        y y component
        
        Parameter ``[in]``:
        z z component
        """
        ...
    
    def FromRotate90Around(*args, **kwargs):
        """
        FromRotate90Around(source: MSPyBentleyGeom.DVec3d, target: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.DVec3d
        
        return a vector same length as source but rotate 90
        degrees around axis
        """
        ...
    
    def FromRotate90Towards(*args, **kwargs):
        """
        FromRotate90Towards(source: MSPyBentleyGeom.DVec3d, target: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.DVec3d
        
        return a vector same length as source but rotate 90
        degrees towards target
        """
        ...
    
    def FromRotateVectorAroundVector(*args, **kwargs):
        """
        FromRotateVectorAroundVector(source: MSPyBentleyGeom.DVec3d, axis: MSPyBentleyGeom.DVec3d, angle: MSPyBentleyGeom.Angle) -> MSPyBentleyGeom.ValidatedDVec3d
        
        return a vector same length as source but rotated by
        angle around axis. (Rodriguez formula)
        """
        ...
    
    def FromRow(*args, **kwargs):
        """
        FromRow(matrix: Bentley.RotMatrix, i: int) -> MSPyBentleyGeom.DVec3d
        
        return a (cyclically indexed) row of the matrix.
        
        Parameter ``[in]``:
        matrix source
        
        Parameter ``[in]``:
        i row index
        """
        ...
    
    def FromScale(*args, **kwargs):
        """
        FromScale(vector: MSPyBentleyGeom.DVec3d, scale: float) -> MSPyBentleyGeom.DVec3d
        
        Returns a scalar multiple of a DVec3d
        
        Parameter ``[in]``:
        vector input vector
        
        Parameter ``[in]``:
        scale scale factor
        """
        ...
    
    def FromStartEnd(*args, **kwargs):
        """
        FromStartEnd(start: MSPyBentleyGeom.DPoint3d, end: MSPyBentleyGeom.DPoint3d) -> MSPyBentleyGeom.DVec3d
        """
        ...
    
    def FromStartEndNormalize(*args, **kwargs):
        """
        FromStartEndNormalize(start: MSPyBentleyGeom.DPoint3d, end: MSPyBentleyGeom.DPoint3d) -> MSPyBentleyGeom.DVec3d
        
        Returns a vector from start towards end, normalized if
        nonzero.
        
        Parameter ``[in]``:
        start start point
        
        Parameter ``[in]``:
        end end point
        """
        ...
    
    def FromSumOf(*args, **kwargs):
        """
        FromSumOf(*args, **kwargs)
        Overloaded function.
        
        1. FromSumOf(origin: MSPyBentleyGeom.DPoint3d, vector: MSPyBentleyGeom.DPoint3d) -> MSPyBentleyGeom.DPoint3d
        
        Add a point and a vector.
        
        Parameter ``[in]``:
        origin start point
        
        Parameter ``[in]``:
        vector vector add
        
        2. FromSumOf(origin: MSPyBentleyGeom.DPoint3d, vector: MSPyBentleyGeom.DPoint3d, scaleFactor: float) -> MSPyBentleyGeom.DPoint3d
        
        Add a point and a vector.
        
        Parameter ``[in]``:
        origin start point
        
        Parameter ``[in]``:
        vector vector add
        
        3. FromSumOf(origin: MSPyBentleyGeom.DPoint3d, point0: MSPyBentleyGeom.DPoint3d, scaleFactor0: float, point1: MSPyBentleyGeom.DPoint3d, scaleFactor1: float) -> MSPyBentleyGeom.DPoint3d
        
        Add a point and a vector.
        
        Parameter ``[in]``:
        origin start point
        
        Parameter ``[in]``:
        vector vector add
        
        4. FromSumOf(origin: MSPyBentleyGeom.DPoint3d, point0: MSPyBentleyGeom.DPoint3d, scaleFactor0: float, point1: MSPyBentleyGeom.DPoint3d, scaleFactor1: float, point2: MSPyBentleyGeom.DPoint3d, scaleFactor2: float) -> MSPyBentleyGeom.DPoint3d
        
        Add a point and a vector.
        
        Parameter ``[in]``:
        origin start point
        
        Parameter ``[in]``:
        vector vector add
        
        5. FromSumOf(point0: MSPyBentleyGeom.DPoint3d, scale0: float, point1: MSPyBentleyGeom.DPoint3d, scale1: float) -> MSPyBentleyGeom.DPoint3d
        
        Add a point and a vector.
        
        Parameter ``[in]``:
        origin start point
        
        Parameter ``[in]``:
        vector vector add
        
        6. FromSumOf(point0: MSPyBentleyGeom.DPoint3d, scale0: float, point1: MSPyBentleyGeom.DPoint3d, scale1: float, point2: MSPyBentleyGeom.DPoint3d, scale2: float) -> MSPyBentleyGeom.DPoint3d
        
        Add a point and a vector.
        
        Parameter ``[in]``:
        origin start point
        
        Parameter ``[in]``:
        vector vector add
        """
        ...
    
    def FromTranslation(*args, **kwargs):
        """
        FromTranslation(source: Bentley.Transform) -> MSPyBentleyGeom.DVec3d
        
        return the translation xyz as a DVec3d (which you can
        pass as a DPoint3d where needed.)
        
        Parameter ``[in]``:
        source source transform
        """
        ...
    
    def FromUnitPerpendicularXY(*args, **kwargs):
        """
        FromUnitPerpendicularXY(vector: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.ValidatedDVec3d
        
        Compute a unit vector perpendicular to the xy parts of
        given vector.
        
        Parameter ``[in]``:
        vector The source vector
        
        Returns:
        perpendicular vector, marked invalid if unable to divide.
        """
        ...
    
    def FromWeightedAverage(*args, **kwargs):
        """
        FromWeightedAverage(*args, **kwargs)
        Overloaded function.
        
        1. FromWeightedAverage(pointA: MSPyBentleyGeom.DPoint3d, weightA: float, pointB: MSPyBentleyGeom.DPoint3d, weightB: float) -> MSPyBentleyGeom.DPoint3d
        
        return the centroid for points with specified weights
        
        2. FromWeightedAverage(pointA: MSPyBentleyGeom.DPoint3d, weightA: float, pointB: MSPyBentleyGeom.DPoint3d, weightB: float, pointC: MSPyBentleyGeom.DPoint3d, weightC: float) -> MSPyBentleyGeom.DPoint3d
        
        return the centroid for points with specified weights
        """
        ...
    
    def FromXYAngleAndMagnitude(*args, **kwargs):
        """
        FromXYAngleAndMagnitude(theta: float, magnitude: float) -> MSPyBentleyGeom.DVec3d
        
        Returns a DVec3d from given angle and distance in xy
        plane. Z part is set to zero.
        
        Parameter ``[in]``:
        theta Angle from X axis to the vector, in the xy plane.
        
        Parameter ``[in]``:
        magnitude Vector magnitude
        """
        ...
    
    def FromZero(*args, **kwargs):
        """
        FromZero() -> MSPyBentleyGeom.DPoint3d
        
        Return a DPoint3d with xyz = 0.
        """
        ...
    
    def GeometricMeanCrossProduct(*args, **kwargs):
        """
        GeometricMeanCrossProduct(self: MSPyBentleyGeom.DVec3d, vector0: MSPyBentleyGeom.DVec3d, vector1: MSPyBentleyGeom.DVec3d) -> float
        
        Computes the cross product of two vectors and scales it
        to the geometric mean of the lengths of the two vectors. This is
        useful because it has the direction of the cross product (i.e. normal
        to the plane of the two vectors) and a size in between the two
        vectors.
        
        Parameter ``[in]``:
        vector1 The first vector
        
        Parameter ``[in]``:
        vector2 The second vector
        
        Returns:
        The The length of unscaled cross product.
        """
        ...
    
    def GetComponent(*args, **kwargs):
        """
        GetComponent(self: MSPyBentleyGeom.DVec3d, index: int) -> float
        
        Gets a single component of a vector. If the index is out
        of range 0,1,2, it is interpreted cyclically.
        
        Parameter ``[in]``:
        index Indicates which component is accessed. The values are 0=x,
        1=y, 2=z. Other values are treated cyclically.
        
        Returns:
        The specified component of the vector.
        """
        ...
    
    def GetComponents(*args, **kwargs):
        """
        GetComponents(self: MSPyBentleyGeom.DVec3d) -> tuple
        """
        ...
    
    def GetNormalizedTriad(*args, **kwargs):
        """
        GetNormalizedTriad(self: MSPyBentleyGeom.DVec3d, xAxis: MSPyBentleyGeom.DVec3d, yAxis: MSPyBentleyGeom.DVec3d, zAxis: MSPyBentleyGeom.DVec3d) -> bool
        
        Sets three vectors so that they are mutually
        perpendicular unit vectors with the third (Z) vector in the direction
        of the given axis vector. If the given axis vector contains only
        zeros, a (0,0,1) vector is used instead.
        
        Parameter ``[out]``:
        xAxis unit x direction vector
        
        Parameter ``[out]``:
        yAxis unit y direction vector
        
        Parameter ``[out]``:
        zAxis unit z direction vector
        
        Returns:
        true unless given vector has zero length.
        """
        ...
    
    def GetPerpendicularParts(*args, **kwargs):
        """
        GetPerpendicularParts(self: MSPyBentleyGeom.DVec3d, hypotenuse: MSPyBentleyGeom.DVec3d, parallelPart: MSPyBentleyGeom.DVec3d, perpendicularPart: MSPyBentleyGeom.DVec3d) -> tuple
        
        Decompose hypotenuse into a vector parallel to the instance and a
        vector perpendicular to the instance.
        
        Parameter ``[in]``:
        hypotenuse vector to decompose
        
        Parameter ``[out]``:
        fraction position where hypotenuse projects onto the instance.
        
        Parameter ``[out]``:
        parallelPart vector parallel to the instance
        
        Parameter ``[out]``:
        perpendicularPart vector perpendicular to the instance
        """
        ...
    
    def GetTriad(*args, **kwargs):
        """
        GetTriad(self: MSPyBentleyGeom.DVec3d, xAxis: MSPyBentleyGeom.DVec3d, yAxis: MSPyBentleyGeom.DVec3d, zAxis: MSPyBentleyGeom.DVec3d) -> bool
        
        Sets three vectors so that they are mutually
        perpendicular, the third (Z) vector is identical to the given axis
        vector, and all have the same length. If the given axis vector
        contains only zeros, a (0,0,1) vector is used instead.
        
        Parameter ``[out]``:
        xAxis x direction of the coordinate system
        
        Parameter ``[out]``:
        yAxis y direction of the coordinate system
        
        Parameter ``[out]``:
        zAxis z direction of the coordinate system
        
        Returns:
        true unless given vector is z zero vector.
        """
        ...
    
    def Init(*args, **kwargs):
        """
        Init(*args, **kwargs)
        Overloaded function.
        
        1. Init(self: MSPyBentleyGeom.DPoint3d, source: MSPyBentleyGeom.DPoint2d) -> None
        
        @description Copy from a 2d point setting z to zero.
        
        Parameter ``[in]``:
        source source point
        
        2. Init(self: MSPyBentleyGeom.DPoint3d, ax: float, ay: float, az: float) -> None
        
        @description Copy from a 2d point setting z to zero.
        
        Parameter ``[in]``:
        source source point
        
        3. Init(self: MSPyBentleyGeom.DPoint3d, ax: float, ay: float) -> None
        
        @description Copy from a 2d point setting z to zero.
        
        Parameter ``[in]``:
        source source point
        
        4. Init(self: MSPyBentleyGeom.DPoint3d, vector: Bentley.DVec3d) -> None
        
        @description Copy from a 2d point setting z to zero.
        
        Parameter ``[in]``:
        source source point
        """
        ...
    
    def InitDisconnect(*args, **kwargs):
        """
        InitDisconnect(self: MSPyBentleyGeom.DPoint3d) -> None
        
        Initialize a point with all coordinates as the disconnect value.
        """
        ...
    
    def InitFromColumn(*args, **kwargs):
        """
        InitFromColumn(self: MSPyBentleyGeom.DVec3d, matrix: Bentley.RotMatrix, col: int) -> None
        """
        ...
    
    def InitFromRow(*args, **kwargs):
        """
        InitFromRow(self: MSPyBentleyGeom.DVec3d, matrix: Bentley.RotMatrix, row: int) -> None
        """
        ...
    
    def InitFromXYAngleAndMagnitude(*args, **kwargs):
        """
        InitFromXYAngleAndMagnitude(self: MSPyBentleyGeom.DVec3d, theta: float, magnitude: float) -> None
        
        Sets a vector from given angle and distance in xy plane. Z part is set to zero
        
        Parameter ``[in]``:
        theta Angle from X axis to the vector, in the xy plane
        
        Parameter ``[in]``:
        magnitude Vector magnitude
        """
        ...
    
    def Interpolate(*args, **kwargs):
        """
        Interpolate(self: MSPyBentleyGeom.DVec3d, vector0: MSPyBentleyGeom.DVec3d, fraction: float, vector1: MSPyBentleyGeom.DVec3d) -> None
        
        Computes a vector whose position is given by a fractional
        argument and two vectors.
        
        Parameter ``[in]``:
        vector0 The vector corresponding to fractionParameter of 0.
        
        Parameter ``[in]``:
        fractionParameter The fractional parametric coordinate. 0.0 is the
        start of the segment, 1.0 is the end, 0.5 is middle
        
        Parameter ``[in]``:
        vector1 The vector corresponding to fractionParameter of 1.
        """
        ...
    
    def IsDisconnect(*args, **kwargs):
        """
        IsDisconnect(self: MSPyBentleyGeom.DPoint3d) -> bool
        
        Returns:
        true if the point has coordinates which indicate it is a
        disconnect (separator) ponit.
        """
        ...
    
    def IsEqual(*args, **kwargs):
        """
        IsEqual(*args, **kwargs)
        Overloaded function.
        
        1. IsEqual(self: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d) -> bool
        
        Test for exact equality between all components of two
        vectors.
        
        Parameter ``[in]``:
        vector2 The second vector
        
        Returns:
        true if the vectors are identical.
        
        2. IsEqual(self: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d, tolerance: float) -> bool
        
        Test for exact equality between all components of two
        vectors.
        
        Parameter ``[in]``:
        vector2 The second vector
        
        Returns:
        true if the vectors are identical.
        """
        ...
    
    def IsParallelTo(*args, **kwargs):
        """
        IsParallelTo(self: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d) -> bool
        
        Tests if two vectors are parallel (opposites are
        considered parallel!)
        
        Parameter ``[in]``:
        vector2 The second vector
        
        Returns:
        true if the vectors are parallel within tolerance
        """
        ...
    
    def IsPerpendicularTo(*args, **kwargs):
        """
        IsPerpendicularTo(self: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d) -> bool
        
        Tests if two vectors are perpendicular.
        
        Parameter ``[in]``:
        vector2 The second vector
        
        Returns:
        true if vectors are perpendicular within tolerance
        """
        ...
    
    def IsPointInCCWector(*args, **kwargs):
        """
        IsPointInCCWector(self: MSPyBentleyGeom.DPoint3d, origin: MSPyBentleyGeom.DPoint3d, target0: MSPyBentleyGeom.DPoint3d, target1: MSPyBentleyGeom.DPoint3d, upVector: Bentley.DVec3d) -> bool
        
        @description Test if a point is within the counter-clockwise sector
        defined by an origin and two boundary points, with an up vector to
        determine which direction is counter clockwise.
        
        Parameter ``[in]``:
        origin The point to test.
        
        Parameter ``[in]``:
        target0 The first target point.
        
        Parameter ``[in]``:
        target1 The second target point.
        
        Parameter ``[in]``:
        upVector vector towards eye to resolve direction.
        
        Returns:
        true if the test point is within the angle.
        """
        ...
    
    def IsPointInSmallerSector(*args, **kwargs):
        """
        IsPointInSmallerSector(self: MSPyBentleyGeom.DPoint3d, origin: MSPyBentleyGeom.DPoint3d, target1: MSPyBentleyGeom.DPoint3d, target2: MSPyBentleyGeom.DPoint3d) -> bool
        
        @description Form vectors from the origin to the test point and the
        two boundary vectors. Test if the test vector is within the smaller
        angle between the other two vectors.
        
        Parameter ``[in]``:
        origin The point to test.
        
        Parameter ``[in]``:
        target1 The first target point.
        
        Parameter ``[in]``:
        target2 The second target point.
        
        Returns:
        true if the test point is within the angle.
        """
        ...
    
    def IsPositiveParallelTo(*args, **kwargs):
        """
        IsPositiveParallelTo(self: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d) -> bool
        
        Tests if two vectors are parallel and have positive dot
        product (opposites are NOT considered parallel)
        
        Parameter ``[in]``:
        vector2 The second vector
        
        Returns:
        true if the vectors are parallel within tolerance
        """
        ...
    
    def IsVectorInCCWSector(*args, **kwargs):
        """
        IsVectorInCCWSector(self: MSPyBentleyGeom.DVec3d, vector0: MSPyBentleyGeom.DVec3d, vector1: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d) -> bool
        
        Test if the test vector vector is " between " vector0 and
        vector1, with CCW direction resolved by an up vector. The cross
        product of vector0 and vector1 is considered the positive plane normal
        if its dot product with the up vector is positive.
        
        Parameter ``[in]``:
        vector0 The boundary vector.
        
        Parameter ``[in]``:
        vector1 The boundary vector.
        
        Parameter ``[in]``:
        upVector The out of plane vector.
        
        Returns:
        true if test vector is within the angle.
        """
        ...
    
    def IsVectorInCCWXYSector(*args, **kwargs):
        """
        IsVectorInCCWXYSector(self: MSPyBentleyGeom.DVec3d, vector1: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d) -> bool
        
        Test if the instance vector vector is " between " vector0
        and vector1, with CCW direction using only xy parts.
        
        Parameter ``[in]``:
        vector0 The boundary vector.
        
        Parameter ``[in]``:
        vector1 The boundary vector.
        
        Returns:
        true if test vector is within the angle.
        """
        ...
    
    def IsVectorInSmallerSector(*args, **kwargs):
        """
        IsVectorInSmallerSector(self: MSPyBentleyGeom.DVec3d, vector0: MSPyBentleyGeom.DVec3d, vector1: MSPyBentleyGeom.DVec3d) -> bool
        
        Test a vector is " between " vector0 and vector1. If the
        vectors are coplanar and vector0 is neither parallel nor antiparallel
        to vector1, betweenness has the expected meaning:there are two angles
        between vector0 and vector1; one is less than 180; the test vector is
        tested to see if it is in the smaller angle. If the vectors are not
        coplanar, the test is based on the projection of the test vector into
        the plane of the other two vectors.
        
        Zero testing is untoleranced, and is biased to all parallel conditions
        " false ". That is, if any pair of the input vectors is parallel or
        antiparallel, the mathematical answer is false. Floating point
        tolerances will cause " nearby " cases to be unpredictable. It is
        assumed that if the caller considers the " parallel " cases important
        they will be checked explicitly.
        
        Parameter ``[in]``:
        vector0 The first boundary vector.
        
        Parameter ``[in]``:
        vector1 The second boundary vector.
        
        Returns:
        true if the test vector is within the angle.
        """
        ...
    
    def IsZero(*args, **kwargs):
        """
        IsZero(self: MSPyBentleyGeom.DVec3d) -> bool
        
        checks if the vector has all zeros
        """
        ...
    
    def Magnitude(*args, **kwargs):
        """
        Magnitude(self: MSPyBentleyGeom.DVec3d) -> float
        
        Computes the magnitude of a vector.
        
        Returns:
        The length of the vector
        """
        ...
    
    def MagnitudeSquared(*args, **kwargs):
        """
        MagnitudeSquared(self: MSPyBentleyGeom.DVec3d) -> float
        
        Computes the squared magnitude of a vector.
        
        Returns:
        The squared magnitude of the vector.
        """
        ...
    
    def MagnitudeSquaredXY(*args, **kwargs):
        """
        MagnitudeSquaredXY(self: MSPyBentleyGeom.DVec3d) -> float
        
        Computes the squared magnitude of the xy part of a
        vector.
        
        Returns:
        The squared magnitude of the xy parts of the given vector.
        """
        ...
    
    def MagnitudeXY(*args, **kwargs):
        """
        MagnitudeXY(self: MSPyBentleyGeom.DVec3d) -> float
        
        Computes the magnitude of the xy part of a vector.
        
        Returns:
        The magnitude of the xy parts of the given vector.
        """
        ...
    
    def MaxAbs(*args, **kwargs):
        """
        MaxAbs(self: MSPyBentleyGeom.DVec3d) -> float
        
        Finds the largest absolute value among the components of
        a vector.
        
        Returns:
        The largest absolute value among vector coordinates.
        """
        ...
    
    def MaxAbsIndex(*args, **kwargs):
        """
        MaxAbsIndex(self: MSPyBentleyGeom.DPoint3d) -> int
        
        return in the index of the MaxAbs () value.
        """
        ...
    
    def MinAbs(*args, **kwargs):
        """
        MinAbs(self: MSPyBentleyGeom.DPoint3d) -> float
        
        @description Finds the smallest absolute value among the components of
        a point or vector.
        
        Returns:
        The smallest absolute value among point coordinates.
        """
        ...
    
    def MinAbsIndex(*args, **kwargs):
        """
        MinAbsIndex(self: MSPyBentleyGeom.DPoint3d) -> int
        
        return in the index of the MinAbs () value
        """
        ...
    
    def Multiply(*args, **kwargs):
        """
        Multiply(*args, **kwargs)
        Overloaded function.
        
        1. Multiply(self: MSPyBentleyGeom.DVec3d, matrix: Bentley.RotMatrix, vector: MSPyBentleyGeom.DVec3d) -> None
        
        Returns the product of a matrix times a vector.
        
        Parameter ``[in]``:
        matrix The matrix.
        
        Parameter ``[in]``:
        vector The known vector.
        
        2. Multiply(self: MSPyBentleyGeom.DVec3d, matrix: Bentley.RotMatrix, x: float, y: float, z: float) -> None
        
        Returns the product of a matrix times a vector.
        
        Parameter ``[in]``:
        matrix The matrix.
        
        Parameter ``[in]``:
        vector The known vector.
        """
        ...
    
    def MultiplyArrayByScales(*args, **kwargs):
        """
        MultiplyArrayByScales(outPoints: MSPyBentleyGeom.DPoint3dArray, inPoints: MSPyBentleyGeom.DPoint3dArray, scales: MSPyBentley.DoubleArray) -> None
        
        @description Multiply each point in an array by its corresponding
        scale factor.
        
        Parameter ``[out]``:
        pDest destination array.
        
        Parameter ``[in]``:
        pSource source array.
        
        Parameter ``[in]``:
        pScales scale factors
        
        Parameter ``[in]``:
        n number of points.
        """
        ...
    
    def MultiplyTranspose(*args, **kwargs):
        """
        MultiplyTranspose(*args, **kwargs)
        Overloaded function.
        
        1. MultiplyTranspose(self: MSPyBentleyGeom.DVec3d, matrix: Bentley.RotMatrix, vector: MSPyBentleyGeom.DVec3d) -> None
        
        Returns the product of a matrix transpose times a vector.
        
        Parameter ``[in]``:
        matrix The the matrix.
        
        Parameter ``[in]``:
        vector The known vector.
        
        2. MultiplyTranspose(self: MSPyBentleyGeom.DVec3d, matrix: Bentley.RotMatrix, x: float, y: float, z: float) -> None
        
        Returns the product of a matrix transpose times a vector.
        
        Parameter ``[in]``:
        matrix The the matrix.
        
        Parameter ``[in]``:
        vector The known vector.
        """
        ...
    
    def Negate(*args, **kwargs):
        """
        Negate(*args, **kwargs)
        Overloaded function.
        
        1. Negate(self: MSPyBentleyGeom.DVec3d, vector: MSPyBentleyGeom.DVec3d) -> None
        
        Computes a negated (opposite) vector.
        
        Parameter ``[in]``:
        vector The vector to be negated.
        
        2. Negate(self: MSPyBentleyGeom.DVec3d) -> None
        
        Computes a negated (opposite) vector.
        
        Parameter ``[in]``:
        vector The vector to be negated.
        """
        ...
    
    def Normalize(*args, **kwargs):
        """
        Normalize(*args, **kwargs)
        Overloaded function.
        
        1. Normalize(self: MSPyBentleyGeom.DVec3d, vector: MSPyBentleyGeom.DVec3d) -> float
        
        Normalizes (scales) a vector to length 1.
        
        Remark:
        In the 0-length error case, the vector is set to (1,0,0) in the
        legacy microstation style.
        
        Parameter ``[in]``:
        vector The vector to be normalized.
        
        Returns:
        The length prior to normalization
        
        2. Normalize(self: MSPyBentleyGeom.DVec3d) -> float
        
        Normalizes (scales) a vector to length 1.
        
        Remark:
        In the 0-length error case, the vector is set to (1,0,0) in the
        legacy microstation style.
        
        Parameter ``[in]``:
        vector The vector to be normalized.
        
        Returns:
        The length prior to normalization
        """
        ...
    
    def NormalizedCrossProduct(*args, **kwargs):
        """
        NormalizedCrossProduct(self: MSPyBentleyGeom.DVec3d, vector0: MSPyBentleyGeom.DVec3d, vector1: MSPyBentleyGeom.DVec3d) -> float
        
        Compute the normalized cross product of two vectors and
        return the length of the unnormalized cross product.
        
        Parameter ``[in]``:
        vector1 The first vector
        
        Parameter ``[in]``:
        vector2 The second vector
        
        Returns:
        The length of the original (prenormalization) cross product vector
        """
        ...
    
    def NormalizedDifference(*args, **kwargs):
        """
        NormalizedDifference(self: MSPyBentleyGeom.DVec3d, target: MSPyBentleyGeom.DPoint3d, origin: MSPyBentleyGeom.DPoint3d) -> float
        
        Computes a unit vector in the direction of the difference
        of the vectors or vectors (Second parameter vector is subtracted from
        the first parameter vector, exactly as in the subtract function.)
        
        Remark:
        In the 0-length error case, the vector is set to (1,0,0) in the
        legacy microstation style.
        
        Parameter ``[in]``:
        target The target point.
        
        Parameter ``[in]``:
        origin The origin point.
        
        Returns:
        The length of original difference vector.
        """
        ...
    
    def NpcCoordinatesOf(*args, **kwargs):
        """
        NpcCoordinatesOf(self: MSPyBentleyGeom.DPoint3d, point: MSPyBentleyGeom.DPoint3d, cube: Bentley.DRange3d) -> None
        
        @description Computes the coordinates of point under the translation
        and scaling that puts 000 at cube>low and 111 at cube>high.
        
        Parameter ``[in]``:
        point Point whose NPC coordinates are to be computed
        
        Parameter ``[in]``:
        cube Cube whose corners map to 000 and 111
        """
        ...
    
    def One(*args, **kwargs):
        """
        One(self: MSPyBentleyGeom.DPoint3d) -> None
        
        @description Returns a point or vector with all components 1.0.
        """
        ...
    
    def PlanarAngleTo(*args, **kwargs):
        """
        PlanarAngleTo(self: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d, planeNormal: MSPyBentleyGeom.DVec3d) -> float
        
        Computes the signed angle between the projection of two
        vectors onto a plane with given normal.
        
        Parameter ``[in]``:
        vector2 The second vector
        
        Parameter ``[in]``:
        planeNormal The plane normal vector
        
        Returns:
        The angle in plane
        """
        ...
    
    def ProjectToPlane(*args, **kwargs):
        """
        ProjectToPlane(self: MSPyBentleyGeom.DVec3d, vectorU: MSPyBentleyGeom.DVec3d, vectorV: MSPyBentleyGeom.DVec3d, uv: MSPyBentleyGeom.DPoint2d) -> bool
        
        Find the projection of the instance vector to a plane defined by two
        vectors.
        
        Parameter ``[in]``:
        vectorU u-direction vector of the plane.
        
        Parameter ``[in]``:
        vectorV v-direction vector of the plane.
        
        Parameter ``[out]``:
        uv fractional coordinates on vectors.
        
        Returns:
        false if plane vectors are not independent. In this case the
        method attempts to project to the longer plane vector, and sets
        the other fraction to 0. If that fails uv is 00.
        """
        ...
    
    def ProjectToVector(*args, **kwargs):
        """
        ProjectToVector(self: MSPyBentleyGeom.DVec3d, targetVector: MSPyBentleyGeom.DVec3d) -> tuple
        
        Find the fraction at which the instance projects to a vector.
        
        Parameter ``[in]``:
        targetVector target vector.
        
        Parameter ``[out]``:
        fraction projection fraction
        
        Returns:
        false if targetVector has zero length. In this case the fraction
        is zero.
        """
        ...
    
    def RotateXY(*args, **kwargs):
        """
        RotateXY(*args, **kwargs)
        Overloaded function.
        
        1. RotateXY(self: MSPyBentleyGeom.DVec3d, vector: MSPyBentleyGeom.DVec3d, theta: float) -> None
        
        Rotate a vector around the z axis.
        
        Parameter ``[in]``:
        vector vector to rotate.
        
        Parameter ``[in]``:
        theta The rotation angle.
        
        2. RotateXY(self: MSPyBentleyGeom.DVec3d, theta: float) -> None
        
        Rotate a vector around the z axis.
        
        Parameter ``[in]``:
        vector vector to rotate.
        
        Parameter ``[in]``:
        theta The rotation angle.
        """
        ...
    
    def SafeDivide(*args, **kwargs):
        """
        SafeDivide(self: MSPyBentleyGeom.DVec3d, vector: MSPyBentleyGeom.DVec3d, denominator: float) -> bool
        
        Try to divide each component of a vector by a scalar. If
        the denominator near zero compared to any numerator component, return
        the original vector.
        
        Parameter ``[in]``:
        vector The initial vector.
        
        Parameter ``[in]``:
        denominator The divisor.
        
        Returns:
        true if division is numerically safe.
        """
        ...
    
    def SafeOneOverMagnitudeSquared(*args, **kwargs):
        """
        SafeOneOverMagnitudeSquared(self: MSPyBentleyGeom.DVec3d, defaultValue: float) -> float
        
        Returns 1 over the squared magnitude, or caller supplied
        default if squared magnitude is too small.
        """
        ...
    
    def Scale(*args, **kwargs):
        """
        Scale(*args, **kwargs)
        Overloaded function.
        
        1. Scale(self: MSPyBentleyGeom.DVec3d, vector: MSPyBentleyGeom.DVec3d, scale: float) -> None
        
        Multiplies a vector by a scale factor.
        
        Parameter ``[in]``:
        vector The vector to be scaled.
        
        Parameter ``[in]``:
        scale The scale factor.
        
        2. Scale(self: MSPyBentleyGeom.DVec3d, scale: float) -> None
        
        Multiplies a vector by a scale factor.
        
        Parameter ``[in]``:
        vector The vector to be scaled.
        
        Parameter ``[in]``:
        scale The scale factor.
        """
        ...
    
    def ScaleToLength(*args, **kwargs):
        """
        ScaleToLength(*args, **kwargs)
        Overloaded function.
        
        1. ScaleToLength(self: MSPyBentleyGeom.DVec3d, vector: MSPyBentleyGeom.DVec3d, length: float) -> float
        
        Scales a vector to specified length.
        
        Remark:
        In the 0-length error case, the vector is set to (1,0,0) in the
        legacy microstation style.
        
        Parameter ``[in]``:
        vector The original vector.
        
        Parameter ``[in]``:
        length The requested length.
        
        Returns:
        The length prior to scaling.
        
        2. ScaleToLength(self: MSPyBentleyGeom.DVec3d, length: float) -> float
        
        Scales a vector to specified length.
        
        Remark:
        In the 0-length error case, the vector is set to (1,0,0) in the
        legacy microstation style.
        
        Parameter ``[in]``:
        vector The original vector.
        
        Parameter ``[in]``:
        length The requested length.
        
        Returns:
        The length prior to scaling.
        """
        ...
    
    def SetComponent(*args, **kwargs):
        """
        SetComponent(self: MSPyBentleyGeom.DVec3d, a: float, index: int) -> None
        
        Set one of three components (x,y,z) of the vector.
        
        Parameter ``[in]``:
        a The component value.
        
        Parameter ``[in]``:
        index Selects the the axis:0=x, 1=y, 2=z, others cyclic.
        """
        ...
    
    def SignedAngleTo(*args, **kwargs):
        """
        SignedAngleTo(self: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d, orientationVector: MSPyBentleyGeom.DVec3d) -> float
        
        Computes the signed angle from one vector to another, in
        the plane of the two vectors. Initial computation using only the two
        vectors yields two possible angles depending on which side of the
        plane of the vectors is viewed. To choose which side to view, go on
        the side whose normal has a positive dot product with the orientation
        vector. This angle can be between -pi and +pi.
        
        Parameter ``[in]``:
        vector2 The second vector
        
        Parameter ``[in]``:
        orientationVector The vector used to determine orientation.
        
        Returns:
        The signed angle
        """
        ...
    
    def SizedCrossProduct(*args, **kwargs):
        """
        SizedCrossProduct(self: MSPyBentleyGeom.DVec3d, vector0: MSPyBentleyGeom.DVec3d, vector1: MSPyBentleyGeom.DVec3d, productLength: float) -> float
        
        Computes the cross product of the two parameter vectors
        and scales it to a given length. The scaled vector is stored as the
        product vector, and the length of the original cross product vector is
        returned.
        
        Parameter ``[in]``:
        vector1 The first vector
        
        Parameter ``[in]``:
        vector2 The second vector
        
        Parameter ``[in]``:
        productLength The Desired length
        
        Returns:
        The The length of unscaled cross product.
        """
        ...
    
    def SmallerUnorientedAngleTo(*args, **kwargs):
        """
        SmallerUnorientedAngleTo(self: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d) -> float
        
        Returns the angle between two vectors, choosing the
        smaller of the two possible angles when both the vectors and their
        negations are considered. This angle is between 0 and pi/2.
        
        Parameter ``[in]``:
        vector2 The second vector
        
        Returns:
        The angle between the vectors.
        """
        ...
    
    def SmallerUnorientedAngleToXY(*args, **kwargs):
        """
        SmallerUnorientedAngleToXY(self: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d) -> float
        
        Returns the angle between two vectors, considering both
        the vectors and their negations and choosing the smaller. This angle
        is between 0 and pi/2.
        
        Parameter ``[in]``:
        vector2 The second vector
        
        Returns:
        The angle between vectors.
        """
        ...
    
    def Subtract(*args, **kwargs):
        """
        Subtract(self: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d) -> None
        
        Subtract two vectors, and return the result in place of
        the first.
        
        Parameter ``[in]``:
        vector2 The vector to subtract.
        """
        ...
    
    def SumOf(*args, **kwargs):
        """
        SumOf(*args, **kwargs)
        Overloaded function.
        
        1. SumOf(self: MSPyBentleyGeom.DVec3d, vector1: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d) -> None
        
        Compute the sum of two vectors.
        
        Parameter ``[in]``:
        vector1 The the first vector
        
        Parameter ``[in]``:
        vector2 The second vector
        
        2. SumOf(self: MSPyBentleyGeom.DVec3d, vector1: MSPyBentleyGeom.DVec3d, scale1: float, vector2: MSPyBentleyGeom.DVec3d, scale2: float) -> None
        
        Compute the sum of two vectors.
        
        Parameter ``[in]``:
        vector1 The the first vector
        
        Parameter ``[in]``:
        vector2 The second vector
        
        3. SumOf(self: MSPyBentleyGeom.DVec3d, vector1: MSPyBentleyGeom.DVec3d, scale1: float, vector2: MSPyBentleyGeom.DVec3d, scale2: float, vector3: MSPyBentleyGeom.DVec3d, scale3: float) -> None
        
        Compute the sum of two vectors.
        
        Parameter ``[in]``:
        vector1 The the first vector
        
        Parameter ``[in]``:
        vector2 The second vector
        
        4. SumOf(self: MSPyBentleyGeom.DVec3d, origin: MSPyBentleyGeom.DVec3d, vector: MSPyBentleyGeom.DVec3d, scale: float) -> None
        
        Compute the sum of two vectors.
        
        Parameter ``[in]``:
        vector1 The the first vector
        
        Parameter ``[in]``:
        vector2 The second vector
        
        5. SumOf(self: MSPyBentleyGeom.DVec3d, origin: MSPyBentleyGeom.DVec3d, vector1: MSPyBentleyGeom.DVec3d, scale1: float, vector2: MSPyBentleyGeom.DVec3d, scale2: float) -> None
        
        Compute the sum of two vectors.
        
        Parameter ``[in]``:
        vector1 The the first vector
        
        Parameter ``[in]``:
        vector2 The second vector
        
        6. SumOf(self: MSPyBentleyGeom.DVec3d, origin: MSPyBentleyGeom.DVec3d, vector1: MSPyBentleyGeom.DVec3d, scale1: float, vector2: MSPyBentleyGeom.DVec3d, scale2: float, vector3: MSPyBentleyGeom.DVec3d, scale3: float) -> None
        
        Compute the sum of two vectors.
        
        Parameter ``[in]``:
        vector1 The the first vector
        
        Parameter ``[in]``:
        vector2 The second vector
        """
        ...
    
    def Swap(*args, **kwargs):
        """
        Swap(self: MSPyBentleyGeom.DPoint3d, other: MSPyBentleyGeom.DPoint3d) -> None
        
        Swap contents of instance, other.
        
        Parameter ``[in,out]``:
        other second point.
        """
        ...
    
    def TripleProduct(*args, **kwargs):
        """
        TripleProduct(self: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d, vector3: MSPyBentleyGeom.DVec3d) -> float
        
        Computes the triple product of three vectors. The
        following are equivalent definitions of the triple product of three
        vectors V1, V2, and V3:
        
        <UL> <LI> (V1 cross V2) dot V3 <LI> V1 dot (V2 cross V3) <LI>The
        determinant of the 3x3 matrix with the three vectors as its columns.
        <LI>The determinant of the 3x3 matrix with the three vectors as its
        rows. <LI>The (signed)volume of the parallelepiped whose 4 vertices
        are at the origin and at the ends of the 3 vectors placed at the
        origin. </UL>
        
        Parameter ``[in]``:
        vector2 The second vector.
        
        Parameter ``[in]``:
        vector3 The third vector.
        
        Returns:
        The triple product
        """
        ...
    
    def TripleProductToPoints(*args, **kwargs):
        """
        TripleProductToPoints(self: MSPyBentleyGeom.DPoint3d, target1: MSPyBentleyGeom.DPoint3d, target2: MSPyBentleyGeom.DPoint3d, target3: MSPyBentleyGeom.DPoint3d) -> float
        
        @description Computes the triple product of vectors from a base point
        three target points.
        
        Parameter ``[in]``:
        target1 The target point for the first vector.
        
        Parameter ``[in]``:
        target2 The target point for the second vector.
        
        Parameter ``[in]``:
        target3 The target point for the third vector.
        
        Returns:
        The triple product
        """
        ...
    
    def TryNormalize(*args, **kwargs):
        """
        TryNormalize(self: MSPyBentleyGeom.DVec3d, source: MSPyBentleyGeom.DVec3d) -> tuple
        
        initialize this vector to unit vector in the direction of
        source.
        
        Remark:
        In the 0-length error case, the vector is set to (1,0,0) in the
        legacy microstation style.
        
        Parameter ``[in]``:
        source The vector to be normalized.
        
        Parameter ``[out]``:
        magnitude The orignal magnitude of the source vector;
        
        Returns:
        true if the other vector length is large enough for
        DoubleOps.SafeDivide to compute 1/length.
        """
        ...
    
    def UnitPerpendicularXY(*args, **kwargs):
        """
        UnitPerpendicularXY(self: MSPyBentleyGeom.DVec3d, vector: MSPyBentleyGeom.DVec3d) -> bool
        
        Compute a unit vector perpendicular to the xy parts of
        given vector.
        
        Parameter ``[in]``:
        vector The source vector
        
        Returns:
        true if the input vector has nonzero length
        """
        ...
    
    def UnitX(*args, **kwargs):
        """
        UnitX() -> MSPyBentleyGeom.DVec3d
        
        unit X vector
        """
        ...
    
    def UnitY(*args, **kwargs):
        """
        UnitY() -> MSPyBentleyGeom.DVec3d
        
        unit Y vector
        """
        ...
    
    def UnitZ(*args, **kwargs):
        """
        UnitZ() -> MSPyBentleyGeom.DVec3d
        
        unit Z vector
        """
        ...
    
    def ValidatedFractionOfProjection(*args, **kwargs):
        """
        ValidatedFractionOfProjection(self: MSPyBentleyGeom.DVec3d, vectorToProject: MSPyBentleyGeom.DVec3d, defaultValue: float = 0.0) -> MSPyBentleyGeom.ValidatedDouble
        
        Returns fraction at which other projects onto this, in
        ValidatedDouble which records if the division was safe.
        """
        ...
    
    def ValidatedNormalize(*args, **kwargs):
        """
        ValidatedNormalize(self: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.ValidatedDVec3d
        
        return a (possibly invalid) unit vector in the direction
        of the calling instance.
        """
        ...
    
    def WeightedDifferenceCrossProduct(*args, **kwargs):
        """
        WeightedDifferenceCrossProduct(self: MSPyBentleyGeom.DVec3d, basePoint: MSPyBentleyGeom.DPoint4d, target1: MSPyBentleyGeom.DPoint4d, target2: MSPyBentleyGeom.DPoint4d) -> None
        
        Form the cross product of the weighted differences from
        base poitn to two targets
        
        Parameter ``[in]``:
        basePoint The common base point (second point for differences)
        
        Parameter ``[in]``:
        target1 The first target point.
        
        Parameter ``[in]``:
        target2 The second target point.
        """
        ...
    
    def WeightedDifferenceOf(*args, **kwargs):
        """
        WeightedDifferenceOf(self: MSPyBentleyGeom.DVec3d, hPoint1: MSPyBentleyGeom.DPoint4d, hPoint2: MSPyBentleyGeom.DPoint4d) -> None
        
        Scale each (homogeneous) point by the other's weight and
        subtract, i.e. form (point1 * point2.w - point2 * point1.w). The
        weight term vanishes. Copy the xyz parts back as a vector.
        
        Parameter ``[in]``:
        hPoint1 The first homogeneous point
        
        Parameter ``[in]``:
        hPoint2 The second homogeneous point.
        """
        ...
    
    def XyzOf(*args, **kwargs):
        """
        XyzOf(self: MSPyBentleyGeom.DVec3d, hPoint: MSPyBentleyGeom.DPoint4d) -> None
        
        Sets the x,y, and z components of a DVec3d structure from
        the corresponding parts of a DPoint4d. Weight part of DPoint4d is not
        used.
        
        Parameter ``[in]``:
        hPoint The homogeneous point
        """
        ...
    
    def Zero(*args, **kwargs):
        """
        Zero(self: MSPyBentleyGeom.DPoint3d) -> None
        
        @description Sets all components of a point or vector to zero.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DVec3d) -> None
        
        2. __init__(self: MSPyBentleyGeom.DVec3d, ax: float, ay: float, az: float = 0.0) -> None
        
        3. __init__(self: MSPyBentleyGeom.DVec3d, point: MSPyBentleyGeom.DPoint3d) -> None
        
        4. __init__(self: MSPyBentleyGeom.DVec3d, vector: MSPyBentleyGeom.DVec2d) -> None
        
        5. __init__(self: MSPyBentleyGeom.DVec3d, start: MSPyBentleyGeom.DPoint3d, end: MSPyBentleyGeom.DPoint3d) -> None
        
        6. __init__(self: MSPyBentleyGeom.DVec3d, start: MSPyBentleyGeom.DPoint4d, end: MSPyBentleyGeom.DPoint4d) -> None
        
        7. __init__(self: MSPyBentleyGeom.DVec3d, start: Bentley.Transform, target: MSPyBentleyGeom.DPoint3d) -> None
        """
        ...
    
    @property
    def x(self: MSPyBentleyGeom.DPoint3d) -> float:
        ...
    @x.setter
    def x(self: MSPyBentleyGeom.DPoint3d, arg0: float) -> None:
        ...
    
    @property
    def y(self: MSPyBentleyGeom.DPoint3d) -> float:
        ...
    @y.setter
    def y(self: MSPyBentleyGeom.DPoint3d, arg0: float) -> None:
        ...
    
    @property
    def z(self: MSPyBentleyGeom.DPoint3d) -> float:
        ...
    @z.setter
    def z(self: MSPyBentleyGeom.DPoint3d, arg0: float) -> None:
        ...
    
class DVec3dArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DVec3dArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.DVec3dArray, arg0: MSPyBentleyGeom.DVec3dArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.DVec3dArray, arg0: Iterable) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.DVec3dArray, x: MSPyBentleyGeom.DVec3d) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.DVec3dArray) -> None
        
        Clear the contents
        """
        ...
    
    def count(*args, **kwargs):
        """
        count(self: MSPyBentleyGeom.DVec3dArray, x: MSPyBentleyGeom.DVec3d) -> int
        
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.DVec3dArray, L: MSPyBentleyGeom.DVec3dArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.DVec3dArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.DVec3dArray, i: int, x: MSPyBentleyGeom.DVec3d) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.DVec3dArray) -> MSPyBentleyGeom.DVec3d
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.DVec3dArray, i: int) -> MSPyBentleyGeom.DVec3d
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(*args, **kwargs):
        """
        remove(self: MSPyBentleyGeom.DVec3dArray, x: MSPyBentleyGeom.DVec3d) -> None
        
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class DVec3dVecArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DVec3dVecArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.DVec3dVecArray, arg0: MSPyBentleyGeom.DVec3dVecArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.DVec3dVecArray, arg0: Iterable) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.DVec3dVecArray, x: MSPyBentleyGeom.DVec3dArray) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.DVec3dVecArray) -> None
        
        Clear the contents
        """
        ...
    
    def count(*args, **kwargs):
        """
        count(self: MSPyBentleyGeom.DVec3dVecArray, x: MSPyBentleyGeom.DVec3dArray) -> int
        
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.DVec3dVecArray, L: MSPyBentleyGeom.DVec3dVecArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.DVec3dVecArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.DVec3dVecArray, i: int, x: MSPyBentleyGeom.DVec3dArray) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.DVec3dVecArray) -> MSPyBentleyGeom.DVec3dArray
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.DVec3dVecArray, i: int) -> MSPyBentleyGeom.DVec3dArray
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(*args, **kwargs):
        """
        remove(self: MSPyBentleyGeom.DVec3dVecArray, x: MSPyBentleyGeom.DVec3dArray) -> None
        
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class DgnBoxDetail:
    """
    None
    """

    def AddCurveIntersections(*args, **kwargs):
        """
        AddCurveIntersections(*args, **kwargs)
        Overloaded function.
        
        1. AddCurveIntersections(self: MSPyBentleyGeom.DgnBoxDetail, curves: MSPyBentleyGeom.CurveVector, curvePoints: MSPyBentleyGeom.CurveLocationDetailArray, solidPoints: MSPyBentleyGeom.SolidLocationDetailArray, messages: MSPyBentleyGeom.MeshAnnotationVector) -> None
        
        Compute intersections with curves and add to the data array.
        
        Parameter ``[in]``:
        curves
        
        Parameter ``[in,out]``:
        curvePoints growing array of curve points.
        
        Parameter ``[in,out]``:
        solidPoints growing array of solid points.
        
        Parameter ``[in,out]``:
        messages array of error messages
        
        2. AddCurveIntersections(self: MSPyBentleyGeom.DgnBoxDetail, curves: MSPyBentleyGeom.ICurvePrimitive, curvePoints: MSPyBentleyGeom.CurveLocationDetailArray, solidPoints: MSPyBentleyGeom.SolidLocationDetailArray, messages: MSPyBentleyGeom.MeshAnnotationVector) -> None
        
        Compute intersections with curves and add to the data array.
        
        Parameter ``[in]``:
        curves
        
        Parameter ``[in,out]``:
        curvePoints growing array of curve points.
        
        Parameter ``[in,out]``:
        solidPoints growing array of solid points.
        
        Parameter ``[in,out]``:
        messages array of error messages
        """
        ...
    
    def AddRayIntersections(*args, **kwargs):
        """
        AddRayIntersections(self: MSPyBentleyGeom.DgnBoxDetail, pickData: MSPyBentleyGeom.SolidLocationDetailArray, ray: MSPyBentleyGeom.DRay3d, parentId: int, minParameter: float) -> None
        
        Compute intersections with a ray and add to the pickData.
        
        Parameter ``[in]``:
        ray origin and direction
        
        Parameter ``[in]``:
        minParameter smallest parameter of pick. (e.g. 0 for picking along
        a positive ray from an eyepoint)
        
        Parameter ``[in,out]``:
        pickData growing array of picks.
        
        Parameter ``[in]``:
        parentId caller's id for this solid. Will be placed in each
        pickData entry has parentId.
        """
        ...
    
    def Clone(*args, **kwargs):
        """
        Clone(self: MSPyBentleyGeom.DgnBoxDetail) -> Bentley.ISolidPrimitive
        
        Copy to a new (allocated) solid primitive.
        """
        ...
    
    def ClosestPoint(*args, **kwargs):
        """
        ClosestPoint(self: MSPyBentleyGeom.DgnBoxDetail, spacePoint: MSPyBentleyGeom.DPoint3d, pickDetail: MSPyBentleyGeom.SolidLocationDetail) -> bool
        
        Parameter ``[in]``:
        spacePoint search for point close to here and on the solid surface
        
        Parameter ``[out]``:
        pickDetail closest point data.
        
        Returns:
        false if not supported.
        """
        ...
    
    def ComputeSecondMomentAreaProducts(*args, **kwargs):
        """
        ComputeSecondMomentAreaProducts(self: MSPyBentleyGeom.DgnBoxDetail, localToWorld: MSPyBentleyGeom.Transform, localProducts: MSPyBentleyGeom.DMatrix4d) -> bool
        
        Return the various integrated products for area moment calculations.
        The primitive is treated as a thin shell.
        
        Parameter ``[out]``:
        localToWorld transform from preferred system where the products
        are most easily computed to world.
        
        Parameter ``[out]``:
        localProducts integrated [xx xy xz x; xy yy yz y; xz yz zz z; x y
        z 1] dA
        
        Returns:
        false if unable to compute.
        """
        ...
    
    def ComputeSecondMomentVolumeProducts(*args, **kwargs):
        """
        ComputeSecondMomentVolumeProducts(self: MSPyBentleyGeom.DgnBoxDetail, localToWorld: MSPyBentleyGeom.Transform, localProducts: MSPyBentleyGeom.DMatrix4d) -> bool
        
        Return the various integrated products for moment calculations. The
        primitive is treated as a volume
        
        Parameter ``[out]``:
        localToWorld transform from preferred system where the products
        are most easily computed to world.
        
        Parameter ``[out]``:
        localProducts integrated [xx xy xz x; xy yy yz y; xz yz zz z; x y
        z 1] dA
        
        Returns:
        false if unable to compute.
        """
        ...
    
    def GetConstantUSection(*args, **kwargs):
        """
        GetConstantUSection(self: MSPyBentleyGeom.DgnBoxDetail, indices: Bentley.SolidLocationDetail.FaceIndices, fraction: float) -> MSPyBentleyGeom.ICurvePrimitive
        
        Copy a section at constant u of a single face to a single
        ICurvePrimitive.
        
        Parameter ``[in]``:
        indices selects face
        
        Parameter ``[in]``:
        fraction u fraction for section curve
        """
        ...
    
    def GetConstantVSection(*args, **kwargs):
        """
        GetConstantVSection(self: MSPyBentleyGeom.DgnBoxDetail, indices: Bentley.SolidLocationDetail.FaceIndices, fraction: float) -> MSPyBentleyGeom.ICurvePrimitive
        
        Copy a section curve at constant v of a single face to a single
        ICurvePrimitive.
        
        Parameter ``[in]``:
        indices selects face
        
        Parameter ``[in]``:
        fraction v fraction for section curve
        """
        ...
    
    def GetCorners(*args, **kwargs):
        """
        GetCorners(*args, **kwargs)
        Overloaded function.
        
        1. GetCorners(self: MSPyBentleyGeom.DgnBoxDetail, corners: MSPyBentleyGeom.DPoint3dArray) -> None
        
        Return 8 corners of the box. x varies fastest, then y then z.
        
        Parameter ``[out]``:
        corners 8 corner coordinates.
        
        2. GetCorners(self: MSPyBentleyGeom.DgnBoxDetail, corners: MSPyBentleyGeom.DPoint3d) -> None
        
        Return 8 corners of the box. x varies fastest, then y then z.
        
        Parameter ``[out]``:
        corners 8 corner coordinates.
        """
        ...
    
    def GetFace(*args, **kwargs):
        """
        GetFace(self: MSPyBentleyGeom.DgnBoxDetail, indices: Bentley.SolidLocationDetail.FaceIndices) -> MSPyBentleyGeom.IGeometry
        
        Return a single face of the solid primitive
        
        Parameter ``indices``:
        integer selectors for the face.
        """
        ...
    
    def GetFaceIndices(*args, **kwargs):
        """
        GetFaceIndices(self: MSPyBentleyGeom.DgnBoxDetail, indices: MSPyBentleyGeom.FaceIndicesArray) -> None
        
        Fill a list of all possible face indices.
        
        Parameter ``[out]``:
        indices array of selectors for the faces.
        """
        ...
    
    def GetNonUniformTransform(*args, **kwargs):
        """
        GetNonUniformTransform(self: MSPyBentleyGeom.DgnBoxDetail, localToWorld: MSPyBentleyGeom.Transform) -> tuple
        
        Return (nonuniform) placement and rectangle sizes. (ax,ay) rectangle
        is on z=0. (bx,by) is on z=1;
        """
        ...
    
    def GetRange(*args, **kwargs):
        """
        GetRange(*args, **kwargs)
        Overloaded function.
        
        1. GetRange(self: MSPyBentleyGeom.DgnBoxDetail, range: MSPyBentleyGeom.DRange3d) -> bool
        
        Return range.
        
        2. GetRange(self: MSPyBentleyGeom.DgnBoxDetail, range: MSPyBentleyGeom.DRange3d, transform: MSPyBentleyGeom.Transform) -> bool
        
        Return range.
        """
        ...
    
    def InitFromCenterAndSize(*args, **kwargs):
        """
        InitFromCenterAndSize(center: MSPyBentleyGeom.DPoint3d, size: MSPyBentleyGeom.DPoint3d, capped: bool) -> MSPyBentleyGeom.DgnBoxDetail
        
        Initialize box detail fields from center and size.
        
        Parameter ``[in]``:
        center center of box in XYZ
        
        Parameter ``[in]``:
        size total range in XYZ
        
        Parameter ``[in]``:
        capped true if closed top and bottom.
        """
        ...
    
    def InitFromCenters(*args, **kwargs):
        """
        InitFromCenters(baseOrigin: MSPyBentleyGeom.DPoint3d, topOrigin: MSPyBentleyGeom.DPoint3d, vectorX: MSPyBentleyGeom.DVec3d, vectorY: MSPyBentleyGeom.DVec3d, baseX: float, baseY: float, topX: float, topY: float, capped: bool) -> MSPyBentleyGeom.DgnBoxDetail
        
        Initialize box detail fields specifying top/base centers instead of
        origins...
        
        Parameter ``[in]``:
        baseCenter center of base rectangle
        
        Parameter ``[in]``:
        topCenter center of Top rectangle
        
        Parameter ``[in]``:
        vectorX X vector of base plane
        
        Parameter ``[in]``:
        vectorY Y vector of base plane
        
        Parameter ``[in]``:
        baseX x size at base
        
        Parameter ``[in]``:
        baseY y size at base
        
        Parameter ``[in]``:
        topX X size at top
        
        Parameter ``[in]``:
        topY y size at top
        
        Parameter ``[in]``:
        capped true if closed top and bottom.
        """
        ...
    
    def IsBlock(*args, **kwargs):
        """
        IsBlock(self: MSPyBentleyGeom.DgnBoxDetail, origin: MSPyBentleyGeom.DPoint3d, unitAxes: MSPyBentleyGeom.RotMatrix, localDiagonal: MSPyBentleyGeom.DVec3d, originXFraction: float, originYFraction: float, originZFraction: float) -> bool
        
        Test if the DgnBox is really a box (aka slab). Return orientation and
        size data, using caller-specifed fractional coordinates to indicate
        position of origin in reference system.
        
        Parameter ``[out]``:
        origin local coordinates origin
        
        Parameter ``[out]``:
        unitAxes transform (with orthogonal axes)
        
        Parameter ``[out]``:
        localDiagonal the box edge lengths.
        
        Parameter ``[in]``:
        originXFraction fractional position of the unitAxes origin along
        the x edge.
        
        Parameter ``[in]``:
        originYFraction fractional position of the unitAxes origin along
        the y edge.
        
        Parameter ``[in]``:
        originZFraction fractional position of the unitAxes origin along
        the z edge.
        """
        ...
    
    def IsClosedVolume(*args, **kwargs):
        """
        IsClosedVolume(self: MSPyBentleyGeom.DgnBoxDetail) -> bool
        
        Test if this is a closed volume.
        """
        ...
    
    def IsSameStructure(*args, **kwargs):
        """
        IsSameStructure(self: MSPyBentleyGeom.DgnBoxDetail, other: Bentley.ISolidPrimitive) -> bool
        
        Test for same type and structure (but no coordinate comparison)
        """
        ...
    
    def IsSameStructureAndGeometry(*args, **kwargs):
        """
        IsSameStructureAndGeometry(self: MSPyBentleyGeom.DgnBoxDetail, other: Bentley.ISolidPrimitive, tolerance: float) -> bool
        
        Test for same type, structure and coordinates.
        """
        ...
    
    def ParameterizationSign(*args, **kwargs):
        """
        ParameterizationSign(self: MSPyBentleyGeom.DgnBoxDetail) -> float
        
        Return +1 or -1 that matches the volume sign after integration over
        the parameter space.
        """
        ...
    
    def SilhouetteCurves(*args, **kwargs):
        """
        SilhouetteCurves(self: MSPyBentleyGeom.DgnBoxDetail, eyePoint: MSPyBentleyGeom.DPoint4d, curves: MSPyBentleyGeom.CurveVector) -> bool
        
        Return curves which are silhoutte curves OTHER than hard edges
        
        Returns:
        return false if not implemented. return true if implemented -- but
        curves may still be empty.
        """
        ...
    
    def TransformInPlace(*args, **kwargs):
        """
        TransformInPlace(self: MSPyBentleyGeom.DgnBoxDetail, transform: MSPyBentleyGeom.Transform) -> bool
        
        Transform in place.
        """
        ...
    
    def TryGetConstructiveFrame(*args, **kwargs):
        """
        TryGetConstructiveFrame(self: MSPyBentleyGeom.DgnBoxDetail, localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform) -> bool
        
        Return coordinate system with 1) XY in box base plane, origin at
        nominal lower left. 2) Z perpendicular
        """
        ...
    
    def TryGetMaxUVLength(*args, **kwargs):
        """
        TryGetMaxUVLength(self: MSPyBentleyGeom.DgnBoxDetail, indices: Bentley.SolidLocationDetail.FaceIndices, uvLength: MSPyBentleyGeom.DVec2d) -> bool
        
        Compute the lengths of the longest u and v direction sections of a
        single face of a solid primitive.
        
        Parameter ``[in]``:
        indices selects face.
        
        Parameter ``[in]``:
        uvLength sizes in u, v directions.
        """
        ...
    
    def TryUVFractionToXYZ(*args, **kwargs):
        """
        TryUVFractionToXYZ(self: MSPyBentleyGeom.DgnBoxDetail, faceIndices: Bentley.SolidLocationDetail.FaceIndices, uFraction: float, vFraction: float, xyz: MSPyBentleyGeom.DPoint3d, dXdu: MSPyBentleyGeom.DVec3d, dXdv: MSPyBentleyGeom.DVec3d) -> bool
        
        convert u,v fraction on specified face to xyz and derivatives.
        
        Parameter ``[in]``:
        faceIndices face selection indices
        
        Parameter ``[in]``:
        uFraction fractional coordinate in u direction.
        
        Parameter ``[in]``:
        vFraction fractional coordinate in v direction.
        
        Parameter ``[out]``:
        xyz point on face.
        
        Parameter ``[out]``:
        dXdu derivative of face point wrt uFraction.
        
        Parameter ``[out]``:
        dXdv derivative of face point wrt vFraction.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DgnBoxDetail) -> None
        
        2. __init__(self: MSPyBentleyGeom.DgnBoxDetail, baseOrigin: MSPyBentleyGeom.DPoint3d, topOrigin: MSPyBentleyGeom.DPoint3d, vectorX: MSPyBentleyGeom.DVec3d, vectorY: MSPyBentleyGeom.DVec3d, baseX: float, baseY: float, topX: float, topY: float, capped: bool) -> None
        """
        ...
    
class DgnConeDetail:
    """
    None
    """

    def AddCurveIntersections(*args, **kwargs):
        """
        AddCurveIntersections(*args, **kwargs)
        Overloaded function.
        
        1. AddCurveIntersections(self: MSPyBentleyGeom.DgnConeDetail, curves: MSPyBentleyGeom.CurveVector, curvePoints: MSPyBentleyGeom.CurveLocationDetailArray, solidPoints: MSPyBentleyGeom.SolidLocationDetailArray, messages: MSPyBentleyGeom.MeshAnnotationVector) -> None
        
        Compute intersections with curves and add to the data array.
        
        Parameter ``[in]``:
        curves
        
        Parameter ``[in,out]``:
        curvePoints growing array of curve points.
        
        Parameter ``[in,out]``:
        solidPoints growing array of solid points.
        
        Parameter ``[in,out]``:
        messages array of error messages
        
        2. AddCurveIntersections(self: MSPyBentleyGeom.DgnConeDetail, curves: MSPyBentleyGeom.ICurvePrimitive, curvePoints: MSPyBentleyGeom.CurveLocationDetailArray, solidPoints: MSPyBentleyGeom.SolidLocationDetailArray, messages: MSPyBentleyGeom.MeshAnnotationVector) -> None
        
        Compute intersections with curves and add to the data array.
        
        Parameter ``[in]``:
        curves
        
        Parameter ``[in,out]``:
        curvePoints growing array of curve points.
        
        Parameter ``[in,out]``:
        solidPoints growing array of solid points.
        
        Parameter ``[in,out]``:
        messages array of error messages
        """
        ...
    
    def AddRayIntersections(*args, **kwargs):
        """
        AddRayIntersections(self: MSPyBentleyGeom.DgnConeDetail, pickData: MSPyBentleyGeom.SolidLocationDetailArray, ray: MSPyBentleyGeom.DRay3d, parentId: int, minParameter: float) -> None
        
        Compute intersections with a ray and add to the pickData.
        
        Parameter ``[in]``:
        ray origin and direction
        
        Parameter ``[in]``:
        minParameter smallest parameter of pick. (e.g. 0 for picking along
        a positive ray from an eyepoint)
        
        Parameter ``[in,out]``:
        pickData growing array of picks.
        
        Parameter ``[in]``:
        parentId caller's id for this solid. Will be placed in each
        pickData entry has parentId.
        """
        ...
    
    def Clone(*args, **kwargs):
        """
        Clone(self: MSPyBentleyGeom.DgnConeDetail) -> Bentley.ISolidPrimitive
        
        Copy to a new (allocated) solid primitive.
        """
        ...
    
    def ClosestPoint(*args, **kwargs):
        """
        ClosestPoint(self: MSPyBentleyGeom.DgnConeDetail, spacePoint: MSPyBentleyGeom.DPoint3d, pickDetail: MSPyBentleyGeom.SolidLocationDetail) -> bool
        
        Parameter ``[in]``:
        spacePoint search for point close to here and on the solid surface
        
        Parameter ``[out]``:
        pickDetail closest point data.
        
        Returns:
        false if not supported.
        """
        ...
    
    def ComputeSecondMomentAreaProducts(*args, **kwargs):
        """
        ComputeSecondMomentAreaProducts(self: MSPyBentleyGeom.DgnConeDetail, localToWorld: MSPyBentleyGeom.Transform, localProducts: MSPyBentleyGeom.DMatrix4d) -> bool
        
        Return the various integrated products for area moment calculations.
        The primitive is treated as a thin shell.
        
        Parameter ``[out]``:
        localToWorld transform from preferred system where the products
        are most easily computed to world.
        
        Parameter ``[out]``:
        localProducts integrated [xx xy xz x; xy yy yz y; xz yz zz z; x y
        z 1] dA
        
        Returns:
        false if unable to compute.
        """
        ...
    
    def ComputeSecondMomentVolumeProducts(*args, **kwargs):
        """
        ComputeSecondMomentVolumeProducts(self: MSPyBentleyGeom.DgnConeDetail, localToWorld: MSPyBentleyGeom.Transform, localProducts: MSPyBentleyGeom.DMatrix4d) -> bool
        
        Return the various integrated products for moment calculations. The
        primitive is treated as a volume
        
        Parameter ``[out]``:
        localToWorld transform from preferred system where the products
        are most easily computed to world.
        
        Parameter ``[out]``:
        localProducts integrated [xx xy xz x; xy yy yz y; xz yz zz z; x y
        z 1] dA
        
        Returns:
        false if unable to compute.
        """
        ...
    
    def FractionToRule(*args, **kwargs):
        """
        FractionToRule(self: MSPyBentleyGeom.DgnConeDetail, fraction: float, segment: MSPyBentleyGeom.DSegment3d) -> bool
        
        Return the rule line section at a fraction around the circular
        sections.
        
        Parameter ``[in]``:
        fraction fractional position around the cone.
        
        Parameter ``[out]``:
        segment rule line
        """
        ...
    
    def FractionToSection(*args, **kwargs):
        """
        FractionToSection(self: MSPyBentleyGeom.DgnConeDetail, fraction: float, ellipse: MSPyBentleyGeom.DEllipse3d) -> bool
        
        Return the ellipse cross section at a fraction along the rotation
        axis.
        
        Parameter ``[in]``:
        fraction fractional position alont the z axis.
        
        Parameter ``[out]``:
        ellipse the section ellipse.
        """
        ...
    
    def GetConstantUSection(*args, **kwargs):
        """
        GetConstantUSection(self: MSPyBentleyGeom.DgnConeDetail, indices: Bentley.SolidLocationDetail.FaceIndices, fraction: float) -> MSPyBentleyGeom.ICurvePrimitive
        
        Copy a section at constant u of a single face to a single
        ICurvePrimitive.
        
        Parameter ``[in]``:
        indices selects face
        
        Parameter ``[in]``:
        fraction u fraction for section curve
        """
        ...
    
    def GetConstantVSection(*args, **kwargs):
        """
        GetConstantVSection(self: MSPyBentleyGeom.DgnConeDetail, indices: Bentley.SolidLocationDetail.FaceIndices, fraction: float) -> MSPyBentleyGeom.ICurvePrimitive
        
        Copy a section curve at constant v of a single face to a single
        ICurvePrimitive.
        
        Parameter ``[in]``:
        indices selects face
        
        Parameter ``[in]``:
        fraction v fraction for section curve
        """
        ...
    
    def GetFace(*args, **kwargs):
        """
        GetFace(self: MSPyBentleyGeom.DgnConeDetail, indices: Bentley.SolidLocationDetail.FaceIndices) -> MSPyBentleyGeom.IGeometry
        
        Return a single face of the solid primitive
        
        Parameter ``indices``:
        integer selectors for the face.
        """
        ...
    
    def GetFaceIndices(*args, **kwargs):
        """
        GetFaceIndices(self: MSPyBentleyGeom.DgnConeDetail, indices: MSPyBentleyGeom.FaceIndicesArray) -> None
        
        Fill a list of all possible face indices.
        
        Parameter ``[out]``:
        indices array of selectors for the faces.
        """
        ...
    
    def GetRange(*args, **kwargs):
        """
        GetRange(*args, **kwargs)
        Overloaded function.
        
        1. GetRange(self: MSPyBentleyGeom.DgnConeDetail, range: MSPyBentleyGeom.DRange3d) -> bool
        
        Return range.
        
        2. GetRange(self: MSPyBentleyGeom.DgnConeDetail, range: MSPyBentleyGeom.DRange3d, transform: MSPyBentleyGeom.Transform) -> bool
        
        Return range.
        """
        ...
    
    def GetSilhouettes(*args, **kwargs):
        """
        GetSilhouettes(self: MSPyBentleyGeom.DgnConeDetail, segmentA: MSPyBentleyGeom.DSegment3d, segmentB: MSPyBentleyGeom.DSegment3d, viewToLocal: MSPyBentleyGeom.DMatrix4d) -> bool
        
        Return the rule lines which are silhouettes as viewed.
        
        Parameter ``[out]``:
        segmentA first silhouette line
        
        Parameter ``[out]``:
        segmentB second silhouette line
        
        Parameter ``[in]``:
        viewToLocal matrix that positions the cone for viewing along the z
        axis.
        """
        ...
    
    def GetTransforms(*args, **kwargs):
        """
        GetTransforms(self: MSPyBentleyGeom.DgnConeDetail, localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform, fractionRadii: bool = False) -> tuple
        
        Try to set up a nonsingular coordinate frame. Returns false if centerB
        is in base plane !!!!
        """
        ...
    
    def IntersectBoundedArc(*args, **kwargs):
        """
        IntersectBoundedArc(self: MSPyBentleyGeom.DgnConeDetail, arc: MSPyBentleyGeom.DEllipse3d, arcFractions: MSPyBentley.DoubleArray, normalizedConePoints: MSPyBentleyGeom.DPoint3dArray, localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform, boundedConeZ: bool) -> tuple
        """
        ...
    
    def IntersectCurveLocal(*args, **kwargs):
        """
        IntersectCurveLocal(self: MSPyBentleyGeom.DgnConeDetail, curve: MSPyBentleyGeom.ICurvePrimitive, curveFractions: MSPyBentley.DoubleArray, normalizedConePoints: MSPyBentleyGeom.DPoint3dArray, localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform, boundedConeZ: bool) -> tuple
        """
        ...
    
    def IsCircular(*args, **kwargs):
        """
        IsCircular(self: MSPyBentleyGeom.DgnConeDetail, centerA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, rotMatrix: MSPyBentleyGeom.RotMatrix) -> tuple
        
        Return true (with supporting data) if the cone is circular.
        """
        ...
    
    def IsClosedVolume(*args, **kwargs):
        """
        IsClosedVolume(self: MSPyBentleyGeom.DgnConeDetail) -> bool
        
        Test if this is a closed volume.
        """
        ...
    
    def IsCylinder(*args, **kwargs):
        """
        IsCylinder(self: MSPyBentleyGeom.DgnConeDetail, centerA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d) -> tuple
        
        Return true (with supporting data) if the cone is a (constant radius)
        cylinder.
        """
        ...
    
    def IsRealCap(*args, **kwargs):
        """
        IsRealCap(self: MSPyBentleyGeom.DgnConeDetail, select01: int) -> bool
        
        Test if caps are active and the indicated cap has nonzero radius.
        """
        ...
    
    def IsSameStructure(*args, **kwargs):
        """
        IsSameStructure(self: MSPyBentleyGeom.DgnConeDetail, other: Bentley.ISolidPrimitive) -> bool
        
        Test for same type and structure (but no coordinate comparison)
        """
        ...
    
    def IsSameStructureAndGeometry(*args, **kwargs):
        """
        IsSameStructureAndGeometry(self: MSPyBentleyGeom.DgnConeDetail, other: Bentley.ISolidPrimitive, tolerance: float) -> bool
        
        Test for same type, structure and coordinates.
        """
        ...
    
    def ParameterizationSign(*args, **kwargs):
        """
        ParameterizationSign(self: MSPyBentleyGeom.DgnConeDetail) -> float
        
        Return +1 or -1 that matches the volume sign after integration over
        the parameter space.
        """
        ...
    
    def SetDetailCoordinatesFromFractionalizedConeCoordinates(*args, **kwargs):
        """
        SetDetailCoordinatesFromFractionalizedConeCoordinates(detail: MSPyBentleyGeom.SolidLocationDetail, localuvw: MSPyBentleyGeom.DPoint3d, localToWorld: MSPyBentleyGeom.Transform, r0: float, r1: float) -> None
        
        set point, uv coordinates, and uv derivatives vectors
        """
        ...
    
    def SilhouetteCurves(*args, **kwargs):
        """
        SilhouetteCurves(self: MSPyBentleyGeom.DgnConeDetail, eyePoint: MSPyBentleyGeom.DPoint4d, curves: MSPyBentleyGeom.CurveVector) -> bool
        
        Return curves which are silhoutte curves OTHER than hard edges
        
        Returns:
        return false if not implemented. return true if implemented -- but
        curves may still be empty.
        """
        ...
    
    def TransformInPlace(*args, **kwargs):
        """
        TransformInPlace(self: MSPyBentleyGeom.DgnConeDetail, transform: MSPyBentleyGeom.Transform) -> bool
        
        Transform in place.
        """
        ...
    
    def TryGetConstructiveFrame(*args, **kwargs):
        """
        TryGetConstructiveFrame(self: MSPyBentleyGeom.DgnConeDetail, localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform) -> bool
        
        Return coordinate system with 1) XY plane of base circle, origin at
        center. 2) Z perpendicular
        """
        ...
    
    def TryGetMaxUVLength(*args, **kwargs):
        """
        TryGetMaxUVLength(self: MSPyBentleyGeom.DgnConeDetail, indices: Bentley.SolidLocationDetail.FaceIndices, uvLength: MSPyBentleyGeom.DVec2d) -> bool
        
        Compute the lengths of the longest u and v direction sections of a
        single face of a solid primitive.
        
        Parameter ``[in]``:
        indices selects face.
        
        Parameter ``[in]``:
        uvLength sizes in u, v directions.
        """
        ...
    
    def TryUVFractionToXYZ(*args, **kwargs):
        """
        TryUVFractionToXYZ(self: MSPyBentleyGeom.DgnConeDetail, faceIndices: Bentley.SolidLocationDetail.FaceIndices, uFraction: float, vFraction: float, xyz: MSPyBentleyGeom.DPoint3d, dXdu: MSPyBentleyGeom.DVec3d, dXdv: MSPyBentleyGeom.DVec3d) -> bool
        
        convert u,v fraction on specified face to xyz and derivatives.
        
        Parameter ``[in]``:
        faceIndices face selection indices
        
        Parameter ``[in]``:
        uFraction fractional coordinate in u direction.
        
        Parameter ``[in]``:
        vFraction fractional coordinate in v direction.
        
        Parameter ``[out]``:
        xyz point on face.
        
        Parameter ``[out]``:
        dXdu derivative of face point wrt uFraction.
        
        Parameter ``[out]``:
        dXdv derivative of face point wrt vFraction.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DgnConeDetail) -> None
        
        2. __init__(self: MSPyBentleyGeom.DgnConeDetail, centerA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, radiusA: float, radiusB: float, capped: bool) -> None
        
        3. __init__(self: MSPyBentleyGeom.DgnConeDetail, centerA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, axes: MSPyBentleyGeom.RotMatrix, radiusA: float, radiusB: float, capped: bool) -> None
        
        4. __init__(self: MSPyBentleyGeom.DgnConeDetail, centerA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, vectorX: MSPyBentleyGeom.DVec3d, vectorY: MSPyBentleyGeom.DVec3d, radiusA: float, radiusB: float, capped: bool) -> None
        """
        ...
    
class DgnExtrusionDetail:
    """
    None
    """

    def AddCurveIntersections(*args, **kwargs):
        """
        AddCurveIntersections(*args, **kwargs)
        Overloaded function.
        
        1. AddCurveIntersections(self: MSPyBentleyGeom.DgnExtrusionDetail, curves: MSPyBentleyGeom.CurveVector, curvePoints: MSPyBentleyGeom.CurveLocationDetailArray, solidPoints: MSPyBentleyGeom.SolidLocationDetailArray, messages: MSPyBentleyGeom.MeshAnnotationVector) -> None
        
        Compute intersections with curves and add to the data array.
        
        Parameter ``[in]``:
        curves
        
        Parameter ``[in,out]``:
        curvePoints growing array of curve points.
        
        Parameter ``[in,out]``:
        solidPoints growing array of solid points.
        
        Parameter ``[in,out]``:
        messages array of error messages
        
        2. AddCurveIntersections(self: MSPyBentleyGeom.DgnExtrusionDetail, curves: MSPyBentleyGeom.ICurvePrimitive, curvePoints: MSPyBentleyGeom.CurveLocationDetailArray, solidPoints: MSPyBentleyGeom.SolidLocationDetailArray, messages: MSPyBentleyGeom.MeshAnnotationVector) -> None
        
        Compute intersections with curves and add to the data array.
        
        Parameter ``[in]``:
        curves
        
        Parameter ``[in,out]``:
        curvePoints growing array of curve points.
        
        Parameter ``[in,out]``:
        solidPoints growing array of solid points.
        
        Parameter ``[in,out]``:
        messages array of error messages
        """
        ...
    
    def AddRayIntersections(*args, **kwargs):
        """
        AddRayIntersections(self: MSPyBentleyGeom.DgnExtrusionDetail, pickData: MSPyBentleyGeom.SolidLocationDetailArray, ray: MSPyBentleyGeom.DRay3d, parentId: int, minParameter: float) -> None
        
        Compute intersections with a ray and add to the pickData.
        
        Parameter ``[in]``:
        ray origin and direction
        
        Parameter ``[in]``:
        minParameter smallest parameter of pick. (e.g. 0 for picking along
        a positive ray from an eyepoint)
        
        Parameter ``[in,out]``:
        pickData growing array of picks.
        
        Parameter ``[in]``:
        parentId caller's id for this solid. Will be placed in each
        pickData entry has parentId.
        """
        ...
    
    def Clone(*args, **kwargs):
        """
        Clone(self: MSPyBentleyGeom.DgnExtrusionDetail) -> Bentley.ISolidPrimitive
        
        Copy to a new (allocated) solid primitive.
        """
        ...
    
    def ClosestPoint(*args, **kwargs):
        """
        ClosestPoint(self: MSPyBentleyGeom.DgnExtrusionDetail, spacePoint: MSPyBentleyGeom.DPoint3d, pickDetail: MSPyBentleyGeom.SolidLocationDetail) -> bool
        
        Parameter ``[in]``:
        spacePoint search for point close to here and on the solid surface
        
        Parameter ``[out]``:
        pickDetail closest point data.
        
        Returns:
        false if not supported.
        """
        ...
    
    def ComputeSecondMomentAreaProducts(*args, **kwargs):
        """
        ComputeSecondMomentAreaProducts(self: MSPyBentleyGeom.DgnExtrusionDetail, localToWorld: MSPyBentleyGeom.Transform, localProducts: MSPyBentleyGeom.DMatrix4d) -> bool
        
        Return the various integrated products for area moment calculations.
        The primitive is treated as a thin shell.
        
        Parameter ``[out]``:
        localToWorld transform from preferred system where the products
        are most easily computed to world.
        
        Parameter ``[out]``:
        localProducts integrated [xx xy xz x; xy yy yz y; xz yz zz z; x y
        z 1] dA
        
        Returns:
        false if unable to compute.
        """
        ...
    
    def ComputeSecondMomentVolumeProducts(*args, **kwargs):
        """
        ComputeSecondMomentVolumeProducts(self: MSPyBentleyGeom.DgnExtrusionDetail, localToWorld: MSPyBentleyGeom.Transform, localProducts: MSPyBentleyGeom.DMatrix4d) -> bool
        
        Return the various integrated products for moment calculations. The
        primitive is treated as a volume
        
        Parameter ``[out]``:
        localToWorld transform from preferred system where the products
        are most easily computed to world.
        
        Parameter ``[out]``:
        localProducts integrated [xx xy xz x; xy yy yz y; xz yz zz z; x y
        z 1] dA
        
        Returns:
        false if unable to compute.
        """
        ...
    
    def FractionToProfile(*args, **kwargs):
        """
        FractionToProfile(self: MSPyBentleyGeom.DgnExtrusionDetail, fraction: float) -> MSPyBentleyGeom.CurveVector
        
        Fractional profile curve
        """
        ...
    
    def GetConstantUSection(*args, **kwargs):
        """
        GetConstantUSection(self: MSPyBentleyGeom.DgnExtrusionDetail, indices: Bentley.SolidLocationDetail.FaceIndices, fraction: float) -> MSPyBentleyGeom.ICurvePrimitive
        
        Copy a section at constant u of a single face to a single
        ICurvePrimitive.
        
        Parameter ``[in]``:
        indices selects face
        
        Parameter ``[in]``:
        fraction u fraction for section curve
        """
        ...
    
    def GetConstantVSection(*args, **kwargs):
        """
        GetConstantVSection(self: MSPyBentleyGeom.DgnExtrusionDetail, indices: Bentley.SolidLocationDetail.FaceIndices, fraction: float) -> MSPyBentleyGeom.ICurvePrimitive
        
        Copy a section curve at constant v of a single face to a single
        ICurvePrimitive.
        
        Parameter ``[in]``:
        indices selects face
        
        Parameter ``[in]``:
        fraction v fraction for section curve
        """
        ...
    
    def GetFace(*args, **kwargs):
        """
        GetFace(self: MSPyBentleyGeom.DgnExtrusionDetail, indices: Bentley.SolidLocationDetail.FaceIndices) -> MSPyBentleyGeom.IGeometry
        
        Return a single face of the solid primitive
        
        Parameter ``indices``:
        integer selectors for the face.
        """
        ...
    
    def GetFaceIndices(*args, **kwargs):
        """
        GetFaceIndices(self: MSPyBentleyGeom.DgnExtrusionDetail, indices: MSPyBentleyGeom.FaceIndicesArray) -> None
        
        Fill a list of all possible face indices.
        
        Parameter ``[out]``:
        indices array of selectors for the faces.
        """
        ...
    
    def GetRange(*args, **kwargs):
        """
        GetRange(*args, **kwargs)
        Overloaded function.
        
        1. GetRange(self: MSPyBentleyGeom.DgnExtrusionDetail, range: MSPyBentleyGeom.DRange3d) -> bool
        
        Return range.
        
        2. GetRange(self: MSPyBentleyGeom.DgnExtrusionDetail, range: MSPyBentleyGeom.DRange3d, transform: MSPyBentleyGeom.Transform) -> bool
        
        Return range.
        """
        ...
    
    def IsClosedVolume(*args, **kwargs):
        """
        IsClosedVolume(self: MSPyBentleyGeom.DgnExtrusionDetail) -> bool
        
        Test if this is a closed volume.
        """
        ...
    
    def IsSameStructure(*args, **kwargs):
        """
        IsSameStructure(self: MSPyBentleyGeom.DgnExtrusionDetail, other: Bentley.ISolidPrimitive) -> bool
        
        Test for same type and structure (but no coordinate comparison)
        """
        ...
    
    def IsSameStructureAndGeometry(*args, **kwargs):
        """
        IsSameStructureAndGeometry(self: MSPyBentleyGeom.DgnExtrusionDetail, other: Bentley.ISolidPrimitive, tolerance: float) -> bool
        
        Test for same type, structure and coordinates.
        """
        ...
    
    def SilhouetteCurves(*args, **kwargs):
        """
        SilhouetteCurves(self: MSPyBentleyGeom.DgnExtrusionDetail, eyePoint: MSPyBentleyGeom.DPoint4d, curves: MSPyBentleyGeom.CurveVector) -> bool
        
        Return curves which are silhoutte curves OTHER than hard edges
        
        Returns:
        return false if not implemented. return true if implemented -- but
        curves may still be empty.
        """
        ...
    
    def TransformInPlace(*args, **kwargs):
        """
        TransformInPlace(self: MSPyBentleyGeom.DgnExtrusionDetail, transform: MSPyBentleyGeom.Transform) -> bool
        
        Transform in place.
        """
        ...
    
    def TryGetConstructiveFrame(*args, **kwargs):
        """
        TryGetConstructiveFrame(self: MSPyBentleyGeom.DgnExtrusionDetail, localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform) -> bool
        
        Return coordinate system based on any frenet frame for base curve
        vector, with yz reversed if necessary to make z sense match exgtusion
        vector.
        """
        ...
    
    def TryGetExtrusionFrame(*args, **kwargs):
        """
        TryGetExtrusionFrame(self: MSPyBentleyGeom.DgnExtrusionDetail, localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform) -> bool
        
        Compute coordinate frames aligned with the extrusion vector.
        
        Parameter ``[out]``:
        localToWorld transform with orign at first point of base curve, z
        vector along extrusion direction, xy vectors arbitrary
        perpendiculars.
        
        Parameter ``[out]``:
        worldToLocal inverse of local to world
        """
        ...
    
    def TryGetMaxUVLength(*args, **kwargs):
        """
        TryGetMaxUVLength(self: MSPyBentleyGeom.DgnExtrusionDetail, indices: Bentley.SolidLocationDetail.FaceIndices, uvLength: MSPyBentleyGeom.DVec2d) -> bool
        
        Compute the lengths of the longest u and v direction sections of a
        single face of a solid primitive.
        
        Parameter ``[in]``:
        indices selects face.
        
        Parameter ``[in]``:
        uvLength sizes in u, v directions.
        """
        ...
    
    def TryUVFractionToXYZ(*args, **kwargs):
        """
        TryUVFractionToXYZ(self: MSPyBentleyGeom.DgnExtrusionDetail, faceIndices: Bentley.SolidLocationDetail.FaceIndices, uFraction: float, vFraction: float, xyz: MSPyBentleyGeom.DPoint3d, dXdu: MSPyBentleyGeom.DVec3d, dXdv: MSPyBentleyGeom.DVec3d) -> bool
        
        convert u,v fraction on specified face to xyz and derivatives.
        
        Parameter ``[in]``:
        faceIndices face selection indices
        
        Parameter ``[in]``:
        uFraction fractional coordinate in u direction.
        
        Parameter ``[in]``:
        vFraction fractional coordinate in v direction.
        
        Parameter ``[out]``:
        xyz point on face.
        
        Parameter ``[out]``:
        dXdu derivative of face point wrt uFraction.
        
        Parameter ``[out]``:
        dXdv derivative of face point wrt vFraction.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DgnExtrusionDetail) -> None
        
        2. __init__(self: MSPyBentleyGeom.DgnExtrusionDetail, baseCurve: MSPyBentleyGeom.CurveVector, extrusionVector: MSPyBentleyGeom.DVec3d, capped: bool) -> None
        """
        ...
    
class DgnRotationalSweepDetail:
    """
    None
    """

    def AddCurveIntersections(*args, **kwargs):
        """
        AddCurveIntersections(*args, **kwargs)
        Overloaded function.
        
        1. AddCurveIntersections(self: MSPyBentleyGeom.DgnRotationalSweepDetail, curves: MSPyBentleyGeom.CurveVector, curvePoints: MSPyBentleyGeom.CurveLocationDetailArray, solidPoints: MSPyBentleyGeom.SolidLocationDetailArray, messages: MSPyBentleyGeom.MeshAnnotationVector) -> None
        
        Compute intersections with curves and add to the data array.
        
        Parameter ``[in]``:
        curves
        
        Parameter ``[in,out]``:
        curvePoints growing array of curve points.
        
        Parameter ``[in,out]``:
        solidPoints growing array of solid points.
        
        Parameter ``[in,out]``:
        messages array of error messages
        
        2. AddCurveIntersections(self: MSPyBentleyGeom.DgnRotationalSweepDetail, curves: MSPyBentleyGeom.ICurvePrimitive, curvePoints: MSPyBentleyGeom.CurveLocationDetailArray, solidPoints: MSPyBentleyGeom.SolidLocationDetailArray, messages: MSPyBentleyGeom.MeshAnnotationVector) -> None
        
        Compute intersections with curves and add to the data array.
        
        Parameter ``[in]``:
        curves
        
        Parameter ``[in,out]``:
        curvePoints growing array of curve points.
        
        Parameter ``[in,out]``:
        solidPoints growing array of solid points.
        
        Parameter ``[in,out]``:
        messages array of error messages
        """
        ...
    
    def AddRayIntersections(*args, **kwargs):
        """
        AddRayIntersections(self: MSPyBentleyGeom.DgnRotationalSweepDetail, pickData: MSPyBentleyGeom.SolidLocationDetailArray, ray: MSPyBentleyGeom.DRay3d, parentId: int, minParameter: float) -> None
        
        Compute intersections with a ray and add to the pickData.
        
        Parameter ``[in]``:
        ray origin and direction
        
        Parameter ``[in]``:
        minParameter smallest parameter of pick. (e.g. 0 for picking along
        a positive ray from an eyepoint)
        
        Parameter ``[in,out]``:
        pickData growing array of picks.
        
        Parameter ``[in]``:
        parentId caller's id for this solid. Will be placed in each
        pickData entry has parentId.
        """
        ...
    
    def Clone(*args, **kwargs):
        """
        Clone(self: MSPyBentleyGeom.DgnRotationalSweepDetail) -> Bentley.ISolidPrimitive
        
        Copy to a new (allocated) solid primitive.
        """
        ...
    
    def ClosestPoint(*args, **kwargs):
        """
        ClosestPoint(self: MSPyBentleyGeom.DgnRotationalSweepDetail, spacePoint: MSPyBentleyGeom.DPoint3d, pickDetail: MSPyBentleyGeom.SolidLocationDetail) -> bool
        
        Parameter ``[in]``:
        spacePoint search for point close to here and on the solid surface
        
        Parameter ``[out]``:
        pickDetail closest point data.
        
        Returns:
        false if not supported.
        """
        ...
    
    def ComputeSecondMomentAreaProducts(*args, **kwargs):
        """
        ComputeSecondMomentAreaProducts(self: MSPyBentleyGeom.DgnRotationalSweepDetail, localToWorld: MSPyBentleyGeom.Transform, localProducts: MSPyBentleyGeom.DMatrix4d) -> bool
        
        Return the various integrated products for area moment calculations.
        The primitive is treated as a thin shell.
        
        Parameter ``[out]``:
        localToWorld transform from preferred system where the products
        are most easily computed to world.
        
        Parameter ``[out]``:
        localProducts integrated [xx xy xz x; xy yy yz y; xz yz zz z; x y
        z 1] dA
        
        Returns:
        false if unable to compute.
        """
        ...
    
    def ComputeSecondMomentVolumeProducts(*args, **kwargs):
        """
        ComputeSecondMomentVolumeProducts(self: MSPyBentleyGeom.DgnRotationalSweepDetail, localToWorld: MSPyBentleyGeom.Transform, localProducts: MSPyBentleyGeom.DMatrix4d) -> bool
        
        Return the various integrated products for moment calculations. The
        primitive is treated as a volume
        
        Parameter ``[out]``:
        localToWorld transform from preferred system where the products
        are most easily computed to world.
        
        Parameter ``[out]``:
        localProducts integrated [xx xy xz x; xy yy yz y; xz yz zz z; x y
        z 1] dA
        
        Returns:
        false if unable to compute.
        """
        ...
    
    def ComputeVRuleCount(*args, **kwargs):
        """
        ComputeVRuleCount(sweepRadians: float, numVRulesFullSweep: int = 4) -> int
        
        Compute v rule count for a given sweep angle and desired number of v
        rules for a full sweep.
        """
        ...
    
    def GetConstantUSection(*args, **kwargs):
        """
        GetConstantUSection(self: MSPyBentleyGeom.DgnRotationalSweepDetail, indices: Bentley.SolidLocationDetail.FaceIndices, fraction: float) -> MSPyBentleyGeom.ICurvePrimitive
        
        Copy a section at constant u of a single face to a single
        ICurvePrimitive.
        
        Parameter ``[in]``:
        indices selects face
        
        Parameter ``[in]``:
        fraction u fraction for section curve
        """
        ...
    
    def GetConstantVSection(*args, **kwargs):
        """
        GetConstantVSection(self: MSPyBentleyGeom.DgnRotationalSweepDetail, indices: Bentley.SolidLocationDetail.FaceIndices, fraction: float) -> MSPyBentleyGeom.ICurvePrimitive
        
        Copy a section curve at constant v of a single face to a single
        ICurvePrimitive.
        
        Parameter ``[in]``:
        indices selects face
        
        Parameter ``[in]``:
        fraction v fraction for section curve
        """
        ...
    
    def GetFace(*args, **kwargs):
        """
        GetFace(self: MSPyBentleyGeom.DgnRotationalSweepDetail, indices: Bentley.SolidLocationDetail.FaceIndices) -> MSPyBentleyGeom.IGeometry
        
        Return a single face of the solid primitive
        
        Parameter ``indices``:
        integer selectors for the face.
        """
        ...
    
    def GetFaceIndices(*args, **kwargs):
        """
        GetFaceIndices(self: MSPyBentleyGeom.DgnRotationalSweepDetail, indices: MSPyBentleyGeom.FaceIndicesArray) -> None
        
        Fill a list of all possible face indices.
        
        Parameter ``[out]``:
        indices array of selectors for the faces.
        """
        ...
    
    def GetRadius(*args, **kwargs):
        """
        GetRadius(self: MSPyBentleyGeom.DgnRotationalSweepDetail, type: MSPyBentleyGeom.DgnRotationalSweepDetail.RadiusType) -> tuple
        
        Return the radius
        
        Parameter ``[out]``:
        radius
        
        Parameter ``[in]``:
        type of radius.
        """
        ...
    
    def GetRange(*args, **kwargs):
        """
        GetRange(*args, **kwargs)
        Overloaded function.
        
        1. GetRange(self: MSPyBentleyGeom.DgnRotationalSweepDetail, range: MSPyBentleyGeom.DRange3d) -> bool
        
        Return range.
        
        2. GetRange(self: MSPyBentleyGeom.DgnRotationalSweepDetail, range: MSPyBentleyGeom.DRange3d, transform: MSPyBentleyGeom.Transform) -> bool
        
        Return range.
        """
        ...
    
    def GetTransforms(*args, **kwargs):
        """
        GetTransforms(self: MSPyBentleyGeom.DgnRotationalSweepDetail, localTransform: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform) -> bool
        
        return transforms for the coordinate frame with z axis on the line of
        rotation.
        
        Parameter ``[out]``:
        localToWorld translation part is is a point on the axis; z
        direction is the rotation axis.
        
        Parameter ``[out]``:
        worldToLocal inverse transform.
        """
        ...
    
    def GetVFractionTransform(*args, **kwargs):
        """
        GetVFractionTransform(self: MSPyBentleyGeom.DgnRotationalSweepDetail, vFraction: float, transform: MSPyBentleyGeom.Transform, derivativeTransform: MSPyBentleyGeom.Transform) -> bool
        
        Get transform from base cap to fractional v position.
        
        Parameter ``[out]``:
        transform transform to rotate a point.
        
        Parameter ``[out]``:
        derivativeTransform Derivative with respect to vFraction. The
        output of derivativeTransform * xyz is a vector, not a point !!!
        (If viewed as a 4x4 matrix, its ww entry is zero)
        
        Parameter ``[in]``:
        vFraction fraction of sweep angle.
        """
        ...
    
    def GetVRuledCount(*args, **kwargs):
        """
        GetVRuledCount(self: MSPyBentleyGeom.DgnRotationalSweepDetail) -> int
        """
        ...
    
    def HasRealCaps(*args, **kwargs):
        """
        HasRealCaps(self: MSPyBentleyGeom.DgnRotationalSweepDetail) -> bool
        
        Return true if capped and incomplete sweep.
        """
        ...
    
    def IsClosedVolume(*args, **kwargs):
        """
        IsClosedVolume(self: MSPyBentleyGeom.DgnRotationalSweepDetail) -> bool
        
        Test if this is a closed volume.
        """
        ...
    
    def IsSameStructure(*args, **kwargs):
        """
        IsSameStructure(self: MSPyBentleyGeom.DgnRotationalSweepDetail, other: Bentley.ISolidPrimitive) -> bool
        
        Test for same type and structure (but no coordinate comparison)
        """
        ...
    
    def IsSameStructureAndGeometry(*args, **kwargs):
        """
        IsSameStructureAndGeometry(self: MSPyBentleyGeom.DgnRotationalSweepDetail, other: Bentley.ISolidPrimitive, tolerance: float) -> bool
        
        Test for same type, structure and coordinates.
        """
        ...
    
    class RadiusType:
        """
        Members:
        
        eMinimum
        
        eMaximum
        
        eCentroidal
        """
    
        def __init__(self: MSPyBentleyGeom.DgnRotationalSweepDetail.RadiusType, value: int) -> None:
            ...
        
        eCentroidal: RadiusType
        
        eMaximum: RadiusType
        
        eMinimum: RadiusType
        
        @property
        def name(self: handle) -> str:
            ...
        
        @property
        def value(arg0: MSPyBentleyGeom.DgnRotationalSweepDetail.RadiusType) -> int:
            ...
        
    def SetRadius(*args, **kwargs):
        """
        SetRadius(self: MSPyBentleyGeom.DgnRotationalSweepDetail, radius: float, type: MSPyBentleyGeom.DgnRotationalSweepDetail.RadiusType) -> bool
        
        Parameter ``[in]``:
        radius
        
        Parameter ``[in]``:
        type of radius.
        """
        ...
    
    def SetVRuledCount(*args, **kwargs):
        """
        SetVRuledCount(self: MSPyBentleyGeom.DgnRotationalSweepDetail, numVRules: int) -> None
        """
        ...
    
    def SilhouetteCurves(*args, **kwargs):
        """
        SilhouetteCurves(self: MSPyBentleyGeom.DgnRotationalSweepDetail, eyePoint: MSPyBentleyGeom.DPoint4d, curves: MSPyBentleyGeom.CurveVector) -> bool
        
        Return curves which are silhoutte curves OTHER than hard edges
        
        Returns:
        return false if not implemented. return true if implemented -- but
        curves may still be empty.
        """
        ...
    
    def TransformInPlace(*args, **kwargs):
        """
        TransformInPlace(self: MSPyBentleyGeom.DgnRotationalSweepDetail, transform: MSPyBentleyGeom.Transform) -> bool
        
        Transform in place.
        """
        ...
    
    def TryGetConstructiveFrame(*args, **kwargs):
        """
        TryGetConstructiveFrame(self: MSPyBentleyGeom.DgnRotationalSweepDetail, localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform) -> bool
        
        Return coordinate system of 1) Z axis along rotation 2) X towards base
        curve extreme point.
        """
        ...
    
    def TryGetMaxUVLength(*args, **kwargs):
        """
        TryGetMaxUVLength(self: MSPyBentleyGeom.DgnRotationalSweepDetail, indices: Bentley.SolidLocationDetail.FaceIndices, uvLength: MSPyBentleyGeom.DVec2d) -> bool
        
        Compute the lengths of the longest u and v direction sections of a
        single face of a solid primitive.
        
        Parameter ``[in]``:
        indices selects face.
        
        Parameter ``[in]``:
        uvLength sizes in u, v directions.
        """
        ...
    
    def TryGetRotationAxis(*args, **kwargs):
        """
        TryGetRotationAxis(self: MSPyBentleyGeom.DgnRotationalSweepDetail, center: MSPyBentleyGeom.DPoint3d, axis: MSPyBentleyGeom.DVec3d) -> tuple
        
        Get the axis of rotation, negated if necessary to force a positive
        sweep angle.
        
        Parameter ``center``:
        OUT center of rotation.
        
        Parameter ``axis``:
        OUT axis of rotation.
        
        Parameter ``sweepRadians``:
        OUT angle of rotation.
        """
        ...
    
    def TryUVFractionToXYZ(*args, **kwargs):
        """
        TryUVFractionToXYZ(self: MSPyBentleyGeom.DgnRotationalSweepDetail, faceIndices: Bentley.SolidLocationDetail.FaceIndices, uFraction: float, vFraction: float, xyz: MSPyBentleyGeom.DPoint3d, dXdu: MSPyBentleyGeom.DVec3d, dXdv: MSPyBentleyGeom.DVec3d) -> bool
        
        convert u,v fraction on specified face to xyz and derivatives.
        
        Parameter ``[in]``:
        faceIndices face selection indices
        
        Parameter ``[in]``:
        uFraction fractional coordinate in u direction.
        
        Parameter ``[in]``:
        vFraction fractional coordinate in v direction.
        
        Parameter ``[out]``:
        xyz point on face.
        
        Parameter ``[out]``:
        dXdu derivative of face point wrt uFraction.
        
        Parameter ``[out]``:
        dXdv derivative of face point wrt vFraction.
        """
        ...
    
    def VFractionToProfile(*args, **kwargs):
        """
        VFractionToProfile(self: MSPyBentleyGeom.DgnRotationalSweepDetail, fraction: float) -> MSPyBentleyGeom.CurveVector
        
        Fractional profile curve
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DgnRotationalSweepDetail) -> None
        
        2. __init__(self: MSPyBentleyGeom.DgnRotationalSweepDetail, baseCurve: MSPyBentleyGeom.CurveVector, center: MSPyBentleyGeom.DPoint3d, axis: MSPyBentleyGeom.DVec3d, sweepAngle: float, capped: bool) -> None
        """
        ...
    
    eCentroidal: RadiusType
    
    eMaximum: RadiusType
    
    eMinimum: RadiusType
    
class DgnRuledSweepDetail:
    """
    None
    """

    def AddCurveIntersections(*args, **kwargs):
        """
        AddCurveIntersections(*args, **kwargs)
        Overloaded function.
        
        1. AddCurveIntersections(self: MSPyBentleyGeom.DgnRuledSweepDetail, curves: MSPyBentleyGeom.CurveVector, curvePoints: MSPyBentleyGeom.CurveLocationDetailArray, solidPoints: MSPyBentleyGeom.SolidLocationDetailArray, messages: MSPyBentleyGeom.MeshAnnotationVector) -> None
        
        Compute intersections with curves and add to the data array.
        
        Parameter ``[in]``:
        curves
        
        Parameter ``[in,out]``:
        curvePoints growing array of curve points.
        
        Parameter ``[in,out]``:
        solidPoints growing array of solid points.
        
        Parameter ``[in,out]``:
        messages array of error messages
        
        2. AddCurveIntersections(self: MSPyBentleyGeom.DgnRuledSweepDetail, curves: MSPyBentleyGeom.ICurvePrimitive, curvePoints: MSPyBentleyGeom.CurveLocationDetailArray, solidPoints: MSPyBentleyGeom.SolidLocationDetailArray, messages: MSPyBentleyGeom.MeshAnnotationVector) -> None
        
        Compute intersections with curves and add to the data array.
        
        Parameter ``[in]``:
        curves
        
        Parameter ``[in,out]``:
        curvePoints growing array of curve points.
        
        Parameter ``[in,out]``:
        solidPoints growing array of solid points.
        
        Parameter ``[in,out]``:
        messages array of error messages
        """
        ...
    
    def AddRayIntersections(*args, **kwargs):
        """
        AddRayIntersections(self: MSPyBentleyGeom.DgnRuledSweepDetail, pickData: MSPyBentleyGeom.SolidLocationDetailArray, ray: MSPyBentleyGeom.DRay3d, parentId: int, minParameter: float) -> None
        
        Compute intersections with a ray and add to the pickData.
        
        Parameter ``[in]``:
        ray origin and direction
        
        Parameter ``[in]``:
        minParameter smallest parameter of pick. (e.g. 0 for picking along
        a positive ray from an eyepoint)
        
        Parameter ``[in,out]``:
        pickData growing array of picks.
        
        Parameter ``[in]``:
        parentId caller's id for this solid. Will be placed in each
        pickData entry has parentId.
        """
        ...
    
    def AddSection(*args, **kwargs):
        """
        AddSection(self: MSPyBentleyGeom.DgnRuledSweepDetail, section: MSPyBentleyGeom.CurveVector) -> None
        
        Add (capture) a section.
        """
        ...
    
    def Clone(*args, **kwargs):
        """
        Clone(self: MSPyBentleyGeom.DgnRuledSweepDetail) -> Bentley.ISolidPrimitive
        
        Copy to a new (allocated) solid primitive.
        """
        ...
    
    def ClosestPoint(*args, **kwargs):
        """
        ClosestPoint(self: MSPyBentleyGeom.DgnRuledSweepDetail, spacePoint: MSPyBentleyGeom.DPoint3d, pickDetail: MSPyBentleyGeom.SolidLocationDetail) -> bool
        
        Parameter ``[in]``:
        spacePoint search for point close to here and on the solid surface
        
        Parameter ``[out]``:
        pickDetail closest point data.
        
        Returns:
        false if not supported.
        """
        ...
    
    def ComputeSecondMomentAreaProducts(*args, **kwargs):
        """
        ComputeSecondMomentAreaProducts(self: MSPyBentleyGeom.DgnRuledSweepDetail, localToWorld: MSPyBentleyGeom.Transform, localProducts: MSPyBentleyGeom.DMatrix4d) -> bool
        
        Return the various integrated products for area moment calculations.
        The primitive is treated as a thin shell.
        
        Parameter ``[out]``:
        localToWorld transform from preferred system where the products
        are most easily computed to world.
        
        Parameter ``[out]``:
        localProducts integrated [xx xy xz x; xy yy yz y; xz yz zz z; x y
        z 1] dA
        
        Returns:
        false if unable to compute.
        """
        ...
    
    def ComputeSecondMomentVolumeProducts(*args, **kwargs):
        """
        ComputeSecondMomentVolumeProducts(self: MSPyBentleyGeom.DgnRuledSweepDetail, localToWorld: MSPyBentleyGeom.Transform, localProducts: MSPyBentleyGeom.DMatrix4d) -> bool
        
        Return the various integrated products for moment calculations. The
        primitive is treated as a volume
        
        Parameter ``[out]``:
        localToWorld transform from preferred system where the products
        are most easily computed to world.
        
        Parameter ``[out]``:
        localProducts integrated [xx xy xz x; xy yy yz y; xz yz zz z; x y
        z 1] dA
        
        Returns:
        false if unable to compute.
        """
        ...
    
    def GetConstantUSection(*args, **kwargs):
        """
        GetConstantUSection(self: MSPyBentleyGeom.DgnRuledSweepDetail, indices: Bentley.SolidLocationDetail.FaceIndices, fraction: float) -> MSPyBentleyGeom.ICurvePrimitive
        
        Copy a section at constant u of a single face to a single
        ICurvePrimitive.
        
        Parameter ``[in]``:
        indices selects face
        
        Parameter ``[in]``:
        fraction u fraction for section curve
        """
        ...
    
    def GetConstantVSection(*args, **kwargs):
        """
        GetConstantVSection(self: MSPyBentleyGeom.DgnRuledSweepDetail, indices: Bentley.SolidLocationDetail.FaceIndices, fraction: float) -> MSPyBentleyGeom.ICurvePrimitive
        
        Copy a section curve at constant v of a single face to a single
        ICurvePrimitive.
        
        Parameter ``[in]``:
        indices selects face
        
        Parameter ``[in]``:
        fraction v fraction for section curve
        """
        ...
    
    def GetFace(*args, **kwargs):
        """
        GetFace(self: MSPyBentleyGeom.DgnRuledSweepDetail, indices: Bentley.SolidLocationDetail.FaceIndices) -> MSPyBentleyGeom.IGeometry
        
        Return a single face of the solid primitive
        
        Parameter ``indices``:
        integer selectors for the face. <remarks>Face orientation
        convention pre> ul> li>There is a natural " forward " direction
        along section curves. li>There is a natural " direction " to the
        (swept) side faces. (e.g. extrusion vector, positive rotation,
        rule line direction) li>The cross product of the curve direction
        and sweep direction is the outward normal for side faces. li>Hence
        base section is REVERSED when used for the Cap0 face. li>Hence the
        base section is NOT reversed when used for the Cap1 face. ul> pre>
        remarks>
        """
        ...
    
    def GetFaceIndices(*args, **kwargs):
        """
        GetFaceIndices(self: MSPyBentleyGeom.DgnRuledSweepDetail, indices: MSPyBentleyGeom.FaceIndicesArray) -> None
        
        Fill a list of all possible face indices.
        
        Parameter ``[out]``:
        indices array of selectors for the faces.
        """
        ...
    
    def GetRange(*args, **kwargs):
        """
        GetRange(*args, **kwargs)
        Overloaded function.
        
        1. GetRange(self: MSPyBentleyGeom.DgnRuledSweepDetail, range: MSPyBentleyGeom.DRange3d) -> bool
        
        Return range.
        
        2. GetRange(self: MSPyBentleyGeom.DgnRuledSweepDetail, range: MSPyBentleyGeom.DRange3d, transform: MSPyBentleyGeom.Transform) -> bool
        
        Return range.
        """
        ...
    
    def IsClosedVolume(*args, **kwargs):
        """
        IsClosedVolume(self: MSPyBentleyGeom.DgnRuledSweepDetail) -> bool
        
        Test if this is a closed volume.
        """
        ...
    
    def IsSameStructure(*args, **kwargs):
        """
        IsSameStructure(self: MSPyBentleyGeom.DgnRuledSweepDetail, other: Bentley.ISolidPrimitive) -> bool
        
        Test for same type and structure (but no coordinate comparison)
        """
        ...
    
    def IsSameStructureAndGeometry(*args, **kwargs):
        """
        IsSameStructureAndGeometry(self: MSPyBentleyGeom.DgnRuledSweepDetail, other: Bentley.ISolidPrimitive, tolerance: float) -> bool
        
        Test for same type, structure and coordinates.
        """
        ...
    
    def SilhouetteCurves(*args, **kwargs):
        """
        SilhouetteCurves(self: MSPyBentleyGeom.DgnRuledSweepDetail, eyePoint: MSPyBentleyGeom.DPoint4d, curves: MSPyBentleyGeom.CurveVector) -> bool
        
        Return curves which are silhoutte curves OTHER than hard edges
        
        Returns:
        return false if not implemented. return true if implemented -- but
        curves may still be empty.
        """
        ...
    
    def TransformInPlace(*args, **kwargs):
        """
        TransformInPlace(self: MSPyBentleyGeom.DgnRuledSweepDetail, transform: MSPyBentleyGeom.Transform) -> bool
        
        Transform in place.
        """
        ...
    
    def TryGetConstructiveFrame(*args, **kwargs):
        """
        TryGetConstructiveFrame(self: MSPyBentleyGeom.DgnRuledSweepDetail, localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform) -> bool
        
        Return coordinate system (LOCAL_COORDINATES_UnitAxesAtStart) for base
        curve vector.
        """
        ...
    
    def TryGetCurvePair(*args, **kwargs):
        """
        TryGetCurvePair(self: MSPyBentleyGeom.DgnRuledSweepDetail, indices: Bentley.SolidLocationDetail.FaceIndices, curveA: MSPyBentleyGeom.ICurvePrimitive, curveB: MSPyBentleyGeom.ICurvePrimitive) -> bool
        
        Get the lower and upper curves of a specified face.
        
        Parameter ``[in]``:
        indices face indices
        
        Parameter ``[out]``:
        curveA lower curve of face
        
        Parameter ``[out]``:
        curveB upper curve of face
        
        Returns:
        false if indices is not a valid ruled face. (Caps return false)
        """
        ...
    
    def TryGetMaxUVLength(*args, **kwargs):
        """
        TryGetMaxUVLength(self: MSPyBentleyGeom.DgnRuledSweepDetail, indices: Bentley.SolidLocationDetail.FaceIndices, uvLength: MSPyBentleyGeom.DVec2d) -> bool
        
        Compute the lengths of the longest u and v direction sections of a
        single face of a solid primitive.
        
        Parameter ``[in]``:
        indices selects face.
        
        Parameter ``[in]``:
        uvLength sizes in u, v directions.
        """
        ...
    
    def TryUVFractionToXYZ(*args, **kwargs):
        """
        TryUVFractionToXYZ(self: MSPyBentleyGeom.DgnRuledSweepDetail, faceIndices: Bentley.SolidLocationDetail.FaceIndices, uFraction: float, vFraction: float, xyz: MSPyBentleyGeom.DPoint3d, dXdu: MSPyBentleyGeom.DVec3d, dXdv: MSPyBentleyGeom.DVec3d) -> bool
        
        convert u,v fraction on specified face to xyz and derivatives.
        
        Parameter ``[in]``:
        faceIndices face selection indices
        
        Parameter ``[in]``:
        uFraction fractional coordinate in u direction.
        
        Parameter ``[in]``:
        vFraction fractional coordinate in v direction.
        
        Parameter ``[out]``:
        xyz point on face.
        
        Parameter ``[out]``:
        dXdu derivative of face point wrt uFraction.
        
        Parameter ``[out]``:
        dXdv derivative of face point wrt vFraction.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DgnRuledSweepDetail, sectionCurves: MSPyBentleyGeom.CurveVectorPtrArray, capped: bool) -> None
        
        2. __init__(self: MSPyBentleyGeom.DgnRuledSweepDetail, sectionA: MSPyBentleyGeom.CurveVector, sectionB: MSPyBentleyGeom.CurveVector, capped: bool) -> None
        
        3. __init__(self: MSPyBentleyGeom.DgnRuledSweepDetail) -> None
        """
        ...
    
class DgnSphereDetail:
    """
    None
    """

    def AddCurveIntersections(*args, **kwargs):
        """
        AddCurveIntersections(*args, **kwargs)
        Overloaded function.
        
        1. AddCurveIntersections(self: MSPyBentleyGeom.DgnSphereDetail, curves: MSPyBentleyGeom.CurveVector, curvePoints: MSPyBentleyGeom.CurveLocationDetailArray, solidPoints: MSPyBentleyGeom.SolidLocationDetailArray, messages: MSPyBentleyGeom.MeshAnnotationVector) -> None
        
        Compute intersections with curves and add to the data array.
        
        Parameter ``[in]``:
        curves
        
        Parameter ``[in,out]``:
        curvePoints growing array of curve points.
        
        Parameter ``[in,out]``:
        solidPoints growing array of solid points.
        
        Parameter ``[in,out]``:
        messages array of error messages
        
        2. AddCurveIntersections(self: MSPyBentleyGeom.DgnSphereDetail, curves: MSPyBentleyGeom.ICurvePrimitive, curvePoints: MSPyBentleyGeom.CurveLocationDetailArray, solidPoints: MSPyBentleyGeom.SolidLocationDetailArray, messages: MSPyBentleyGeom.MeshAnnotationVector) -> None
        
        Compute intersections with curves and add to the data array.
        
        Parameter ``[in]``:
        curves
        
        Parameter ``[in,out]``:
        curvePoints growing array of curve points.
        
        Parameter ``[in,out]``:
        solidPoints growing array of solid points.
        
        Parameter ``[in,out]``:
        messages array of error messages
        """
        ...
    
    def AddRayIntersections(*args, **kwargs):
        """
        AddRayIntersections(self: MSPyBentleyGeom.DgnSphereDetail, pickData: MSPyBentleyGeom.SolidLocationDetailArray, ray: MSPyBentleyGeom.DRay3d, parentId: int, minParameter: float) -> None
        
        Compute intersections with a ray and add to the pickData.
        
        Parameter ``[in]``:
        ray origin and direction
        
        Parameter ``[in]``:
        minParameter smallest parameter of pick. (e.g. 0 for picking along
        a positive ray from an eyepoint)
        
        Parameter ``[in,out]``:
        pickData growing array of picks.
        
        Parameter ``[in]``:
        parentId caller's id for this solid. Will be placed in each
        pickData entry has parentId.
        """
        ...
    
    def Clone(*args, **kwargs):
        """
        Clone(self: MSPyBentleyGeom.DgnSphereDetail) -> Bentley.ISolidPrimitive
        
        Copy to a new (allocated) solid primitive.
        """
        ...
    
    def ClosestPoint(*args, **kwargs):
        """
        ClosestPoint(self: MSPyBentleyGeom.DgnSphereDetail, spacePoint: MSPyBentleyGeom.DPoint3d, pickDetail: MSPyBentleyGeom.SolidLocationDetail) -> bool
        
        Parameter ``[in]``:
        spacePoint search for point close to here and on the solid surface
        
        Parameter ``[out]``:
        pickDetail closest point data.
        
        Returns:
        false if not supported.
        """
        ...
    
    def ComputeSecondMomentAreaProducts(*args, **kwargs):
        """
        ComputeSecondMomentAreaProducts(self: MSPyBentleyGeom.DgnSphereDetail, localToWorld: MSPyBentleyGeom.Transform, localProducts: MSPyBentleyGeom.DMatrix4d) -> bool
        
        Return the various integrated products for area moment calculations.
        The primitive is treated as a thin shell.
        
        Parameter ``[out]``:
        localToWorld transform from preferred system where the products
        are most easily computed to world.
        
        Parameter ``[out]``:
        localProducts integrated [xx xy xz x; xy yy yz y; xz yz zz z; x y
        z 1] dA
        
        Returns:
        false if unable to compute.
        """
        ...
    
    def ComputeSecondMomentVolumeProducts(*args, **kwargs):
        """
        ComputeSecondMomentVolumeProducts(self: MSPyBentleyGeom.DgnSphereDetail, localToWorld: MSPyBentleyGeom.Transform, localProducts: MSPyBentleyGeom.DMatrix4d) -> bool
        
        Return the various integrated products for moment calculations. The
        primitive is treated as a volume
        
        Parameter ``[out]``:
        localToWorld transform from preferred system where the products
        are most easily computed to world.
        
        Parameter ``[out]``:
        localProducts integrated [xx xy xz x; xy yy yz y; xz yz zz z; x y
        z 1] dA
        
        Returns:
        false if unable to compute.
        """
        ...
    
    def GetConstantUSection(*args, **kwargs):
        """
        GetConstantUSection(self: MSPyBentleyGeom.DgnSphereDetail, indices: Bentley.SolidLocationDetail.FaceIndices, fraction: float) -> MSPyBentleyGeom.ICurvePrimitive
        
        Copy a section at constant u of a single face to a single
        ICurvePrimitive.
        
        Parameter ``[in]``:
        indices selects face
        
        Parameter ``[in]``:
        fraction u fraction for section curve
        """
        ...
    
    def GetConstantVSection(*args, **kwargs):
        """
        GetConstantVSection(self: MSPyBentleyGeom.DgnSphereDetail, indices: Bentley.SolidLocationDetail.FaceIndices, fraction: float) -> MSPyBentleyGeom.ICurvePrimitive
        
        Copy a section curve at constant v of a single face to a single
        ICurvePrimitive.
        
        Parameter ``[in]``:
        indices selects face
        
        Parameter ``[in]``:
        fraction v fraction for section curve
        """
        ...
    
    def GetFace(*args, **kwargs):
        """
        GetFace(self: MSPyBentleyGeom.DgnSphereDetail, indices: Bentley.SolidLocationDetail.FaceIndices) -> MSPyBentleyGeom.IGeometry
        
        Return a single face of the solid primitive
        
        Parameter ``indices``:
        integer selectors for the face.
        """
        ...
    
    def GetFaceIndices(*args, **kwargs):
        """
        GetFaceIndices(self: MSPyBentleyGeom.DgnSphereDetail, indices: MSPyBentleyGeom.FaceIndicesArray) -> None
        
        Fill a list of all possible face indices.
        
        Parameter ``[out]``:
        indices array of selectors for the faces.
        """
        ...
    
    def GetNonUniformTransforms(*args, **kwargs):
        """
        GetNonUniformTransforms(self: MSPyBentleyGeom.DgnSphereDetail, localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform) -> bool
        
        Return (nonuniform) transforms for normalized system where sphere
        radius is 1.
        """
        ...
    
    def GetRange(*args, **kwargs):
        """
        GetRange(*args, **kwargs)
        Overloaded function.
        
        1. GetRange(self: MSPyBentleyGeom.DgnSphereDetail, range: MSPyBentleyGeom.DRange3d) -> bool
        
        Return range.
        
        2. GetRange(self: MSPyBentleyGeom.DgnSphereDetail, range: MSPyBentleyGeom.DRange3d, transform: MSPyBentleyGeom.Transform) -> bool
        
        Return range.
        """
        ...
    
    def GetSweepLimits(*args, **kwargs):
        """
        GetSweepLimits(self: MSPyBentleyGeom.DgnSphereDetail, forceSweepNorth: bool) -> tuple
        
        Parameter ``[out]``:
        latitude0 latitude at start of sweep.
        
        Parameter ``[out]``:
        latitude1 latitude at end of sweep.
        
        Parameter ``[out]``:
        z0 z coordinate at start of sweep.
        
        Parameter ``[out]``:
        z1 z coordinate at end of sweep.
        
        Parameter ``[in]``:
        forceSweepNorth true to exchange if necessary to make sweep south
        to north.
        
        Returns:
        false if no sweep limits (full sphere)
        """
        ...
    
    def GetTransforms(*args, **kwargs):
        """
        GetTransforms(self: MSPyBentleyGeom.DgnSphereDetail, localTransform: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform) -> bool
        
        Return transforms for unit-axis system.
        """
        ...
    
    def IntersectBoundedArc(*args, **kwargs):
        """
        IntersectBoundedArc(self: MSPyBentleyGeom.DgnSphereDetail, arc: MSPyBentleyGeom.DEllipse3d, arcFractions: MSPyBentley.DoubleArray, normalizedConePoints: MSPyBentleyGeom.DPoint3dArray, localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform, boundedZ: bool) -> None
        
        Return all intersection points of an (unbounded) arc with the sphere.
        Returned data is the detailed local coordinates, with additional data
        to relate it back to world.
        """
        ...
    
    def IsClosedVolume(*args, **kwargs):
        """
        IsClosedVolume(self: MSPyBentleyGeom.DgnSphereDetail) -> bool
        
        Test if this is a closed volume.
        """
        ...
    
    def IsRealCap(*args, **kwargs):
        """
        IsRealCap(self: MSPyBentleyGeom.DgnSphereDetail, select01: int) -> bool
        
        Test if caps are active and the indicated cap is not at a pole
        """
        ...
    
    def IsSameStructure(*args, **kwargs):
        """
        IsSameStructure(self: MSPyBentleyGeom.DgnSphereDetail, other: Bentley.ISolidPrimitive) -> bool
        
        Test for same type and structure (but no coordinate comparison)
        """
        ...
    
    def IsSameStructureAndGeometry(*args, **kwargs):
        """
        IsSameStructureAndGeometry(self: MSPyBentleyGeom.DgnSphereDetail, other: Bentley.ISolidPrimitive, tolerance: float) -> bool
        
        Test for same type, structure and coordinates.
        """
        ...
    
    def IsTrueRotationAroundZ(*args, **kwargs):
        """
        IsTrueRotationAroundZ(self: MSPyBentleyGeom.DgnSphereDetail, center: MSPyBentleyGeom.DPoint3d, unitX: MSPyBentleyGeom.DVec3d, unitY: MSPyBentleyGeom.DVec3d, unitZ: MSPyBentleyGeom.DVec3d) -> tuple
        
        Return true (with supporting local coordinate frame) iff this is a
        rotation around the Z axis.
        """
        ...
    
    def IsTrueSphere(*args, **kwargs):
        """
        IsTrueSphere(self: MSPyBentleyGeom.DgnSphereDetail, center: MSPyBentleyGeom.DPoint3d, axes: MSPyBentleyGeom.RotMatrix) -> tuple
        
        Return true (with supporting data) iff this is a (complete) true
        sphere.
        """
        ...
    
    def LatitudeToVFraction(*args, **kwargs):
        """
        LatitudeToVFraction(self: MSPyBentleyGeom.DgnSphereDetail, latitude: float) -> float
        
        Compute the v fraction of latitude
        """
        ...
    
    def LongitudeToUFraction(*args, **kwargs):
        """
        LongitudeToUFraction(self: MSPyBentleyGeom.DgnSphereDetail, longitude: float) -> float
        
        Compute the u fraction of longitude
        """
        ...
    
    def ParameterizationSign(*args, **kwargs):
        """
        ParameterizationSign(self: MSPyBentleyGeom.DgnSphereDetail) -> float
        
        Return +1 or -1 that matches the volume sign after integration over
        the parameter space.
        """
        ...
    
    def SetDetailUVFromUnitSphereCoordinates(*args, **kwargs):
        """
        SetDetailUVFromUnitSphereCoordinates(detail: MSPyBentleyGeom.SolidLocationDetail, localuvw: MSPyBentleyGeom.DPoint3d, localToWorld: MSPyBentleyGeom.Transform, startLatitude: float, sweepLatitude: float) -> None
        
        set point, uv coordinates, and uv derivatives vectors
        """
        ...
    
    def SilhouetteCurves(*args, **kwargs):
        """
        SilhouetteCurves(self: MSPyBentleyGeom.DgnSphereDetail, eyePoint: MSPyBentleyGeom.DPoint4d, curves: MSPyBentleyGeom.CurveVector) -> bool
        
        Return curves which are silhoutte curves OTHER than hard edges
        
        Returns:
        return false if not implemented. return true if implemented -- but
        curves may still be empty.
        """
        ...
    
    def TransformInPlace(*args, **kwargs):
        """
        TransformInPlace(self: MSPyBentleyGeom.DgnSphereDetail, transform: MSPyBentleyGeom.Transform) -> bool
        
        Transform in place.
        """
        ...
    
    def TryGetConstructiveFrame(*args, **kwargs):
        """
        TryGetConstructiveFrame(self: MSPyBentleyGeom.DgnSphereDetail, localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform) -> bool
        
        Return coordinate system with 1) XY plane in equatorial plane, origin
        at sphere center. 2) Z perpendicular
        """
        ...
    
    def TryGetMaxUVLength(*args, **kwargs):
        """
        TryGetMaxUVLength(self: MSPyBentleyGeom.DgnSphereDetail, indices: Bentley.SolidLocationDetail.FaceIndices, uvLength: MSPyBentleyGeom.DVec2d) -> bool
        
        Compute the lengths of the longest u and v direction sections of a
        single face of a solid primitive.
        
        Parameter ``[in]``:
        indices selects face.
        
        Parameter ``[in]``:
        uvLength sizes in u, v directions.
        """
        ...
    
    def TryGetRotationAxis(*args, **kwargs):
        """
        TryGetRotationAxis(self: MSPyBentleyGeom.DgnSphereDetail, center: MSPyBentleyGeom.DPoint3d, axes: MSPyBentleyGeom.DVec3d) -> tuple
        
        Parameter ``center``:
        OUT center of rotation.
        
        Parameter ``axis``:
        OUT axis of rotation.
        
        Parameter ``sweepRadians``:
        OUT angle of rotation.
        """
        ...
    
    def TryUVFractionToXYZ(*args, **kwargs):
        """
        TryUVFractionToXYZ(self: MSPyBentleyGeom.DgnSphereDetail, faceIndices: Bentley.SolidLocationDetail.FaceIndices, uFraction: float, vFraction: float, xyz: MSPyBentleyGeom.DPoint3d, dXdu: MSPyBentleyGeom.DVec3d, dXdv: MSPyBentleyGeom.DVec3d) -> bool
        
        convert u,v fraction on specified face to xyz and derivatives.
        
        Parameter ``[in]``:
        faceIndices face selection indices
        
        Parameter ``[in]``:
        uFraction fractional coordinate in u direction.
        
        Parameter ``[in]``:
        vFraction fractional coordinate in v direction.
        
        Parameter ``[out]``:
        xyz point on face.
        
        Parameter ``[out]``:
        dXdu derivative of face point wrt uFraction.
        
        Parameter ``[out]``:
        dXdv derivative of face point wrt vFraction.
        """
        ...
    
    def UFractionToVSectionDEllipse3d(*args, **kwargs):
        """
        UFractionToVSectionDEllipse3d(self: MSPyBentleyGeom.DgnSphereDetail, fraction: float) -> MSPyBentleyGeom.DEllipse3d
        
        Return the ellipse on the meridian at fractional position.
        """
        ...
    
    def VFractionToLatitude(*args, **kwargs):
        """
        VFractionToLatitude(self: MSPyBentleyGeom.DgnSphereDetail, v: float) -> float
        
        Compute the latitude at v fraction.
        """
        ...
    
    def VFractionToUSectionDEllipse3d(*args, **kwargs):
        """
        VFractionToUSectionDEllipse3d(self: MSPyBentleyGeom.DgnSphereDetail, fraction: float) -> MSPyBentleyGeom.DEllipse3d
        
        Return the ellipse on the parallel at fractional position.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DgnSphereDetail) -> None
        
        2. __init__(self: MSPyBentleyGeom.DgnSphereDetail, center: MSPyBentleyGeom.DPoint3d, radius: float) -> None
        
        3. __init__(self: MSPyBentleyGeom.DgnSphereDetail, center: MSPyBentleyGeom.DPoint3d, axes: MSPyBentleyGeom.RotMatrix, radius: float) -> None
        
        4. __init__(self: MSPyBentleyGeom.DgnSphereDetail, center: MSPyBentleyGeom.DPoint3d, vectorX: MSPyBentleyGeom.DVec3d, vectorZ: MSPyBentleyGeom.DVec3d, radiusXY: float, radiusZ: float, startLatitude: float, latitudeSweep: float, capped: bool) -> None
        """
        ...
    
class DgnTorusPipeDetail:
    """
    None
    """

    def AddCurveIntersections(*args, **kwargs):
        """
        AddCurveIntersections(*args, **kwargs)
        Overloaded function.
        
        1. AddCurveIntersections(self: MSPyBentleyGeom.DgnTorusPipeDetail, curves: MSPyBentleyGeom.CurveVector, curvePoints: MSPyBentleyGeom.CurveLocationDetailArray, solidPoints: MSPyBentleyGeom.SolidLocationDetailArray, messages: MSPyBentleyGeom.MeshAnnotationVector) -> None
        
        Compute intersections with curves and add to the data array.
        
        Parameter ``[in]``:
        curves
        
        Parameter ``[in,out]``:
        curvePoints growing array of curve points.
        
        Parameter ``[in,out]``:
        solidPoints growing array of solid points.
        
        Parameter ``[in,out]``:
        messages array of error messages
        
        2. AddCurveIntersections(self: MSPyBentleyGeom.DgnTorusPipeDetail, curves: MSPyBentleyGeom.ICurvePrimitive, curvePoints: MSPyBentleyGeom.CurveLocationDetailArray, solidPoints: MSPyBentleyGeom.SolidLocationDetailArray, messages: MSPyBentleyGeom.MeshAnnotationVector) -> None
        
        Compute intersections with curves and add to the data array.
        
        Parameter ``[in]``:
        curves
        
        Parameter ``[in,out]``:
        curvePoints growing array of curve points.
        
        Parameter ``[in,out]``:
        solidPoints growing array of solid points.
        
        Parameter ``[in,out]``:
        messages array of error messages
        """
        ...
    
    def AddRayIntersections(*args, **kwargs):
        """
        AddRayIntersections(self: MSPyBentleyGeom.DgnTorusPipeDetail, pickData: MSPyBentleyGeom.SolidLocationDetailArray, ray: MSPyBentleyGeom.DRay3d, parentId: int, minParameter: float) -> None
        
        Compute intersections with a ray and add to the pickData.
        
        Parameter ``[in]``:
        ray origin and direction
        
        Parameter ``[in]``:
        minParameter smallest parameter of pick. (e.g. 0 for picking along
        a positive ray from an eyepoint)
        
        Parameter ``[in,out]``:
        pickData growing array of picks.
        
        Parameter ``[in]``:
        parentId caller's id for this solid. Will be placed in each
        pickData entry has parentId.
        """
        ...
    
    def Clone(*args, **kwargs):
        """
        Clone(self: MSPyBentleyGeom.DgnTorusPipeDetail) -> Bentley.ISolidPrimitive
        
        Copy to a new (allocated) solid primitive.
        """
        ...
    
    def ClosestPoint(*args, **kwargs):
        """
        ClosestPoint(self: MSPyBentleyGeom.DgnTorusPipeDetail, spacePoint: MSPyBentleyGeom.DPoint3d, pickDetail: MSPyBentleyGeom.SolidLocationDetail) -> bool
        
        Parameter ``[in]``:
        spacePoint search for point close to here and on the solid surface
        
        Parameter ``[out]``:
        pickDetail closest point data.
        
        Returns:
        false if not supported.
        """
        ...
    
    def ComputeSecondMomentAreaProducts(*args, **kwargs):
        """
        ComputeSecondMomentAreaProducts(self: MSPyBentleyGeom.DgnTorusPipeDetail, localToWorld: MSPyBentleyGeom.Transform, localProducts: MSPyBentleyGeom.DMatrix4d) -> bool
        
        Return the various integrated products for area moment calculations.
        The primitive is treated as a thin shell.
        
        Parameter ``[out]``:
        localToWorld transform from preferred system where the products
        are most easily computed to world.
        
        Parameter ``[out]``:
        localProducts integrated [xx xy xz x; xy yy yz y; xz yz zz z; x y
        z 1] dA
        
        Returns:
        false if unable to compute.
        """
        ...
    
    def ComputeSecondMomentVolumeProducts(*args, **kwargs):
        """
        ComputeSecondMomentVolumeProducts(self: MSPyBentleyGeom.DgnTorusPipeDetail, localToWorld: MSPyBentleyGeom.Transform, localProducts: MSPyBentleyGeom.DMatrix4d) -> bool
        
        Return the various integrated products for moment calculations. The
        primitive is treated as a volume
        
        Parameter ``[out]``:
        localToWorld transform from preferred system where the products
        are most easily computed to world.
        
        Parameter ``[out]``:
        localProducts integrated [xx xy xz x; xy yy yz y; xz yz zz z; x y
        z 1] dA
        
        Returns:
        false if unable to compute.
        """
        ...
    
    def GetConstantUSection(*args, **kwargs):
        """
        GetConstantUSection(self: MSPyBentleyGeom.DgnTorusPipeDetail, indices: Bentley.SolidLocationDetail.FaceIndices, fraction: float) -> MSPyBentleyGeom.ICurvePrimitive
        
        Copy a section at constant u of a single face to a single
        ICurvePrimitive.
        
        Parameter ``[in]``:
        indices selects face
        
        Parameter ``[in]``:
        fraction u fraction for section curve
        """
        ...
    
    def GetConstantVSection(*args, **kwargs):
        """
        GetConstantVSection(self: MSPyBentleyGeom.DgnTorusPipeDetail, indices: Bentley.SolidLocationDetail.FaceIndices, fraction: float) -> MSPyBentleyGeom.ICurvePrimitive
        
        Copy a section curve at constant v of a single face to a single
        ICurvePrimitive.
        
        Parameter ``[in]``:
        indices selects face
        
        Parameter ``[in]``:
        fraction v fraction for section curve
        """
        ...
    
    def GetFace(*args, **kwargs):
        """
        GetFace(self: MSPyBentleyGeom.DgnTorusPipeDetail, indices: Bentley.SolidLocationDetail.FaceIndices) -> MSPyBentleyGeom.IGeometry
        
        Return a single face of the solid primitive
        
        Parameter ``indices``:
        integer selectors for the face.
        """
        ...
    
    def GetFaceIndices(*args, **kwargs):
        """
        GetFaceIndices(self: MSPyBentleyGeom.DgnTorusPipeDetail, indices: MSPyBentleyGeom.FaceIndicesArray) -> None
        
        Fill a list of all possible face indices.
        
        Parameter ``[out]``:
        indices array of selectors for the faces.
        """
        ...
    
    def GetRange(*args, **kwargs):
        """
        GetRange(*args, **kwargs)
        Overloaded function.
        
        1. GetRange(self: MSPyBentleyGeom.DgnTorusPipeDetail, range: MSPyBentleyGeom.DRange3d) -> bool
        
        Return range.
        
        2. GetRange(self: MSPyBentleyGeom.DgnTorusPipeDetail, range: MSPyBentleyGeom.DRange3d, transform: MSPyBentleyGeom.Transform) -> bool
        
        Return range.
        """
        ...
    
    def HasRealCaps(*args, **kwargs):
        """
        HasRealCaps(self: MSPyBentleyGeom.DgnTorusPipeDetail) -> bool
        
        Return true if capped and incomplete major sweep.
        """
        ...
    
    def IntersectCurveLocal(*args, **kwargs):
        """
        IntersectCurveLocal(self: MSPyBentleyGeom.DgnTorusPipeDetail, curve: MSPyBentleyGeom.ICurvePrimitive, curveFractions: MSPyBentley.DoubleArray, normalizedConePoints: MSPyBentleyGeom.DPoint3dArray, localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform, boundedConeZ: bool) -> tuple
        
        Return all intersection points of a curve with the pipe body Returned
        data is the detailed local coordinates, with additional data to relate
        it back to world.
        """
        ...
    
    def IsClosedVolume(*args, **kwargs):
        """
        IsClosedVolume(self: MSPyBentleyGeom.DgnTorusPipeDetail) -> bool
        
        Test if this is a closed volume.
        """
        ...
    
    def IsSameStructure(*args, **kwargs):
        """
        IsSameStructure(self: MSPyBentleyGeom.DgnTorusPipeDetail, other: Bentley.ISolidPrimitive) -> bool
        
        Test for same type and structure (but no coordinate comparison)
        """
        ...
    
    def IsSameStructureAndGeometry(*args, **kwargs):
        """
        IsSameStructureAndGeometry(self: MSPyBentleyGeom.DgnTorusPipeDetail, other: Bentley.ISolidPrimitive, tolerance: float) -> bool
        
        Test for same type, structure and coordinates.
        """
        ...
    
    def ParameterizationSign(*args, **kwargs):
        """
        ParameterizationSign(self: MSPyBentleyGeom.DgnTorusPipeDetail) -> float
        
        Return +1 or -1 that matches the volume sign after integration over
        the parameter space.
        """
        ...
    
    def SetDetailCoordinatesFromLocalPipeCoordinates(*args, **kwargs):
        """
        SetDetailCoordinatesFromLocalPipeCoordinates(self: MSPyBentleyGeom.DgnTorusPipeDetail, detail: MSPyBentleyGeom.SolidLocationDetail, localuvw: MSPyBentleyGeom.DPoint3d, localToWorld: MSPyBentleyGeom.Transform) -> tuple
        
        set point, uv coordinates, and uv derivatives vectors
        """
        ...
    
    def SilhouetteCurves(*args, **kwargs):
        """
        SilhouetteCurves(self: MSPyBentleyGeom.DgnTorusPipeDetail, eyePoint: MSPyBentleyGeom.DPoint4d, curves: MSPyBentleyGeom.CurveVector) -> bool
        
        Return curves which are silhoutte curves OTHER than hard edges
        
        Returns:
        return false if not implemented. return true if implemented -- but
        curves may still be empty.
        """
        ...
    
    def TransformInPlace(*args, **kwargs):
        """
        TransformInPlace(self: MSPyBentleyGeom.DgnTorusPipeDetail, transform: MSPyBentleyGeom.Transform) -> bool
        
        Transform in place.
        """
        ...
    
    def TryGetConstructiveFrame(*args, **kwargs):
        """
        TryGetConstructiveFrame(self: MSPyBentleyGeom.DgnTorusPipeDetail, localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform) -> bool
        
        Return coordinate system with origin at major hoop center, X axis
        towards starting minor circle center.
        """
        ...
    
    def TryGetFrame(*args, **kwargs):
        """
        TryGetFrame(*args, **kwargs)
        Overloaded function.
        
        1. TryGetFrame(self: MSPyBentleyGeom.DgnTorusPipeDetail, center: MSPyBentleyGeom.DPoint3d, axis: MSPyBentleyGeom.RotMatrix) -> tuple
        
        Parameter ``[out]``:
        center center of rotation.
        
        Parameter ``[out]``:
        axes coordinate axes, xy in major plane, z through hole.
        
        Parameter ``[out]``:
        radiusA major radius (elbow radius)
        
        Parameter ``[out]``:
        radiusB minor radius (pipe diameter)
        
        Parameter ``[out]``:
        sweepRadians angle of rotation.
        
        2. TryGetFrame(self: MSPyBentleyGeom.DgnTorusPipeDetail, center: MSPyBentleyGeom.Transform, axis: MSPyBentleyGeom.Transform) -> tuple
        
        Parameter ``[out]``:
        center center of rotation.
        
        Parameter ``[out]``:
        axes coordinate axes, xy in major plane, z through hole.
        
        Parameter ``[out]``:
        radiusA major radius (elbow radius)
        
        Parameter ``[out]``:
        radiusB minor radius (pipe diameter)
        
        Parameter ``[out]``:
        sweepRadians angle of rotation.
        """
        ...
    
    def TryGetMaxUVLength(*args, **kwargs):
        """
        TryGetMaxUVLength(self: MSPyBentleyGeom.DgnTorusPipeDetail, indices: Bentley.SolidLocationDetail.FaceIndices, uvLength: MSPyBentleyGeom.DVec2d) -> bool
        
        Compute the lengths of the longest u and v direction sections of a
        single face of a solid primitive.
        
        Parameter ``[in]``:
        indices selects face.
        
        Parameter ``[out]``:
        uvLength sizes in u, v directions.
        """
        ...
    
    def TryGetRotationAxis(*args, **kwargs):
        """
        TryGetRotationAxis(self: MSPyBentleyGeom.DgnTorusPipeDetail, center: MSPyBentleyGeom.DPoint3d, axis: MSPyBentleyGeom.DVec3d) -> tuple
        
        Parameter ``center``:
        OUT center of rotation.
        
        Parameter ``axis``:
        OUT axis of rotation.
        
        Parameter ``sweepRadians``:
        OUT angle of rotation.
        """
        ...
    
    def TryUVFractionToXYZ(*args, **kwargs):
        """
        TryUVFractionToXYZ(self: MSPyBentleyGeom.DgnTorusPipeDetail, faceIndices: Bentley.SolidLocationDetail.FaceIndices, uFraction: float, vFraction: float, xyz: MSPyBentleyGeom.DPoint3d, dXdu: MSPyBentleyGeom.DVec3d, dXdv: MSPyBentleyGeom.DVec3d) -> bool
        
        convert u,v fraction on specified face to xyz and derivatives.
        
        Parameter ``[in]``:
        faceIndices face selection indices
        
        Parameter ``[in]``:
        uFraction fractional coordinate in u direction.
        
        Parameter ``[in]``:
        vFraction fractional coordinate in v direction.
        
        Parameter ``[out]``:
        xyz point on face.
        
        Parameter ``[out]``:
        dXdu derivative of face point wrt uFraction.
        
        Parameter ``[out]``:
        dXdv derivative of face point wrt vFraction.
        """
        ...
    
    def UFractionToVSectionDEllipse3d(*args, **kwargs):
        """
        UFractionToVSectionDEllipse3d(self: MSPyBentleyGeom.DgnTorusPipeDetail, fraction: float) -> MSPyBentleyGeom.DEllipse3d
        
        Return full ellipse on minor hoop at fractional position along major
        circle.
        """
        ...
    
    def VFractionToUSectionDEllipse3d(*args, **kwargs):
        """
        VFractionToUSectionDEllipse3d(self: MSPyBentleyGeom.DgnTorusPipeDetail, fraction: float) -> MSPyBentleyGeom.DEllipse3d
        
        Return full ellipse on minor hoop at fractional position along minor
        circle.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DgnTorusPipeDetail) -> None
        
        2. __init__(self: MSPyBentleyGeom.DgnTorusPipeDetail, center: MSPyBentleyGeom.DPoint3d, vectorX: MSPyBentleyGeom.DVec3d, vectorY: MSPyBentleyGeom.DVec3d, majorRadius: float, minorRadius: float, sweepAngle: float, capped: bool) -> None
        """
        ...
    
class DirectionalVolumeData:
    """
    None
    """

    def __init__(self: MSPyBentleyGeom.DirectionalVolumeData) -> None:
        ...
    
    @property
    def areaProducts(self: MSPyBentleyGeom.DirectionalVolumeData) -> MSPyBentleyGeom.DMatrix4d:
        ...
    @areaProducts.setter
    def areaProducts(self: MSPyBentleyGeom.DirectionalVolumeData, arg0: MSPyBentleyGeom.DMatrix4d) -> None:
        ...
    
    @property
    def volume(self: MSPyBentleyGeom.DirectionalVolumeData) -> float:
        ...
    @volume.setter
    def volume(self: MSPyBentleyGeom.DirectionalVolumeData, arg0: float) -> None:
        ...
    
class DoubleSizeSize:
    """
    None
    """

    def Get(*args, **kwargs):
        """
        Get(self: MSPyBentleyGeom.DoubleSizeSizeT) -> float
        """
        ...
    
    def GetCR(*args, **kwargs):
        """
        GetCR(self: MSPyBentleyGeom.DoubleSizeSizeT) -> float
        """
        ...
    
    def GetTag(*args, **kwargs):
        """
        GetTag(self: MSPyBentleyGeom.DoubleSizeSizeT, tagA: bool) -> int
        """
        ...
    
    def GetTagA(*args, **kwargs):
        """
        GetTagA(self: MSPyBentleyGeom.DoubleSizeSizeT) -> int
        """
        ...
    
    def GetTagB(*args, **kwargs):
        """
        GetTagB(self: MSPyBentleyGeom.DoubleSizeSizeT) -> int
        """
        ...
    
    def Set(*args, **kwargs):
        """
        Set(self: MSPyBentleyGeom.DoubleSizeSizeT, value: float) -> None
        """
        ...
    
    def SetTagA(*args, **kwargs):
        """
        SetTagA(self: MSPyBentleyGeom.DoubleSizeSizeT, tag: int) -> None
        """
        ...
    
    def SetTagB(*args, **kwargs):
        """
        SetTagB(self: MSPyBentleyGeom.DoubleSizeSizeT, tag: int) -> None
        """
        ...
    
    def SwapTags(*args, **kwargs):
        """
        SwapTags(self: MSPyBentleyGeom.DoubleSizeSizeT) -> None
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.DoubleSizeSize, value: float, tagA: int, tagB: int) -> None:
        ...
    
class DoubleSizeSizeT:
    """
    None
    """

    def Get(*args, **kwargs):
        """
        Get(self: MSPyBentleyGeom.DoubleSizeSizeT) -> float
        """
        ...
    
    def GetCR(*args, **kwargs):
        """
        GetCR(self: MSPyBentleyGeom.DoubleSizeSizeT) -> float
        """
        ...
    
    def GetTag(*args, **kwargs):
        """
        GetTag(self: MSPyBentleyGeom.DoubleSizeSizeT, tagA: bool) -> int
        """
        ...
    
    def GetTagA(*args, **kwargs):
        """
        GetTagA(self: MSPyBentleyGeom.DoubleSizeSizeT) -> int
        """
        ...
    
    def GetTagB(*args, **kwargs):
        """
        GetTagB(self: MSPyBentleyGeom.DoubleSizeSizeT) -> int
        """
        ...
    
    def Set(*args, **kwargs):
        """
        Set(self: MSPyBentleyGeom.DoubleSizeSizeT, value: float) -> None
        """
        ...
    
    def SetTagA(*args, **kwargs):
        """
        SetTagA(self: MSPyBentleyGeom.DoubleSizeSizeT, tag: int) -> None
        """
        ...
    
    def SetTagB(*args, **kwargs):
        """
        SetTagB(self: MSPyBentleyGeom.DoubleSizeSizeT, tag: int) -> None
        """
        ...
    
    def SwapTags(*args, **kwargs):
        """
        SwapTags(self: MSPyBentleyGeom.DoubleSizeSizeT) -> None
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DoubleSizeSizeT) -> None
        
        2. __init__(self: MSPyBentleyGeom.DoubleSizeSizeT, value: float, tagA: int, tagB: int) -> None
        """
        ...
    
class EdgeId:
    """
    None
    """

    def GetFaces(*args, **kwargs):
        """
        GetFaces(self: MSPyBentleyGeom.EdgeId) -> tuple
        """
        ...
    
    def SetFaces(*args, **kwargs):
        """
        SetFaces(self: MSPyBentleyGeom.EdgeId, f1: MSPyBentleyGeom.FaceId, f2: MSPyBentleyGeom.FaceId) -> None
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.EdgeId) -> None:
        ...
    
class EdgeIdArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.EdgeIdArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.EdgeIdArray, arg0: MSPyBentleyGeom.EdgeIdArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.EdgeIdArray, arg0: Iterable) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.EdgeIdArray, x: MSPyBentleyGeom.EdgeId) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.EdgeIdArray) -> None
        
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.EdgeIdArray, L: MSPyBentleyGeom.EdgeIdArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.EdgeIdArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.EdgeIdArray, i: int, x: MSPyBentleyGeom.EdgeId) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.EdgeIdArray) -> MSPyBentleyGeom.EdgeId
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.EdgeIdArray, i: int) -> MSPyBentleyGeom.EdgeId
        
        Remove and return the item at index ``i``
        """
        ...
    
FIT_CATMULLROM: int

FIT_LEASTSQUARES: int

FIT_POINTS: int

FIT_POLES: int

class FaceId:
    """
    None
    """

    def __init__(self: MSPyBentleyGeom.FaceId) -> None:
        ...
    
    @property
    def entityId(self: MSPyBentleyGeom.FaceId) -> int:
        ...
    @entityId.setter
    def entityId(self: MSPyBentleyGeom.FaceId, arg0: int) -> None:
        ...
    
    @property
    def nodeId(self: MSPyBentleyGeom.FaceId) -> int:
        ...
    @nodeId.setter
    def nodeId(self: MSPyBentleyGeom.FaceId, arg0: int) -> None:
        ...
    
class FaceIdArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.FaceIdArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.FaceIdArray, arg0: MSPyBentleyGeom.FaceIdArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.FaceIdArray, arg0: Iterable) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.FaceIdArray, x: MSPyBentleyGeom.FaceId) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.FaceIdArray) -> None
        
        Clear the contents
        """
        ...
    
    def count(*args, **kwargs):
        """
        count(self: MSPyBentleyGeom.FaceIdArray, x: MSPyBentleyGeom.FaceId) -> int
        
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.FaceIdArray, L: MSPyBentleyGeom.FaceIdArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.FaceIdArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.FaceIdArray, i: int, x: MSPyBentleyGeom.FaceId) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.FaceIdArray) -> MSPyBentleyGeom.FaceId
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.FaceIdArray, i: int) -> MSPyBentleyGeom.FaceId
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(*args, **kwargs):
        """
        remove(self: MSPyBentleyGeom.FaceIdArray, x: MSPyBentleyGeom.FaceId) -> None
        
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class FaceIndicesArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.FaceIndicesArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.FaceIndicesArray, arg0: MSPyBentleyGeom.FaceIndicesArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.FaceIndicesArray, arg0: Iterable) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.FaceIndicesArray, x: MSPyBentleyGeom.SolidLocationDetail.FaceIndices) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.FaceIndicesArray) -> None
        
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.FaceIndicesArray, L: MSPyBentleyGeom.FaceIndicesArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.FaceIndicesArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.FaceIndicesArray, i: int, x: MSPyBentleyGeom.SolidLocationDetail.FaceIndices) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.FaceIndicesArray) -> MSPyBentleyGeom.SolidLocationDetail.FaceIndices
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.FaceIndicesArray, i: int) -> MSPyBentleyGeom.SolidLocationDetail.FaceIndices
        
        Remove and return the item at index ``i``
        """
        ...
    
class FacetCutFillHandler:
    """
    None
    """

    def ContinueSearch(*args, **kwargs):
        """
        ContinueSearch(self: MSPyBentleyGeom.FacetCutFillHandler) -> bool
        
        Test if the handler object is still interested in the calls. This is
        not normally implemented
        """
        ...
    
    def ProcessCutFillFacet(*args, **kwargs):
        """
        ProcessCutFillFacet(self: MSPyBentleyGeom.FacetCutFillHandler, dtm: MSPyBentleyGeom.DPoint3dArray, dtmReadIndex: int, road: MSPyBentleyGeom.DPoint3dArray, roadReadIndex: int, roadBoundaryFlag: MSPyBentley.BoolArray, isCut: bool) -> None
        
        Announce coordinates in paired dtm and road loops.
        
        * both loops are oriented CCW.
        
        * Hence when building closed meshes, the lower of the two must be
        reversed to get the downward directed surface properly oriented
        
        * points are in corresponding order -- dtm[i] and road[i] have
        identical xy coordinates, different z
        
        * isCut is true when the dtm is above the road
        
        * isCut is false for road above dtm.
        
        * isCut (or comparison of corresponding z coordinates) is consistent
        around the entire facet.
        """
        ...
    
    def ProcessSideFacet(*args, **kwargs):
        """
        ProcessSideFacet(self: MSPyBentleyGeom.FacetCutFillHandler, points: MSPyBentleyGeom.DPoint3dArray, isCut: bool) -> None
        """
        ...
    
    def Reset(*args, **kwargs):
        """
        Reset(self: MSPyBentleyGeom.FacetCutFillHandler) -> None
        
        Called to reset the computation. This is important:The FastCutFill
        caller may decide to throw away partially completed results and
        restart.
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.FacetCutFillHandler) -> None:
        ...
    
class FacetEdgeLocationDetail:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.FacetEdgeLocationDetail) -> None
        
        2. __init__(self: MSPyBentleyGeom.FacetEdgeLocationDetail, readIndex: int, fraction: float) -> None
        """
        ...
    
    @property
    def fraction(self: MSPyBentleyGeom.FacetEdgeLocationDetail) -> float:
        ...
    @fraction.setter
    def fraction(self: MSPyBentleyGeom.FacetEdgeLocationDetail, arg0: float) -> None:
        ...
    
    @property
    def readIndex(self: MSPyBentleyGeom.FacetEdgeLocationDetail) -> int:
        ...
    @readIndex.setter
    def readIndex(self: MSPyBentleyGeom.FacetEdgeLocationDetail, arg0: int) -> None:
        ...
    
class FacetFaceData:
    """
    None
    """

    def ConvertParamToDistance(*args, **kwargs):
        """
        ConvertParamToDistance(self: MSPyBentleyGeom.FacetFaceData, distanceParam: MSPyBentleyGeom.DPoint2d, param: MSPyBentleyGeom.DPoint2d) -> None
        
        convert parameter from stored value to distance-based parameter.
        """
        ...
    
    def ConvertParamToNormalized(*args, **kwargs):
        """
        ConvertParamToNormalized(self: MSPyBentleyGeom.FacetFaceData, normalizedParam: MSPyBentleyGeom.DPoint2d, param: MSPyBentleyGeom.DPoint2d) -> None
        
        convert parameter from stored value to normalized (0-1) parameter.
        """
        ...
    
    def Init(*args, **kwargs):
        """
        Init(self: MSPyBentleyGeom.FacetFaceData) -> None
        
        restore to constructor state.
        """
        ...
    
    def ScaleDistances(*args, **kwargs):
        """
        ScaleDistances(self: MSPyBentleyGeom.FacetFaceData, distanceScale: float) -> None
        
        Scale distance parameters
        """
        ...
    
    def SetParamDistanceRangeFromNewFaceData(*args, **kwargs):
        """
        SetParamDistanceRangeFromNewFaceData(self: MSPyBentleyGeom.FacetFaceData, polyface: Bentley.PolyfaceHeader, endIndex: int = 0) -> None
        
        To be called just after one or more " one - based, zero terminated "
        facets have been added to the polyface. The new facets are identified
        as a " face " and the face size data is recorded. Face size is tied to
        parameter range by scale factors from simple triangulation of all
        facets.
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.FacetFaceData) -> None:
        ...
    
    @property
    def faceIndices(self: MSPyBentleyGeom.FacetFaceData) -> Bentley.SolidLocationDetail.FaceIndices:
        ...
    @faceIndices.setter
    def faceIndices(self: MSPyBentleyGeom.FacetFaceData, arg0: Bentley.SolidLocationDetail.FaceIndices) -> None:
        ...
    
    @property
    def normalRange(self: MSPyBentleyGeom.FacetFaceData) -> MSPyBentleyGeom.DRange3d:
        ...
    @normalRange.setter
    def normalRange(self: MSPyBentleyGeom.FacetFaceData, arg0: MSPyBentleyGeom.DRange3d) -> None:
        ...
    
    @property
    def paramDistanceRange(self: MSPyBentleyGeom.FacetFaceData) -> MSPyBentleyGeom.DRange2d:
        ...
    @paramDistanceRange.setter
    def paramDistanceRange(self: MSPyBentleyGeom.FacetFaceData, arg0: MSPyBentleyGeom.DRange2d) -> None:
        ...
    
    @property
    def paramRange(self: MSPyBentleyGeom.FacetFaceData) -> MSPyBentleyGeom.DRange2d:
        ...
    @paramRange.setter
    def paramRange(self: MSPyBentleyGeom.FacetFaceData, arg0: MSPyBentleyGeom.DRange2d) -> None:
        ...
    
    @property
    def sourceIndex(self: MSPyBentleyGeom.FacetFaceData) -> int:
        ...
    @sourceIndex.setter
    def sourceIndex(self: MSPyBentleyGeom.FacetFaceData, arg0: int) -> None:
        ...
    
    @property
    def xyzRange(self: MSPyBentleyGeom.FacetFaceData) -> MSPyBentleyGeom.DRange3d:
        ...
    @xyzRange.setter
    def xyzRange(self: MSPyBentleyGeom.FacetFaceData, arg0: MSPyBentleyGeom.DRange3d) -> None:
        ...
    
class FacetFaceDataArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.FacetFaceDataArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.FacetFaceDataArray, arg0: MSPyBentleyGeom.FacetFaceDataArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.FacetFaceDataArray, arg0: Iterable) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.FacetFaceDataArray, x: MSPyBentleyGeom.FacetFaceData) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.FacetFaceDataArray) -> None
        
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.FacetFaceDataArray, L: MSPyBentleyGeom.FacetFaceDataArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.FacetFaceDataArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.FacetFaceDataArray, i: int, x: MSPyBentleyGeom.FacetFaceData) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.FacetFaceDataArray) -> MSPyBentleyGeom.FacetFaceData
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.FacetFaceDataArray, i: int) -> MSPyBentleyGeom.FacetFaceData
        
        Remove and return the item at index ``i``
        """
        ...
    
class FacetLocationDetail:
    """
    None
    """

    def AccumulateScaledData(*args, **kwargs):
        """
        AccumulateScaledData(self: MSPyBentleyGeom.FacetLocationDetail, source: MSPyBentleyGeom.FacetLocationDetail, fraction: float) -> None
        
        accumulate a scaled multiple of all numeric data from source. append
        index data and fraction arrays to arrays (if possible within space
        restrictions). Fractions from the source are scaled by the new
        fraction.
        """
        ...
    
    def CompareUV(*args, **kwargs):
        """
        CompareUV(self: MSPyBentleyGeom.FacetLocationDetail, other: MSPyBentleyGeom.FacetLocationDetail) -> bool
        
        lexical compare in u,v coordinates.
        """
        ...
    
    def GetIsInterior(*args, **kwargs):
        """
        GetIsInterior(self: MSPyBentleyGeom.FacetLocationDetail) -> bool
        
        Get interior point flag
        """
        ...
    
    def GetNumWeights(*args, **kwargs):
        """
        GetNumWeights(self: MSPyBentleyGeom.FacetLocationDetail) -> int
        
        Return the number of vertices that are weighted together for the
        computed values. This (along with the weight fractions, intColor, and
        colorTable indices) can be used compute additional data accessed
        through the indices. At most 4 weights can be stored. The possible
        data is:
        
        * vertex index -- the index of the vertex (numbered within the facet)
        
        * fraction -- (double) the weight used for data at this indexed
        vertex.
        
        * intColor -- integer color data.
        
        * colorTable -- color table index
        """
        ...
    
    def GetReadIndex(*args, **kwargs):
        """
        GetReadIndex(self: MSPyBentleyGeom.FacetLocationDetail) -> int
        
        Get read index
        """
        ...
    
    @property
    def IsInterior(arg0: MSPyBentleyGeom.FacetLocationDetail) -> bool:
        ...
    @IsInterior.setter
    def IsInterior(arg0: MSPyBentleyGeom.FacetLocationDetail, arg1: bool) -> None:
        ...
    
    @property
    def NumWeights(arg0: MSPyBentleyGeom.FacetLocationDetail) -> int:
        ...
    
    @property
    def ReadIndex(arg0: MSPyBentleyGeom.FacetLocationDetail) -> int:
        ...
    @ReadIndex.setter
    def ReadIndex(arg0: MSPyBentleyGeom.FacetLocationDetail, arg1: int) -> None:
        ...
    
    def SetDoubleColor(*args, **kwargs):
        """
        SetDoubleColor(self: MSPyBentleyGeom.FacetLocationDetail, data: MSPyBentleyGeom.RgbFactor) -> None
        """
        ...
    
    def SetFloatColor(*args, **kwargs):
        """
        SetFloatColor(self: MSPyBentleyGeom.FacetLocationDetail, data: MSPyBentleyGeom.FloatRgb) -> None
        """
        ...
    
    def SetIsInterior(*args, **kwargs):
        """
        SetIsInterior(self: MSPyBentleyGeom.FacetLocationDetail, value: bool) -> None
        
        Set flag as interior point
        """
        ...
    
    def SetNormal(*args, **kwargs):
        """
        SetNormal(self: MSPyBentleyGeom.FacetLocationDetail, data: MSPyBentleyGeom.DVec3d) -> None
        
        Set the normal and record that it is valid.
        """
        ...
    
    def SetParam(*args, **kwargs):
        """
        SetParam(self: MSPyBentleyGeom.FacetLocationDetail, data: MSPyBentleyGeom.DPoint2d) -> None
        """
        ...
    
    def SetReadIndex(*args, **kwargs):
        """
        SetReadIndex(self: MSPyBentleyGeom.FacetLocationDetail, readIndex: int) -> None
        
        Set read index
        """
        ...
    
    def SortUV(*args, **kwargs):
        """
        SortUV(data: MSPyBentleyGeom.FacetLocationDetailArray) -> None
        
        Sort an array based by CompareUV ...
        """
        ...
    
    def TryGetColorTable(*args, **kwargs):
        """
        TryGetColorTable(self: MSPyBentleyGeom.FacetLocationDetail, index: int) -> tuple
        
        Access a color table index (by index within the facet)
        """
        ...
    
    def TryGetDoubleColor(*args, **kwargs):
        """
        TryGetDoubleColor(self: MSPyBentleyGeom.FacetLocationDetail, data: MSPyBentleyGeom.RgbFactor) -> bool
        
        Copy doubleColor data. Return false if not available.
        """
        ...
    
    def TryGetFloatColor(*args, **kwargs):
        """
        TryGetFloatColor(self: MSPyBentleyGeom.FacetLocationDetail, data: MSPyBentleyGeom.FloatRgb) -> bool
        
        Copy floatColor data. Return false if not available.
        """
        ...
    
    def TryGetIntColor(*args, **kwargs):
        """
        TryGetIntColor(self: MSPyBentleyGeom.FacetLocationDetail, index: int) -> tuple
        
        Access (for an index into the tables within the detail) the int color
        """
        ...
    
    def TryGetNormal(*args, **kwargs):
        """
        TryGetNormal(self: MSPyBentleyGeom.FacetLocationDetail, data: MSPyBentleyGeom.DVec3d) -> bool
        
        Copy normal data. Return false if not available.
        """
        ...
    
    def TryGetParam(*args, **kwargs):
        """
        TryGetParam(self: MSPyBentleyGeom.FacetLocationDetail, data: MSPyBentleyGeom.DPoint2d) -> bool
        
        Copy parameter data. Return false if not available.
        """
        ...
    
    def TryGetPoint(*args, **kwargs):
        """
        TryGetPoint(self: MSPyBentleyGeom.FacetLocationDetail, data: MSPyBentleyGeom.DPoint3d) -> bool
        
        Copy point data. Return false if not available.
        """
        ...
    
    def TryGetVertexIndex(*args, **kwargs):
        """
        TryGetVertexIndex(self: MSPyBentleyGeom.FacetLocationDetail, index: int) -> tuple
        
        Access (for an index into the tables within the detail) the vertex
        index (numbered within the facet)
        """
        ...
    
    def TryGetWeight(*args, **kwargs):
        """
        TryGetWeight(self: MSPyBentleyGeom.FacetLocationDetail, index: int) -> tuple
        
        Access (for an index into the tables within the detail) a weight for
        contributing data.
        """
        ...
    
    def Zero(*args, **kwargs):
        """
        Zero(self: MSPyBentleyGeom.FacetLocationDetail) -> None
        
        Zero all contents.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.FacetLocationDetail) -> None
        
        2. __init__(self: MSPyBentleyGeom.FacetLocationDetail, readIndex: int, a: float = 0.0) -> None
        """
        ...
    
class FacetLocationDetailArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.FacetLocationDetailArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.FacetLocationDetailArray, arg0: MSPyBentleyGeom.FacetLocationDetailArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.FacetLocationDetailArray, arg0: Iterable) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.FacetLocationDetailArray, x: MSPyBentleyGeom.FacetLocationDetail) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.FacetLocationDetailArray) -> None
        
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.FacetLocationDetailArray, L: MSPyBentleyGeom.FacetLocationDetailArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.FacetLocationDetailArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.FacetLocationDetailArray, i: int, x: MSPyBentleyGeom.FacetLocationDetail) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.FacetLocationDetailArray) -> MSPyBentleyGeom.FacetLocationDetail
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.FacetLocationDetailArray, i: int) -> MSPyBentleyGeom.FacetLocationDetail
        
        Remove and return the item at index ``i``
        """
        ...
    
class FacetLocationDetailPair:
    """
    None
    """

    def __init__(self: MSPyBentleyGeom.FacetLocationDetailPair) -> None:
        ...
    
    @property
    def detailA(self: MSPyBentleyGeom.FacetLocationDetailPair) -> MSPyBentleyGeom.FacetLocationDetail:
        ...
    @detailA.setter
    def detailA(self: MSPyBentleyGeom.FacetLocationDetailPair, arg0: MSPyBentleyGeom.FacetLocationDetail) -> None:
        ...
    
    @property
    def detailB(self: MSPyBentleyGeom.FacetLocationDetailPair) -> MSPyBentleyGeom.FacetLocationDetail:
        ...
    @detailB.setter
    def detailB(self: MSPyBentleyGeom.FacetLocationDetailPair, arg0: MSPyBentleyGeom.FacetLocationDetail) -> None:
        ...
    
class FacetLocationDetailPairWithIndices:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.FacetLocationDetailPairWithIndices, defaultIndex: int) -> None
        
        2. __init__(self: MSPyBentleyGeom.FacetLocationDetailPairWithIndices, detailA: MSPyBentleyGeom.FacetLocationDetail, detailB: MSPyBentleyGeom.FacetLocationDetail, indexA: int, indexB: int) -> None
        """
        ...
    
    @property
    def detailA(self: MSPyBentleyGeom.FacetLocationDetailPair) -> MSPyBentleyGeom.FacetLocationDetail:
        ...
    @detailA.setter
    def detailA(self: MSPyBentleyGeom.FacetLocationDetailPair, arg0: MSPyBentleyGeom.FacetLocationDetail) -> None:
        ...
    
    @property
    def detailB(self: MSPyBentleyGeom.FacetLocationDetailPair) -> MSPyBentleyGeom.FacetLocationDetail:
        ...
    @detailB.setter
    def detailB(self: MSPyBentleyGeom.FacetLocationDetailPair, arg0: MSPyBentleyGeom.FacetLocationDetail) -> None:
        ...
    
    @property
    def indexA(self: MSPyBentleyGeom.FacetLocationDetailPairWithIndices) -> int:
        ...
    @indexA.setter
    def indexA(self: MSPyBentleyGeom.FacetLocationDetailPairWithIndices, arg0: int) -> None:
        ...
    
    @property
    def indexB(self: MSPyBentleyGeom.FacetLocationDetailPairWithIndices) -> int:
        ...
    @indexB.setter
    def indexB(self: MSPyBentleyGeom.FacetLocationDetailPairWithIndices, arg0: int) -> None:
        ...
    
class FacetParamMode:
    """
    Members:
    
    eFACET_PARAM_01BothAxes
    
    eFACET_PARAM_01LargerAxis
    
    eFACET_PARAM_Distance
    """

    def __init__(self: MSPyBentleyGeom.FacetParamMode, value: int) -> None:
        ...
    
    eFACET_PARAM_01BothAxes: FacetParamMode
    
    eFACET_PARAM_01LargerAxis: FacetParamMode
    
    eFACET_PARAM_Distance: FacetParamMode
    
    @property
    def name(self: handle) -> str:
        ...
    
    @property
    def value(arg0: MSPyBentleyGeom.FacetParamMode) -> int:
        ...
    
class FilletDetailArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.FilletDetailArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.FilletDetailArray, arg0: MSPyBentleyGeom.FilletDetailArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.FilletDetailArray, arg0: Iterable) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.FilletDetailArray, x: MSPyBentleyGeom.CurveCurve.FilletDetail) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.FilletDetailArray) -> None
        
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.FilletDetailArray, L: MSPyBentleyGeom.FilletDetailArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.FilletDetailArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.FilletDetailArray, i: int, x: MSPyBentleyGeom.CurveCurve.FilletDetail) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.FilletDetailArray) -> MSPyBentleyGeom.CurveCurve.FilletDetail
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.FilletDetailArray, i: int) -> MSPyBentleyGeom.CurveCurve.FilletDetail
        
        Remove and return the item at index ``i``
        """
        ...
    
class FloatRgb:
    """
    None
    """

    def __init__(self: MSPyBentleyGeom.FloatRgb) -> None:
        ...
    
    @property
    def blue(self: MSPyBentleyGeom.FloatRgb) -> float:
        ...
    @blue.setter
    def blue(self: MSPyBentleyGeom.FloatRgb, arg0: float) -> None:
        ...
    
    @property
    def green(self: MSPyBentleyGeom.FloatRgb) -> float:
        ...
    @green.setter
    def green(self: MSPyBentleyGeom.FloatRgb, arg0: float) -> None:
        ...
    
    @property
    def red(self: MSPyBentleyGeom.FloatRgb) -> float:
        ...
    @red.setter
    def red(self: MSPyBentleyGeom.FloatRgb, arg0: float) -> None:
        ...
    
class FloatRgbArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.FloatRgbArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.FloatRgbArray, arg0: MSPyBentleyGeom.FloatRgbArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.FloatRgbArray, arg0: Iterable) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.FloatRgbArray, x: MSPyBentleyGeom.FloatRgb) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.FloatRgbArray) -> None
        
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.FloatRgbArray, L: MSPyBentleyGeom.FloatRgbArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.FloatRgbArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.FloatRgbArray, i: int, x: MSPyBentleyGeom.FloatRgb) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.FloatRgbArray) -> MSPyBentleyGeom.FloatRgb
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.FloatRgbArray, i: int) -> MSPyBentleyGeom.FloatRgb
        
        Remove and return the item at index ``i``
        """
        ...
    
class GeoPoint:
    """
    None
    """

    def Init(*args, **kwargs):
        """
        Init(self: MSPyBentleyGeom.GeoPoint, longitudeValue: float, latitudeValue: float, elevationValue: float) -> None
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.GeoPoint) -> None:
        ...
    
    @property
    def elevation(self: MSPyBentleyGeom.GeoPoint) -> float:
        ...
    @elevation.setter
    def elevation(self: MSPyBentleyGeom.GeoPoint, arg0: float) -> None:
        ...
    
    @property
    def latitude(self: MSPyBentleyGeom.GeoPoint) -> float:
        ...
    @latitude.setter
    def latitude(self: MSPyBentleyGeom.GeoPoint, arg0: float) -> None:
        ...
    
    @property
    def longitude(self: MSPyBentleyGeom.GeoPoint) -> float:
        ...
    @longitude.setter
    def longitude(self: MSPyBentleyGeom.GeoPoint, arg0: float) -> None:
        ...
    
class GeoPoint2d:
    """
    None
    """

    def Init(*args, **kwargs):
        """
        Init(self: MSPyBentleyGeom.GeoPoint2d, longitudeValue: float, latitudeValue: float) -> None
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.GeoPoint2d) -> None:
        ...
    
    @property
    def latitude(self: MSPyBentleyGeom.GeoPoint2d) -> float:
        ...
    @latitude.setter
    def latitude(self: MSPyBentleyGeom.GeoPoint2d, arg0: float) -> None:
        ...
    
    @property
    def longitude(self: MSPyBentleyGeom.GeoPoint2d) -> float:
        ...
    @longitude.setter
    def longitude(self: MSPyBentleyGeom.GeoPoint2d, arg0: float) -> None:
        ...
    
class ICurvePrimitive:
    """
    None
    """

    def AddRuledSurfaceRayIntersections(*args, **kwargs):
        """
        AddRuledSurfaceRayIntersections(pickData: MSPyBentleyGeom.SolidLocationDetailArray, curveA: MSPyBentleyGeom.ICurvePrimitive, curveB: MSPyBentleyGeom.ICurvePrimitive, ray: Bentley.DRay3d) -> bool
        
        Compute intersections of a ray with a ruled surface between two
        primitves.
        
        Returns:
        false if primitives are not compatible
        
        Parameter ``[out]``:
        pickData array to receive picks
        
        Parameter ``[in]``:
        curveA first curve
        
        Parameter ``[in]``:
        curveB second curve
        
        Parameter ``[in]``:
        ray ray
        """
        ...
    
    def AddStrokes(*args, **kwargs):
        """
        AddStrokes(*args, **kwargs)
        Overloaded function.
        
        1. AddStrokes(self: MSPyBentleyGeom.ICurvePrimitive, points: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >, options: Bentley.IFacetOptions, includeStartPoint: bool = True, startFraction: float = 0.0, endFraction: float = 1.0) -> bool
        
        Stroke the curve and add points to the bvector. return true if this is
        a strokable primitive -- Line, Arc, Bspline, Spiral, Akima, or partial
        curve. false for non-strokable -- i.e. child vector or point vector.
        
        Parameter ``[in,out]``:
        points growing vector of strokes.
        
        Parameter ``[in]``:
        options stroke tolerance.
        
        Parameter ``[in]``:
        includeStartPoint if false, do NOT put start point in the output.
        
        Parameter ``[in]``:
        startFraction start of partial curve interval.
        
        Parameter ``[in]``:
        endFraction end of partial curve interval.
        
        2. AddStrokes(self: MSPyBentleyGeom.ICurvePrimitive, points: Bentley.DPoint3dDoubleUVCurveArrays, options: Bentley.IFacetOptions, startFraction: float = 0.0, endFraction: float = 1.0) -> bool
        
        Stroke the curve and add points to the bvector. return true if this is
        a strokable primitive -- Line, Arc, Bspline, Spiral, Akima, or partial
        curve. false for non-strokable -- i.e. child vector or point vector.
        
        Parameter ``[in,out]``:
        points growing vector of strokes.
        
        Parameter ``[in]``:
        options stroke tolerance.
        
        Parameter ``[in]``:
        includeStartPoint if false, do NOT put start point in the output.
        
        Parameter ``[in]``:
        startFraction start of partial curve interval.
        
        Parameter ``[in]``:
        endFraction end of partial curve interval.
        """
        ...
    
    def AdjustFractionToBreakFraction(*args, **kwargs):
        """
        AdjustFractionToBreakFraction(self: MSPyBentleyGeom.ICurvePrimitive, arg0: float, arg1: Bentley.Rounding.RoundingMode) -> tuple
        
        Move a fraction to the nearest break fraction.
        """
        ...
    
    @property
    def AkimaCurve(arg0: MSPyBentleyGeom.ICurvePrimitive) -> Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >:
        ...
    
    def AnnounceKeyPoints(*args, **kwargs):
        """
        AnnounceKeyPoints(self: MSPyBentleyGeom.ICurvePrimitive, spacePoint: Bentley.DPoint3d, collector: MSPyBentleyGeom.CurveKeyPointCollector, extend0: bool, extend1: bool) -> None
        
        Search for various keypoints (as requested by the collector) During
        recursion, extension bits are changed to false for interior points of
        paths
        """
        ...
    
    def AppendCurveBilinearPatchIntersections(*args, **kwargs):
        """
        AppendCurveBilinearPatchIntersections(self: MSPyBentleyGeom.ICurvePrimitive, patch: Bentley.DBilinearPatch3d, intersections: MSPyBentleyGeom.CurveAndSolidLocationDetailArray) -> None
        
        Return intesections of curve primitive with a bilinear patch
        """
        ...
    
    def AppendCurvePlaneIntersections(*args, **kwargs):
        """
        AppendCurvePlaneIntersections(*args, **kwargs)
        Overloaded function.
        
        1. AppendCurvePlaneIntersections(self: MSPyBentleyGeom.ICurvePrimitive, plane: Bentley.DPlane3d, intersections: MSPyBentleyGeom.CurveLocationDetailPairArray, tolerance: float = 0.0) -> None
        
        Return vector of intersections with a plane. Single point intersection
        appears as a CurveLocationDetailPair with identical locations for both
        parts of the pair (SameCurveAndFraction) Curve-on-plane appears as
        CurveLocationDetailPair with curve,fraction data for start and end of
        on-plane sections.
        
        Parameter ``[in]``:
        plane
        
        Parameter ``[out]``:
        intersections intersection details
        
        Parameter ``[in]``:
        tolerance for on-plane decisions. If 0, a tolerance is computed
        based on the coordinates in the curve.
        
        2. AppendCurvePlaneIntersections(self: MSPyBentleyGeom.ICurvePrimitive, plane: Bentley.DPlane3dByVectors, bounded: Bentley.UVBoundarySelect, intersections: MSPyBentleyGeom.CurveAndSolidLocationDetailArray) -> None
        
        Return vector of intersections with a plane. Single point intersection
        appears as a CurveLocationDetailPair with identical locations for both
        parts of the pair (SameCurveAndFraction) Curve-on-plane appears as
        CurveLocationDetailPair with curve,fraction data for start and end of
        on-plane sections.
        
        Parameter ``[in]``:
        plane
        
        Parameter ``[out]``:
        intersections intersection details
        
        Parameter ``[in]``:
        tolerance for on-plane decisions. If 0, a tolerance is computed
        based on the coordinates in the curve.
        """
        ...
    
    def AppendCurveRangeIntersections(*args, **kwargs):
        """
        AppendCurveRangeIntersections(self: MSPyBentleyGeom.ICurvePrimitive, range: MSPyBentleyGeom.LocalRange, intersections: Bentley.Bstdcxx.bvector<Bentley.PartialCurveDetail,Bentley.BentleyAllocator<Bentley.PartialCurveDetail> >) -> None
        
        Return intesections of curve primitive with a range box.
        """
        ...
    
    @property
    def Arc(arg0: MSPyBentleyGeom.ICurvePrimitive) -> Bentley.DEllipse3d:
        ...
    
    @property
    def BsplineCurve(arg0: MSPyBentleyGeom.ICurvePrimitive) -> Bentley.RefCountedMSBsplineCurve:
        ...
    
    @property
    def ChildCurveVector(arg0: MSPyBentleyGeom.ICurvePrimitive) -> Bentley.CurveVector:
        ...
    
    def Clone(*args, **kwargs):
        """
        Clone(self: MSPyBentleyGeom.ICurvePrimitive) -> MSPyBentleyGeom.ICurvePrimitive
        
        Return a deep copy
        """
        ...
    
    def CloneAsSingleOffsetPrimitiveXY(*args, **kwargs):
        """
        CloneAsSingleOffsetPrimitiveXY(self: MSPyBentleyGeom.ICurvePrimitive, options: MSPyBentleyGeom.CurveOffsetOptions) -> MSPyBentleyGeom.ICurvePrimitive
        
        Return an offset primitive. This operates only on single primtives
        that can offset to another single primitive.
        
        Parameter ``[in]``:
        options contains tolerance for bspline and ellipse offset.
        """
        ...
    
    def CloneBetweenFractions(*args, **kwargs):
        """
        CloneBetweenFractions(self: MSPyBentleyGeom.ICurvePrimitive, fractionA: float, fractionB: float, allowExtrapolation: bool) -> MSPyBentleyGeom.ICurvePrimitive
        
        Return a copy of a subset. The fraction interval may be high to low;
        fraction clamping respects the interval direction. return null pointer
        if fraction clamping resulted in zero-length interval.
        
        Parameter ``[in]``:
        fractionA start of returned invterval.
        
        Parameter ``[in]``:
        fractionB end of returned interval.
        
        Parameter ``[in]``:
        allowExtrapolation If false, out of bounds values are clamped.
        """
        ...
    
    def CloneComponent(*args, **kwargs):
        """
        CloneComponent(self: MSPyBentleyGeom.ICurvePrimitive, componentIndex: int) -> MSPyBentleyGeom.ICurvePrimitive
        
        Return a copy of a component. Component index only applies to
        linestring. Any invalid index clones entire linestring. All others are
        complete Clone.
        """
        ...
    
    def CloneDereferenced(*args, **kwargs):
        """
        CloneDereferenced(self: MSPyBentleyGeom.ICurvePrimitive, allowExtrapolation: bool = False, maximumDeref: bool = True) -> MSPyBentleyGeom.ICurvePrimitive
        
        Return a (deep) clone with all partial curves replaced by complete
        curves.
        
        Parameter ``[in]``:
        maximumDeref true to recurse through all steps of PartialCurve
        chains
        
        Parameter ``[in]``:
        allowExtrapolation true to allow extension before/after endpoints.
        """
        ...
    
    def ClosestPointBounded(*args, **kwargs):
        """
        ClosestPointBounded(*args, **kwargs)
        Overloaded function.
        
        1. ClosestPointBounded(self: MSPyBentleyGeom.ICurvePrimitive, spacePoint: Bentley.DPoint3d) -> tuple
        
        Find the closest point to a space point. return false if not a simple
        curve. (EXAMPLE:ChildCurveVector)
        
        Parameter ``[in]``:
        spacePoint reference point.
        
        Parameter ``[out]``:
        fraction fractional position at closest point.
        
        Parameter ``[out]``:
        curvePoint coordinates on curve
        
        2. ClosestPointBounded(self: MSPyBentleyGeom.ICurvePrimitive, spacePoint: Bentley.DPoint3d, location: MSPyBentleyGeom.CurveLocationDetail, extend0: bool, extend1: bool) -> bool
        
        Find the closest point to a space point. return false if not a simple
        curve. (EXAMPLE:ChildCurveVector)
        
        Parameter ``[in]``:
        spacePoint reference point.
        
        Parameter ``[out]``:
        fraction fractional position at closest point.
        
        Parameter ``[out]``:
        curvePoint coordinates on curve
        
        3. ClosestPointBounded(self: MSPyBentleyGeom.ICurvePrimitive, spacePoint: Bentley.DPoint3d, location: MSPyBentleyGeom.CurveLocationDetail) -> bool
        
        Find the closest point to a space point. return false if not a simple
        curve. (EXAMPLE:ChildCurveVector)
        
        Parameter ``[in]``:
        spacePoint reference point.
        
        Parameter ``[out]``:
        fraction fractional position at closest point.
        
        Parameter ``[out]``:
        curvePoint coordinates on curve
        """
        ...
    
    def ClosestPointBoundedXY(*args, **kwargs):
        """
        ClosestPointBoundedXY(*args, **kwargs)
        Overloaded function.
        
        1. ClosestPointBoundedXY(self: MSPyBentleyGeom.ICurvePrimitive, spacePoint: Bentley.DPoint3d, worldToLocal: Bentley.DMatrix4d, location: MSPyBentleyGeom.CurveLocationDetail) -> bool
        
        Find closest point, measuring in xy plane after applying a (possibly
        perspective) transform to both the curve and space point.
        
        Parameter ``[in]``:
        spacePoint reference point.
        
        Parameter ``[in]``:
        worldToLocal optional transform.
        
        Parameter ``[out]``:
        location details of closest point. See ClosestPointBounded.
        
        2. ClosestPointBoundedXY(self: MSPyBentleyGeom.ICurvePrimitive, spacePoint: Bentley.DPoint3d, worldToLocal: Bentley.DMatrix4d, location: MSPyBentleyGeom.CurveLocationDetail, entend0: bool, extend1: bool) -> bool
        
        Find closest point, measuring in xy plane after applying a (possibly
        perspective) transform to both the curve and space point.
        
        Parameter ``[in]``:
        spacePoint reference point.
        
        Parameter ``[in]``:
        worldToLocal optional transform.
        
        Parameter ``[out]``:
        location details of closest point. See ClosestPointBounded.
        """
        ...
    
    def ComponentFractionToPoint(*args, **kwargs):
        """
        ComponentFractionToPoint(*args, **kwargs)
        Overloaded function.
        
        1. ComponentFractionToPoint(self: MSPyBentleyGeom.ICurvePrimitive, componentIndex: int, f: float, point: Bentley.DPoint3d) -> bool
        
        Evaluate curve fractional position within the parameter space of a
        component. (For anything except a linestring, componentIndex is
        ignored and this is equivalent to FractionToPoint) return false if
        this is not a parameterized curve (EXAMPLE:A ChildCurveVector)
        
        Parameter ``[in]``:
        componentIndex index of the component to evaluate.
        
        Parameter ``[in]``:
        f evaluation fraction.
        
        Parameter ``[out]``:
        point point on curve.
        
        2. ComponentFractionToPoint(self: MSPyBentleyGeom.ICurvePrimitive, componentIndex: int, f: float, point: Bentley.DPoint3d, tangent: Bentley.DVec3d) -> bool
        
        Evaluate curve fractional position within the parameter space of a
        component. (For anything except a linestring, componentIndex is
        ignored and this is equivalent to FractionToPoint) return false if
        this is not a parameterized curve (EXAMPLE:A ChildCurveVector)
        
        Parameter ``[in]``:
        componentIndex index of the component to evaluate.
        
        Parameter ``[in]``:
        f evaluation fraction.
        
        Parameter ``[out]``:
        point point on curve.
        """
        ...
    
    def CreateAkimaCurve(*args, **kwargs):
        """
        CreateAkimaCurve(points: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >) -> MSPyBentleyGeom.ICurvePrimitive
        
        Allocate and fill a new akima curve
        
        Parameter ``[in]``:
        points akima control points to copy into the primitive. First two
        and final two points are slope end condition controls. Others are
        pass-through.
        
        Parameter ``[in]``:
        nPoints control point count.
        """
        ...
    
    def CreateArc(*args, **kwargs):
        """
        CreateArc(ellipse: Bentley.DEllipse3d) -> MSPyBentleyGeom.ICurvePrimitive
        
        Allocate and fill a new elliptic arc
        
        Parameter ``[in]``:
        ellipse source ellipse.
        """
        ...
    
    def CreateAustralianRailCorpBearingRadiusLengthRadius(*args, **kwargs):
        """
        CreateAustralianRailCorpBearingRadiusLengthRadius(startPoint: Bentley.DPoint3d, startRadians: float, startRadius: float, targetLength: float, endRadius: float) -> MSPyBentleyGeom.ICurvePrimitive
        """
        ...
    
    def CreateBsplineCurve(*args, **kwargs):
        """
        CreateBsplineCurve(*args, **kwargs)
        Overloaded function.
        
        1. CreateBsplineCurve(curve: Bentley.MSBsplineCurve) -> MSPyBentleyGeom.ICurvePrimitive
        
        Allocate and fill a new bspline curve
        
        Parameter ``[in]``:
        curve source curve. A copy (clone, repeat allocation of memory) of
        the curve is placed into the new object. Caller is still
        responsible for freeing the input curve.
        
        2. CreateBsplineCurve(curve: Bentley.RefCountedMSBsplineCurve) -> MSPyBentleyGeom.ICurvePrimitive
        
        Allocate and fill a new bspline curve
        
        Parameter ``[in]``:
        curve source curve. A copy (clone, repeat allocation of memory) of
        the curve is placed into the new object. Caller is still
        responsible for freeing the input curve.
        """
        ...
    
    def CreateBsplineCurveSwapFromSource(*args, **kwargs):
        """
        CreateBsplineCurveSwapFromSource(curve: Bentley.MSBsplineCurve) -> MSPyBentleyGeom.ICurvePrimitive
        
        Allocate and fill a new bspline curve
        
        Parameter ``[in]``:
        curve source curve. Bits (including pointers) are copied to the
        CurvePrimtive. source curve is zeroed -- caller has no " free "
        responsibilities.
        """
        ...
    
    def CreateChildCurveVector(*args, **kwargs):
        """
        CreateChildCurveVector(source: Bentley.CurveVector) -> MSPyBentleyGeom.ICurvePrimitive
        
        Create a curve primitive with (ref coutnted pointer to preexisting
        refcounted child.
        """
        ...
    
    def CreateChildCurveVector_CopyFromSource(*args, **kwargs):
        """
        CreateChildCurveVector_CopyFromSource(source: Bentley.CurveVector) -> MSPyBentleyGeom.ICurvePrimitive
        
        Create child vector, making deep copy of the source.
        """
        ...
    
    def CreateChildCurveVector_SwapFromSource(*args, **kwargs):
        """
        CreateChildCurveVector_SwapFromSource(source: Bentley.CurveVector) -> MSPyBentleyGeom.ICurvePrimitive
        
        Create a child vector; contents of source are taken, source itself is
        cleared.
        """
        ...
    
    def CreateInterpolationBetweenCurves(*args, **kwargs):
        """
        CreateInterpolationBetweenCurves(curveA: MSPyBentleyGeom.ICurvePrimitive, fraction: float, curveB: MSPyBentleyGeom.ICurvePrimitive) -> MSPyBentleyGeom.ICurvePrimitive
        
        Create a curve that is interpolated between parents.
        
        Parameter ``[in]``:
        curveA first curve
        
        Parameter ``[in]``:
        curveB second curve
        
        Parameter ``[in]``:
        fraction interpolation position.
        
        Returns:
        null curve pointer if curves are not compatible for interpolation.
        """
        ...
    
    def CreateInterpolationCurve(*args, **kwargs):
        """
        CreateInterpolationCurve(fitCurve: Bentley.MSInterpolationCurve) -> MSPyBentleyGeom.ICurvePrimitive
        
        Allocate and fill a new interpolation curve
        
        Parameter ``[in]``:
        fitCurve source curve. Data is COPIED into the new object. Caller
        is still responsible for freeing the input fitCurve.
        """
        ...
    
    def CreateInterpolationCurveSwapFromSource(*args, **kwargs):
        """
        CreateInterpolationCurveSwapFromSource(fitCurve: Bentley.MSInterpolationCurve) -> MSPyBentleyGeom.ICurvePrimitive
        
        Allocate and fill a new interpolation curve
        
        Parameter ``[in]``:
        fitCurve source curve. Data is swapped into the curve. input
        fitCurve is zeroed.
        """
        ...
    
    def CreateLine(*args, **kwargs):
        """
        CreateLine(segment: Bentley.DSegment3d) -> MSPyBentleyGeom.ICurvePrimitive
        
        Allocate and fill a new line segemnt.
        
        Parameter ``[in]``:
        segment source segment.
        """
        ...
    
    def CreateLineString(*args, **kwargs):
        """
        CreateLineString(points: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >) -> MSPyBentleyGeom.ICurvePrimitive
        
        Allocate and fill a new linestring
        
        Parameter ``[in]``:
        points source coordinates.
        
        Parameter ``[in]``:
        nPoints point count.
        """
        ...
    
    def CreatePartialCurve(*args, **kwargs):
        """
        CreatePartialCurve(parentCurve: MSPyBentleyGeom.ICurvePrimitive, fraction0: float, fraction1: float, index: int = 0) -> MSPyBentleyGeom.ICurvePrimitive
        
        Allocate and fill a reference to a portion of a parent curve.
        
        Parameter ``[in]``:
        parentCurve pointer to another curve.
        
        Parameter ``[in]``:
        fraction0 start of active portion of parent.
        
        Parameter ``[in]``:
        fraction1 end of active portion of parent.
        
        Parameter ``[in]``:
        index application data.
        
        Remark:
        fraction0 and fraction1 may be in forward or reverse relationship.
        """
        ...
    
    def CreatePointString(*args, **kwargs):
        """
        CreatePointString(points: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >) -> MSPyBentleyGeom.ICurvePrimitive
        
        Allocate and fill a new point string
        
        Parameter ``[in]``:
        points coordinates to copy into the primitive
        
        Parameter ``[in]``:
        nPoints number of points
        """
        ...
    
    def CreatePseudoSpiralPointBearingRadiusLengthRadius(*args, **kwargs):
        """
        CreatePseudoSpiralPointBearingRadiusLengthRadius(*args, **kwargs)
        Overloaded function.
        
        1. CreatePseudoSpiralPointBearingRadiusLengthRadius(typeCode: int, startPoint: Bentley.DPoint3d, startRadians: float, radiusA: float, lengthAB: float, radiusB: float) -> MSPyBentleyGeom.ICurvePrimitive
        
        Construct a spiral with start radius, spiral length, and end radius.
        ul> li> The spiral is paralllel to the xy plane. li> This is a special
        construction for " cubic " approximations. li> The constructed spiral is
        a fractional subset of another spiral that includes its inflection
        point (which may be outside the active fractional subset). ul>
        
        2. CreatePseudoSpiralPointBearingRadiusLengthRadius(typeCode: int, startPoint: Bentley.DPoint3d, startRadians: float, radiusA: float, lengthAB: float, radiusB: float, startFraction: float, endFraction: float) -> MSPyBentleyGeom.ICurvePrimitive
        
        Construct a spiral with start radius, spiral length, and end radius.
        ul> li> The spiral is paralllel to the xy plane. li> This is a special
        construction for " cubic " approximations. li> The constructed spiral is
        a fractional subset of another spiral that includes its inflection
        point (which may be outside the active fractional subset). ul>
        """
        ...
    
    def CreatePseudolSpiralWithTrueRadiusLengthRadius(*args, **kwargs):
        """
        CreatePseudolSpiralWithTrueRadiusLengthRadius(transitionType: int, startPoint: Bentley.DPoint3d, startRadians: float, startRadius: float, targetLength: float, endRadius: float) -> MSPyBentleyGeom.ICurvePrimitive
        """
        ...
    
    def CreateRectangle(*args, **kwargs):
        """
        CreateRectangle(x0: float, y0: float, x1: float, y1: float, z: float, areaSignPreference: int = 0) -> MSPyBentleyGeom.ICurvePrimitive
        
        Create a rectangle from xy corners.
        
        Parameter ``[in]``:
        x0 start point x coordinate
        
        Parameter ``[in]``:
        y0 start point y coordinate
        
        Parameter ``[in]``:
        x1 opposite corner x coordinate
        
        Parameter ``[in]``:
        y1 opposite corner y coordinate
        
        Parameter ``[in]``:
        z z value for all points.
        
        Parameter ``[in]``:
        areaSignPreference is one of
        
        * any positive integer to force positive xy areLa.
        
        * 0 to take order (x0,y0)(x1,y0),(x1,y1),(x0,y1)
        
        * any negative integer to force negative xy area.
        """
        ...
    
    def CreateSpiral(*args, **kwargs):
        """
        CreateSpiral(spiral: Bentley.DSpiral2dBase, frame: Bentley.Transform, fractionA: float, fractionB: float) -> MSPyBentleyGeom.ICurvePrimitive
        
        Allocate and fill a spiral curve.
        
        Parameter ``[in]``:
        spiral spiral structure (to be cloned -- caller still responsible
        for deallocation)
        
        Parameter ``[in]``:
        frame placement frame
        
        Parameter ``[in]``:
        fractionA start fraction for active portion of curve
        
        Parameter ``[in]``:
        fractionB end fraction for active portion of curve
        """
        ...
    
    def CreateSpiralBearingCurvatureBearingCurvature(*args, **kwargs):
        """
        CreateSpiralBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float, frame: Bentley.Transform, fractionA: float, fractionB: float) -> MSPyBentleyGeom.ICurvePrimitive
        
        Allocate and fill a spiral curve.
        
        Parameter ``[in]``:
        startRadians bearing at start
        
        Parameter ``[in]``:
        startCurvature curvature at start (or 0 of flat)
        
        Parameter ``[in]``:
        endRadians bearing at end
        
        Parameter ``[in]``:
        endCurvature curvature at end (or 0 if flat)
        
        Parameter ``[in]``:
        transitionType (see DSpiral2dBase)
        
        Parameter ``[in]``:
        frame placement frame
        
        Parameter ``[in]``:
        fractionA start fraction for active portion of curve
        
        Parameter ``[in]``:
        fractionB end fraction for active portion of curve
        """
        ...
    
    def CreateSpiralBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        CreateSpiralBearingCurvatureLengthCurvature(*args, **kwargs)
        Overloaded function.
        
        1. CreateSpiralBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float, frame: Bentley.Transform, fractionA: float, fractionB: float, extraData: MSPyBentley.DoubleArray) -> MSPyBentleyGeom.ICurvePrimitive
        
        Allocate and fill a spiral curve.
        
        Parameter ``[in]``:
        startRadians bearing at start
        
        Parameter ``[in]``:
        startCurvature curvature at start (or 0 if flat)
        
        Parameter ``[in]``:
        length length along spiral
        
        Parameter ``[in]``:
        endCurvature curvature at end (or 0 if flat)
        
        Parameter ``[in]``:
        transitionType (see DSpiral2dBase)
        
        Parameter ``[in]``:
        frame placement frame
        
        Parameter ``[in]``:
        fractionA start fraction for active portion of curve
        
        Parameter ``[in]``:
        fractionB end fraction for active portion of curve @praam [in]
        extraData type-specific extra data.
        
        2. CreateSpiralBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float, frame: Bentley.Transform, fractionA: float, fractionB: float) -> MSPyBentleyGeom.ICurvePrimitive
        
        Allocate and fill a spiral curve.
        
        Parameter ``[in]``:
        startRadians bearing at start
        
        Parameter ``[in]``:
        startCurvature curvature at start (or 0 if flat)
        
        Parameter ``[in]``:
        length length along spiral
        
        Parameter ``[in]``:
        endCurvature curvature at end (or 0 if flat)
        
        Parameter ``[in]``:
        transitionType (see DSpiral2dBase)
        
        Parameter ``[in]``:
        frame placement frame
        
        Parameter ``[in]``:
        fractionA start fraction for active portion of curve
        
        Parameter ``[in]``:
        fractionB end fraction for active portion of curve @praam [in]
        extraData type-specific extra data.
        """
        ...
    
    def CreateSpiralBearingRadiusBearingRadius(*args, **kwargs):
        """
        CreateSpiralBearingRadiusBearingRadius(transitionType: int, startRadians: float, startRadius: float, endRadians: float, endRadius: float, frame: Bentley.Transform, fractionA: float, fractionB: float, extraData: MSPyBentley.DoubleArray) -> MSPyBentleyGeom.ICurvePrimitive
        
        Allocate and fill a spiral curve.
        
        Parameter ``[in]``:
        startRadians bearing at start
        
        Parameter ``[in]``:
        startRadius radius at start (or 0 of flat)
        
        Parameter ``[in]``:
        endRadians bearing at end
        
        Parameter ``[in]``:
        endRadius radius at end (or 0 if flat)
        
        Parameter ``[in]``:
        transitionType (see DSpiral2dBase)
        
        Parameter ``[in]``:
        frame placement frame
        
        Parameter ``[in]``:
        fractionA start fraction for active portion of curve
        
        Parameter ``[in]``:
        fractionB end fraction for active portion of curve @praam [in]
        extraData type-specific extra data.
        """
        ...
    
    def CreateSpiralBearingRadiusLengthRadius(*args, **kwargs):
        """
        CreateSpiralBearingRadiusLengthRadius(*args, **kwargs)
        Overloaded function.
        
        1. CreateSpiralBearingRadiusLengthRadius(transitionType: int, startRadians: float, startRadius: float, length: float, endRadius: float, frame: Bentley.Transform, fractionA: float, fractionB: float, extraData: MSPyBentley.DoubleArray) -> MSPyBentleyGeom.ICurvePrimitive
        
        Allocate and fill a spiral curve.
        
        Parameter ``[in]``:
        startRadians bearing at start
        
        Parameter ``[in]``:
        startRadius radius at start (or 0 if flat)
        
        Parameter ``[in]``:
        length length along spiral
        
        Parameter ``[in]``:
        endRadius radius at end (or 0 if flat)
        
        Parameter ``[in]``:
        transitionType (see DSpiral2dBase)
        
        Parameter ``[in]``:
        frame placement frame
        
        Parameter ``[in]``:
        fractionA start fraction for active portion of curve
        
        Parameter ``[in]``:
        fractionB end fraction for active portion of curve @praam [in]
        extraData type-specific extra data.
        
        2. CreateSpiralBearingRadiusLengthRadius(transitionType: int, startRadians: float, startRadius: float, length: float, endRadius: float, frame: Bentley.Transform, fractionA: float, fractionB: float) -> MSPyBentleyGeom.ICurvePrimitive
        
        Allocate and fill a spiral curve.
        
        Parameter ``[in]``:
        startRadians bearing at start
        
        Parameter ``[in]``:
        startRadius radius at start (or 0 if flat)
        
        Parameter ``[in]``:
        length length along spiral
        
        Parameter ``[in]``:
        endRadius radius at end (or 0 if flat)
        
        Parameter ``[in]``:
        transitionType (see DSpiral2dBase)
        
        Parameter ``[in]``:
        frame placement frame
        
        Parameter ``[in]``:
        fractionA start fraction for active portion of curve
        
        Parameter ``[in]``:
        fractionB end fraction for active portion of curve @praam [in]
        extraData type-specific extra data.
        """
        ...
    
    class CurvePrimitiveMarkerBit:
        """
        Members:
        
        eCURVE_PRIMITIVE_BIT_GapCurve
        
        eCURVE_PRIMITIVE_BIT_AllApplicationBits
        """
    
        def __init__(self: MSPyBentleyGeom.ICurvePrimitive.CurvePrimitiveMarkerBit, value: int) -> None:
            ...
        
        eCURVE_PRIMITIVE_BIT_AllApplicationBits: CurvePrimitiveMarkerBit
        
        eCURVE_PRIMITIVE_BIT_GapCurve: CurvePrimitiveMarkerBit
        
        @property
        def name(self: handle) -> str:
            ...
        
        @property
        def value(arg0: MSPyBentleyGeom.ICurvePrimitive.CurvePrimitiveMarkerBit) -> int:
            ...
        
    @property
    def CurvePrimitiveType(arg0: MSPyBentleyGeom.ICurvePrimitive) -> MSPyBentleyGeom.ICurvePrimitive.CurvePrimitiveType:
        ...
    
    def FastLength(*args, **kwargs):
        """
        FastLength(self: MSPyBentleyGeom.ICurvePrimitive) -> tuple
        
        Compute a fast approximation of curve length. return false if no
        measurable curves.
        
        Parameter ``[out]``:
        length curve length. For ChildCurveVector, length of contained
        curves is summed.
        """
        ...
    
    def FastMaxAbs(*args, **kwargs):
        """
        FastMaxAbs(self: MSPyBentleyGeom.ICurvePrimitive) -> float
        
        Return a representative large coordinate. This is not required to be a
        true range limit. For instance, a max abs of a bspline pole range is
        acceptable.
        """
        ...
    
    def FractionToFrenetFrame(*args, **kwargs):
        """
        FractionToFrenetFrame(*args, **kwargs)
        Overloaded function.
        
        1. FractionToFrenetFrame(self: MSPyBentleyGeom.ICurvePrimitive, f: float, frame: Bentley.Transform) -> bool
        
        Evaluate curve point at fractional position within its parameter
        space.
        
        Returns:
        false if this is not a parameterized curve (EXAMPLE:A
        ChildCurveVector)
        
        Parameter ``[in]``:
        f evaluation fraction.
        
        Parameter ``[out]``:
        frame Coordinate frame with origin on curve, x direction along
        curve, y direction in curvature plane, z direction perpendicular.
        
        2. FractionToFrenetFrame(self: MSPyBentleyGeom.ICurvePrimitive, f: float, frame: Bentley.Transform) -> tuple
        
        Evaluate curve point at fractional position within its parameter
        space.
        
        Returns:
        false if this is not a parameterized curve (EXAMPLE:A
        ChildCurveVector)
        
        Parameter ``[in]``:
        f evaluation fraction.
        
        Parameter ``[out]``:
        frame Coordinate frame with origin on curve, x direction along
        curve, y direction in curvature plane, z direction perpendicular.
        
        3. FractionToFrenetFrame(self: MSPyBentleyGeom.ICurvePrimitive, f: float) -> Bentley.ValidatedValue<Bentley.Transform>
        
        Evaluate curve point at fractional position within its parameter
        space.
        
        Returns:
        false if this is not a parameterized curve (EXAMPLE:A
        ChildCurveVector)
        
        Parameter ``[in]``:
        f evaluation fraction.
        
        Parameter ``[out]``:
        frame Coordinate frame with origin on curve, x direction along
        curve, y direction in curvature plane, z direction perpendicular.
        """
        ...
    
    def FractionToPoint(*args, **kwargs):
        """
        FractionToPoint(*args, **kwargs)
        Overloaded function.
        
        1. FractionToPoint(self: MSPyBentleyGeom.ICurvePrimitive, f: float, point: Bentley.DPoint3d) -> bool
        
        Evaluate curve fractional position within its parameter space. return
        false if this is not a parameterized curve (EXAMPLE:A
        ChildCurveVector)
        
        Parameter ``[in]``:
        f evaluation fraction.
        
        Parameter ``[out]``:
        point point on curve.
        
        2. FractionToPoint(self: MSPyBentleyGeom.ICurvePrimitive, f: float, point: Bentley.DPoint3d, tangent: Bentley.DVec3d) -> bool
        
        Evaluate curve fractional position within its parameter space. return
        false if this is not a parameterized curve (EXAMPLE:A
        ChildCurveVector)
        
        Parameter ``[in]``:
        f evaluation fraction.
        
        Parameter ``[out]``:
        point point on curve.
        
        3. FractionToPoint(self: MSPyBentleyGeom.ICurvePrimitive, f: float, ray: Bentley.DRay3d) -> bool
        
        Evaluate curve fractional position within its parameter space. return
        false if this is not a parameterized curve (EXAMPLE:A
        ChildCurveVector)
        
        Parameter ``[in]``:
        f evaluation fraction.
        
        Parameter ``[out]``:
        point point on curve.
        
        4. FractionToPoint(self: MSPyBentleyGeom.ICurvePrimitive, f: float, detail: MSPyBentleyGeom.CurveLocationDetail) -> bool
        
        Evaluate curve fractional position within its parameter space. return
        false if this is not a parameterized curve (EXAMPLE:A
        ChildCurveVector)
        
        Parameter ``[in]``:
        f evaluation fraction.
        
        Parameter ``[out]``:
        point point on curve.
        
        5. FractionToPoint(self: MSPyBentleyGeom.ICurvePrimitive, f: float, point: Bentley.DPoint3d, tangent: Bentley.DVec3d, derivate2: Bentley.DVec3d) -> bool
        
        Evaluate curve fractional position within its parameter space. return
        false if this is not a parameterized curve (EXAMPLE:A
        ChildCurveVector)
        
        Parameter ``[in]``:
        f evaluation fraction.
        
        Parameter ``[out]``:
        point point on curve.
        
        6. FractionToPoint(self: MSPyBentleyGeom.ICurvePrimitive, f: float, point: Bentley.DPoint3d, tangent: Bentley.DVec3d, derivate2: Bentley.DVec3d, derivate3: Bentley.DVec3d) -> bool
        
        Evaluate curve fractional position within its parameter space. return
        false if this is not a parameterized curve (EXAMPLE:A
        ChildCurveVector)
        
        Parameter ``[in]``:
        f evaluation fraction.
        
        Parameter ``[out]``:
        point point on curve.
        """
        ...
    
    def FractionToPointWithTwoSidedDerivative(*args, **kwargs):
        """
        FractionToPointWithTwoSidedDerivative(self: MSPyBentleyGeom.ICurvePrimitive, f: float, point: Bentley.DPoint3d, derivativeA: Bentley.DVec3d, derivativeB: Bentley.DVec3d) -> bool
        
        Evaluate curve fractional position within its parameter space.
        
        * On a smooth curve, incoming and outgoing derivatives will be
        identical.
        
        * Incoming and outgoing derivatives can differ at linestring interior
        points and bspline knots.
        
        return false if this is not a parameterized curve (EXAMPLE:A
        ChildCurveVector)
        
        Parameter ``[in]``:
        f evaluation fraction.
        
        Parameter ``[out]``:
        point point on curve.
        
        Parameter ``[out]``:
        derivativeA first derivative with respect to the fractional
        coordinate, taken on the inbound (lower parameter) side of the
        parameter.
        
        Parameter ``[out]``:
        derivativeB first derivative with respect to the fractional
        coordinate, taken on the outbound (higher parameter) side of the
        parameter.
        """
        ...
    
    def GetAkimaCurve(*args, **kwargs):
        """
        GetAkimaCurve(self: MSPyBentleyGeom.ICurvePrimitive) -> Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >
        """
        ...
    
    def GetArc(*args, **kwargs):
        """
        GetArc(self: MSPyBentleyGeom.ICurvePrimitive) -> Bentley.DEllipse3d
        """
        ...
    
    def GetBreakFraction(*args, **kwargs):
        """
        GetBreakFraction(self: MSPyBentleyGeom.ICurvePrimitive, arg0: int) -> tuple
        
        Return the fractional postion of a point where the curve's continuity
        has a break.
        """
        ...
    
    def GetBsplineCurve(*args, **kwargs):
        """
        GetBsplineCurve(self: MSPyBentleyGeom.ICurvePrimitive) -> Bentley.RefCountedMSBsplineCurve
        """
        ...
    
    def GetChildCurveVector(*args, **kwargs):
        """
        GetChildCurveVector(self: MSPyBentleyGeom.ICurvePrimitive) -> Bentley.CurveVector
        """
        ...
    
    def GetCurvePrimitiveType(*args, **kwargs):
        """
        GetCurvePrimitiveType(self: MSPyBentleyGeom.ICurvePrimitive) -> MSPyBentleyGeom.ICurvePrimitive.CurvePrimitiveType
        
        Return the integer type code for the curve primitive type.
        """
        ...
    
    def GetId(*args, **kwargs):
        """
        GetId(self: MSPyBentleyGeom.ICurvePrimitive) -> Bentley.CurvePrimitiveId
        """
        ...
    
    def GetIntTag(*args, **kwargs):
        """
        GetIntTag(self: MSPyBentleyGeom.ICurvePrimitive) -> int
        
        Get the Int64 tag (cast to int)
        """
        ...
    
    def GetInterpolationCurve(*args, **kwargs):
        """
        GetInterpolationCurve(self: MSPyBentleyGeom.ICurvePrimitive) -> Bentley.MSInterpolationCurve
        """
        ...
    
    def GetLine(*args, **kwargs):
        """
        GetLine(self: MSPyBentleyGeom.ICurvePrimitive) -> Bentley.DSegment3d
        """
        ...
    
    def GetLineString(*args, **kwargs):
        """
        GetLineString(self: MSPyBentleyGeom.ICurvePrimitive) -> Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >
        """
        ...
    
    def GetMSBspineCurvePtr(*args, **kwargs):
        """
        GetMSBspineCurvePtr(self: MSPyBentleyGeom.ICurvePrimitive, fraction0: float = 0.0, fraction1: float = 1.0) -> Bentley.RefCountedMSBsplineCurve
        """
        ...
    
    def GetMarkerBit(*args, **kwargs):
        """
        GetMarkerBit(self: MSPyBentleyGeom.ICurvePrimitive, selector: MSPyBentleyGeom.ICurvePrimitive.CurvePrimitiveMarkerBit) -> bool
        
        Ask if specified marker bit is on or off
        """
        ...
    
    def GetPartialCurveDetail(*args, **kwargs):
        """
        GetPartialCurveDetail(self: MSPyBentleyGeom.ICurvePrimitive) -> MSPyBentleyGeom.PartialCurveDetail
        """
        ...
    
    def GetPointString(*args, **kwargs):
        """
        GetPointString(self: MSPyBentleyGeom.ICurvePrimitive) -> Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >
        """
        ...
    
    def GetProxyBsplineCurve(*args, **kwargs):
        """
        GetProxyBsplineCurve(self: MSPyBentleyGeom.ICurvePrimitive) -> Bentley.RefCountedMSBsplineCurve
        """
        ...
    
    def GetRange(*args, **kwargs):
        """
        GetRange(*args, **kwargs)
        Overloaded function.
        
        1. GetRange(self: MSPyBentleyGeom.ICurvePrimitive, range: Bentley.DRange3d) -> bool
        
        Return range of the primitive.
        
        2. GetRange(self: MSPyBentleyGeom.ICurvePrimitive, range: Bentley.DRange3d, transform: Bentley.Transform) -> bool
        
        Return range of the primitive.
        """
        ...
    
    def GetSpiralPlacement(*args, **kwargs):
        """
        GetSpiralPlacement(self: MSPyBentleyGeom.ICurvePrimitive) -> Bentley.DSpiral2dPlacement
        """
        ...
    
    def GetStartEnd(*args, **kwargs):
        """
        GetStartEnd(*args, **kwargs)
        Overloaded function.
        
        1. GetStartEnd(self: MSPyBentleyGeom.ICurvePrimitive, pointA: Bentley.DPoint3d, pointB: Bentley.DPoint3d) -> bool
        
        return the start and end points of the curve
        
        Parameter ``[out]``:
        pointA start point
        
        Parameter ``[out]``:
        pointB end point
        
        Remark:
        For ChildCurveVector, the first and last component endpoints are
        determined.
        
        2. GetStartEnd(self: MSPyBentleyGeom.ICurvePrimitive, pointA: Bentley.DPoint3d, pointB: Bentley.DPoint3d, unitTangentA: Bentley.DVec3d, unitTangentB: Bentley.DVec3d) -> bool
        
        return the start and end points of the curve
        
        Parameter ``[out]``:
        pointA start point
        
        Parameter ``[out]``:
        pointB end point
        
        Remark:
        For ChildCurveVector, the first and last component endpoints are
        determined.
        """
        ...
    
    def GetStartPoint(*args, **kwargs):
        """
        GetStartPoint(self: MSPyBentleyGeom.ICurvePrimitive, point: Bentley.DPoint3d) -> bool
        
        Return first primitive in a deep search.
        
        Parameter ``[out]``:
        point start point.
        """
        ...
    
    def GetStrokeCount(*args, **kwargs):
        """
        GetStrokeCount(self: MSPyBentleyGeom.ICurvePrimitive, options: Bentley.IFacetOptions, startFraction: float = 0.0, endFraction: float = 1.0) -> int
        
        Return the number of strokes needed to approximate this curve
        primitive.
        """
        ...
    
    def GetTag(*args, **kwargs):
        """
        GetTag(self: MSPyBentleyGeom.ICurvePrimitive) -> int
        
        Get the Int64 tag ...
        """
        ...
    
    @property
    def Id(arg0: MSPyBentleyGeom.ICurvePrimitive) -> Bentley.CurvePrimitiveId:
        ...
    
    @property
    def IntTag(arg0: MSPyBentleyGeom.ICurvePrimitive) -> int:
        ...
    @IntTag.setter
    def IntTag(arg0: MSPyBentleyGeom.ICurvePrimitive, arg1: int) -> None:
        ...
    
    @property
    def InterpolationCurve(arg0: MSPyBentleyGeom.ICurvePrimitive) -> Bentley.MSInterpolationCurve:
        ...
    
    def IsExtensibleFractionSpace(*args, **kwargs):
        """
        IsExtensibleFractionSpace(self: MSPyBentleyGeom.ICurvePrimitive) -> bool
        
        Test if fractional queries allow extension. When this is true, the
        CurvePrimitive recognizes fractions outside of 0..1.
        """
        ...
    
    def IsFractionSpace(*args, **kwargs):
        """
        IsFractionSpace(self: MSPyBentleyGeom.ICurvePrimitive) -> bool
        
        Test if this is a curve (i.e. not a child vector or point string)
        """
        ...
    
    def IsMappableFractionSpace(*args, **kwargs):
        """
        IsMappableFractionSpace(self: MSPyBentleyGeom.ICurvePrimitive) -> bool
        
        Test if cloned fractional intervals map linearly back to parent
        fractions. (Not true for linestrings and child curve vectors.
        """
        ...
    
    def IsPeriodicFractionSpace(*args, **kwargs):
        """
        IsPeriodicFractionSpace(self: MSPyBentleyGeom.ICurvePrimitive) -> tuple
        
        Return true if the curve is part of a (possibly larger) periodic
        curve.
        
        Parameter ``[out]``:
        period period as a multiple of the bounded curve's fraction space.
        For example, a quarter arc has a period of 4.
        """
        ...
    
    def IsSameStructure(*args, **kwargs):
        """
        IsSameStructure(self: MSPyBentleyGeom.ICurvePrimitive, other: MSPyBentleyGeom.ICurvePrimitive) -> bool
        
        Recursive check for structural match (tree structure and leaf type)
        with the other curve primitive.
        """
        ...
    
    def IsSameStructureAndGeometry(*args, **kwargs):
        """
        IsSameStructureAndGeometry(self: MSPyBentleyGeom.ICurvePrimitive, other: MSPyBentleyGeom.ICurvePrimitive, tolerance: float = 0.0) -> bool
        
        Recursive check for match (tree structure. leaf type, and geometry)
        with a peer. <param name=" other ">peer for comparison</param> <param
        name=" tolerance ">distance tolerance. (See DoubleOps.AlmostEqual
        ())</param>
        """
        ...
    
    def Length(*args, **kwargs):
        """
        Length(*args, **kwargs)
        Overloaded function.
        
        1. Length(self: MSPyBentleyGeom.ICurvePrimitive) -> tuple
        
        Compute curve length. return false if no measurable curves.
        
        Parameter ``[out]``:
        length curve length. For ChildCurveVector, length of contained
        curves is summed.
        
        2. Length(self: MSPyBentleyGeom.ICurvePrimitive, arg0: Bentley.RotMatrix) -> tuple
        
        Compute curve length. return false if no measurable curves.
        
        Parameter ``[out]``:
        length curve length. For ChildCurveVector, length of contained
        curves is summed.
        """
        ...
    
    @property
    def Line(arg0: MSPyBentleyGeom.ICurvePrimitive) -> Bentley.DSegment3d:
        ...
    
    @property
    def LineString(arg0: MSPyBentleyGeom.ICurvePrimitive) -> Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >:
        ...
    
    def NumComponent(*args, **kwargs):
        """
        NumComponent(self: MSPyBentleyGeom.ICurvePrimitive) -> int
        
        Return the number of components that can be parameterized. This is ul>
        li> 1 for all curves except linestrings. li> 0 for child curve vector
        li> the number of edges in a linestring. ul>
        """
        ...
    
    @property
    def PartialCurveDetail(arg0: MSPyBentleyGeom.ICurvePrimitive) -> MSPyBentleyGeom.PartialCurveDetail:
        ...
    
    def PointAtSignedDistanceFromFraction(*args, **kwargs):
        """
        PointAtSignedDistanceFromFraction(*args, **kwargs)
        Overloaded function.
        
        1. PointAtSignedDistanceFromFraction(self: MSPyBentleyGeom.ICurvePrimitive, startFraction: float, signedDistance: float, allowExtension: bool, location: MSPyBentleyGeom.CurveLocationDetail) -> bool
        
        Attempt to move a specified distance from given fraction.
        
        Parameter ``[in]``:
        startFraction starting position.
        
        Parameter ``[in]``:
        signedDistance distance for attempted move.
        
        Parameter ``[in]``:
        allowExtension controls extended behaior of line, arc, and
        linestring.
        
        Parameter ``[out]``:
        location fraction and point after move.{a} field indicates actual
        signed distance moved (which may be less than request!!)
        
        Remark:
        If extension is not allowed, there are fussy rules for both the
        input and output. (1) The startFraction is clamped to{0..1} (2)
        Movement stops at the endpoint in the indicated direction.
        
        2. PointAtSignedDistanceFromFraction(self: MSPyBentleyGeom.ICurvePrimitive, worldToView: Bentley.RotMatrix, startFraction: float, signedDistance: float, allowExtension: bool, location: MSPyBentleyGeom.CurveLocationDetail) -> bool
        
        Attempt to move a specified distance from given fraction.
        
        Parameter ``[in]``:
        startFraction starting position.
        
        Parameter ``[in]``:
        signedDistance distance for attempted move.
        
        Parameter ``[in]``:
        allowExtension controls extended behaior of line, arc, and
        linestring.
        
        Parameter ``[out]``:
        location fraction and point after move.{a} field indicates actual
        signed distance moved (which may be less than request!!)
        
        Remark:
        If extension is not allowed, there are fussy rules for both the
        input and output. (1) The startFraction is clamped to{0..1} (2)
        Movement stops at the endpoint in the indicated direction.
        """
        ...
    
    @property
    def PointString(arg0: MSPyBentleyGeom.ICurvePrimitive) -> Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >:
        ...
    
    def ProjectedParameterRange(*args, **kwargs):
        """
        ProjectedParameterRange(*args, **kwargs)
        Overloaded function.
        
        1. ProjectedParameterRange(self: MSPyBentleyGeom.ICurvePrimitive, ray: Bentley.DRay3d) -> Bentley.DRange1d
        
        Return the range the primitive projected onto a ray. return DRange1d
        with range data.
        
        Parameter ``[in]``:
        ray test ray.
        
        Parameter ``[in]``:
        fraction0 start fraction of active part.
        
        Parameter ``[in]``:
        fraction1 end fraction of active part.
        
        Remark:
        If the ray's direction vector is a unit vector, the projected
        parameters are physical distances.
        
        Remark:
        If the ray's direction vector is NOT a unit vector, the projected
        parameters are fractions of the ray's direction vector.
        
        Remark:
        If the primitive has no curves, the returned range returns true on
        the DRange1d.IsNull() predicate.
        
        2. ProjectedParameterRange(self: MSPyBentleyGeom.ICurvePrimitive, ray: Bentley.DRay3d, fraction0: float, fraction1: float) -> Bentley.DRange1d
        
        Return the range the primitive projected onto a ray. return DRange1d
        with range data.
        
        Parameter ``[in]``:
        ray test ray.
        
        Parameter ``[in]``:
        fraction0 start fraction of active part.
        
        Parameter ``[in]``:
        fraction1 end fraction of active part.
        
        Remark:
        If the ray's direction vector is a unit vector, the projected
        parameters are physical distances.
        
        Remark:
        If the ray's direction vector is NOT a unit vector, the projected
        parameters are fractions of the ray's direction vector.
        
        Remark:
        If the primitive has no curves, the returned range returns true on
        the DRange1d.IsNull() predicate.
        """
        ...
    
    @property
    def ProxyBsplineCurve(arg0: MSPyBentleyGeom.ICurvePrimitive) -> Bentley.RefCountedMSBsplineCurve:
        ...
    
    def ReverseCurvesInPlace(*args, **kwargs):
        """
        ReverseCurvesInPlace(self: MSPyBentleyGeom.ICurvePrimitive) -> bool
        
        reverse the parameterization in place.
        """
        ...
    
    def SetIntTag(*args, **kwargs):
        """
        SetIntTag(self: MSPyBentleyGeom.ICurvePrimitive, tag: int) -> None
        """
        ...
    
    def SetMarkerBit(*args, **kwargs):
        """
        SetMarkerBit(self: MSPyBentleyGeom.ICurvePrimitive, selector: MSPyBentleyGeom.ICurvePrimitive.CurvePrimitiveMarkerBit, value: bool) -> None
        
        Set the specified marker bit on or off
        """
        ...
    
    def SetTag(*args, **kwargs):
        """
        SetTag(self: MSPyBentleyGeom.ICurvePrimitive, tag: int) -> None
        
        Set the Int64 tag
        """
        ...
    
    def SignedDistanceBetweenFractions(*args, **kwargs):
        """
        SignedDistanceBetweenFractions(*args, **kwargs)
        Overloaded function.
        
        1. SignedDistanceBetweenFractions(self: MSPyBentleyGeom.ICurvePrimitive, startFraction: float, endFraction: float) -> tuple
        
        Return distance between fractions. Primitives that do not have
        extensible fraction spaces will SILENTLY clamp the fractions to 0..1.
        return false if this is not a parameterized curve (EXAMPLE:A
        ChildCurveVector)
        
        Parameter ``[in]``:
        startFraction starting position for partial curve.
        
        Parameter ``[in]``:
        endFraction end position for partial curve.
        
        Parameter ``[out]``:
        signedDistance distance along curve, negative if fraction
        direction is reversed.
        
        2. SignedDistanceBetweenFractions(self: MSPyBentleyGeom.ICurvePrimitive, worldToLocal: Bentley.RotMatrix, startFraction: float, endFraction: float) -> tuple
        
        Return distance between fractions. Primitives that do not have
        extensible fraction spaces will SILENTLY clamp the fractions to 0..1.
        return false if this is not a parameterized curve (EXAMPLE:A
        ChildCurveVector)
        
        Parameter ``[in]``:
        startFraction starting position for partial curve.
        
        Parameter ``[in]``:
        endFraction end position for partial curve.
        
        Parameter ``[out]``:
        signedDistance distance along curve, negative if fraction
        direction is reversed.
        """
        ...
    
    @property
    def SpiralPlacement(arg0: MSPyBentleyGeom.ICurvePrimitive) -> Bentley.DSpiral2dPlacement:
        ...
    
    @property
    def Tag(arg0: MSPyBentleyGeom.ICurvePrimitive) -> int:
        ...
    @Tag.setter
    def Tag(arg0: MSPyBentleyGeom.ICurvePrimitive, arg1: int) -> None:
        ...
    
    def TransformInPlace(*args, **kwargs):
        """
        TransformInPlace(self: MSPyBentleyGeom.ICurvePrimitive, transform: Bentley.Transform) -> bool
        
        Transform in place.
        """
        ...
    
    def TryAddLineStringPoint(*args, **kwargs):
        """
        TryAddLineStringPoint(self: MSPyBentleyGeom.ICurvePrimitive, xyz: Bentley.DPoint3d) -> bool
        
        If this is a linestring, add a point.
        """
        ...
    
    def TryGetArc(*args, **kwargs):
        """
        TryGetArc(self: MSPyBentleyGeom.ICurvePrimitive, arc: Bentley.DEllipse3d) -> bool
        
        If this is a line primitive, copy its coordinate data to a DEllipse3d.
        """
        ...
    
    def TryGetLine(*args, **kwargs):
        """
        TryGetLine(self: MSPyBentleyGeom.ICurvePrimitive, segment: Bentley.DSegment3d) -> bool
        
        If this is a line primitive, copy its coordinate data to a DSegment3d.
        """
        ...
    
    def TryGetPartialCurveData(*args, **kwargs):
        """
        TryGetPartialCurveData(self: MSPyBentleyGeom.ICurvePrimitive) -> tuple
        """
        ...
    
    def TryGetSegmentInLineString(*args, **kwargs):
        """
        TryGetSegmentInLineString(self: MSPyBentleyGeom.ICurvePrimitive, segment: Bentley.DSegment3d, startPointIndex: int) -> bool
        
        If this is a linestring and index is valid, get the (single) indexed
        segment.
        """
        ...
    
    def TrySetEnd(*args, **kwargs):
        """
        TrySetEnd(self: MSPyBentleyGeom.ICurvePrimitive, xyz: Bentley.DPoint3d) -> bool
        
        Modify the end point if possible
        """
        ...
    
    def TrySetStart(*args, **kwargs):
        """
        TrySetStart(self: MSPyBentleyGeom.ICurvePrimitive, xyz: Bentley.DPoint3d) -> bool
        
        Modify the start point if possible
        """
        ...
    
    def WireCentroid(*args, **kwargs):
        """
        WireCentroid(self: MSPyBentleyGeom.ICurvePrimitive, fraction0: float = 0.0, fraction1: float = 1.0) -> tuple
        
        Return the centroid of (a portion of) the curve.
        
        Parameter ``[out]``:
        length curve length
        
        Parameter ``[out]``:
        centroid curve centroid
        
        Parameter ``[in]``:
        fraction0 start fraction of active part of sweep.
        
        Parameter ``[in]``:
        fraction1 end fraction of active part of sweep.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    
    eCURVE_PRIMITIVE_BIT_AllApplicationBits: CurvePrimitiveMarkerBit
    
    eCURVE_PRIMITIVE_BIT_GapCurve: CurvePrimitiveMarkerBit
    
    eCURVE_PRIMITIVE_TYPE_AkimaCurve: CurvePrimitiveType
    
    eCURVE_PRIMITIVE_TYPE_Arc: CurvePrimitiveType
    
    eCURVE_PRIMITIVE_TYPE_BsplineCurve: CurvePrimitiveType
    
    eCURVE_PRIMITIVE_TYPE_CurveVector: CurvePrimitiveType
    
    eCURVE_PRIMITIVE_TYPE_InterpolationCurve: CurvePrimitiveType
    
    eCURVE_PRIMITIVE_TYPE_Invalid: CurvePrimitiveType
    
    eCURVE_PRIMITIVE_TYPE_Line: CurvePrimitiveType
    
    eCURVE_PRIMITIVE_TYPE_LineString: CurvePrimitiveType
    
    eCURVE_PRIMITIVE_TYPE_NotClassified: CurvePrimitiveType
    
    eCURVE_PRIMITIVE_TYPE_PartialCurve: CurvePrimitiveType
    
    eCURVE_PRIMITIVE_TYPE_PointString: CurvePrimitiveType
    
    eCURVE_PRIMITIVE_TYPE_Spiral: CurvePrimitiveType
    
class ICurvePrimitivePtrArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ICurvePrimitivePtrArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.ICurvePrimitivePtrArray, arg0: MSPyBentleyGeom.ICurvePrimitivePtrArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.ICurvePrimitivePtrArray, arg0: Iterable) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.ICurvePrimitivePtrArray, x: MSPyBentleyGeom.ICurvePrimitive) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.ICurvePrimitivePtrArray) -> None
        
        Clear the contents
        """
        ...
    
    def count(*args, **kwargs):
        """
        count(self: MSPyBentleyGeom.ICurvePrimitivePtrArray, x: MSPyBentleyGeom.ICurvePrimitive) -> int
        
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.ICurvePrimitivePtrArray, L: MSPyBentleyGeom.ICurvePrimitivePtrArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.ICurvePrimitivePtrArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.ICurvePrimitivePtrArray, i: int, x: MSPyBentleyGeom.ICurvePrimitive) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.ICurvePrimitivePtrArray) -> MSPyBentleyGeom.ICurvePrimitive
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.ICurvePrimitivePtrArray, i: int) -> MSPyBentleyGeom.ICurvePrimitive
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(*args, **kwargs):
        """
        remove(self: MSPyBentleyGeom.ICurvePrimitivePtrArray, x: MSPyBentleyGeom.ICurvePrimitive) -> None
        
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class IFacetOptions:
    """
    None
    """

    @property
    def AngleTolerance(arg0: MSPyBentleyGeom.IFacetOptions) -> float:
        ...
    @AngleTolerance.setter
    def AngleTolerance(arg0: MSPyBentleyGeom.IFacetOptions, arg1: float) -> None:
        ...
    
    @property
    def BSurfSmoothTriangleFlowRequired(arg0: MSPyBentleyGeom.IFacetOptions) -> bool:
        ...
    @BSurfSmoothTriangleFlowRequired.setter
    def BSurfSmoothTriangleFlowRequired(arg0: MSPyBentleyGeom.IFacetOptions, arg1: bool) -> None:
        ...
    
    def BezierStrokeCount(*args, **kwargs):
        """
        BezierStrokeCount(self: MSPyBentleyGeom.IFacetOptions, poles: MSPyBentleyGeom.DPoint4dArray, index0: int, order: int) -> tuple
        
        Compute the number of strokes needed for a (weighted) bezier.
        """
        ...
    
    def BsplineCurveStrokeCount(*args, **kwargs):
        """
        BsplineCurveStrokeCount(self: MSPyBentleyGeom.IFacetOptions, curve: Bentley.MSBsplineCurve) -> int
        
        Comptue the number of strokes needed for a bspline curve.
        """
        ...
    
    @property
    def ChordTolerance(arg0: MSPyBentleyGeom.IFacetOptions) -> float:
        ...
    @ChordTolerance.setter
    def ChordTolerance(arg0: MSPyBentleyGeom.IFacetOptions, arg1: float) -> None:
        ...
    
    def Clone(*args, **kwargs):
        """
        Clone(self: MSPyBentleyGeom.IFacetOptions) -> MSPyBentleyGeom.IFacetOptions
        
        Create a copy.
        """
        ...
    
    @property
    def CombineFacets(arg0: MSPyBentleyGeom.IFacetOptions) -> bool:
        ...
    @CombineFacets.setter
    def CombineFacets(arg0: MSPyBentleyGeom.IFacetOptions, arg1: bool) -> None:
        ...
    
    @property
    def ConvexFacetsRequired(arg0: MSPyBentleyGeom.IFacetOptions) -> bool:
        ...
    @ConvexFacetsRequired.setter
    def ConvexFacetsRequired(arg0: MSPyBentleyGeom.IFacetOptions, arg1: bool) -> None:
        ...
    
    def CreateForCurves(*args, **kwargs):
        """
        CreateForCurves() -> MSPyBentleyGeom.IFacetOptions
        
        Return a (smart pointer) implementation of the interface, with
        tolerances set for typical curves.
        """
        ...
    
    def CreateForSurfaces(*args, **kwargs):
        """
        CreateForSurfaces(chordTol: float = 0.0, angleRadians: float = 0.26179938779914946, maxEdgeLength: float = 0.0, triangulate: bool = False, normals: bool = False, params: bool = False) -> MSPyBentleyGeom.IFacetOptions
        
        Return a (smart pointer) implementation of the interface
        """
        ...
    
    @property
    def CurvatureWeightFactor(arg0: MSPyBentleyGeom.IFacetOptions) -> float:
        ...
    @CurvatureWeightFactor.setter
    def CurvatureWeightFactor(arg0: MSPyBentleyGeom.IFacetOptions, arg1: float) -> None:
        ...
    
    @property
    def CurveParameterMapping(arg0: MSPyBentleyGeom.IFacetOptions) -> Bentley.CurveParameterMapping:
        ...
    @CurveParameterMapping.setter
    def CurveParameterMapping(arg0: MSPyBentleyGeom.IFacetOptions, arg1: Bentley.CurveParameterMapping) -> None:
        ...
    
    @property
    def CurvedSurfaceMaxPerFace(arg0: MSPyBentleyGeom.IFacetOptions) -> int:
        ...
    @CurvedSurfaceMaxPerFace.setter
    def CurvedSurfaceMaxPerFace(arg0: MSPyBentleyGeom.IFacetOptions, arg1: int) -> None:
        ...
    
    def DistanceAndTurnStrokeCount(*args, **kwargs):
        """
        DistanceAndTurnStrokeCount(self: MSPyBentleyGeom.IFacetOptions, distance: float, turnRadians: float) -> int
        
        Compute the number of strokes needed for distance with turn.
        """
        ...
    
    def DistanceStrokeCount(*args, **kwargs):
        """
        DistanceStrokeCount(self: MSPyBentleyGeom.IFacetOptions, distance: float) -> int
        
        Compute the number of strokes needed for a distance.
        """
        ...
    
    @property
    def DoSpatialLaplaceSmoothing(arg0: MSPyBentleyGeom.IFacetOptions) -> bool:
        ...
    @DoSpatialLaplaceSmoothing.setter
    def DoSpatialLaplaceSmoothing(arg0: MSPyBentleyGeom.IFacetOptions, arg1: bool) -> None:
        ...
    
    @property
    def EdgeChainsRequired(arg0: MSPyBentleyGeom.IFacetOptions) -> bool:
        ...
    @EdgeChainsRequired.setter
    def EdgeChainsRequired(arg0: MSPyBentleyGeom.IFacetOptions, arg1: bool) -> None:
        ...
    
    @property
    def EdgeHiding(arg0: MSPyBentleyGeom.IFacetOptions) -> bool:
        ...
    @EdgeHiding.setter
    def EdgeHiding(arg0: MSPyBentleyGeom.IFacetOptions, arg1: bool) -> None:
        ...
    
    def EllipseStrokeCount(*args, **kwargs):
        """
        EllipseStrokeCount(self: MSPyBentleyGeom.IFacetOptions, ellipse: MSPyBentleyGeom.DEllipse3d) -> int
        
        Compute the number of strokes needed for a partial ellipse.
        """
        ...
    
    def FullEllipseStrokeCount(*args, **kwargs):
        """
        FullEllipseStrokeCount(self: MSPyBentleyGeom.IFacetOptions, ellipse: MSPyBentleyGeom.DEllipse3d) -> int
        
        Compute the number of strokes needed for a complete ellipse.
        """
        ...
    
    def GetAngleTolerance(*args, **kwargs):
        """
        GetAngleTolerance(self: MSPyBentleyGeom.IFacetOptions) -> float
        
        Get the AngleTolerance facet control.
        """
        ...
    
    def GetBSurfSmoothTriangleFlowRequired(*args, **kwargs):
        """
        GetBSurfSmoothTriangleFlowRequired(self: MSPyBentleyGeom.IFacetOptions) -> bool
        
        Get the SmoothTriangleFlow facet control -- bspline surfaces only.
        """
        ...
    
    def GetChordTolerance(*args, **kwargs):
        """
        GetChordTolerance(self: MSPyBentleyGeom.IFacetOptions) -> float
        
        Get the ChordTolerance facet control.
        """
        ...
    
    def GetCombineFacets(*args, **kwargs):
        """
        GetCombineFacets(self: MSPyBentleyGeom.IFacetOptions) -> bool
        
        Get the CombineFacets facet control.
        """
        ...
    
    def GetConvexFacetsRequired(*args, **kwargs):
        """
        GetConvexFacetsRequired(self: MSPyBentleyGeom.IFacetOptions) -> bool
        
        Get the ConvexFacetsRequired facet control.
        """
        ...
    
    def GetCurvatureWeightFactor(*args, **kwargs):
        """
        GetCurvatureWeightFactor(self: MSPyBentleyGeom.IFacetOptions) -> float
        
        Get the CurvatureWeightFactor control.
        """
        ...
    
    def GetCurveParameterMapping(*args, **kwargs):
        """
        GetCurveParameterMapping(self: MSPyBentleyGeom.IFacetOptions) -> Bentley.CurveParameterMapping
        
        Get the CurveParameterMapping facet control.
        """
        ...
    
    def GetCurvedSurfaceMaxPerFace(*args, **kwargs):
        """
        GetCurvedSurfaceMaxPerFace(self: MSPyBentleyGeom.IFacetOptions) -> int
        
        Get the CurvedSurfaceMaxPerFace facet control.
        """
        ...
    
    def GetDoSpatialLaplaceSmoothing(*args, **kwargs):
        """
        GetDoSpatialLaplaceSmoothing(self: MSPyBentleyGeom.IFacetOptions) -> bool
        
        Get the SmoothTriangleFlow facet control -- bspline surfaces only.
        """
        ...
    
    def GetEdgeChainsRequired(*args, **kwargs):
        """
        GetEdgeChainsRequired(self: MSPyBentleyGeom.IFacetOptions) -> bool
        
        Get the EdgeChainsRequired facet control.
        """
        ...
    
    def GetEdgeHiding(*args, **kwargs):
        """
        GetEdgeHiding(self: MSPyBentleyGeom.IFacetOptions) -> bool
        
        Get the EdgeHiding facet control.
        """
        ...
    
    def GetHideSmoothEdgesWhenGeneratingNormals(*args, **kwargs):
        """
        GetHideSmoothEdgesWhenGeneratingNormals(self: MSPyBentleyGeom.IFacetOptions) -> bool
        
        Get whether mooth edges between facets are marked as hidden when
        normals are genereted for a polyface without normals.
        """
        ...
    
    def GetIgnoreFaceMaterialAttachments(*args, **kwargs):
        """
        GetIgnoreFaceMaterialAttachments(self: MSPyBentleyGeom.IFacetOptions) -> bool
        
        Get whether facets returned for BReps are separated by color/material
        when there is per-face symbology attachments.
        """
        ...
    
    def GetMaxEdgeLength(*args, **kwargs):
        """
        GetMaxEdgeLength(self: MSPyBentleyGeom.IFacetOptions) -> float
        
        Get the MaxEdgeLength facet control.
        """
        ...
    
    def GetMaxFacetWidth(*args, **kwargs):
        """
        GetMaxFacetWidth(self: MSPyBentleyGeom.IFacetOptions) -> float
        
        Gets the maximum facet width.
        """
        ...
    
    def GetMaxPerBezier(*args, **kwargs):
        """
        GetMaxPerBezier(self: MSPyBentleyGeom.IFacetOptions) -> int
        
        Get the MaxPerBezier facet control.
        """
        ...
    
    def GetMaxPerFace(*args, **kwargs):
        """
        GetMaxPerFace(self: MSPyBentleyGeom.IFacetOptions) -> int
        
        Get the MaxPerFace facet control.
        """
        ...
    
    def GetMinPerBezier(*args, **kwargs):
        """
        GetMinPerBezier(self: MSPyBentleyGeom.IFacetOptions) -> int
        
        Get the MinPerBezier facet control.
        """
        ...
    
    def GetNormalsRequired(*args, **kwargs):
        """
        GetNormalsRequired(self: MSPyBentleyGeom.IFacetOptions) -> bool
        
        Get the NormalsRequired facet control.
        """
        ...
    
    def GetParamDistanceScale(*args, **kwargs):
        """
        GetParamDistanceScale(self: MSPyBentleyGeom.IFacetOptions) -> float
        
        Get the ParamDistanceScale facet control.
        """
        ...
    
    def GetParamMode(*args, **kwargs):
        """
        GetParamMode(self: MSPyBentleyGeom.IFacetOptions) -> MSPyBentleyGeom.FacetParamMode
        
        Get the ParamMode facet control.
        """
        ...
    
    def GetParamsRequired(*args, **kwargs):
        """
        GetParamsRequired(self: MSPyBentleyGeom.IFacetOptions) -> bool
        
        Get the ParamsRequired facet control.
        """
        ...
    
    def GetSilhouetteDirection(*args, **kwargs):
        """
        GetSilhouetteDirection(self: MSPyBentleyGeom.IFacetOptions) -> MSPyBentleyGeom.DVec3d
        
        Get the SilhouetteDirection facet control.
        """
        ...
    
    def GetSilhouetteOrigin(*args, **kwargs):
        """
        GetSilhouetteOrigin(self: MSPyBentleyGeom.IFacetOptions) -> MSPyBentleyGeom.DPoint3d
        
        Get the SilhouetteOrigin facet control.
        """
        ...
    
    def GetSilhouetteToleranceDivisor(*args, **kwargs):
        """
        GetSilhouetteToleranceDivisor(self: MSPyBentleyGeom.IFacetOptions) -> float
        
        Get the SilhouetteToleranceDivisor facet control.
        """
        ...
    
    def GetSilhouetteType(*args, **kwargs):
        """
        GetSilhouetteType(self: MSPyBentleyGeom.IFacetOptions) -> int
        
        Get the SilhouetteType facet control.
        """
        ...
    
    def GetSmoothTriangleFlowRequired(*args, **kwargs):
        """
        GetSmoothTriangleFlowRequired(self: MSPyBentleyGeom.IFacetOptions) -> bool
        
        Get the SmoothTriangleFlow facet control.
        """
        ...
    
    def GetToleranceDistanceScale(*args, **kwargs):
        """
        GetToleranceDistanceScale(self: MSPyBentleyGeom.IFacetOptions) -> float
        
        Get the ToleranceDistanceScale facet control.
        """
        ...
    
    def GetVertexColorsRequired(*args, **kwargs):
        """
        GetVertexColorsRequired(self: MSPyBentleyGeom.IFacetOptions) -> bool
        
        Get the VertexColorsRequired facet control.
        """
        ...
    
    @property
    def HideSmoothEdgesWhenGeneratingNormals(arg0: MSPyBentleyGeom.IFacetOptions) -> bool:
        ...
    @HideSmoothEdgesWhenGeneratingNormals.setter
    def HideSmoothEdgesWhenGeneratingNormals(arg0: MSPyBentleyGeom.IFacetOptions, arg1: bool) -> None:
        ...
    
    @property
    def IgnoreFaceMaterialAttachments(arg0: MSPyBentleyGeom.IFacetOptions) -> bool:
        ...
    @IgnoreFaceMaterialAttachments.setter
    def IgnoreFaceMaterialAttachments(arg0: MSPyBentleyGeom.IFacetOptions, arg1: bool) -> None:
        ...
    
    def LineStringStrokeCount(*args, **kwargs):
        """
        LineStringStrokeCount(self: MSPyBentleyGeom.IFacetOptions, points: MSPyBentleyGeom.DPoint3dArray) -> int
        
        Comptue the number of strokes needed for a linestring. This is the sum
        of counts on individual segments.
        """
        ...
    
    @property
    def MaxEdgeLength(arg0: MSPyBentleyGeom.IFacetOptions) -> float:
        ...
    @MaxEdgeLength.setter
    def MaxEdgeLength(arg0: MSPyBentleyGeom.IFacetOptions, arg1: float) -> None:
        ...
    
    @property
    def MaxFacetWidth(arg0: MSPyBentleyGeom.IFacetOptions) -> float:
        ...
    @MaxFacetWidth.setter
    def MaxFacetWidth(arg0: MSPyBentleyGeom.IFacetOptions, arg1: float) -> None:
        ...
    
    @property
    def MaxPerBezier(arg0: MSPyBentleyGeom.IFacetOptions) -> int:
        ...
    @MaxPerBezier.setter
    def MaxPerBezier(arg0: MSPyBentleyGeom.IFacetOptions, arg1: int) -> None:
        ...
    
    @property
    def MaxPerFace(arg0: MSPyBentleyGeom.IFacetOptions) -> int:
        ...
    @MaxPerFace.setter
    def MaxPerFace(arg0: MSPyBentleyGeom.IFacetOptions, arg1: int) -> None:
        ...
    
    @property
    def MinPerBezier(arg0: MSPyBentleyGeom.IFacetOptions) -> int:
        ...
    @MinPerBezier.setter
    def MinPerBezier(arg0: MSPyBentleyGeom.IFacetOptions, arg1: int) -> None:
        ...
    
    @property
    def NormalsRequired(arg0: MSPyBentleyGeom.IFacetOptions) -> bool:
        ...
    @NormalsRequired.setter
    def NormalsRequired(arg0: MSPyBentleyGeom.IFacetOptions, arg1: bool) -> None:
        ...
    
    @property
    def ParamDistanceScale(arg0: MSPyBentleyGeom.IFacetOptions) -> float:
        ...
    @ParamDistanceScale.setter
    def ParamDistanceScale(arg0: MSPyBentleyGeom.IFacetOptions, arg1: float) -> None:
        ...
    
    @property
    def ParamMode(arg0: MSPyBentleyGeom.IFacetOptions) -> MSPyBentleyGeom.FacetParamMode:
        ...
    @ParamMode.setter
    def ParamMode(arg0: MSPyBentleyGeom.IFacetOptions, arg1: MSPyBentleyGeom.FacetParamMode) -> None:
        ...
    
    @property
    def ParamsRequired(arg0: MSPyBentleyGeom.IFacetOptions) -> bool:
        ...
    @ParamsRequired.setter
    def ParamsRequired(arg0: MSPyBentleyGeom.IFacetOptions, arg1: bool) -> None:
        ...
    
    def SegmentStrokeCount(*args, **kwargs):
        """
        SegmentStrokeCount(self: MSPyBentleyGeom.IFacetOptions, segment: MSPyBentleyGeom.DSegment3d) -> int
        
        Compute the number of strokes needed for a line segment.
        """
        ...
    
    def SetAngleTolerance(*args, **kwargs):
        """
        SetAngleTolerance(self: MSPyBentleyGeom.IFacetOptions, normalAngleTolerance: float) -> None
        
        Set the AngleTolerance facet control.
        """
        ...
    
    def SetBSurfSmoothTriangleFlowRequired(*args, **kwargs):
        """
        SetBSurfSmoothTriangleFlowRequired(self: MSPyBentleyGeom.IFacetOptions, value: bool) -> None
        
        Set the SmoothTriangleFlow facet control -- bspline surfaces only. A
        true unqualified SetSmoothTriangleFlowRequired overrides false for the
        Bsurf setting!!
        """
        ...
    
    def SetChordTolerance(*args, **kwargs):
        """
        SetChordTolerance(self: MSPyBentleyGeom.IFacetOptions, chordTolerance: float) -> None
        
        Set the ChordTolerance facet control.
        """
        ...
    
    def SetCombineFacets(*args, **kwargs):
        """
        SetCombineFacets(self: MSPyBentleyGeom.IFacetOptions, combineFacets: bool) -> None
        
        Set the CombineFacets facet control.
        """
        ...
    
    def SetConvexFacetsRequired(*args, **kwargs):
        """
        SetConvexFacetsRequired(self: MSPyBentleyGeom.IFacetOptions, convexFacetsRequired: bool) -> None
        
        Set the ConvexFacetsRequired facet control.
        """
        ...
    
    def SetCurvatureWeightFactor(*args, **kwargs):
        """
        SetCurvatureWeightFactor(self: MSPyBentleyGeom.IFacetOptions, value: float) -> None
        
        Set the CurvatureWeightFactor facet control.
        """
        ...
    
    def SetCurveDefaults(*args, **kwargs):
        """
        SetCurveDefaults(self: MSPyBentleyGeom.IFacetOptions) -> None
        
        Set all parameters to default values for curves. (This will have finer
        angle tolerance than surfaces)
        """
        ...
    
    def SetCurveParameterMapping(*args, **kwargs):
        """
        SetCurveParameterMapping(self: MSPyBentleyGeom.IFacetOptions, curveParameterMapping: Bentley.CurveParameterMapping) -> None
        
        Set the CurveParameterMapping facet control.
        """
        ...
    
    def SetCurvedSurfaceMaxPerFace(*args, **kwargs):
        """
        SetCurvedSurfaceMaxPerFace(self: MSPyBentleyGeom.IFacetOptions, curvedSurfaceMaxPerFace: int) -> None
        
        Set the CurvedSurfaceMaxPerFace facet control.
        """
        ...
    
    def SetDefaults(*args, **kwargs):
        """
        SetDefaults(self: MSPyBentleyGeom.IFacetOptions) -> None
        
        Set all parameters to default values
        """
        ...
    
    def SetDoSpatialLaplaceSmoothing(*args, **kwargs):
        """
        SetDoSpatialLaplaceSmoothing(self: MSPyBentleyGeom.IFacetOptions, value: bool) -> None
        
        Set the SmoothTriangleFlow facet control -- bspline surfaces only. A
        true unqualified SetSmoothTriangleFlowRequired overrides false for the
        Bsurf setting!!
        """
        ...
    
    def SetEdgeChainsRequired(*args, **kwargs):
        """
        SetEdgeChainsRequired(self: MSPyBentleyGeom.IFacetOptions, edgeChainRequired: bool) -> None
        
        Set the EdgeChainsRequired facet control.
        """
        ...
    
    def SetEdgeHiding(*args, **kwargs):
        """
        SetEdgeHiding(self: MSPyBentleyGeom.IFacetOptions, edgeHiding: bool) -> None
        
        Set the EdgeHiding facet control.
        """
        ...
    
    def SetHideSmoothEdgesWhenGeneratingNormals(*args, **kwargs):
        """
        SetHideSmoothEdgesWhenGeneratingNormals(self: MSPyBentleyGeom.IFacetOptions, hideSmoothEdgesWhenGeneratingNormals: bool) -> None
        
        Set whether smooth edges between facets are marked as hidden when
        normals are genereted for a polyface without normals.
        """
        ...
    
    def SetIgnoreFaceMaterialAttachments(*args, **kwargs):
        """
        SetIgnoreFaceMaterialAttachments(self: MSPyBentleyGeom.IFacetOptions, inoreFaceAttachments: bool) -> None
        
        Set whether facets returned for BReps are separated by color/material
        when there is per-face symbology attachments.
        """
        ...
    
    def SetMaxEdgeLength(*args, **kwargs):
        """
        SetMaxEdgeLength(self: MSPyBentleyGeom.IFacetOptions, maxEdgeLength: float) -> None
        
        Set the MaxEdgeLength facet control.
        """
        ...
    
    def SetMaxFacetWidth(*args, **kwargs):
        """
        SetMaxFacetWidth(self: MSPyBentleyGeom.IFacetOptions, maxWidth: float) -> None
        
        Sets maximum facet width. As of now, only bodies faceted by Parasolid
        use this parameter.
        """
        ...
    
    def SetMaxPerBezier(*args, **kwargs):
        """
        SetMaxPerBezier(self: MSPyBentleyGeom.IFacetOptions, maxPerBezier: int) -> None
        
        Set the MaxPerBezier facet control.
        """
        ...
    
    def SetMaxPerFace(*args, **kwargs):
        """
        SetMaxPerFace(self: MSPyBentleyGeom.IFacetOptions, maxPerFace: int) -> None
        
        Set the MaxPerFace facet control.
        """
        ...
    
    def SetMinPerBezier(*args, **kwargs):
        """
        SetMinPerBezier(self: MSPyBentleyGeom.IFacetOptions, minPerBezier: int) -> None
        
        Set the MinPerBezier facet control.
        """
        ...
    
    def SetNormalsRequired(*args, **kwargs):
        """
        SetNormalsRequired(self: MSPyBentleyGeom.IFacetOptions, normalIsRequired: bool) -> None
        
        Set the NormalsRequired facet control.
        """
        ...
    
    def SetParamDistanceScale(*args, **kwargs):
        """
        SetParamDistanceScale(self: MSPyBentleyGeom.IFacetOptions, paramDistanceScale: float) -> None
        
        Set the ParamDistanceScale facet control.
        """
        ...
    
    def SetParamMode(*args, **kwargs):
        """
        SetParamMode(self: MSPyBentleyGeom.IFacetOptions, paramMode: MSPyBentleyGeom.FacetParamMode) -> None
        
        Set the ParamMode facet control.
        """
        ...
    
    def SetParamsRequired(*args, **kwargs):
        """
        SetParamsRequired(self: MSPyBentleyGeom.IFacetOptions, paramsRequired: bool) -> None
        
        Set the ParamsRequired facet control.
        """
        ...
    
    def SetSilhouetteDirection(*args, **kwargs):
        """
        SetSilhouetteDirection(self: MSPyBentleyGeom.IFacetOptions, silhouetteDirection: MSPyBentleyGeom.DVec3d) -> None
        
        Set the SilhouetteDirection facet control.
        """
        ...
    
    def SetSilhouetteOrigin(*args, **kwargs):
        """
        SetSilhouetteOrigin(self: MSPyBentleyGeom.IFacetOptions, silhouetteOrigin: MSPyBentleyGeom.DPoint3d) -> None
        
        Set the SilhouetteOrigin facet control.
        """
        ...
    
    def SetSilhouetteToleranceDivisor(*args, **kwargs):
        """
        SetSilhouetteToleranceDivisor(self: MSPyBentleyGeom.IFacetOptions, silhouetteToleranceDivisor: float) -> None
        
        Set the SilhouetteToleranceDivisor facet control.
        """
        ...
    
    def SetSilhouetteType(*args, **kwargs):
        """
        SetSilhouetteType(self: MSPyBentleyGeom.IFacetOptions, silhouetteType: int) -> None
        
        Set the SilhouetteType facet control.
        """
        ...
    
    def SetSmoothTriangleFlowRequired(*args, **kwargs):
        """
        SetSmoothTriangleFlowRequired(self: MSPyBentleyGeom.IFacetOptions, value: bool) -> None
        
        Set the SmoothTriangleFlow facet control. (This can apply to both
        bspline and non-bspline. See
        """
        ...
    
    def SetToleranceDistanceScale(*args, **kwargs):
        """
        SetToleranceDistanceScale(self: MSPyBentleyGeom.IFacetOptions, toleranceDistanceScale: float) -> None
        
        Set the ToleranceDistanceScale facet control.
        """
        ...
    
    def SetVertexColorsRequired(*args, **kwargs):
        """
        SetVertexColorsRequired(self: MSPyBentleyGeom.IFacetOptions, vertexColorsRequired: bool) -> None
        
        Set the VertexColorsRequired facet control.
        """
        ...
    
    @property
    def SilhouetteDirection(arg0: MSPyBentleyGeom.IFacetOptions) -> MSPyBentleyGeom.DVec3d:
        ...
    @SilhouetteDirection.setter
    def SilhouetteDirection(arg0: MSPyBentleyGeom.IFacetOptions, arg1: MSPyBentleyGeom.DVec3d) -> None:
        ...
    
    @property
    def SilhouetteOrigin(arg0: MSPyBentleyGeom.IFacetOptions) -> MSPyBentleyGeom.DPoint3d:
        ...
    @SilhouetteOrigin.setter
    def SilhouetteOrigin(arg0: MSPyBentleyGeom.IFacetOptions, arg1: MSPyBentleyGeom.DPoint3d) -> None:
        ...
    
    @property
    def SilhouetteToleranceDivisor(arg0: MSPyBentleyGeom.IFacetOptions) -> float:
        ...
    @SilhouetteToleranceDivisor.setter
    def SilhouetteToleranceDivisor(arg0: MSPyBentleyGeom.IFacetOptions, arg1: float) -> None:
        ...
    
    @property
    def SilhouetteType(arg0: MSPyBentleyGeom.IFacetOptions) -> int:
        ...
    @SilhouetteType.setter
    def SilhouetteType(arg0: MSPyBentleyGeom.IFacetOptions, arg1: int) -> None:
        ...
    
    @property
    def SmoothTriangleFlowRequired(arg0: MSPyBentleyGeom.IFacetOptions) -> bool:
        ...
    @SmoothTriangleFlowRequired.setter
    def SmoothTriangleFlowRequired(arg0: MSPyBentleyGeom.IFacetOptions, arg1: bool) -> None:
        ...
    
    @property
    def ToleranceDistanceScale(arg0: MSPyBentleyGeom.IFacetOptions) -> float:
        ...
    @ToleranceDistanceScale.setter
    def ToleranceDistanceScale(arg0: MSPyBentleyGeom.IFacetOptions, arg1: float) -> None:
        ...
    
    @property
    def VertexColorsRequired(arg0: MSPyBentleyGeom.IFacetOptions) -> bool:
        ...
    @VertexColorsRequired.setter
    def VertexColorsRequired(arg0: MSPyBentleyGeom.IFacetOptions, arg1: bool) -> None:
        ...
    
    def __init__(self: MSPyBentleyGeom.IFacetOptions) -> None:
        ...
    
class IGeometry:
    """
    None
    """

    def Clone(*args, **kwargs):
        """
        Clone(*args, **kwargs)
        Overloaded function.
        
        1. Clone(self: MSPyBentleyGeom.IGeometry) -> MSPyBentleyGeom.IGeometry
        
        2. Clone(self: MSPyBentleyGeom.IGeometry, transform: Bentley.Transform) -> MSPyBentleyGeom.IGeometry
        """
        ...
    
    @property
    def GeometryType(arg0: MSPyBentleyGeom.IGeometry) -> MSPyBentleyGeom.IGeometry.GeometryType:
        ...
    
    def GetAsCurveVector(*args, **kwargs):
        """
        GetAsCurveVector(self: MSPyBentleyGeom.IGeometry) -> MSPyBentleyGeom.CurveVector
        """
        ...
    
    def GetAsICurvePrimitive(*args, **kwargs):
        """
        GetAsICurvePrimitive(self: MSPyBentleyGeom.IGeometry) -> MSPyBentleyGeom.ICurvePrimitive
        """
        ...
    
    def GetAsISolidPrimitive(*args, **kwargs):
        """
        GetAsISolidPrimitive(self: MSPyBentleyGeom.IGeometry) -> Bentley.ISolidPrimitive
        """
        ...
    
    def GetAsMSBsplineSurface(*args, **kwargs):
        """
        GetAsMSBsplineSurface(self: MSPyBentleyGeom.IGeometry) -> Bentley.RefCountedMSBsplineSurface
        """
        ...
    
    def GetAsPolyfaceHeader(*args, **kwargs):
        """
        GetAsPolyfaceHeader(self: MSPyBentleyGeom.IGeometry) -> Bentley.PolyfaceHeader
        """
        ...
    
    def GetGeometryType(*args, **kwargs):
        """
        GetGeometryType(self: MSPyBentleyGeom.IGeometry) -> MSPyBentleyGeom.IGeometry.GeometryType
        """
        ...
    
    def IsSameStructureAndGeometry(*args, **kwargs):
        """
        IsSameStructureAndGeometry(self: MSPyBentleyGeom.IGeometry, other: MSPyBentleyGeom.IGeometry, tolerance: float = 0.0) -> bool
        """
        ...
    
    def TryGetRange(*args, **kwargs):
        """
        TryGetRange(*args, **kwargs)
        Overloaded function.
        
        1. TryGetRange(self: MSPyBentleyGeom.IGeometry, range: MSPyBentleyGeom.DRange3d) -> bool
        
        2. TryGetRange(self: MSPyBentleyGeom.IGeometry, range: MSPyBentleyGeom.DRange3d, transform: Bentley.Transform) -> bool
        """
        ...
    
    def TryTransformInPlace(*args, **kwargs):
        """
        TryTransformInPlace(self: MSPyBentleyGeom.IGeometry, transform: Bentley.Transform) -> bool
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.IGeometry, source: MSPyBentleyGeom.ICurvePrimitive) -> None
        
        2. __init__(self: MSPyBentleyGeom.IGeometry, source: MSPyBentleyGeom.CurveVector) -> None
        
        3. __init__(self: MSPyBentleyGeom.IGeometry, source: Bentley.ISolidPrimitive) -> None
        
        4. __init__(self: MSPyBentleyGeom.IGeometry, source: Bentley.RefCountedMSBsplineSurface) -> None
        
        5. __init__(self: MSPyBentleyGeom.IGeometry, source: Bentley.PolyfaceHeader) -> None
        """
        ...
    
    eBsplineSurface: GeometryType
    
    eCurvePrimitive: GeometryType
    
    eCurveVector: GeometryType
    
    ePolyface: GeometryType
    
    eSolidPrimitive: GeometryType
    
class IPolyfaceConstruction:
    """
    None
    """

    def Add(*args, **kwargs):
        """
        Add(*args, **kwargs)
        Overloaded function.
        
        1. Add(self: MSPyBentleyGeom.IPolyfaceConstruction, surface: Bentley.MSBsplineSurface) -> None
        
        Add bspline surface mesh
        
        2. Add(self: MSPyBentleyGeom.IPolyfaceConstruction, cone: Bentley.DgnConeDetail) -> bool
        
        Add bspline surface mesh
        
        3. Add(self: MSPyBentleyGeom.IPolyfaceConstruction, sphere: Bentley.DgnSphereDetail) -> bool
        
        Add bspline surface mesh
        
        4. Add(self: MSPyBentleyGeom.IPolyfaceConstruction, box: Bentley.DgnBoxDetail) -> bool
        
        Add bspline surface mesh
        
        5. Add(self: MSPyBentleyGeom.IPolyfaceConstruction, torus: Bentley.DgnTorusPipeDetail) -> bool
        
        Add bspline surface mesh
        
        6. Add(self: MSPyBentleyGeom.IPolyfaceConstruction, extrusion: Bentley.DgnExtrusionDetail) -> bool
        
        Add bspline surface mesh
        
        7. Add(self: MSPyBentleyGeom.IPolyfaceConstruction, sweep: Bentley.DgnRotationalSweepDetail) -> bool
        
        Add bspline surface mesh
        
        8. Add(self: MSPyBentleyGeom.IPolyfaceConstruction, sweep: Bentley.DgnRuledSweepDetail) -> bool
        
        Add bspline surface mesh
        
        9. Add(self: MSPyBentleyGeom.IPolyfaceConstruction, sweep: Bentley.PolyfaceHeader) -> bool
        
        Add bspline surface mesh
        """
        ...
    
    def AddColorIndex(*args, **kwargs):
        """
        AddColorIndex(self: MSPyBentleyGeom.IPolyfaceConstruction, zeroBasedIndex: int) -> int
        
        Add a color index, adjusted to 1-based indexing Return the (0-based)
        position in the ParamIndex array.
        """
        ...
    
    def AddColorIndexQuad(*args, **kwargs):
        """
        AddColorIndexQuad(self: MSPyBentleyGeom.IPolyfaceConstruction, index0: int, index1: int, index2: int, index3: int) -> int
        
        Add a quad to the color index table. Return the (0-based) position in
        the ColorIndex array.
        """
        ...
    
    def AddColorIndexTerminator(*args, **kwargs):
        """
        AddColorIndexTerminator(self: MSPyBentleyGeom.IPolyfaceConstruction) -> int
        
        Add a terminator to the color index table. Return the (0-based)
        position in the ColorIndex array.
        """
        ...
    
    def AddColorIndexTriangle(*args, **kwargs):
        """
        AddColorIndexTriangle(self: MSPyBentleyGeom.IPolyfaceConstruction, index0: int, index1: int, index2: int) -> int
        
        Add a triangle to the color index table. Return the (0-based) position
        in the ColorIndex array.
        """
        ...
    
    def AddEllipsoidPatch(*args, **kwargs):
        """
        AddEllipsoidPatch(self: MSPyBentleyGeom.IPolyfaceConstruction, center: MSPyBentleyGeom.DPoint3d, radiusX: float, radiusY: float, radiusPole: float, numEastWestEdge: int = 0, numNorthSouthEdge: int = 0, longitudeStart: float = 0.0, longitudeSweep: float = 6.283185307179586, latitudeStart: float = -1.5707963267948966, latitudeSweep: float = 3.141592653589793, capped: bool = False, orientationSelect: int = 1) -> None
        """
        ...
    
    def AddFullDisk(*args, **kwargs):
        """
        AddFullDisk(self: MSPyBentleyGeom.IPolyfaceConstruction, ellipse: MSPyBentleyGeom.DEllipse3d, numPerQuadrant: int = 0) -> None
        
        Add complete disk. When options specify maxEdgeLength, radial lines go
        full distance from center to edge. (See AddFulLDiskTriangles)
        
        Parameter ``[in]``:
        ellipse arc to stroke
        
        Parameter ``[in]``:
        numPerQuadrant overrides all options controls.
        """
        ...
    
    def AddFullDiskTriangles(*args, **kwargs):
        """
        AddFullDiskTriangles(self: MSPyBentleyGeom.IPolyfaceConstruction, ellipse: MSPyBentleyGeom.DEllipse3d, numPerQuadrant: int = 0) -> None
        
        Add complete disk. When options specify maxEdgeLength, triangles are
        created without imposed radial edges.
        
        Parameter ``[in]``:
        ellipse arc to stroke
        
        Parameter ``[in]``:
        numPerQuadrant overrides all options controls.
        """
        ...
    
    def AddFullSphere(*args, **kwargs):
        """
        AddFullSphere(self: MSPyBentleyGeom.IPolyfaceConstruction, center: MSPyBentleyGeom.DPoint3d, radius: float, numPerQuadrantEW: int = 0, numPerQuadrantNS: int = 0) -> None
        
        Add complete sphere.
        
        Parameter ``[in]``:
        center ellipse center
        
        Parameter ``[in]``:
        radius ellipse radius
        
        Parameter ``[in]``:
        numPerQuadrantNS if nonzero overrides all option controls.
        
        Parameter ``[in]``:
        numPerQuadrantEW if nonzero overrides all option controls.
        """
        ...
    
    def AddLinearSweep(*args, **kwargs):
        """
        AddLinearSweep(self: MSPyBentleyGeom.IPolyfaceConstruction, pointA: MSPyBentleyGeom.DPoint3dArray, tangentA: MSPyBentleyGeom.DVec3dArray, step: MSPyBentleyGeom.DVec3d) -> None
        
        Make a linear sweep from base points. To indicate a sharp corner,
        duplicate the point, using incoming tangent on the first, outgoing on
        the second. Any zero-length edge will be skipped, and the sweep edge
        will be marked visible.
        """
        ...
    
    def AddNormalIndex(*args, **kwargs):
        """
        AddNormalIndex(self: MSPyBentleyGeom.IPolyfaceConstruction, zeroBasedIndex: int) -> int
        
        Add a normal index, adjusted to 1-based indexing. Return the (0-based)
        position in the NormalIndex array.
        """
        ...
    
    def AddNormalIndexFan(*args, **kwargs):
        """
        AddNormalIndexFan(self: MSPyBentleyGeom.IPolyfaceConstruction, centerIndex: int, index: MSPyBentley.UInt64Array, numChord: int, reverse: bool) -> None
        
        Add normal triangles from a center index to multiple edges.
        """
        ...
    
    def AddNormalIndexPlanarFan(*args, **kwargs):
        """
        AddNormalIndexPlanarFan(*args, **kwargs)
        Overloaded function.
        
        1. AddNormalIndexPlanarFan(self: MSPyBentleyGeom.IPolyfaceConstruction, vectorA: MSPyBentleyGeom.DVec3d, vectorB: MSPyBentleyGeom.DVec3d, reverse: bool, numChord: int) -> None
        
        Add triangles that share index to the a new normal whose coordinates
        are the cross product of given vectors.
        
        2. AddNormalIndexPlanarFan(self: MSPyBentleyGeom.IPolyfaceConstruction, normalIndex: int, numChord: int) -> None
        
        Add triangles that share index to the a new normal whose coordinates
        are the cross product of given vectors.
        """
        ...
    
    def AddNormalIndexPlanarStrip(*args, **kwargs):
        """
        AddNormalIndexPlanarStrip(self: MSPyBentleyGeom.IPolyfaceConstruction, index: int, numQuad: int) -> None
        
        Add quads that share index to the a single normal.
        """
        ...
    
    def AddNormalIndexQuad(*args, **kwargs):
        """
        AddNormalIndexQuad(self: MSPyBentleyGeom.IPolyfaceConstruction, index0: int, index1: int, index2: int, index3: int) -> int
        
        Add a quad to the normal index table. Return the (0-based) position in
        the NormalIndex array.
        """
        ...
    
    def AddNormalIndexTerminator(*args, **kwargs):
        """
        AddNormalIndexTerminator(self: MSPyBentleyGeom.IPolyfaceConstruction) -> int
        
        Add a terminator to the normal index table. Return the (0-based)
        position in the NormalIndex array.
        """
        ...
    
    def AddNormalIndexTriangle(*args, **kwargs):
        """
        AddNormalIndexTriangle(self: MSPyBentleyGeom.IPolyfaceConstruction, index0: int, index1: int, index2: int) -> int
        
        Add a triangle to the normal index table. Return the (0-based)
        position in the NormalIndex array.
        """
        ...
    
    def AddParamIndex(*args, **kwargs):
        """
        AddParamIndex(self: MSPyBentleyGeom.IPolyfaceConstruction, zeroBasedIndex: int) -> int
        
        Add a param index, adjusted to 1-based indexing Return the (0-based)
        position in the ParamIndex array.
        """
        ...
    
    def AddParamIndexFan(*args, **kwargs):
        """
        AddParamIndexFan(self: MSPyBentleyGeom.IPolyfaceConstruction, centerIndex: int, index: MSPyBentley.UInt64Array, numChord: int, reverse: bool) -> None
        
        Add parameter triangles from a center index to edges of a polyline.
        """
        ...
    
    def AddParamIndexQuad(*args, **kwargs):
        """
        AddParamIndexQuad(self: MSPyBentleyGeom.IPolyfaceConstruction, index0: int, index1: int, index2: int, index3: int) -> int
        
        Add a quad to the param index table. Return the (0-based) position in
        the ParamIndex array.
        """
        ...
    
    def AddParamIndexStrip(*args, **kwargs):
        """
        AddParamIndexStrip(self: MSPyBentleyGeom.IPolyfaceConstruction, indexA: MSPyBentley.UInt64Array, indexB: MSPyBentley.UInt64Array, numQuad: int, reverse: bool) -> None
        
        Add parameter quads between same-size indices.
        """
        ...
    
    def AddParamIndexTerminator(*args, **kwargs):
        """
        AddParamIndexTerminator(self: MSPyBentleyGeom.IPolyfaceConstruction) -> int
        
        Add a terminator to the param index table. Return the (0-based)
        position in the ParamIndex array.
        """
        ...
    
    def AddParamIndexTriangle(*args, **kwargs):
        """
        AddParamIndexTriangle(self: MSPyBentleyGeom.IPolyfaceConstruction, index0: int, index1: int, index2: int) -> int
        
        Add a triangle to the param index table. Return the (0-based) position
        in the ParamIndex array.
        """
        ...
    
    def AddPointIndex(*args, **kwargs):
        """
        AddPointIndex(self: MSPyBentleyGeom.IPolyfaceConstruction, zeroBasedIndex: int, visible: bool) -> int
        
        Add a point index, adjusted to 1-based indexing with visibility in
        sign. Return the (0-based) position in the PointIndex array.
        """
        ...
    
    def AddPointIndexFan(*args, **kwargs):
        """
        AddPointIndexFan(*args, **kwargs)
        Overloaded function.
        
        1. AddPointIndexFan(self: MSPyBentleyGeom.IPolyfaceConstruction, centerIndex: int, index: MSPyBentley.UInt64Array, numChord: int, reverse: bool) -> None
        
        Add point triangles from a center index to edges of a polyline. spoke
        edges are hidden, outer edges are visible.
        
        2. AddPointIndexFan(self: MSPyBentleyGeom.IPolyfaceConstruction, centerIndex: int, index: MSPyBentley.UInt64Array, numChord: int, reverse: bool, spokesVisible: bool, visibleBoundary: bool) -> None
        
        Add point triangles from a center index to edges of a polyline. spoke
        edges are hidden, outer edges are visible.
        """
        ...
    
    def AddPointIndexQuad(*args, **kwargs):
        """
        AddPointIndexQuad(self: MSPyBentleyGeom.IPolyfaceConstruction, index0: int, visible0: bool, index1: int, visible1: bool, index2: int, visible2: bool, index3: int, visible3: bool) -> int
        
        Add a quad to the point index table. Return the (0-based) position in
        the PointIndex array.
        """
        ...
    
    def AddPointIndexStrip(*args, **kwargs):
        """
        AddPointIndexStrip(self: MSPyBentleyGeom.IPolyfaceConstruction, visibleLeft: bool, indexA: MSPyBentley.UInt64Array, visibleA: bool, indexB: MSPyBentley.UInt64Array, visibleB: bool, visibleRight: bool, numQuad: int, reverse: bool) -> None
        
        Add point quads between EQUAL LENGTH index vectors.
        """
        ...
    
    def AddPointIndexTerminator(*args, **kwargs):
        """
        AddPointIndexTerminator(self: MSPyBentleyGeom.IPolyfaceConstruction) -> int
        
        Add a terminator to the point index table. Return the (0-based)
        position in the PointIndex array.
        """
        ...
    
    def AddPointIndexTriangle(*args, **kwargs):
        """
        AddPointIndexTriangle(self: MSPyBentleyGeom.IPolyfaceConstruction, index0: int, visible0: bool, index1: int, visible1: bool, index2: int, visible2: bool) -> int
        
        Add a triangle to the point index table. Return the (0-based) position
        in the PointIndex array.
        """
        ...
    
    def AddPolyface(*args, **kwargs):
        """
        AddPolyface(self: MSPyBentleyGeom.IPolyfaceConstruction, polyface: Bentley.PolyfaceQuery, drawMethodIndex: int = 0) -> bool
        
        Add polyface mesh.
        """
        ...
    
    def AddRegion(*args, **kwargs):
        """
        AddRegion(self: MSPyBentleyGeom.IPolyfaceConstruction, region: MSPyBentleyGeom.CurveVector) -> None
        
        Add (triangulation of) the region bounded by a curve vector.
        """
        ...
    
    def AddRotationalSweep(*args, **kwargs):
        """
        AddRotationalSweep(self: MSPyBentleyGeom.IPolyfaceConstruction, curve: MSPyBentleyGeom.CurveVector, center: MSPyBentleyGeom.DPoint3d, axis: MSPyBentleyGeom.DVec3d, totalSweep: float, capped: bool) -> None
        
        Add rotational sweep from curves
        """
        ...
    
    def AddRotationalSweepLoop(*args, **kwargs):
        """
        AddRotationalSweepLoop(self: MSPyBentleyGeom.IPolyfaceConstruction, pointA: MSPyBentleyGeom.DPoint3dArray, tangentA: MSPyBentleyGeom.DVec3dArray, center: MSPyBentleyGeom.DPoint3d, rotationAxis: MSPyBentleyGeom.DVec3d, totalSweepRadians: float, reverse: bool, nominalBaseCurveLength: float, startCapPointAccumulator: MSPyBentleyGeom.DPoint3dArray, endCapPointAccumulator: MSPyBentleyGeom.DPoint3dArray) -> None
        
        Make a Rotational sweep from base points. To indicate a sharp corner,
        duplicate the point, using incoming tangent on the first, outgoing on
        the second. The zero-length edge will be skipped, and the sweep edge
        will be marked visible.
        
        Parameter ``[in]``:
        pointA base curve points
        
        Parameter ``[in]``:
        tangentA base curve tangents
        
        Parameter ``[in]``:
        center center of rotation
        
        Parameter ``[in]``:
        rotationAxis rotation axis
        
        Parameter ``[in]``:
        totalSweepRadians sweep angle
        
        Parameter ``[in]``:
        reverse true to reverse facet orientations.
        
        Parameter ``[in]``:
        nominalBaseCurveLength if nonzero, parameter distances along the
        base curve are scaled to this length
        
        Parameter ``[in]``:
        startCapPointAccumulator optional array to receive fully
        transformed endcap points. This array is NOT cleared (so caller
        can combine over multiple calls.)
        
        Parameter ``[in]``:
        endCapPointAccumulator optional array to receive fully transformed
        endcap points. This array is NOT cleared (so caller can combine
        over multiple calls.)
        """
        ...
    
    def AddRowMajorQuadGrid(*args, **kwargs):
        """
        AddRowMajorQuadGrid(self: MSPyBentleyGeom.IPolyfaceConstruction, points: List[MSPyBentleyGeom.DPoint3d], normals: List[MSPyBentleyGeom.DVec3d], params: List[MSPyBentleyGeom.DPoint2d], numPerRow: int, numRow: int, forceTriangles: bool = False) -> None
        
        Add square grid with normal, param at each point.
        """
        ...
    
    def AddRuled(*args, **kwargs):
        """
        AddRuled(self: MSPyBentleyGeom.IPolyfaceConstruction, ellipse0: MSPyBentleyGeom.DEllipse3d, ellipse1: MSPyBentleyGeom.DEllipse3d, cap: bool) -> None
        
        Add ruled facets between ellipses.
        """
        ...
    
    def AddSignedOneBasedColorIndex(*args, **kwargs):
        """
        AddSignedOneBasedColorIndex(self: MSPyBentleyGeom.IPolyfaceConstruction, zeroBasedIndex: int) -> int
        
        Add a color index, directly, i.e. caller is responsible for providing
        a one based index
        """
        ...
    
    def AddSignedOneBasedNormalIndex(*args, **kwargs):
        """
        AddSignedOneBasedNormalIndex(self: MSPyBentleyGeom.IPolyfaceConstruction, zeroBasedIndex: int) -> int
        
        Add a normal index, directly, i.e. caller is responsible for providing
        a one based index
        """
        ...
    
    def AddSignedOneBasedParamIndex(*args, **kwargs):
        """
        AddSignedOneBasedParamIndex(self: MSPyBentleyGeom.IPolyfaceConstruction, zeroBasedIndex: int) -> int
        
        Add a param index, directly, i.e. caller is responsible for providing
        a one based index
        """
        ...
    
    def AddSignedOneBasedPointIndex(*args, **kwargs):
        """
        AddSignedOneBasedPointIndex(self: MSPyBentleyGeom.IPolyfaceConstruction, zeroBasedIndex: int) -> int
        
        Add a point index directly, i.e. caller is responsible for providing a
        one based index with optional negation for hidden edges.
        """
        ...
    
    def AddSmoothed(*args, **kwargs):
        """
        AddSmoothed(self: MSPyBentleyGeom.IPolyfaceConstruction, surface: Bentley.MSBsplineSurface) -> None
        
        Add bspline surface mesh, with smoothing effects.
        """
        ...
    
    def AddSolidPrimitive(*args, **kwargs):
        """
        AddSolidPrimitive(self: MSPyBentleyGeom.IPolyfaceConstruction, primitive: Bentley.ISolidPrimitive) -> bool
        
        Add facets for all faces of a solid primitive.
        """
        ...
    
    def AddSweptNGon(*args, **kwargs):
        """
        AddSweptNGon(self: MSPyBentleyGeom.IPolyfaceConstruction, n: int, rOuter: float, z0: float, z1: float, bottomCap: bool, topCap: bool) -> bool
        
        Sweep a regular polygon (parallel to xy plane) from z0 to z1.
        
        Parameter ``[in]``:
        n number of edges. Must be 3 or greater.
        
        Parameter ``[in]``:
        rOuter outer radius
        
        Parameter ``[in]``:
        z0 start z
        
        Parameter ``[in]``:
        z1 end z
        
        Parameter ``[in]``:
        bottomCap true to include bottom cap
        
        Parameter ``[in]``:
        topCap true to include top cap.
        """
        ...
    
    def AddTriStrip(*args, **kwargs):
        """
        AddTriStrip(self: MSPyBentleyGeom.IPolyfaceConstruction, points: List[MSPyBentleyGeom.DPoint3d], normals: List[MSPyBentleyGeom.DVec3d], params: List[MSPyBentleyGeom.DPoint2d], firstTriangle012: bool) -> None
        
        Add square grid with normal, param at each point.
        
        Parameter ``[in]``:
        points coordinates alternating between bottom and top of strip.
        
        Parameter ``[in]``:
        params corresponding parameters
        
        Parameter ``[in]``:
        normals corresponding normals
        
        Parameter ``[in]``:
        numPoint number of points (2 more than number of triangles)
        
        Parameter ``[in]``:
        firstTriangle012 true if 012 is leading triangle order, false if
        021 is leading triangle order.
        """
        ...
    
    def AddTriangles(*args, **kwargs):
        """
        AddTriangles(self: MSPyBentleyGeom.IPolyfaceConstruction, triangles: MSPyBentleyGeom.DTriangle3dArray, reverse: bool, paramTriangles: MSPyBentleyGeom.DTriangle3dArray = None) -> None
        
        Add all triangles to mesh. Optionally reverse orientations.
        """
        ...
    
    def AddTriangulation(*args, **kwargs):
        """
        AddTriangulation(self: MSPyBentleyGeom.IPolyfaceConstruction, points: MSPyBentleyGeom.DPoint3dArray) -> bool
        
        Triangulate a space polygon and add to mesh. Disconnect points
        separate multiple loops.
        """
        ...
    
    def AddTriangulationPair(*args, **kwargs):
        """
        AddTriangulationPair(self: MSPyBentleyGeom.IPolyfaceConstruction, pointA: MSPyBentleyGeom.DPoint3dArray, reverseA: bool, pointB: MSPyBentleyGeom.DPoint3dArray, reverseB: bool) -> None
        
        AddTriangulation on 2 sets of points, optionally reversing each.
        """
        ...
    
    def AddTubeMesh(*args, **kwargs):
        """
        AddTubeMesh(self: MSPyBentleyGeom.IPolyfaceConstruction, centerlineCurve: Bentley.MSBsplineCurve, radius: float, numEdgePerSection: int, numSectionEdge: int) -> None
        
        Add facets to a mesh. Facets approximate a tube around a centerline.
        The centerline curve (bspline) should be planar or nearly so. (If it
        is not, the successive circular sections may pinch in strange ways)
        
        Parameter ``[in]``:
        centerlineCurve tube centerline
        
        Parameter ``[in]``:
        radius tube radius
        
        Parameter ``[in]``:
        numEdgePerSection number of edges around each section circle. If
        zero, determined from builder's facet options.
        
        Parameter ``[in]``:
        numSectionEdge number of edges along curve. If zero, determined
        from builder's facet options.
        """
        ...
    
    def ApplyLocalToWorld(*args, **kwargs):
        """
        ApplyLocalToWorld(self: MSPyBentleyGeom.IPolyfaceConstruction, relativeTransform: Bentley.Transform) -> bool
        
        Apply (right multiply) the local to world transform.
        
        Returns:
        false if the given transform is not invertible.
        """
        ...
    
    def Clear(*args, **kwargs):
        """
        Clear(self: MSPyBentleyGeom.IPolyfaceConstruction) -> None
        
        Clear client mesh and all construction support
        """
        ...
    
    def CollectCurrentFaceRanges(*args, **kwargs):
        """
        CollectCurrentFaceRanges(self: MSPyBentleyGeom.IPolyfaceConstruction) -> None
        
        Collect point, param, and normal range data in the current face.
        """
        ...
    
    def EndFace(*args, **kwargs):
        """
        EndFace(self: MSPyBentleyGeom.IPolyfaceConstruction) -> None
        
        Finalize data for the current face.
        """
        ...
    
    @property
    def FaceData(arg0: MSPyBentleyGeom.IPolyfaceConstruction) -> Bentley.FacetFaceData:
        ...
    @FaceData.setter
    def FaceData(arg0: MSPyBentleyGeom.IPolyfaceConstruction, arg1: Bentley.FacetFaceData) -> None:
        ...
    
    @property
    def FaceIndex(arg0: MSPyBentleyGeom.IPolyfaceConstruction) -> int:
        ...
    @FaceIndex.setter
    def FaceIndex(arg0: MSPyBentleyGeom.IPolyfaceConstruction, arg1: int) -> None:
        ...
    
    @property
    def FacetOptions(arg0: MSPyBentleyGeom.IPolyfaceConstruction) -> MSPyBentleyGeom.IFacetOptions:
        ...
    
    def FindOrAddDoubleColor(*args, **kwargs):
        """
        FindOrAddDoubleColor(self: MSPyBentleyGeom.IPolyfaceConstruction, color: Bentley.RgbFactor) -> int
        
        Find or add a color. Return the (0-based) index.
        """
        ...
    
    def FindOrAddNormal(*args, **kwargs):
        """
        FindOrAddNormal(self: MSPyBentleyGeom.IPolyfaceConstruction, normal: MSPyBentleyGeom.DVec3d) -> int
        
        Find or add a normal. Return the (0-based) index.
        """
        ...
    
    def FindOrAddNormals(*args, **kwargs):
        """
        FindOrAddNormals(self: MSPyBentleyGeom.IPolyfaceConstruction, point: MSPyBentleyGeom.DVec3dArray, n: int, numWrap: int, index: MSPyBentley.UInt64Array) -> None
        
        Find or add n indices. Return the n indices plus numWrap additional
        wraparounds.
        """
        ...
    
    def FindOrAddParam(*args, **kwargs):
        """
        FindOrAddParam(self: MSPyBentleyGeom.IPolyfaceConstruction, param: MSPyBentleyGeom.DPoint2d) -> int
        
        Find or add a param. Return the (0-based) index.
        """
        ...
    
    def FindOrAddParams(*args, **kwargs):
        """
        FindOrAddParams(self: MSPyBentleyGeom.IPolyfaceConstruction, params: MSPyBentleyGeom.DPoint2dArray, index: MSPyBentley.UInt64Array) -> None
        
        Find or add n indices. Return the n indices plus numWrap additional
        wraparounds.
        """
        ...
    
    def FindOrAddPoint(*args, **kwargs):
        """
        FindOrAddPoint(self: MSPyBentleyGeom.IPolyfaceConstruction, point: MSPyBentleyGeom.DPoint3d) -> int
        
        Find or add a point. Return the (0-based) index.
        """
        ...
    
    def FindOrAddPoints(*args, **kwargs):
        """
        FindOrAddPoints(self: MSPyBentleyGeom.IPolyfaceConstruction, point: MSPyBentleyGeom.DPoint3dArray, n: int, numWrap: int, index: MSPyBentley.UInt64Array) -> None
        
        Find or add n indices. Return the n indices plus numWrap additional
        wraparounds.
        """
        ...
    
    def GetClientMesh(*args, **kwargs):
        """
        GetClientMesh(self: MSPyBentleyGeom.IPolyfaceConstruction) -> Bentley.PolyfaceHeader
        """
        ...
    
    def GetFaceData(*args, **kwargs):
        """
        GetFaceData(self: MSPyBentleyGeom.IPolyfaceConstruction) -> Bentley.FacetFaceData
        
        Return the current face data.
        """
        ...
    
    def GetFaceIndex(*args, **kwargs):
        """
        GetFaceIndex(self: MSPyBentleyGeom.IPolyfaceConstruction) -> int
        
        Get the (modal) face index.
        """
        ...
    
    def GetFacetOptions(*args, **kwargs):
        """
        GetFacetOptions(self: MSPyBentleyGeom.IPolyfaceConstruction) -> MSPyBentleyGeom.IFacetOptions
        """
        ...
    
    def GetLocalToWorld(*args, **kwargs):
        """
        GetLocalToWorld(self: MSPyBentleyGeom.IPolyfaceConstruction, transform: Bentley.Transform) -> bool
        
        Get the local to world placement transform.
        
        Returns:
        false if the transform is an identity.
        
        Remark:
        s This is affected by PushState/PopState operations.
        """
        ...
    
    def GetLocalToWorldNormals(*args, **kwargs):
        """
        GetLocalToWorldNormals(self: MSPyBentleyGeom.IPolyfaceConstruction, matrix: Bentley.RotMatrix) -> bool
        
        Get the local to world matrix for surface normals.
        
        Parameter ``[out]``:
        matrix returned matrix
        
        Returns:
        false if no local to world transform is in effect.
        """
        ...
    
    def GetLocalToWorldScale(*args, **kwargs):
        """
        GetLocalToWorldScale(self: MSPyBentleyGeom.IPolyfaceConstruction) -> float
        
        Get the (average) scale factor of the local to world transform.
        
        Remark:
        s This is affected by PushState/PopState operations.
        """
        ...
    
    def GetReverseNewFacetIndexOrder(*args, **kwargs):
        """
        GetReverseNewFacetIndexOrder(self: MSPyBentleyGeom.IPolyfaceConstruction) -> bool
        
        Ask if facets are to be reversed as received.
        
        Remark:
        s This is affected by PushState/PopState operations.
        """
        ...
    
    def GetReverseNewNormals(*args, **kwargs):
        """
        GetReverseNewNormals(self: MSPyBentleyGeom.IPolyfaceConstruction) -> bool
        
        Get the current normal vector reversal state.
        """
        ...
    
    def GetWorldToLocal(*args, **kwargs):
        """
        GetWorldToLocal(self: MSPyBentleyGeom.IPolyfaceConstruction, transform: Bentley.Transform) -> bool
        
        Get the world to local placement transform.
        
        Returns:
        false if the transform is an identity.
        
        Remark:
        s This is affected by PushState/PopState operations.
        """
        ...
    
    def GetWorldToLocalScale(*args, **kwargs):
        """
        GetWorldToLocalScale(self: MSPyBentleyGeom.IPolyfaceConstruction) -> float
        
        Get the (average) scale factor of the world to local transform.
        
        Remark:
        s This is affected by PushState/PopState operations.
        """
        ...
    
    def IncrementFaceIndex(*args, **kwargs):
        """
        IncrementFaceIndex(self: MSPyBentleyGeom.IPolyfaceConstruction) -> int
        
        Increment the (modal) face index. (And clear the modal parameter
        range) return the (incremented) index.
        """
        ...
    
    def InitializeConstructionStateAndStack(*args, **kwargs):
        """
        InitializeConstructionStateAndStack(self: MSPyBentleyGeom.IPolyfaceConstruction) -> None
        
        Clear the construction state stack and set current state.
        """
        ...
    
    def InitializeCurrentConstructionState(*args, **kwargs):
        """
        InitializeCurrentConstructionState(self: MSPyBentleyGeom.IPolyfaceConstruction) -> None
        
        Clear the current construction state, but leave the stack unchanged.
        """
        ...
    
    def IsTransformed(*args, **kwargs):
        """
        IsTransformed(self: MSPyBentleyGeom.IPolyfaceConstruction) -> bool
        
        Ask if the local to world transform is nontrivial
        
        Remark:
        s This is affected by PushState/PopState operations.
        """
        ...
    
    @property
    def LocalToWorldScale(arg0: MSPyBentleyGeom.IPolyfaceConstruction) -> float:
        ...
    
    def MultiplyByLocalToWorld(*args, **kwargs):
        """
        MultiplyByLocalToWorld(self: MSPyBentleyGeom.IPolyfaceConstruction, localPoint: MSPyBentleyGeom.DPoint3d) -> MSPyBentleyGeom.DPoint3d
        
        Multiply the local to world transform times the input point.
        
        Returns:
        transformed point.
        """
        ...
    
    def MultiplyNormalByLocalToWorld(*args, **kwargs):
        """
        MultiplyNormalByLocalToWorld(self: MSPyBentleyGeom.IPolyfaceConstruction, localNormal: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.DVec3d
        
        Multiply a surface normal by the local to world effects and
        renormalize. This also applies the normal reversal flag.
        
        Returns:
        transformed ponit.
        """
        ...
    
    def NeedNormals(*args, **kwargs):
        """
        NeedNormals(self: MSPyBentleyGeom.IPolyfaceConstruction) -> bool
        
        Ask if normals are needed.
        """
        ...
    
    def NeedParams(*args, **kwargs):
        """
        NeedParams(self: MSPyBentleyGeom.IPolyfaceConstruction) -> bool
        
        Ask if params are needed.
        """
        ...
    
    def PopState(*args, **kwargs):
        """
        PopState(self: MSPyBentleyGeom.IPolyfaceConstruction) -> bool
        
        Pop the current transform and revesal state.
        
        Returns:
        true if the stack had a state to pop.
        """
        ...
    
    def PushState(*args, **kwargs):
        """
        PushState(self: MSPyBentleyGeom.IPolyfaceConstruction, initializeCurrentState: bool = False) -> None
        
        Push the current transform and revesal state.
        
        Parameter ``[in]``:
        initializeCurrentState controls whether current state is
        reinitialized (true) or left unchanged (false)
        """
        ...
    
    def RemapPseudoDistanceParams(*args, **kwargs):
        """
        RemapPseudoDistanceParams(*args, **kwargs)
        Overloaded function.
        
        1. RemapPseudoDistanceParams(self: MSPyBentleyGeom.IPolyfaceConstruction, params: MSPyBentleyGeom.DPoint2dArray, distanceRange: MSPyBentleyGeom.DRange2d, paramRange: MSPyBentleyGeom.DRange2d, xDistanceFactor: float, yDistanceFactor: float, transform: Bentley.Transform) -> bool
        
        Apply the FacetParamMode to an array of parameters. On input, params
        are in coordinates that can be scaled independently in x and y to
        obtain distances. On ouptut, params are in PARAM_MODE_01BothAxes,
        PARAM_MODE_01LargerAxis, or PARAM_MODE_Distance as requested by the
        facet options in effect.
        
        Parameter ``[in,out]``:
        params parameters to remap.
        
        Parameter ``[out]``:
        distanceRange range of parameters when scaled to distance (whether
        or not params are returned as distances)
        
        Parameter ``[out]``:
        paramRange range of parameters as actually returned.
        
        Parameter ``[in]``:
        xDistanceFactor scale factor to turn input x coordinates to
        distance (if distance requested either as final result or for
        larger axis scaling)
        
        Parameter ``[in]``:
        yDistanceFactor scale factor to turn input y coordinates to
        distance (if distance requested either as final result or for
        larger axis scaling)
        
        Parameter ``[out]``:
        transform optional transform (e.g. to be applied later to more
        params in the same parameter space) (May be nullptr)
        
        2. RemapPseudoDistanceParams(self: MSPyBentleyGeom.IPolyfaceConstruction, params: MSPyBentleyGeom.DPoint2dArray, distanceRange: MSPyBentleyGeom.DRange2d, paramRange: MSPyBentleyGeom.DRange2d, xDistanceFactor: float, yDistanceFactor: float) -> bool
        
        Apply the FacetParamMode to an array of parameters. On input, params
        are in coordinates that can be scaled independently in x and y to
        obtain distances. On ouptut, params are in PARAM_MODE_01BothAxes,
        PARAM_MODE_01LargerAxis, or PARAM_MODE_Distance as requested by the
        facet options in effect.
        
        Parameter ``[in,out]``:
        params parameters to remap.
        
        Parameter ``[out]``:
        distanceRange range of parameters when scaled to distance (whether
        or not params are returned as distances)
        
        Parameter ``[out]``:
        paramRange range of parameters as actually returned.
        
        Parameter ``[in]``:
        xDistanceFactor scale factor to turn input x coordinates to
        distance (if distance requested either as final result or for
        larger axis scaling)
        
        Parameter ``[in]``:
        yDistanceFactor scale factor to turn input y coordinates to
        distance (if distance requested either as final result or for
        larger axis scaling)
        
        Parameter ``[out]``:
        transform optional transform (e.g. to be applied later to more
        params in the same parameter space) (May be nullptr)
        """
        ...
    
    def SetCurrentFaceParamDistanceRange(*args, **kwargs):
        """
        SetCurrentFaceParamDistanceRange(self: MSPyBentleyGeom.IPolyfaceConstruction, range: MSPyBentleyGeom.DRange2d) -> None
        
        Set (only) the paramDistance range part of the current FacetFacetData.
        """
        ...
    
    def SetFaceData(*args, **kwargs):
        """
        SetFaceData(self: MSPyBentleyGeom.IPolyfaceConstruction, data: Bentley.FacetFaceData) -> None
        
        Set the current face data.
        """
        ...
    
    def SetFaceIndex(*args, **kwargs):
        """
        SetFaceIndex(self: MSPyBentleyGeom.IPolyfaceConstruction, index: int) -> None
        
        Set the (modal) face index. (And clear the modal parameter range)
        """
        ...
    
    def SetLocalToWorld(*args, **kwargs):
        """
        SetLocalToWorld(self: MSPyBentleyGeom.IPolyfaceConstruction, transform: Bentley.Transform) -> bool
        
        Set the local to world transform.
        
        Returns:
        false if the given transform is not invertible.
        
        Remark:
        s This is affected by PushState/PopState operations.
        """
        ...
    
    def SetReverseNewFacetIndexOrder(*args, **kwargs):
        """
        SetReverseNewFacetIndexOrder(self: MSPyBentleyGeom.IPolyfaceConstruction, reverse: bool) -> None
        
        Set the current facet index reversal state.
        """
        ...
    
    def SetReverseNewNormals(*args, **kwargs):
        """
        SetReverseNewNormals(self: MSPyBentleyGeom.IPolyfaceConstruction, reverse: bool) -> None
        
        Set the current normal vector reversal state.
        """
        ...
    
    def Stroke(*args, **kwargs):
        """
        Stroke(self: MSPyBentleyGeom.IPolyfaceConstruction, curves: MSPyBentleyGeom.CurveVector, points: MSPyBentleyGeom.DPoint3dArray) -> tuple
        
        Stroke with facet options from the PolyfaceConstruction. Return false
        if not a simple loop.
        
        Remark:
        points are doubled at hard corners (so the incoming and outgoing
        tangents can be distinguished)
        """
        ...
    
    def StrokeWithDoubledPointsAtCorners(*args, **kwargs):
        """
        StrokeWithDoubledPointsAtCorners(*args, **kwargs)
        Overloaded function.
        
        1. StrokeWithDoubledPointsAtCorners(self: MSPyBentleyGeom.IPolyfaceConstruction, curves: MSPyBentleyGeom.CurveVector, points: MSPyBentleyGeom.DPoint3dArray, tangents: MSPyBentleyGeom.DVec3dArray) -> tuple
        
        Stroke with facet options from the PolyfaceConstruction. Return false
        if not a simple loop.
        
        Remark:
        points are doubled at hard corners (so the incoming and outgoing
        tangents can be distinguished)
        
        2. StrokeWithDoubledPointsAtCorners(self: MSPyBentleyGeom.IPolyfaceConstruction, curves: MSPyBentleyGeom.CurveVector, points: MSPyBentleyGeom.DPoint3dVecArray, tangent: MSPyBentleyGeom.DVec3dVecArray, curveLengths: MSPyBentley.DoubleArray) -> bool
        
        Stroke with facet options from the PolyfaceConstruction. Return false
        if not a simple loop.
        
        Remark:
        points are doubled at hard corners (so the incoming and outgoing
        tangents can be distinguished)
        """
        ...
    
    def ToggleIndexOrderAndNormalReversal(*args, **kwargs):
        """
        ToggleIndexOrderAndNormalReversal(self: MSPyBentleyGeom.IPolyfaceConstruction) -> None
        
        Toggle both index order and normal
        """
        ...
    
    @property
    def WorldToLocalScale(arg0: MSPyBentleyGeom.IPolyfaceConstruction) -> float:
        ...
    
    def __init__(self: MSPyBentleyGeom.IPolyfaceConstruction, options: MSPyBentleyGeom.IFacetOptions) -> None:
        ...
    
class ISolidPrimitive:
    """
    None
    """

    def AddCurveIntersections(*args, **kwargs):
        """
        AddCurveIntersections(*args, **kwargs)
        Overloaded function.
        
        1. AddCurveIntersections(self: MSPyBentleyGeom.ISolidPrimitive, curves: MSPyBentleyGeom.CurveVector, curvePoints: MSPyBentleyGeom.CurveLocationDetailArray, solidPoints: MSPyBentleyGeom.SolidLocationDetailArray, messages: MSPyBentleyGeom.MeshAnnotationVector) -> None
        
        Compute intersections with curves and add to the data array.
        
        Parameter ``[in]``:
        curves
        
        Parameter ``[in,out]``:
        curvePoints growing array of curve points.
        
        Parameter ``[in,out]``:
        solidPoints growing array of solid points.
        
        Parameter ``[in,out]``:
        messages array of error messages
        
        2. AddCurveIntersections(self: MSPyBentleyGeom.ISolidPrimitive, curves: MSPyBentleyGeom.ICurvePrimitive, curvePoints: MSPyBentleyGeom.CurveLocationDetailArray, solidPoints: MSPyBentleyGeom.SolidLocationDetailArray, messages: MSPyBentleyGeom.MeshAnnotationVector) -> None
        
        Compute intersections with curves and add to the data array.
        
        Parameter ``[in]``:
        curves
        
        Parameter ``[in,out]``:
        curvePoints growing array of curve points.
        
        Parameter ``[in,out]``:
        solidPoints growing array of solid points.
        
        Parameter ``[in,out]``:
        messages array of error messages
        """
        ...
    
    def AddRayIntersections(*args, **kwargs):
        """
        AddRayIntersections(self: MSPyBentleyGeom.ISolidPrimitive, pickData: MSPyBentleyGeom.SolidLocationDetailArray, ray: MSPyBentleyGeom.DRay3d, parentId: int, minParameter: float = -1.7976931348623157e+308) -> None
        
        Compute intersections with a ray and add to the pickData.
        
        Parameter ``[in]``:
        ray origin and direction
        
        Parameter ``[in]``:
        minParameter smallest parameter of pick. (e.g. 0 for picking along
        a positive ray from an eyepoint)
        
        Parameter ``[in,out]``:
        pickData growing array of picks.
        
        Parameter ``[in]``:
        parentId caller's id for this solid. Will be placed in each
        pickData entry has parentId.
        """
        ...
    
    @property
    def Capped(arg0: MSPyBentleyGeom.ISolidPrimitive) -> bool:
        ...
    @Capped.setter
    def Capped(arg0: MSPyBentleyGeom.ISolidPrimitive, arg1: bool) -> None:
        ...
    
    def Clone(*args, **kwargs):
        """
        Clone(self: MSPyBentleyGeom.ISolidPrimitive) -> MSPyBentleyGeom.ISolidPrimitive
        
        Deep copy.
        """
        ...
    
    def ClosestPoint(*args, **kwargs):
        """
        ClosestPoint(self: MSPyBentleyGeom.ISolidPrimitive, spacePoint: MSPyBentleyGeom.DPoint3d, pickDetail: MSPyBentleyGeom.SolidLocationDetail) -> bool
        
        Parameter ``[in]``:
        spacePoint search for point close to here and on the solid surface
        
        Parameter ``[out]``:
        pickDetail closest point data.
        
        Returns:
        false if not supported.
        """
        ...
    
    def ComputeFacetedPrincipalAreaMoments(*args, **kwargs):
        """
        ComputeFacetedPrincipalAreaMoments(self: MSPyBentleyGeom.ISolidPrimitive, options: MSPyBentleyGeom.IFacetOptions, centroid: MSPyBentleyGeom.DVec3d, axes: MSPyBentleyGeom.RotMatrix, momentxyz: MSPyBentleyGeom.DVec3d) -> tuple
        
        Return the volume, centroid, orientation, and principal momentsof the
        surface area (shell), using a faceted approximation.
        
        Remark:
        This method only attempts faceted computations. Use
        ComputePrincipalMoments to get exact moments.
        
        Parameter ``[in]``:
        options optional controls for facets
        
        Parameter ``[in]``:
        options optional controls for facet density.
        
        Parameter ``[out]``:
        area surface area
        
        Parameter ``[out]``:
        centroid centroid
        
        Parameter ``[out]``:
        axes columns of this matrix are the principal directions.
        
        Parameter ``[out]``:
        momentxyz moments (yy+zz,xx+zz,xx+yy) around the principal
        directions.
        
        Returns:
        false if (a) solid primitive is not capped or (b) facets failed.
        """
        ...
    
    def ComputeFacetedPrincipalMoments(*args, **kwargs):
        """
        ComputeFacetedPrincipalMoments(self: MSPyBentleyGeom.ISolidPrimitive, options: MSPyBentleyGeom.IFacetOptions, centroid: MSPyBentleyGeom.DVec3d, axes: MSPyBentleyGeom.RotMatrix, momentxyz: MSPyBentleyGeom.DVec3d) -> tuple
        
        Return the volume, centroid, orientation, and principal moments, using
        a faceted approximation.
        
        Remark:
        This method only attempts faceted computations. Use
        ComputePrincipalMoments to get exact moments.
        
        Parameter ``[in]``:
        options optional controls for facets
        
        Parameter ``[in]``:
        options optional controls for facet density.
        
        Parameter ``[out]``:
        volume volume
        
        Parameter ``[out]``:
        centroid centroid
        
        Parameter ``[out]``:
        axes columns of this matrix are the principal directions.
        
        Parameter ``[out]``:
        momentxyz moments (yy+zz,xx+zz,xx+yy) around the principal
        directions.
        
        Returns:
        false if (a) solid primitive is not capped or (b) facets failed.
        """
        ...
    
    def ComputePrincipalAreaMoments(*args, **kwargs):
        """
        ComputePrincipalAreaMoments(self: MSPyBentleyGeom.ISolidPrimitive, centroid: MSPyBentleyGeom.DVec3d, axes: MSPyBentleyGeom.RotMatrix, momentxyz: MSPyBentleyGeom.DVec3d) -> tuple
        
        Return the volume, centroid, orientation, and principal moments of the
        surface area (shell) using most accurate (possibly exact) formulas.
        
        Remark:
        This method only attempts " exact " computations. Use
        ComputeFacetedPrincipalMoments to get approximate moments.
        
        Parameter ``[out]``:
        area surface area
        
        Parameter ``[out]``:
        centroid centroid
        
        Parameter ``[out]``:
        axes columns of this matrix are the principal directions.
        
        Parameter ``[out]``:
        momentxyz moments (yy+zz,xx+zz,xx+yy) around the principal
        directions.
        
        Returns:
        false if (a) solid primitive is not capped or (b) high accuracy
        moments are not supported for this type.
        """
        ...
    
    def ComputePrincipalMoments(*args, **kwargs):
        """
        ComputePrincipalMoments(self: MSPyBentleyGeom.ISolidPrimitive, centroid: MSPyBentleyGeom.DVec3d, axes: MSPyBentleyGeom.RotMatrix, momentxyz: MSPyBentleyGeom.DVec3d) -> tuple
        
        Return the volume, centroid, orientation, and principal moments using
        most accurate (possibly exact) formulas.
        
        Remark:
        This method only attempts " exact " computations. Use
        ComputeFacetedPrincipalMoments to get approximate moments.
        
        Parameter ``[out]``:
        volume volume
        
        Parameter ``[out]``:
        centroid centroid
        
        Parameter ``[out]``:
        axes columns of this matrix are the principal directions.
        
        Parameter ``[out]``:
        momentxyz moments (yy+zz,xx+zz,xx+yy) around the principal
        directions.
        
        Returns:
        false if (a) solid primitive is not capped or (b) high accuracy
        moments are not supported for this type.
        """
        ...
    
    def ComputeSecondMomentAreaProducts(*args, **kwargs):
        """
        ComputeSecondMomentAreaProducts(*args, **kwargs)
        Overloaded function.
        
        1. ComputeSecondMomentAreaProducts(self: MSPyBentleyGeom.ISolidPrimitive, localToWorld: MSPyBentleyGeom.Transform, localProducts: MSPyBentleyGeom.DMatrix4d) -> bool
        
        Return the various integrated products for area moment calculations.
        The primitive is treated as a thin shell.
        
        Parameter ``[out]``:
        localToWorld transform from preferred system where the products
        are most easily computed to world.
        
        Parameter ``[out]``:
        localProducts integrated [xx xy xz x; xy yy yz y; xz yz zz z; x y
        z 1] dA
        
        Returns:
        false if unable to compute.
        
        2. ComputeSecondMomentAreaProducts(self: MSPyBentleyGeom.ISolidPrimitive, worldProducts: MSPyBentleyGeom.DMatrix4d) -> bool
        
        Return the various integrated products for area moment calculations.
        The primitive is treated as a thin shell.
        
        Parameter ``[out]``:
        localToWorld transform from preferred system where the products
        are most easily computed to world.
        
        Parameter ``[out]``:
        localProducts integrated [xx xy xz x; xy yy yz y; xz yz zz z; x y
        z 1] dA
        
        Returns:
        false if unable to compute.
        """
        ...
    
    def ComputeSecondMomentVolumeProducts(*args, **kwargs):
        """
        ComputeSecondMomentVolumeProducts(*args, **kwargs)
        Overloaded function.
        
        1. ComputeSecondMomentVolumeProducts(self: MSPyBentleyGeom.ISolidPrimitive, localToWorld: MSPyBentleyGeom.Transform, localProducts: MSPyBentleyGeom.DMatrix4d) -> bool
        
        Return the various integrated products for moment calculations. The
        primitive is treated as a volume
        
        Parameter ``[out]``:
        localToWorld transform from preferred system where the products
        are most easily computed to world.
        
        Parameter ``[out]``:
        localProducts integrated [xx xy xz x; xy yy yz y; xz yz zz z; x y
        z 1] dA
        
        Returns:
        false if unable to compute.
        
        2. ComputeSecondMomentVolumeProducts(self: MSPyBentleyGeom.ISolidPrimitive, worldProducts: MSPyBentleyGeom.DMatrix4d) -> bool
        
        Return the various integrated products for moment calculations. The
        primitive is treated as a volume
        
        Parameter ``[out]``:
        localToWorld transform from preferred system where the products
        are most easily computed to world.
        
        Parameter ``[out]``:
        localProducts integrated [xx xy xz x; xy yy yz y; xz yz zz z; x y
        z 1] dA
        
        Returns:
        false if unable to compute.
        """
        ...
    
    def CreateDgnBox(*args, **kwargs):
        """
        CreateDgnBox(data: MSPyBentleyGeom.DgnBoxDetail) -> MSPyBentleyGeom.ISolidPrimitive
        
        Return a new ISolidPrimtive which is a DgnBox.
        """
        ...
    
    def CreateDgnCone(*args, **kwargs):
        """
        CreateDgnCone(data: MSPyBentleyGeom.DgnConeDetail) -> MSPyBentleyGeom.ISolidPrimitive
        
        Return a new ISolidPrimtive which is a DgnCone.
        """
        ...
    
    def CreateDgnExtrusion(*args, **kwargs):
        """
        CreateDgnExtrusion(data: MSPyBentleyGeom.DgnExtrusionDetail) -> MSPyBentleyGeom.ISolidPrimitive
        
        Return a new ISolidPrimtive which is a DgnExtrusion.
        """
        ...
    
    def CreateDgnRotationalSweep(*args, **kwargs):
        """
        CreateDgnRotationalSweep(data: MSPyBentleyGeom.DgnRotationalSweepDetail) -> MSPyBentleyGeom.ISolidPrimitive
        
        Return a new ISolidPrimtive which is a DgnRotationalSweep.
        """
        ...
    
    def CreateDgnRuledSweep(*args, **kwargs):
        """
        CreateDgnRuledSweep(data: MSPyBentleyGeom.DgnRuledSweepDetail) -> MSPyBentleyGeom.ISolidPrimitive
        
        Return a new ISolidPrimtive which is a DgnRuledSweep.
        """
        ...
    
    def CreateDgnSphere(*args, **kwargs):
        """
        CreateDgnSphere(data: MSPyBentleyGeom.DgnSphereDetail) -> MSPyBentleyGeom.ISolidPrimitive
        
        Return a new ISolidPrimtive which is a DgnSphere.
        """
        ...
    
    def CreateDgnTorusPipe(*args, **kwargs):
        """
        CreateDgnTorusPipe(data: MSPyBentleyGeom.DgnTorusPipeDetail) -> MSPyBentleyGeom.ISolidPrimitive
        
        Return a new ISolidPrimtive which is a DgnTorusPipe.
        """
        ...
    
    def GetCapped(*args, **kwargs):
        """
        GetCapped(self: MSPyBentleyGeom.ISolidPrimitive) -> bool
        
        return flag for cap surface. Note that sphere and torus can be closed
        without having a cap surface, so this is not a closure test, just a
        test if the field for capping is set.
        """
        ...
    
    def GetConstantUSection(*args, **kwargs):
        """
        GetConstantUSection(self: MSPyBentleyGeom.ISolidPrimitive, indices: Bentley.SolidLocationDetail.FaceIndices, fraction: float) -> MSPyBentleyGeom.ICurvePrimitive
        
        Copy a section at constant u of a single face to a single
        ICurvePrimitive. This is usually a single primitive, but can have a
        disjoint, multi-component child for cut of non-convex cap,
        
        Parameter ``[in]``:
        indices selects face
        
        Parameter ``[in]``:
        fraction u fraction for section curve
        """
        ...
    
    def GetConstantVSection(*args, **kwargs):
        """
        GetConstantVSection(self: MSPyBentleyGeom.ISolidPrimitive, indices: Bentley.SolidLocationDetail.FaceIndices, fraction: float) -> MSPyBentleyGeom.ICurvePrimitive
        
        Copy a section curve at constant v of a single face to a single
        ICurvePrimitive. This is usually a single primitive, but can have a
        disjoint, multi-component child for cut of non-convex cap.
        
        Parameter ``[in]``:
        indices selects face
        
        Parameter ``[in]``:
        fraction v fraction for section curve
        """
        ...
    
    def GetFace(*args, **kwargs):
        """
        GetFace(self: MSPyBentleyGeom.ISolidPrimitive, indices: Bentley.SolidLocationDetail.FaceIndices) -> MSPyBentleyGeom.IGeometry
        
        Copy a single face to a new object.
        
        Parameter ``[in]``:
        indices indices of face.
        
        Returns:
        IGeometryPtr with representing a single face. End caps will always
        return as CurveVectorPtr. Planar side faces will return as
        CurveVectorPtr. Cylindrical side faces will return as
        DgnConeDetail with no cap. Other ruled side faces will appear as
        DgnRuledSweepDetail with one swept primitive and no cap.
        Rotational sweeps of arcs will appear as (preferably)
        DgnTorusPipeDetail or DgnRotationalRotationalSweep.
        """
        ...
    
    def GetFaceIndices(*args, **kwargs):
        """
        GetFaceIndices(self: MSPyBentleyGeom.ISolidPrimitive, indices: MSPyBentleyGeom.FaceIndicesArray) -> None
        
        Fill an array containing all the valid face indices for this
        primitive.
        
        Parameter ``[out]``:
        indices array of FaceIndices of all faces of the solid.
        """
        ...
    
    def GetRange(*args, **kwargs):
        """
        GetRange(*args, **kwargs)
        Overloaded function.
        
        1. GetRange(self: MSPyBentleyGeom.ISolidPrimitive, range: MSPyBentleyGeom.DRange3d) -> bool
        
        Compute range of primitive
        
        2. GetRange(self: MSPyBentleyGeom.ISolidPrimitive, range: MSPyBentleyGeom.DRange3d, transform: MSPyBentleyGeom.Transform) -> bool
        
        Compute range of primitive
        """
        ...
    
    def GetSolidPrimitiveType(*args, **kwargs):
        """
        GetSolidPrimitiveType(self: MSPyBentleyGeom.ISolidPrimitive) -> MSPyBentleyGeom.SolidPrimitiveType
        
        Query the primitive type.
        """
        ...
    
    def HasCurvedFaceOrEdge(*args, **kwargs):
        """
        HasCurvedFaceOrEdge(self: MSPyBentleyGeom.ISolidPrimitive) -> bool
        
        Return true if solid primitve has a non-linear edge or non-planar
        face.
        """
        ...
    
    def IsClosedVolume(*args, **kwargs):
        """
        IsClosedVolume(self: MSPyBentleyGeom.ISolidPrimitive) -> bool
        
        Test if this is a closed volume.
        """
        ...
    
    def IsSameStructure(*args, **kwargs):
        """
        IsSameStructure(self: MSPyBentleyGeom.ISolidPrimitive, other: MSPyBentleyGeom.ISolidPrimitive) -> bool
        
        Test for same type and structure (but no coordinate comparison)
        """
        ...
    
    def IsSameStructureAndGeometry(*args, **kwargs):
        """
        IsSameStructureAndGeometry(self: MSPyBentleyGeom.ISolidPrimitive, other: MSPyBentleyGeom.ISolidPrimitive, tolerance: float) -> bool
        
        Test for same type, structure and coordinates.
        """
        ...
    
    def SetCapped(*args, **kwargs):
        """
        SetCapped(self: MSPyBentleyGeom.ISolidPrimitive, value: bool) -> None
        
        Set flag for cap surface.
        """
        ...
    
    def SilhouetteCurves(*args, **kwargs):
        """
        SilhouetteCurves(self: MSPyBentleyGeom.ISolidPrimitive, eyePoint: MSPyBentleyGeom.DPoint4d, curves: MSPyBentleyGeom.CurveVector) -> bool
        
        Return curves which are silhoutte curves OTHER than hard edges
        
        Parameter ``[in]``:
        eyePoint For flat view, the view direction with weight=0. For
        perspective, the eye point with weight=1.
        
        Parameter ``[in]``:
        curves silhouette curves.
        
        Returns:
        return false if not implemented. return true if implemented -- but
        curves may still be empty.
        """
        ...
    
    def Simplify(*args, **kwargs):
        """
        Simplify(primitive: MSPyBentleyGeom.ISolidPrimitive) -> bool
        
        Detect a solid primitive that could be represented as a simpler type
        and change it to the simple type. Tests for rotational sweeps that are
        a sphere or torus as well as ruled sweeps that are a box, cone, or
        extrusion.
        
        Returns:
        true if input primitive was simplified.
        """
        ...
    
    @property
    def SolidPrimitiveType(arg0: MSPyBentleyGeom.ISolidPrimitive) -> MSPyBentleyGeom.SolidPrimitiveType:
        ...
    
    def TransformInPlace(*args, **kwargs):
        """
        TransformInPlace(self: MSPyBentleyGeom.ISolidPrimitive, transform: MSPyBentleyGeom.Transform) -> bool
        
        Transform in place.
        """
        ...
    
    def TryGetConstructiveFrame(*args, **kwargs):
        """
        TryGetConstructiveFrame(self: MSPyBentleyGeom.ISolidPrimitive, localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform) -> bool
        
        Return a typical coordinate frame
        """
        ...
    
    def TryGetDgnBoxDetail(*args, **kwargs):
        """
        TryGetDgnBoxDetail(self: MSPyBentleyGeom.ISolidPrimitive, data: MSPyBentleyGeom.DgnBoxDetail) -> bool
        
        Ask if this is a DgnBox If so, return true with copy of detail data.
        If not, return false, leave data untouched.
        """
        ...
    
    def TryGetDgnConeDetail(*args, **kwargs):
        """
        TryGetDgnConeDetail(self: MSPyBentleyGeom.ISolidPrimitive, data: MSPyBentleyGeom.DgnConeDetail) -> bool
        
        Ask if this is a DgnCone If so, return true with copy of detail data.
        If not, return false, leave data untouched.
        """
        ...
    
    def TryGetDgnExtrusionDetail(*args, **kwargs):
        """
        TryGetDgnExtrusionDetail(self: MSPyBentleyGeom.ISolidPrimitive, data: MSPyBentleyGeom.DgnExtrusionDetail) -> bool
        
        Ask if this is a DgnExtrusion If so, return true with copy of detail
        data. If not, return false, leave data untouched.
        """
        ...
    
    def TryGetDgnRotationalSweepDetail(*args, **kwargs):
        """
        TryGetDgnRotationalSweepDetail(self: MSPyBentleyGeom.ISolidPrimitive, data: MSPyBentleyGeom.DgnRotationalSweepDetail) -> bool
        
        Ask if this is a DgnRotationalSweep If so, return true with copy of
        detail data. If not, return false, leave data untouched.
        """
        ...
    
    def TryGetDgnRuledSweepDetail(*args, **kwargs):
        """
        TryGetDgnRuledSweepDetail(self: MSPyBentleyGeom.ISolidPrimitive, data: MSPyBentleyGeom.DgnRuledSweepDetail) -> bool
        
        Ask if this is a DgnRuledSweep If so, return true with copy of detail
        data. If not, return false, leave data untouched.
        """
        ...
    
    def TryGetDgnSphereDetail(*args, **kwargs):
        """
        TryGetDgnSphereDetail(self: MSPyBentleyGeom.ISolidPrimitive, data: MSPyBentleyGeom.DgnSphereDetail) -> bool
        
        Ask if this is a DgnSphere If so, return true with copy of detail
        data. If not, return false, leave data untouched.
        """
        ...
    
    def TryGetDgnTorusPipeDetail(*args, **kwargs):
        """
        TryGetDgnTorusPipeDetail(self: MSPyBentleyGeom.ISolidPrimitive, data: MSPyBentleyGeom.DgnTorusPipeDetail) -> bool
        
        Ask if this is a DgnTorusPipe If so, return true with copy of detail
        data. If not, return false, leave data untouched.
        """
        ...
    
    def TryGetMaxUVLength(*args, **kwargs):
        """
        TryGetMaxUVLength(self: MSPyBentleyGeom.ISolidPrimitive, indices: Bentley.SolidLocationDetail.FaceIndices, uvLength: MSPyBentleyGeom.DVec2d) -> bool
        
        Compute the lengths of the longest u and v direction sections of a
        single face of a solid primitive.
        
        Parameter ``[in]``:
        indices selects face.
        
        Parameter ``[in]``:
        uvLength sizes in u, v directions.
        """
        ...
    
    def TrySetDgnBoxDetail(*args, **kwargs):
        """
        TrySetDgnBoxDetail(self: MSPyBentleyGeom.ISolidPrimitive, data: MSPyBentleyGeom.DgnBoxDetail) -> bool
        
        Set DgnBoxDetail content.
        """
        ...
    
    def TrySetDgnConeDetail(*args, **kwargs):
        """
        TrySetDgnConeDetail(self: MSPyBentleyGeom.ISolidPrimitive, data: MSPyBentleyGeom.DgnConeDetail) -> bool
        
        Set DgnConeDetail content.
        """
        ...
    
    def TrySetDgnExtrusionDetail(*args, **kwargs):
        """
        TrySetDgnExtrusionDetail(self: MSPyBentleyGeom.ISolidPrimitive, data: MSPyBentleyGeom.DgnExtrusionDetail) -> bool
        
        Set DgnExtrusionDetail content.
        """
        ...
    
    def TrySetDgnRotationalSweepDetail(*args, **kwargs):
        """
        TrySetDgnRotationalSweepDetail(self: MSPyBentleyGeom.ISolidPrimitive, data: MSPyBentleyGeom.DgnRotationalSweepDetail) -> bool
        
        Set DgnRotationalSweepDetail content.
        """
        ...
    
    def TrySetDgnRuledSweepDetail(*args, **kwargs):
        """
        TrySetDgnRuledSweepDetail(self: MSPyBentleyGeom.ISolidPrimitive, data: MSPyBentleyGeom.DgnRuledSweepDetail) -> bool
        
        Set DgnRuledSweepDetail content.
        """
        ...
    
    def TrySetDgnSphereDetail(*args, **kwargs):
        """
        TrySetDgnSphereDetail(self: MSPyBentleyGeom.ISolidPrimitive, data: MSPyBentleyGeom.DgnSphereDetail) -> bool
        
        Set DgnSphereDetail content.
        """
        ...
    
    def TrySetDgnTorusPipeDetail(*args, **kwargs):
        """
        TrySetDgnTorusPipeDetail(self: MSPyBentleyGeom.ISolidPrimitive, data: MSPyBentleyGeom.DgnTorusPipeDetail) -> bool
        
        Set DgnTorusPipeDetail content.
        """
        ...
    
    def TryUVFractionToXYZ(*args, **kwargs):
        """
        TryUVFractionToXYZ(self: MSPyBentleyGeom.ISolidPrimitive, faceIndices: Bentley.SolidLocationDetail.FaceIndices, uFraction: float, vFraction: float, xyz: MSPyBentleyGeom.DPoint3d, dXdu: MSPyBentleyGeom.DVec3d, dXdv: MSPyBentleyGeom.DVec3d) -> bool
        
        convert u,v fraction on specified face to xyz and derivatives.
        
        Parameter ``[in]``:
        faceIndices face selection indices
        
        Parameter ``[in]``:
        uFraction fractional coordinate in u direction.
        
        Parameter ``[in]``:
        vFraction fractional coordinate in v direction.
        
        Parameter ``[out]``:
        xyz point on face.
        
        Parameter ``[out]``:
        dXdu derivative of face point wrt uFraction.
        
        Parameter ``[out]``:
        dXdv derivative of face point wrt vFraction.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    
class IndexedParameterMap:
    """
    None
    """

    def ConstructMapping(*args, **kwargs):
        """
        ConstructMapping(self: MSPyBentleyGeom.IndexedParameterMap, points: MSPyBentleyGeom.DPoint3dArray) -> bool
        
        Find any 3 non-colinear points and construct world-to-barycentric map.
        Return false (with identity transforms) if no independent triple
        found.
        """
        ...
    
    def MapDVec3d(*args, **kwargs):
        """
        MapDVec3d(self: MSPyBentleyGeom.IndexedParameterMap, xyz: MSPyBentleyGeom.DPoint3d, normals: MSPyBentleyGeom.DVec3dArray) -> MSPyBentleyGeom.DVec3d
        """
        ...
    
    def MapPoint2d(*args, **kwargs):
        """
        MapPoint2d(self: MSPyBentleyGeom.IndexedParameterMap, xyz: MSPyBentleyGeom.DPoint3d, params: MSPyBentleyGeom.DPoint2dArray) -> MSPyBentleyGeom.DPoint2d
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.IndexedParameterMap) -> None:
        ...
    
    @property
    def index0(self: MSPyBentleyGeom.IndexedParameterMap) -> int:
        ...
    @index0.setter
    def index0(self: MSPyBentleyGeom.IndexedParameterMap, arg0: int) -> None:
        ...
    
    @property
    def index1(self: MSPyBentleyGeom.IndexedParameterMap) -> int:
        ...
    @index1.setter
    def index1(self: MSPyBentleyGeom.IndexedParameterMap, arg0: int) -> None:
        ...
    
    @property
    def index2(self: MSPyBentleyGeom.IndexedParameterMap) -> int:
        ...
    @index2.setter
    def index2(self: MSPyBentleyGeom.IndexedParameterMap, arg0: int) -> None:
        ...
    
    @property
    def localToWorld(self: MSPyBentleyGeom.IndexedParameterMap) -> MSPyBentleyGeom.Transform:
        ...
    @localToWorld.setter
    def localToWorld(self: MSPyBentleyGeom.IndexedParameterMap, arg0: MSPyBentleyGeom.Transform) -> None:
        ...
    
    @property
    def worldToLocal(self: MSPyBentleyGeom.IndexedParameterMap) -> MSPyBentleyGeom.Transform:
        ...
    @worldToLocal.setter
    def worldToLocal(self: MSPyBentleyGeom.IndexedParameterMap, arg0: MSPyBentleyGeom.Transform) -> None:
        ...
    
class LocalCoordinateSelect:
    """
    Members:
    
    eLOCAL_COORDINATE_SCALE_UnitAxesAtStart
    
    eLOCAL_COORDINATE_SCALE_UnitAxesAtLowerLeft
    
    eLOCAL_COORDINATE_SCALE_01RangeBothAxes
    
    eLOCAL_COORDINATE_SCALE_01RangeLargerAxis
    """

    def __init__(self: MSPyBentleyGeom.LocalCoordinateSelect, value: int) -> None:
        ...
    
    eLOCAL_COORDINATE_SCALE_01RangeBothAxes: LocalCoordinateSelect
    
    eLOCAL_COORDINATE_SCALE_01RangeLargerAxis: LocalCoordinateSelect
    
    eLOCAL_COORDINATE_SCALE_UnitAxesAtLowerLeft: LocalCoordinateSelect
    
    eLOCAL_COORDINATE_SCALE_UnitAxesAtStart: LocalCoordinateSelect
    
    @property
    def name(self: handle) -> str:
        ...
    
    @property
    def value(arg0: MSPyBentleyGeom.LocalCoordinateSelect) -> int:
        ...
    
class LocalRange:
    """
    None
    """

    def DistanceOutside(*args, **kwargs):
        """
        DistanceOutside(self: MSPyBentleyGeom.LocalRange, spacePoint: Bentley.DPoint3d) -> float
        """
        ...
    
    def InitFromPrincipalAxesOfPoints(*args, **kwargs):
        """
        InitFromPrincipalAxesOfPoints(*args, **kwargs)
        Overloaded function.
        
        1. InitFromPrincipalAxesOfPoints(self: MSPyBentleyGeom.LocalRange, xyz: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >) -> bool
        
        2. InitFromPrincipalAxesOfPoints(self: MSPyBentleyGeom.LocalRange, xyzw: Bentley.Bstdcxx.bvector<Bentley.DPoint4d,Bentley.BentleyAllocator<Bentley.DPoint4d> >) -> bool
        """
        ...
    
    def InitNullRange(*args, **kwargs):
        """
        InitNullRange(self: MSPyBentleyGeom.LocalRange) -> None
        
        Initialize with identity transforms and an empty range. Initialize
        with identity transforms and an empty range.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.LocalRange) -> None
        
        2. __init__(self: MSPyBentleyGeom.LocalRange, localToWorld: Bentley.Transform, worldToLocal: Bentley.Transform, localRange: Bentley.DRange3d) -> None
        """
        ...
    
    @property
    def localRange(self: MSPyBentleyGeom.LocalRange) -> Bentley.DRange3d:
        ...
    @localRange.setter
    def localRange(self: MSPyBentleyGeom.LocalRange, arg0: Bentley.DRange3d) -> None:
        ...
    
    @property
    def localToWorld(self: MSPyBentleyGeom.LocalRange) -> Bentley.Transform:
        ...
    @localToWorld.setter
    def localToWorld(self: MSPyBentleyGeom.LocalRange, arg0: Bentley.Transform) -> None:
        ...
    
    @property
    def worldRange(self: MSPyBentleyGeom.LocalRange) -> Bentley.DRange3d:
        ...
    @worldRange.setter
    def worldRange(self: MSPyBentleyGeom.LocalRange, arg0: Bentley.DRange3d) -> None:
        ...
    
    @property
    def worldToLocal(self: MSPyBentleyGeom.LocalRange) -> Bentley.Transform:
        ...
    @worldToLocal.setter
    def worldToLocal(self: MSPyBentleyGeom.LocalRange, arg0: Bentley.Transform) -> None:
        ...
    
MSB_ERROR: int

MSB_SUCCESS: int

class MSBsplineCurve:
    """
    None
    """

    def AddArcIntersectionsXY(*args, **kwargs):
        """
        AddArcIntersectionsXY(self: MSPyBentleyGeom.MSBsplineCurve, curvePoints: MSPyBentleyGeom.DPoint3dArray, curveFractions: MSPyBentley.DoubleArray, ellipsePoints: MSPyBentleyGeom.DPoint3dArray, ellipseFractions: MSPyBentley.DoubleArray, arc: MSPyBentleyGeom.DEllipse3d, extendConic: bool, matrix: MSPyBentleyGeom.DMatrix4d) -> None
        """
        ...
    
    def AddCurveIntersectionsXY(*args, **kwargs):
        """
        AddCurveIntersectionsXY(self: MSPyBentleyGeom.MSBsplineCurve, curveAPoints: MSPyBentleyGeom.DPoint3dArray, curveAFractions: MSPyBentley.DoubleArray, curveBPoints: MSPyBentleyGeom.DPoint3dArray, curveBFractions: MSPyBentley.DoubleArray, curveB: MSPyBentleyGeom.MSBsplineCurve, matrix: MSPyBentleyGeom.DMatrix4d) -> None
        """
        ...
    
    def AddCusps(*args, **kwargs):
        """
        AddCusps(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, fractionParameters: MSPyBentley.DoubleArray) -> None
        
        Find full 3d cusps.
        
        Parameter ``[out]``:
        points array to receive xyz of cusps.
        
        Parameter ``[out]``:
        fractionParameters array to receive fraction parameters of cusps.
        """
        ...
    
    def AddCuspsXY(*args, **kwargs):
        """
        AddCuspsXY(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, fractionParameters: MSPyBentley.DoubleArray, matrix: MSPyBentleyGeom.DMatrix4d) -> None
        
        Find full cusps as viewed in xy.
        
        Parameter ``[out]``:
        points array to receive xyz of cusps.
        
        Parameter ``[out]``:
        fractionParameters array to receive fraction parameters of cusps.
        
        Parameter ``[in]``:
        matrix optional transformation into viewing space.
        """
        ...
    
    def AddKnot(*args, **kwargs):
        """
        AddKnot(self: MSPyBentleyGeom.MSBsplineCurve, unnormalizedKnotValue: float, newMultiplicity: int) -> int
        
        Add a given knot value to the B-spline curve. that newMultiplicity is
        the desired final multiplicity of a knot that may already exist.
        """
        ...
    
    def AddLineIntersectionsXY(*args, **kwargs):
        """
        AddLineIntersectionsXY(*args, **kwargs)
        Overloaded function.
        
        1. AddLineIntersectionsXY(self: MSPyBentleyGeom.MSBsplineCurve, curvePoints: MSPyBentleyGeom.DPoint3dArray, curveFractions: MSPyBentley.DoubleArray, linePoints: MSPyBentleyGeom.DPoint3dArray, lineFractions: MSPyBentley.DoubleArray, segment: MSPyBentleyGeom.DSegment3d, extendSegment: bool, matrix: MSPyBentleyGeom.DMatrix4d) -> None
        
        2. AddLineIntersectionsXY(self: MSPyBentleyGeom.MSBsplineCurve, curvePoints: MSPyBentleyGeom.DPoint3dArray, curveFractions: MSPyBentley.DoubleArray, linePoints: MSPyBentleyGeom.DPoint3dArray, lineFractions: MSPyBentley.DoubleArray, segment: MSPyBentleyGeom.DSegment3d, extendSegment0: bool, extendSegment1: bool, matrix: MSPyBentleyGeom.DMatrix4d) -> None
        """
        ...
    
    def AddLinestringIntersectionsXY(*args, **kwargs):
        """
        AddLinestringIntersectionsXY(*args, **kwargs)
        Overloaded function.
        
        1. AddLinestringIntersectionsXY(self: MSPyBentleyGeom.MSBsplineCurve, curveAPoints: MSPyBentleyGeom.DPoint3dArray, curveAFractions: MSPyBentley.DoubleArray, curveBPoints: MSPyBentleyGeom.DPoint3dArray, curveBFractions: MSPyBentley.DoubleArray, lineString: MSPyBentleyGeom.DPoint3dArray, matrix: MSPyBentleyGeom.DMatrix4d) -> None
        
        2. AddLinestringIntersectionsXY(self: MSPyBentleyGeom.MSBsplineCurve, curveAPoints: MSPyBentleyGeom.DPoint3dArray, curveAFractions: MSPyBentley.DoubleArray, curveBPoints: MSPyBentleyGeom.DPoint3dArray, curveBFractions: MSPyBentley.DoubleArray, lineString: MSPyBentleyGeom.DPoint3dArray, extendLineString: bool, matrix: MSPyBentleyGeom.DMatrix4d) -> None
        """
        ...
    
    def AddPlaneIntersections(*args, **kwargs):
        """
        AddPlaneIntersections(*args, **kwargs)
        Overloaded function.
        
        1. AddPlaneIntersections(self: MSPyBentleyGeom.MSBsplineCurve, point: MSPyBentleyGeom.DPoint3dArray, fractionParameters: MSPyBentley.DoubleArray, plane: MSPyBentleyGeom.DPlane3d) -> None
        
        2. AddPlaneIntersections(self: MSPyBentleyGeom.MSBsplineCurve, point: MSPyBentleyGeom.DPoint3dArray, fractionParameters: MSPyBentley.DoubleArray, planeCoeffs: MSPyBentleyGeom.DPoint4d) -> None
        """
        ...
    
    def AddRuleSurfaceRayIntersections(*args, **kwargs):
        """
        AddRuleSurfaceRayIntersections(pickData: MSPyBentleyGeom.SolidLocationDetailArray, curveA: MSPyBentleyGeom.MSBsplineCurve, curveB: MSPyBentleyGeom.MSBsplineCurve, ray: MSPyBentleyGeom.DRay3d) -> bool
        """
        ...
    
    def AddStrokes(*args, **kwargs):
        """
        AddStrokes(*args, **kwargs)
        Overloaded function.
        
        1. AddStrokes(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, chordTol: float = 0.0, angleTol: float = 0.2, maxEdgeLength: float = 0.0, includeStartPoint: bool = True) -> None
        
        2. AddStrokes(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, derivatives: MSPyBentleyGeom.DVec3dArray = None, params: MSPyBentley.DoubleArray = None, chordTol: float = 0.0, angleTol: float = 0.2, maxEdgeLength: float = 0.0, includeStartPoint: bool = True, parameterSelect: MSPyBentleyGeom.CurveParameterMapping = <CurveParameterMapping.eCURVE_PARAMETER_MAPPING_CurveKnot: 1>) -> None
        
        3. AddStrokes(self: MSPyBentleyGeom.MSBsplineCurve, options: MSPyBentleyGeom.IFacetOptions, points: MSPyBentleyGeom.DPoint3dArray, derivatives: MSPyBentleyGeom.DVec3dArray = None, params: MSPyBentley.DoubleArray = None, includeStart: bool = True) -> None
        
        4. AddStrokes(self: MSPyBentleyGeom.MSBsplineCurve, numPoints: int, points: MSPyBentleyGeom.DPoint3dArray, derivatives: MSPyBentleyGeom.DVec3dArray = None, params: MSPyBentley.DoubleArray = None, includeStartPoint: bool = True, parameterSelect: MSPyBentleyGeom.CurveParameterMapping = <CurveParameterMapping.eCURVE_PARAMETER_MAPPING_CurveKnot: 1>) -> None
        """
        ...
    
    def AdvanceToBezierInFractionInterval(*args, **kwargs):
        """
        AdvanceToBezierInFractionInterval(self: MSPyBentleyGeom.MSBsplineCurve, segment: MSPyBentleyGeom.BCurveSegment, interval: MSPyBentleyGeom.DRange1d) -> tuple
        """
        ...
    
    def AdvanceToBezierInKnotInterval(*args, **kwargs):
        """
        AdvanceToBezierInKnotInterval(self: MSPyBentleyGeom.MSBsplineCurve, segment: MSPyBentleyGeom.BCurveSegment, interval: MSPyBentleyGeom.DRange1d) -> tuple
        """
        ...
    
    def AllParallellTangentsXY(*args, **kwargs):
        """
        AllParallellTangentsXY(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, fractions: MSPyBentley.DoubleArray, vector: MSPyBentleyGeom.DVec3d) -> None
        
        Find all curve points X where the tangents is parallel to the given
        vector.
        
        Parameter ``[out]``:
        points array to receive points.
        
        Parameter ``[out]``:
        fractions array to receive fraction parameters.
        
        Parameter ``[in]``:
        vector given direction.
        """
        ...
    
    def AllTangents(*args, **kwargs):
        """
        AllTangents(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, fractions: MSPyBentley.DoubleArray, spacePoint: MSPyBentleyGeom.DPoint3d) -> None
        
        For space point Q, find all curve points X where line XQ is tangent to
        the curve.
        
        Parameter ``[out]``:
        points array to receive points.
        
        Parameter ``[out]``:
        fractions array to receive fraction parameters.
        
        Parameter ``[in]``:
        spacePoint space point.
        """
        ...
    
    def AllTangentsXY(*args, **kwargs):
        """
        AllTangentsXY(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, fractions: MSPyBentley.DoubleArray, spacePoint: MSPyBentleyGeom.DPoint3d, matrix: MSPyBentleyGeom.DMatrix4d) -> None
        
        For space point Q (spacePoint), find all curve points X where line XQ
        is tangent to the curve.
        
        Parameter ``[out]``:
        points array to receive points.
        
        Parameter ``[out]``:
        fractions array to receive fraction parameters.
        
        Parameter ``[in]``:
        spacePoint space point.
        
        Parameter ``[in]``:
        matrix optional transformation into viewing space.
        """
        ...
    
    def Allocate(*args, **kwargs):
        """
        Allocate(*args, **kwargs)
        Overloaded function.
        
        1. Allocate(self: MSPyBentleyGeom.MSBsplineCurve) -> int
        
        Allocate memory arrays to match the current counts.
        
        2. Allocate(self: MSPyBentleyGeom.MSBsplineCurve, numPoles: int, order: int, closed: bool, rational: bool) -> int
        
        Allocate memory arrays to match the current counts.
        """
        ...
    
    def AllocateKnots(*args, **kwargs):
        """
        AllocateKnots(self: MSPyBentleyGeom.MSBsplineCurve, count: int, data: float = None) -> int
        
        <summary>Allocate knot pointer to specified count. (Optionally)copy
        data from callers buffer</summary>
        """
        ...
    
    def AllocatePoles(*args, **kwargs):
        """
        AllocatePoles(self: MSPyBentleyGeom.MSBsplineCurve, count: int, data: MSPyBentleyGeom.DPoint3d = None) -> int
        
        <summary>Allocate pole pointer to specified count. (Optionally)copy
        data from callers buffer</summary>
        """
        ...
    
    def AllocateWeights(*args, **kwargs):
        """
        AllocateWeights(self: MSPyBentleyGeom.MSBsplineCurve, count: int, data: float = None) -> int
        
        <summary>Allocate weight pointer to specified count. (Optionally)copy
        data from callers buffer</summary>
        """
        ...
    
    def AlmostEqual(*args, **kwargs):
        """
        AlmostEqual(*args, **kwargs)
        Overloaded function.
        
        1. AlmostEqual(self: MSPyBentleyGeom.MSBsplineCurve, other: MSPyBentleyGeom.MSBsplineCurve) -> bool
        
        Compare curves.
        
        2. AlmostEqual(self: MSPyBentleyGeom.MSBsplineCurve, other: MSPyBentleyGeom.MSBsplineCurve, tolerance: float) -> bool
        
        Compare curves.
        """
        ...
    
    def AppendCurve(*args, **kwargs):
        """
        AppendCurve(self: MSPyBentleyGeom.MSBsplineCurve, inCurve: MSPyBentleyGeom.MSBsplineCurve) -> int
        
        Change the B-spline curve by appending a given curve.
        """
        ...
    
    def AppendCurves(*args, **kwargs):
        """
        AppendCurves(self: MSPyBentleyGeom.MSBsplineCurve, inCurve1: MSPyBentleyGeom.MSBsplineCurve, inCurve2: MSPyBentleyGeom.MSBsplineCurve, forceContinuity: bool, reparam: bool) -> int
        
        Create the B-spline curve by appending two input curves with
        continuity and reparameterization constraints.
        """
        ...
    
    def ApproximateAnyCurve(*args, **kwargs):
        """
        ApproximateAnyCurve(self: MSPyBentleyGeom.MSBsplineCurve, inCurve: MSPyBentleyGeom.MSBsplineCurve, tolerance: float, order: int, parameterization: int, bMaintainEndTangents: bool) -> int
        
        This routine computes a B-spline curve approximated the old one.
        return ERROR if no results.
        
        Parameter ``[in]``:
        pIn Input G1 curve.
        
        Parameter ``[in]``:
        tolerance Geometric tolerance, this should be in general the chord
        height tol.
        
        Parameter ``[in]``:
        order Desired degree of the pOut, 4 is recommended.
        
        Parameter ``[in]``:
        parametrization CHORDLENGTH = 2, CENTRIPETAL = 3.
        
        Parameter ``[in]``:
        bMaintainEndTangents true to maintain the end tangents.
        """
        ...
    
    def ApproximateG1Curve(*args, **kwargs):
        """
        ApproximateG1Curve(outCurve: MSPyBentleyGeom.MSBsplineCurve, inCurve: MSPyBentleyGeom.MSBsplineCurve, degree: int, keepTangent: bool, parametrization: int, geomTol: float, paramTol: float, pointTol: float) -> int
        """
        ...
    
    def ApproximateNurbsCurve(*args, **kwargs):
        """
        ApproximateNurbsCurve(outCurve: MSPyBentleyGeom.MSBsplineCurve, inCurve: MSPyBentleyGeom.MSBsplineCurve, degree: int, keepTangent: bool, parametrization: int, tol: float) -> int
        """
        ...
    
    def AreCompatible(*args, **kwargs):
        """
        AreCompatible(curveA: MSPyBentleyGeom.MSBsplineCurve, curveB: MSPyBentleyGeom.MSBsplineCurve) -> bool
        
        <summary>Test if two curves have compatible knots, order, and pole
        count</summary>
        """
        ...
    
    def AreKnotsValid(*args, **kwargs):
        """
        AreKnotsValid(self: MSPyBentleyGeom.MSBsplineCurve, clampingRequired: bool = True) -> bool
        
        Return false if knot counts or values are invalid.
        """
        ...
    
    def AreSameKnots(*args, **kwargs):
        """
        AreSameKnots(knot0: float, knot1: float) -> bool
        
        Compare knots. Absolute tolerance 1e-8 for knots in -1..1. Relative
        tolerance 1e-8 outside.
        """
        ...
    
    def AreSameWeights(*args, **kwargs):
        """
        AreSameWeights(w0: float, w1: float) -> bool
        
        Compare weights with arbitrary but consistent tolerance.
        """
        ...
    
    def CleanKnots(*args, **kwargs):
        """
        CleanKnots(self: MSPyBentleyGeom.MSBsplineCurve) -> int
        
        Clean all unnecessary knots.
        """
        ...
    
    def ClosestPoint(*args, **kwargs):
        """
        ClosestPoint(self: MSPyBentleyGeom.MSBsplineCurve, curvePoint: MSPyBentleyGeom.DPoint3d, spacePoint: MSPyBentleyGeom.DPoint3d) -> float
        """
        ...
    
    def ClosestPointXY(*args, **kwargs):
        """
        ClosestPointXY(self: MSPyBentleyGeom.MSBsplineCurve, curvePoint: MSPyBentleyGeom.DPoint3d, spacePoint: MSPyBentleyGeom.DPoint3d, viewMatrix: MSPyBentleyGeom.DMatrix4d) -> tuple
        """
        ...
    
    def ClosestTangent(*args, **kwargs):
        """
        ClosestTangent(self: MSPyBentleyGeom.MSBsplineCurve, curvePoint: MSPyBentleyGeom.DPoint3d, spacePoint: MSPyBentleyGeom.DPoint3d, biasPoint: MSPyBentleyGeom.DPoint3d) -> tuple
        """
        ...
    
    def ClosestTangentXY(*args, **kwargs):
        """
        ClosestTangentXY(self: MSPyBentleyGeom.MSBsplineCurve, curvePoint: MSPyBentleyGeom.DPoint3d, spacePoint: MSPyBentleyGeom.DPoint3d, biasPoint: MSPyBentleyGeom.DPoint3d, matrix: MSPyBentleyGeom.DMatrix4d) -> tuple
        """
        ...
    
    def CompressKnots(*args, **kwargs):
        """
        CompressKnots(inKnot: MSPyBentley.DoubleArray, order: int, outKnot: MSPyBentley.DoubleArray, multiplicities: MSPyBentley.UInt64Array) -> tuple
        """
        ...
    
    def ComputeDerivatives(*args, **kwargs):
        """
        ComputeDerivatives(self: MSPyBentleyGeom.MSBsplineCurve, dervs: MSPyBentleyGeom.DVec3d, numDervs: int, fractionParameter: float) -> int
        
        Calculate the number of derivatives specified by numDervs of the
        B-spline curve at a particular fraction.
        """
        ...
    
    def ComputeGrevilleAbscissa(*args, **kwargs):
        """
        ComputeGrevilleAbscissa(self: MSPyBentleyGeom.MSBsplineCurve, averageKnots: MSPyBentley.DoubleArray = True) -> None
        """
        ...
    
    def ComputeInflectionPoints(*args, **kwargs):
        """
        ComputeInflectionPoints(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, params: MSPyBentley.DoubleArray) -> int
        
        Calculate the parameters and location of the all inflection points of
        a B-spline curve. @DotNetMethodExclude
        """
        ...
    
    def ComputeInflectionPointsXY(*args, **kwargs):
        """
        ComputeInflectionPointsXY(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, params: MSPyBentley.DoubleArray, transform: Bentley.RotMatrix) -> int
        
        Calculate the parameters and location of the all inflection points of
        a B-spline curve.
        """
        ...
    
    def ComputeUniformKnotGrevilleAbscissa(*args, **kwargs):
        """
        ComputeUniformKnotGrevilleAbscissa(averageKnots: MSPyBentley.DoubleArray, numInterval: int, order: int) -> None
        """
        ...
    
    def ComputeUniformKnots(*args, **kwargs):
        """
        ComputeUniformKnots(self: MSPyBentleyGeom.MSBsplineCurve) -> bool
        
        Compute uniformly spaced knots. This uses counts from params.
        
        Returns:
        false if param counts are not set.
        """
        ...
    
    def CopyClosed(*args, **kwargs):
        """
        CopyClosed(self: MSPyBentleyGeom.MSBsplineCurve, source: MSPyBentleyGeom.MSBsplineCurve) -> int
        
        Create B-spline curve by closing a open B-spline curve.
        """
        ...
    
    def CopyFractionSegment(*args, **kwargs):
        """
        CopyFractionSegment(self: MSPyBentleyGeom.MSBsplineCurve, source: MSPyBentleyGeom.MSBsplineCurve, fractionA: float, fractionB: float) -> int
        
        Create B-spline curve by extracting a part of a B-spline curve.
        """
        ...
    
    def CopyFrom(*args, **kwargs):
        """
        CopyFrom(self: MSPyBentleyGeom.MSBsplineCurve, source: MSPyBentleyGeom.MSBsplineCurve) -> int
        """
        ...
    
    def CopyOpen(*args, **kwargs):
        """
        CopyOpen(self: MSPyBentleyGeom.MSBsplineCurve, source: MSPyBentleyGeom.MSBsplineCurve, unnormalizedKnot: float) -> int
        
        Create B-spline curve by opening a closed B-spline curve.
        """
        ...
    
    def CopyReversed(*args, **kwargs):
        """
        CopyReversed(self: MSPyBentleyGeom.MSBsplineCurve, source: MSPyBentleyGeom.MSBsplineCurve) -> int
        
        Create B-spline curve by reserving the direction of a B-spline curve.
        """
        ...
    
    def CopySegment(*args, **kwargs):
        """
        CopySegment(self: MSPyBentleyGeom.MSBsplineCurve, source: MSPyBentleyGeom.MSBsplineCurve, unnormalizedKnotA: float, unnormalizedKnotB: float) -> int
        
        Create B-spline curve by extracting a part of a B-spline curve.
        """
        ...
    
    def CopyTransformed(*args, **kwargs):
        """
        CopyTransformed(self: MSPyBentleyGeom.MSBsplineCurve, source: MSPyBentleyGeom.MSBsplineCurve, transform: Bentley.Transform) -> int
        
        Create B-spline curve by transforming a B-spline curve.
        """
        ...
    
    def CountDistinctBeziers(*args, **kwargs):
        """
        CountDistinctBeziers(self: MSPyBentleyGeom.MSBsplineCurve) -> int
        
        Count the number of beziers that have non-null knot intervals.
        """
        ...
    
    def Create(*args, **kwargs):
        """
        Create() -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        """
        ...
    
    def CreateCapture(*args, **kwargs):
        """
        CreateCapture(self: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        
        <summary>Copy bits into smart pointer. Caller instance zeroed
        out.<summary>
        """
        ...
    
    def CreateCopy(*args, **kwargs):
        """
        CreateCopy(self: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        
        <summary>Return copy as smart pointer target.</summary>
        """
        ...
    
    def CreateCopyBetweenFractions(*args, **kwargs):
        """
        CreateCopyBetweenFractions(self: MSPyBentleyGeom.MSBsplineCurve, fraction0: float, fraction1: float) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        
        <summary>Copy the portion between specified fractions.</summary>
        """
        ...
    
    def CreateCopyBetweenKnots(*args, **kwargs):
        """
        CreateCopyBetweenKnots(self: MSPyBentleyGeom.MSBsplineCurve, konot0: float, knot1: float) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        
        <summary>Copy the portion between specified knots.</summary>
        """
        ...
    
    def CreateCopyBezier(*args, **kwargs):
        """
        CreateCopyBezier(self: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        
        <summary>Copy with all knots saturated.</summary>
        """
        ...
    
    def CreateCopyClosed(*args, **kwargs):
        """
        CreateCopyClosed(self: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        
        <summary>Return copy as smart pointer target; if physically closed
        revise poles to be a closed bspline</summary>
        """
        ...
    
    def CreateCopyOffsetXY(*args, **kwargs):
        """
        CreateCopyOffsetXY(self: MSPyBentleyGeom.MSBsplineCurve, offset0: float, offset1: float, options: MSPyBentleyGeom.CurveOffsetOptions) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        
        <summary>Copy with offset in XY plane.</summary>
        """
        ...
    
    def CreateCopyOpenAtFraction(*args, **kwargs):
        """
        CreateCopyOpenAtFraction(self: MSPyBentleyGeom.MSBsplineCurve, fraction: float) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        
        <summary>Return copy as smart pointer target; if closed, open it at
        fraction.</summary>
        """
        ...
    
    def CreateCopyOpenAtKnot(*args, **kwargs):
        """
        CreateCopyOpenAtKnot(self: MSPyBentleyGeom.MSBsplineCurve, knot: float) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        
        <summary>Return copy as smart pointer target; if closed, open it at
        knot.</summary>
        """
        ...
    
    def CreateCopyReversed(*args, **kwargs):
        """
        CreateCopyReversed(self: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        
        <summary>Complete copy with reversed parameterization.</summary>
        """
        ...
    
    def CreateCopyTransformed(*args, **kwargs):
        """
        CreateCopyTransformed(self: MSPyBentleyGeom.MSBsplineCurve, transform: Bentley.Transform) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        
        <summary>Copy with transform applied to poles.</summary>
        """
        ...
    
    def CreateFromInterpolationAtBasisFunctionPeaks(*args, **kwargs):
        """
        CreateFromInterpolationAtBasisFunctionPeaks(xyz: MSPyBentleyGeom.DPoint3dArray, order: int, selector: int = 0) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        """
        ...
    
    def CreateFromInterpolationAtGrevilleKnots(*args, **kwargs):
        """
        CreateFromInterpolationAtGrevilleKnots(curve: MSPyBentleyGeom.ICurvePrimitive, numPoles: int, order: int, normalizeKnots: bool, knotSelector: int = 0) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        """
        ...
    
    def CreateFromInterpolationPointsWithKnots(*args, **kwargs):
        """
        CreateFromInterpolationPointsWithKnots(xyz: MSPyBentleyGeom.DPoint3dArray, interpolationKnots: MSPyBentley.DoubleArray, curveKnots: MSPyBentley.DoubleArray, order: int) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        """
        ...
    
    def CreateFromPointsAndOrder(*args, **kwargs):
        """
        CreateFromPointsAndOrder(self: MSPyBentleyGeom.MSBsplineCurve, pointArray: MSPyBentleyGeom.DPoint3dArray, order: int, closed: bool = False) -> int
        
        Create the B-spline curve from point array and order.
        """
        ...
    
    def CreateFromPolesAndOrder(*args, **kwargs):
        """
        CreateFromPolesAndOrder(poles: MSPyBentleyGeom.DPoint3dArray, weights: MSPyBentley.DoubleArray, knots: MSPyBentley.DoubleArray, order: int, closed: bool, inputPolesAlreadyWeighted: bool = True) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        """
        ...
    
    def CreateInterpolationBetweenCurves(*args, **kwargs):
        """
        CreateInterpolationBetweenCurves(curveA: MSPyBentleyGeom.MSBsplineCurve, fraction: float, curveB: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        
        <summary>Create a curve whose poles are interpolated between the poles
        of two curves.</summary> <remarks>This will only succeed if the curves
        have the same pole, knot, and order structure</remarks>
        """
        ...
    
    @property
    def CurveDisplay(arg0: MSPyBentleyGeom.MSBsplineCurve) -> bool:
        ...
    @CurveDisplay.setter
    def CurveDisplay(arg0: MSPyBentleyGeom.MSBsplineCurve, arg1: bool) -> None:
        ...
    
    def ElevateDegree(*args, **kwargs):
        """
        ElevateDegree(self: MSPyBentleyGeom.MSBsplineCurve, newDegree: int) -> int
        
        Elevate the degree (increases the order) of the B-spline curve.
        """
        ...
    
    def ExtractCurveNormal(*args, **kwargs):
        """
        ExtractCurveNormal(self: MSPyBentleyGeom.MSBsplineCurve, normal: MSPyBentleyGeom.DVec3d, position: MSPyBentleyGeom.DPoint3d) -> tuple
        """
        ...
    
    def ExtractEndPoints(*args, **kwargs):
        """
        ExtractEndPoints(self: MSPyBentleyGeom.MSBsplineCurve, start: MSPyBentleyGeom.DPoint3d, end: MSPyBentleyGeom.DPoint3d) -> None
        
        Extract the start or end point of the B-spline curve.
        """
        ...
    
    def ExtractSegmentBetweenKnots(*args, **kwargs):
        """
        ExtractSegmentBetweenKnots(self: MSPyBentleyGeom.MSBsplineCurve, target: MSPyBentleyGeom.MSBsplineCurve, unnormalizedKnotA: float, unnormalizedKnotB: float) -> int
        
        Exteact the curve from the B-spline curve at the interval
        [unnormalizedKnotA, unnormalizedKnotB].
        """
        ...
    
    def ExtractTo(*args, **kwargs):
        """
        ExtractTo(self: MSPyBentleyGeom.MSBsplineCurve, dest: MSPyBentleyGeom.MSBsplineCurve) -> None
        
        Copy bits into simple structure. Caller instance zeroed.
        """
        ...
    
    def FindKnotInterval(*args, **kwargs):
        """
        FindKnotInterval(self: MSPyBentleyGeom.MSBsplineCurve, knotValue: float) -> int
        
        Return the index of the knot at the left of the interval containing
        specified knot. When knotValue exactly matches a knot, the returned
        index is of the knot to the left - i.e. knotValue appears at the RIGHT
        of the returned interval. (favor knot[index]<knotValue <= knot[index
        + 1])
        """
        ...
    
    def FractionAtSignedDistance(*args, **kwargs):
        """
        FractionAtSignedDistance(*args, **kwargs)
        Overloaded function.
        
        1. FractionAtSignedDistance(self: MSPyBentleyGeom.MSBsplineCurve, startParam: float, signedDistance: float) -> tuple
        
        2. FractionAtSignedDistance(self: MSPyBentleyGeom.MSBsplineCurve, worldToLocal: Bentley.RotMatrix, startParam: float, signedDistance: float) -> tuple
        """
        ...
    
    def FractionToKnot(*args, **kwargs):
        """
        FractionToKnot(self: MSPyBentleyGeom.MSBsplineCurve, f: float) -> float
        
        Return the knot value at a fractional parameter ...
        """
        ...
    
    def FractionToPoint(*args, **kwargs):
        """
        FractionToPoint(*args, **kwargs)
        Overloaded function.
        
        1. FractionToPoint(self: MSPyBentleyGeom.MSBsplineCurve, xyz: MSPyBentleyGeom.DPoint3d, f: float) -> None
        
        2. FractionToPoint(self: MSPyBentleyGeom.MSBsplineCurve, xyz: MSPyBentleyGeom.DPoint3d, tangent: MSPyBentleyGeom.DVec3d, f: float) -> None
        
        3. FractionToPoint(self: MSPyBentleyGeom.MSBsplineCurve, xyz: MSPyBentleyGeom.DPoint3d, tangent: MSPyBentleyGeom.DVec3d, f: float) -> float
        
        4. FractionToPoint(self: MSPyBentleyGeom.MSBsplineCurve, xyz: MSPyBentleyGeom.DPoint3d, dXYZ: MSPyBentleyGeom.DVec3d, ddXYZ: MSPyBentleyGeom.DVec3d, f: float) -> None
        """
        ...
    
    def FractionToPoints(*args, **kwargs):
        """
        FractionToPoints(*args, **kwargs)
        Overloaded function.
        
        1. FractionToPoints(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, numPoints: int) -> None
        
        2. FractionToPoints(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, fractions: MSPyBentley.DoubleArray) -> None
        """
        ...
    
    def GeneralLeastSquaresApproximation(*args, **kwargs):
        """
        GeneralLeastSquaresApproximation(outCurve: MSPyBentleyGeom.MSBsplineCurve, Q: MSPyBentleyGeom.DPoint3dArray, u: MSPyBentley.DoubleArray, knots: MSPyBentley.DoubleArray, numPoles: int, order: int) -> int
        """
        ...
    
    def GetBezier(*args, **kwargs):
        """
        GetBezier(self: MSPyBentleyGeom.MSBsplineCurve, segment: MSPyBentleyGeom.BCurveSegment, bezierSelect: int) -> bool
        
        Get poles for a single bezier poles from the curve. return false if
        invalid bezierSelect. Note that the bezierSelect for a high
        multiplicity knot returns true for the function but marks the interval
        as null. Normal usage is to loop over all beziers in a bspline but
        skip processing the null intervals.
        
        Parameter ``[out]``:
        segment a filled BCurveSegment.
        
        Parameter ``[in]``:
        bezierSelect selects a bezier interval within the bspline
        @DotNetMethodExclude
        """
        ...
    
    def GetC1DiscontinuousCurves(*args, **kwargs):
        """
        GetC1DiscontinuousCurves(self: MSPyBentleyGeom.MSBsplineCurve, fractions: MSPyBentley.DoubleArray, curves: MSPyBentleyGeom.MSBsplineCurvePtrArray) -> None
        
        Create copies of each segment with breaks at point or tangent changes.
        """
        ...
    
    def GetC1DiscontinuousFractions(*args, **kwargs):
        """
        GetC1DiscontinuousFractions(self: MSPyBentleyGeom.MSBsplineCurve, fractions: MSPyBentley.DoubleArray) -> None
        
        Get all C1 fractional Discontinuities. This inspects xyz and tangent
        at each knot break. (It does not look for intraknot cusps)
        @DotNetMethodExclude
        """
        ...
    
    def GetCurveDisplay(*args, **kwargs):
        """
        GetCurveDisplay(self: MSPyBentleyGeom.MSBsplineCurve) -> bool
        
        Return curve display flag.
        """
        ...
    
    def GetDisjointCurves(*args, **kwargs):
        """
        GetDisjointCurves(self: MSPyBentleyGeom.MSBsplineCurve, curves: MSPyBentleyGeom.MSBsplineCurvePtrArray) -> None
        
        Create copies of each segment with breaks at disjoint knot points.
        """
        ...
    
    def GetFrenetFrame(*args, **kwargs):
        """
        GetFrenetFrame(*args, **kwargs)
        Overloaded function.
        
        1. GetFrenetFrame(self: MSPyBentleyGeom.MSBsplineCurve, frame: MSPyBentleyGeom.DVec3d, point: MSPyBentleyGeom.DPoint3d, u: float) -> tuple
        
        2. GetFrenetFrame(self: MSPyBentleyGeom.MSBsplineCurve, frame: Bentley.Transform, u: float) -> int
        """
        ...
    
    def GetKnot(*args, **kwargs):
        """
        GetKnot(self: MSPyBentleyGeom.MSBsplineCurve, index: int) -> float
        
        return knot by index. returns 0 if out of range. (Use
        NumberAllocatedKnots to determine index range).
        """
        ...
    
    def GetKnotP(*args, **kwargs):
        """
        GetKnotP(self: MSPyBentleyGeom.MSBsplineCurve) -> float
        
        return pointer to contiguous knots. @DotNetMethodExclude
        """
        ...
    
    def GetKnotRange(*args, **kwargs):
        """
        GetKnotRange(*args, **kwargs)
        Overloaded function.
        
        1. GetKnotRange(self: MSPyBentleyGeom.MSBsplineCurve) -> tuple
        
        2. GetKnotRange(self: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.DSegment1d
        
        Return the knot values corresponding to fraction 0 and fraction 1 ...
        """
        ...
    
    def GetKnots(*args, **kwargs):
        """
        GetKnots(*args, **kwargs)
        Overloaded function.
        
        1. GetKnots(self: MSPyBentleyGeom.MSBsplineCurve, outData: MSPyBentley.DoubleArray) -> None
        
        Copy all knots out into caller array.
        
        2. GetKnots(self: MSPyBentleyGeom.MSBsplineCurve, outData: MSPyBentleyGeom.DPoint4dArray) -> None
        
        Copy all knots out into caller array.
        """
        ...
    
    def GetNumKnots(*args, **kwargs):
        """
        GetNumKnots(self: MSPyBentleyGeom.MSBsplineCurve) -> int
        """
        ...
    
    def GetNumPoles(*args, **kwargs):
        """
        GetNumPoles(self: MSPyBentleyGeom.MSBsplineCurve) -> int
        """
        ...
    
    def GetOrder(*args, **kwargs):
        """
        GetOrder(self: MSPyBentleyGeom.MSBsplineCurve) -> int
        """
        ...
    
    def GetPole(*args, **kwargs):
        """
        GetPole(self: MSPyBentleyGeom.MSBsplineCurve, index: int) -> MSPyBentleyGeom.DPoint3d
        """
        ...
    
    def GetPoleDPoint4d(*args, **kwargs):
        """
        GetPoleDPoint4d(self: MSPyBentleyGeom.MSBsplineCurve, index: int) -> MSPyBentleyGeom.DPoint4d
        
        return pole by index. returns 0 point if out of range. (Use
        NumberAllocatedPoles to determine index range). @DotNetMethodExclude
        """
        ...
    
    def GetPoleP(*args, **kwargs):
        """
        GetPoleP(self: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.DPoint3d
        
        return pointer to contiguous poles. @DotNetMethodExclude
        """
        ...
    
    def GetPoleRange(*args, **kwargs):
        """
        GetPoleRange(self: MSPyBentleyGeom.MSBsplineCurve, range: MSPyBentleyGeom.DRange3d) -> None
        
        Get the range of the poles of the B-spline curve.
        """
        ...
    
    def GetPoles(*args, **kwargs):
        """
        GetPoles(self: MSPyBentleyGeom.MSBsplineCurve, outData: MSPyBentleyGeom.DPoint3dArray) -> None
        
        Copy all poles out into caller array.
        """
        ...
    
    def GetPolygonDisplay(*args, **kwargs):
        """
        GetPolygonDisplay(self: MSPyBentleyGeom.MSBsplineCurve) -> bool
        
        Return polygon display flag.
        """
        ...
    
    def GetRange(*args, **kwargs):
        """
        GetRange(self: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.DRange3d
        
        Get the range of the B-spline curve.
        """
        ...
    
    def GetRangeOfProjectionOnRay(*args, **kwargs):
        """
        GetRangeOfProjectionOnRay(self: MSPyBentleyGeom.MSBsplineCurve, ray: MSPyBentleyGeom.DRay3d, fraction0: float = 0.0, fraction1: float = 1.0) -> MSPyBentleyGeom.DRange1d
        
        Get the range of parameters of the projection of (a fractional portion
        of the curve onto a ray return range whose low and high values are the
        extreme parameters (in ray fractions) of the projection of the curve
        onto the ray.
        
        Parameter ``[in]``:
        ray ray to project to
        
        Parameter ``[in]``:
        fraction0 start of active part of the curve
        
        Parameter ``[in]``:
        fraction1 end of active part of the curve
        """
        ...
    
    def GetRemovalKnotBound(*args, **kwargs):
        """
        GetRemovalKnotBound(curve: MSPyBentleyGeom.MSBsplineCurve, r: int, s: int) -> float
        
        Compute the bound of remove r-th knot s times
        """
        ...
    
    def GetReversePole(*args, **kwargs):
        """
        GetReversePole(self: MSPyBentleyGeom.MSBsplineCurve, index: int) -> MSPyBentleyGeom.DPoint3d
        
        return pole by index, counting from the last pole . (i.e. index 0 is
        the final weight) Returns 0 point if out of range. (Use
        NumberAllocatedPoles to determine index range). @DotNetMethodExclude
        """
        ...
    
    def GetReverseWeight(*args, **kwargs):
        """
        GetReverseWeight(self: MSPyBentleyGeom.MSBsplineCurve, index: int) -> float
        
        return weight by index, counting from the last weight. (i.e. index 0
        is the final weight) Returns 1.0 if out of range. (Use
        NumberAllocatedPoles to determine index range). @DotNetMethodExclude
        """
        ...
    
    def GetStrokeCount(*args, **kwargs):
        """
        GetStrokeCount(self: MSPyBentleyGeom.MSBsplineCurve, chordTol: float, angleTol: float, maxEdgeLength: float) -> int
        
        Compute stroke count
        """
        ...
    
    def GetTailBezierSelect(*args, **kwargs):
        """
        GetTailBezierSelect(self: MSPyBentleyGeom.MSBsplineCurve) -> int
        
        return an index to use to start " Retreat " order bezier access.
        """
        ...
    
    def GetUnWeightedPole(*args, **kwargs):
        """
        GetUnWeightedPole(self: MSPyBentleyGeom.MSBsplineCurve, index: int, reverse: bool = False) -> MSPyBentleyGeom.DPoint3d
        
        return pole by index. returns 0 point if out of range. If spline is
        weighted, the weight is divided out. If weight zero, no division
        happens. (Use NumberAllocatedPoles to determine index range).
        @DotNetMethodExclude
        """
        ...
    
    def GetUnWeightedPoles(*args, **kwargs):
        """
        GetUnWeightedPoles(self: MSPyBentleyGeom.MSBsplineCurve, outData: MSPyBentleyGeom.DPoint3dArray) -> None
        
        Copy all poles out into caller array, dividing each by its weight
        """
        ...
    
    def GetWeight(*args, **kwargs):
        """
        GetWeight(self: MSPyBentleyGeom.MSBsplineCurve, arg0: int) -> float
        
        index
        """
        ...
    
    def GetWeightP(*args, **kwargs):
        """
        GetWeightP(self: MSPyBentleyGeom.MSBsplineCurve) -> float
        
        return pointer to contiguous weights @DotNetMethodExclude
        """
        ...
    
    def GetWeightRange(*args, **kwargs):
        """
        GetWeightRange(self: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.DRange1d
        """
        ...
    
    def GetWeights(*args, **kwargs):
        """
        GetWeights(self: MSPyBentleyGeom.MSBsplineCurve, outData: MSPyBentley.DoubleArray) -> None
        
        Copy all weights out into caller array.
        """
        ...
    
    def HasValidCountsAndAllocations(*args, **kwargs):
        """
        HasValidCountsAndAllocations(self: MSPyBentleyGeom.MSBsplineCurve) -> bool
        """
        ...
    
    def HasValidKnotAllocation(*args, **kwargs):
        """
        HasValidKnotAllocation(self: MSPyBentleyGeom.MSBsplineCurve) -> bool
        """
        ...
    
    def HasValidOrder(*args, **kwargs):
        """
        HasValidOrder(self: MSPyBentleyGeom.MSBsplineCurve) -> bool
        """
        ...
    
    def HasValidPoleAllocation(*args, **kwargs):
        """
        HasValidPoleAllocation(self: MSPyBentleyGeom.MSBsplineCurve) -> bool
        """
        ...
    
    def HasValidPoleCounts(*args, **kwargs):
        """
        HasValidPoleCounts(self: MSPyBentleyGeom.MSBsplineCurve) -> bool
        """
        ...
    
    def HasValidWeightAllocation(*args, **kwargs):
        """
        HasValidWeightAllocation(self: MSPyBentleyGeom.MSBsplineCurve) -> bool
        """
        ...
    
    def HasWeights(*args, **kwargs):
        """
        HasWeights(self: MSPyBentleyGeom.MSBsplineCurve) -> bool
        
        Check whether the B-spline curve has stored weights (This does not
        check if any are other than 1.0)
        """
        ...
    
    def InitAkima(*args, **kwargs):
        """
        InitAkima(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, compressPoints: bool) -> None
        """
        ...
    
    def InitEllipticArc(*args, **kwargs):
        """
        InitEllipticArc(self: MSPyBentleyGeom.MSBsplineCurve, center: MSPyBentleyGeom.DPoint3d, rX: float, rY: float, startRadians: float = 0.0, sweepRadians: float = 6.283185307179586, axes: Bentley.RotMatrix = None) -> int
        """
        ...
    
    def InitFromBeziers(*args, **kwargs):
        """
        InitFromBeziers(self: MSPyBentleyGeom.MSBsplineCurve, beziers: MSPyBentleyGeom.MSBsplineCurveArray) -> int
        
        Create a B-spline curve from a series of Bezier curve.
        """
        ...
    
    def InitFromDEllipse3d(*args, **kwargs):
        """
        InitFromDEllipse3d(self: MSPyBentleyGeom.MSBsplineCurve, ellipse: MSPyBentleyGeom.DEllipse3d) -> int
        
        Initialize the B-spline curve for an ellipse.
        """
        ...
    
    def InitFromDPoint4dArray(*args, **kwargs):
        """
        InitFromDPoint4dArray(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint4dArray, order: int) -> None
        """
        ...
    
    def InitFromGeneralLeastSquares(*args, **kwargs):
        """
        InitFromGeneralLeastSquares(self: MSPyBentleyGeom.MSBsplineCurve, avgDistance: float, maxDistance: float, info: MSPyBentleyGeom.BsplineParam, knts: MSPyBentley.DoubleArray, pnts: MSPyBentleyGeom.DPoint3d, uValues: float, numPnts: int) -> int
        """
        ...
    
    def InitFromInterpolatePoints(*args, **kwargs):
        """
        InitFromInterpolatePoints(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3d, numPoints: int, parameterization: int, endControl: bool, sTangent: MSPyBentleyGeom.DVec3d, eTangent: MSPyBentleyGeom.DVec3d, keepTanMag: bool, order: int) -> int
        """
        ...
    
    def InitFromLeastSquaresFit(*args, **kwargs):
        """
        InitFromLeastSquaresFit(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3d, numPoints: int, endControl: bool, sTangent: MSPyBentleyGeom.DVec3d, eTangent: MSPyBentleyGeom.DVec3d, keepTanMag: bool, iterDegree: int, reqDegree: int, singleKnot: bool, tolerance: float) -> int
        """
        ...
    
    def InitFromPoints(*args, **kwargs):
        """
        InitFromPoints(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray) -> None
        """
        ...
    
    def IsClosed(*args, **kwargs):
        """
        IsClosed(self: MSPyBentleyGeom.MSBsplineCurve) -> bool
        
        Check whether the B-spline curve is periodic.
        """
        ...
    
    def IsParabola(*args, **kwargs):
        """
        IsParabola(self: MSPyBentleyGeom.MSBsplineCurve, localToWorld: Bentley.Transform, worldToLocal: Bentley.Transform, localStart: MSPyBentleyGeom.DPoint3d, localEnd: MSPyBentleyGeom.DPoint3d) -> tuple
        """
        ...
    
    def IsPhysicallyClosed(*args, **kwargs):
        """
        IsPhysicallyClosed(self: MSPyBentleyGeom.MSBsplineCurve, tolerance: float) -> bool
        
        Check whether the B-spline curve is physically closed. A B-spline
        curve may be non-periodic, but still return true if its first and last
        poles coincide.
        """
        ...
    
    def IsSameGeometry(*args, **kwargs):
        """
        IsSameGeometry(self: MSPyBentleyGeom.MSBsplineCurve, other: MSPyBentleyGeom.MSBsplineCurve) -> bool
        
        Check if the B-spline curves has same parameters with the given curve.
        """
        ...
    
    class KnotPosition:
        """
        Members:
        
        eKNOTPOS_BEFORE_START
        
        eKNOTPOS_START
        
        eKNOTPOS_INTERVAL
        
        eKNOTPOS_INTERIOR
        
        eKNOTPOS_FINAL
        
        eKNOTPOS_AFTER_FINAL
        """
    
        def __init__(self: MSPyBentleyGeom.MSBsplineCurve.KnotPosition, value: int) -> None:
            ...
        
        eKNOTPOS_AFTER_FINAL: KnotPosition
        
        eKNOTPOS_BEFORE_START: KnotPosition
        
        eKNOTPOS_FINAL: KnotPosition
        
        eKNOTPOS_INTERIOR: KnotPosition
        
        eKNOTPOS_INTERVAL: KnotPosition
        
        eKNOTPOS_START: KnotPosition
        
        @property
        def name(self: handle) -> str:
            ...
        
        @property
        def value(arg0: MSPyBentleyGeom.MSBsplineCurve.KnotPosition) -> int:
            ...
        
    def KnotRefinement(*args, **kwargs):
        """
        KnotRefinement(X: MSPyBentley.DoubleArray, curve: MSPyBentleyGeom.MSBsplineCurve) -> int
        """
        ...
    
    def KnotToBlendFunctions(*args, **kwargs):
        """
        KnotToBlendFunctions(self: MSPyBentleyGeom.MSBsplineCurve, blend: float, blendDerivatives: float, u: float) -> int
        """
        ...
    
    def KnotToFraction(*args, **kwargs):
        """
        KnotToFraction(self: MSPyBentleyGeom.MSBsplineCurve, knot: float) -> float
        
        Return the fractional parameter corresponding to a knot value ...
        """
        ...
    
    def Length(*args, **kwargs):
        """
        Length(*args, **kwargs)
        Overloaded function.
        
        1. Length(self: MSPyBentleyGeom.MSBsplineCurve) -> float
        
        compute the length of the B-spline curve.
        
        2. Length(self: MSPyBentleyGeom.MSBsplineCurve, worldToLocal: Bentley.RotMatrix) -> float
        
        compute the length of the B-spline curve.
        """
        ...
    
    def LengthBetweenFractions(*args, **kwargs):
        """
        LengthBetweenFractions(*args, **kwargs)
        Overloaded function.
        
        1. LengthBetweenFractions(self: MSPyBentleyGeom.MSBsplineCurve, startKnot: float, endKnot: float) -> float
        
        2. LengthBetweenFractions(self: MSPyBentleyGeom.MSBsplineCurve, worldToLocal: Bentley.RotMatrix, startKnot: float, endKnot: float) -> float
        """
        ...
    
    def LengthBetweenKnots(*args, **kwargs):
        """
        LengthBetweenKnots(*args, **kwargs)
        Overloaded function.
        
        1. LengthBetweenKnots(self: MSPyBentleyGeom.MSBsplineCurve, startKnot: float, endKnot: float) -> float
        
        2. LengthBetweenKnots(self: MSPyBentleyGeom.MSBsplineCurve, worldToLocal: Bentley.RotMatrix, startKnot: float, endKnot: float) -> float
        """
        ...
    
    def MakeBezier(*args, **kwargs):
        """
        MakeBezier(self: MSPyBentleyGeom.MSBsplineCurve, bezierCurve: MSPyBentleyGeom.MSBsplineCurve) -> int
        
        Create equivalent Bezier curve for the B-spline curve.
        """
        ...
    
    def MakeBeziers(*args, **kwargs):
        """
        MakeBeziers(self: MSPyBentleyGeom.MSBsplineCurve, beziers: MSPyBentleyGeom.MSBsplineCurveArray) -> int
        
        Create a series of Bezier curve for the B-spline curve.
        @DotNetMethodExclude
        """
        ...
    
    def MakeClosed(*args, **kwargs):
        """
        MakeClosed(self: MSPyBentleyGeom.MSBsplineCurve) -> int
        
        Close the open B-spline curve.
        """
        ...
    
    def MakeOpen(*args, **kwargs):
        """
        MakeOpen(self: MSPyBentleyGeom.MSBsplineCurve, u: float) -> int
        
        Open the closed B-spline curve.
        """
        ...
    
    def MakeRational(*args, **kwargs):
        """
        MakeRational(self: MSPyBentleyGeom.MSBsplineCurve) -> int
        
        Make an equivalent rational B-spline curve.
        """
        ...
    
    def MakeReversed(*args, **kwargs):
        """
        MakeReversed(self: MSPyBentleyGeom.MSBsplineCurve) -> int
        
        Reverse the direction of the B-spline curve.
        """
        ...
    
    def MapFractions(*args, **kwargs):
        """
        MapFractions(params: MSPyBentley.DoubleArray, derivatives: MSPyBentleyGeom.DVec3dArray, i0: int, knot0: float, knot1: float, select: MSPyBentleyGeom.CurveParameterMapping, curve: MSPyBentleyGeom.MSBsplineCurve) -> None
        """
        ...
    
    def MapKnots(*args, **kwargs):
        """
        MapKnots(self: MSPyBentleyGeom.MSBsplineCurve, a: float, b: float) -> bool
        
        rewrite knot values in a..b. Return true if a,b and current start,end
        define a valid scale factor
        """
        ...
    
    def NormalizeKnots(*args, **kwargs):
        """
        NormalizeKnots(self: MSPyBentleyGeom.MSBsplineCurve) -> None
        
        Normalize knots to 01
        """
        ...
    
    def PointsAtUniformArcLength(*args, **kwargs):
        """
        PointsAtUniformArcLength(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, fractions: MSPyBentley.DoubleArray, numPoints: int) -> bool
        
        Compute points at uniform arclength steps.
        
        Parameter ``[out]``:
        points array to receive points.
        
        Parameter ``[out]``:
        fractions array to receive fractions.
        
        Parameter ``[in]``:
        numPoints number of points.
        """
        ...
    
    def PointsAtUniformFractions(*args, **kwargs):
        """
        PointsAtUniformFractions(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, fractions: MSPyBentley.DoubleArray, numPoints: int) -> None
        
        Compute strokes at uniform fraction step.
        
        Parameter ``[out]``:
        points array to receive points.
        
        Parameter ``[out]``:
        fractions array to receive fractions.
        
        Parameter ``[in]``:
        numPoints number of points.
        """
        ...
    
    @property
    def PolygonDisplay(arg0: MSPyBentleyGeom.MSBsplineCurve) -> bool:
        ...
    @PolygonDisplay.setter
    def PolygonDisplay(arg0: MSPyBentleyGeom.MSBsplineCurve, arg1: bool) -> None:
        ...
    
    def PolygonLength(*args, **kwargs):
        """
        PolygonLength(self: MSPyBentleyGeom.MSBsplineCurve) -> float
        
        Compute the length of the control polygon of the B-spline curve.
        """
        ...
    
    def Populate(*args, **kwargs):
        """
        Populate(self: MSPyBentleyGeom.MSBsplineCurve, pointVector: MSPyBentleyGeom.DPoint3dArray, weightVector: MSPyBentley.DoubleArray, knotVector: MSPyBentley.DoubleArray, order: int, closed: bool, inputPolesAlreadyWeighted: bool) -> int
        """
        ...
    
    def ProjectToZFocalPlane(*args, **kwargs):
        """
        ProjectToZFocalPlane(self: MSPyBentleyGeom.MSBsplineCurve, focalLength: float) -> None
        
        convert to a weighted curve whose normalized points fall on a focal
        plane
        """
        ...
    
    @property
    def Range(arg0: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.DRange3d:
        ...
    
    def ReleaseMem(*args, **kwargs):
        """
        ReleaseMem(self: MSPyBentleyGeom.MSBsplineCurve) -> None
        
        Free memory allocated for the poles, weights and knot vector of a
        B-spline curve.
        """
        ...
    
    def RemoveKnotsBounded(*args, **kwargs):
        """
        RemoveKnotsBounded(self: MSPyBentleyGeom.MSBsplineCurve, tol: float, startPreservation: int, endPreservation: int) -> int
        
        Remove all removable knots with the tolerance and end condition
        constraints.
        """
        ...
    
    def Resolution(*args, **kwargs):
        """
        Resolution(*args, **kwargs)
        Overloaded function.
        
        1. Resolution(self: MSPyBentleyGeom.MSBsplineCurve) -> float
        
        Get a (fairly tight) tolerance for the B-spline curve.
        
        2. Resolution(self: MSPyBentleyGeom.MSBsplineCurve, abstol: float, reltol: float) -> float
        
        Get a (fairly tight) tolerance for the B-spline curve.
        """
        ...
    
    def RetreatToBezierInKnotInterval(*args, **kwargs):
        """
        RetreatToBezierInKnotInterval(self: MSPyBentleyGeom.MSBsplineCurve, segment: MSPyBentleyGeom.BCurveSegment, interval: MSPyBentleyGeom.DRange1d) -> tuple
        """
        ...
    
    def RotateCurve(*args, **kwargs):
        """
        RotateCurve(self: MSPyBentleyGeom.MSBsplineCurve, rMatrix: Bentley.RotMatrix) -> int
        
        Rotate the B-spline curve.
        """
        ...
    
    def RuledSurfaceClosestPoint(*args, **kwargs):
        """
        RuledSurfaceClosestPoint(pickData: MSPyBentleyGeom.SolidLocationDetail, curveA: MSPyBentleyGeom.MSBsplineCurve, curveB: MSPyBentleyGeom.MSBsplineCurve, spacePoint: MSPyBentleyGeom.DPoint3d) -> bool
        """
        ...
    
    def SampleG1CurveByPoints(*args, **kwargs):
        """
        SampleG1CurveByPoints(P: MSPyBentleyGeom.DPoint3dArray, up: MSPyBentley.DoubleArray, uq: MSPyBentley.DoubleArray, curve: MSPyBentleyGeom.MSBsplineCurve, par: int, Eg: float, ptol: float) -> int
        """
        ...
    
    def SearchKnot(*args, **kwargs):
        """
        SearchKnot(self: MSPyBentleyGeom.MSBsplineCurve, unnormalizedKnotValue: float) -> tuple
        """
        ...
    
    def SegmentAkimaCurve(*args, **kwargs):
        """
        SegmentAkimaCurve(self: MSPyBentleyGeom.MSBsplineCurve, segment: MSPyBentleyGeom.DPoint3dArray, akimaCurve: MSPyBentleyGeom.DPoint3dArray, transform: Bentley.Transform, param0: float, param1: float, tolerance: float = -1.0) -> bool
        """
        ...
    
    def SetCurveDisplay(*args, **kwargs):
        """
        SetCurveDisplay(self: MSPyBentleyGeom.MSBsplineCurve, value: bool) -> None
        
        Set the curve display flag.
        """
        ...
    
    def SetKnot(*args, **kwargs):
        """
        SetKnot(self: MSPyBentleyGeom.MSBsplineCurve, index: int, value: float) -> bool
        
        set weight by index. returns false if index out of range.
        @DotNetMethodExclude
        """
        ...
    
    def SetKnots(*args, **kwargs):
        """
        SetKnots(self: MSPyBentleyGeom.MSBsplineCurve, index: int, value: float, n: int) -> bool
        
        set weight by index. returns false if index out of range.
        @DotNetMethodExclude
        """
        ...
    
    def SetPole(*args, **kwargs):
        """
        SetPole(*args, **kwargs)
        Overloaded function.
        
        1. SetPole(self: MSPyBentleyGeom.MSBsplineCurve, index: int, value: MSPyBentleyGeom.DPoint3d) -> bool
        
        set pole by index. returns false if index out of range.
        @DotNetMethodExclude
        
        2. SetPole(self: MSPyBentleyGeom.MSBsplineCurve, index: int, x: float, y: float, z: float) -> bool
        
        set pole by index. returns false if index out of range.
        @DotNetMethodExclude
        """
        ...
    
    def SetPoles(*args, **kwargs):
        """
        SetPoles(self: MSPyBentleyGeom.MSBsplineCurve, index: int, value: MSPyBentleyGeom.DPoint3d, n: int) -> bool
        
        set pole by index. returns false if index out of range.
        @DotNetMethodExclude
        """
        ...
    
    def SetPolygonDisplay(*args, **kwargs):
        """
        SetPolygonDisplay(self: MSPyBentleyGeom.MSBsplineCurve, value: bool) -> None
        
        Set the polygon display flag.
        """
        ...
    
    def SetReWeightedPole(*args, **kwargs):
        """
        SetReWeightedPole(self: MSPyBentleyGeom.MSBsplineCurve, index: int, value: MSPyBentleyGeom.DPoint3d, reverse: bool = False) -> bool
        
        set pole by index. returns false if index out of range. If the curve
        is weighted, the current weight is multiplied into the input pole.
        @DotNetMethodExclude
        """
        ...
    
    def SetWeight(*args, **kwargs):
        """
        SetWeight(self: MSPyBentleyGeom.MSBsplineCurve, index: int, value: float) -> bool
        
        set weight by index. returns false if index out of range.
        @DotNetMethodExclude
        """
        ...
    
    def SetWeights(*args, **kwargs):
        """
        SetWeights(self: MSPyBentleyGeom.MSBsplineCurve, index: int, value: float, n: int) -> bool
        
        set weight by index. returns false if index out of range.
        @DotNetMethodExclude
        """
        ...
    
    def SwapContents(*args, **kwargs):
        """
        SwapContents(self: MSPyBentleyGeom.MSBsplineCurve, other: MSPyBentleyGeom.MSBsplineCurve) -> None
        
        Exchange all bits with other. Usually used to transfer poles etc and
        leave zeros behind.
        """
        ...
    
    def TransformCurve(*args, **kwargs):
        """
        TransformCurve(self: MSPyBentleyGeom.MSBsplineCurve, transform: Bentley.Transform) -> int
        
        Transform the B-spline curve.
        """
        ...
    
    def TransformCurve4d(*args, **kwargs):
        """
        TransformCurve4d(self: MSPyBentleyGeom.MSBsplineCurve, transform4d: MSPyBentleyGeom.DMatrix4d) -> int
        
        Transform the B-spline curve using a 4d transformation.
        """
        ...
    
    def TransformPoles(*args, **kwargs):
        """
        TransformPoles(*args, **kwargs)
        Overloaded function.
        
        1. TransformPoles(self: MSPyBentleyGeom.MSBsplineCurve, transform: Bentley.Transform, index: int, n: int) -> None
        
        Apply a transform to a single pole.
        
        2. TransformPoles(self: MSPyBentleyGeom.MSBsplineCurve, transform: Bentley.Transform, index: int, n: int) -> None
        
        Apply a transform to a single pole.
        """
        ...
    
    def UnWeightPoles(*args, **kwargs):
        """
        UnWeightPoles(self: MSPyBentleyGeom.MSBsplineCurve) -> None
        
        if the curve is rational, divide (wx,wy,wz) style poles by the weights
        """
        ...
    
    def WeightPoles(*args, **kwargs):
        """
        WeightPoles(self: MSPyBentleyGeom.MSBsplineCurve) -> None
        
        if the curve is rational, multiply (wx,wy,wz) style poles by the
        weights
        """
        ...
    
    def WeightedLeastSquaresFit(*args, **kwargs):
        """
        WeightedLeastSquaresFit(outCurve: MSPyBentleyGeom.MSBsplineCurve, Q: MSPyBentleyGeom.DPoint3dArray, u: MSPyBentley.DoubleArray, endControl: bool, sTangent: MSPyBentleyGeom.DVec3d, eTangent: MSPyBentleyGeom.DVec3d, numPoles: int, order: int) -> int
        """
        ...
    
    def WireCentroid(*args, **kwargs):
        """
        WireCentroid(self: MSPyBentleyGeom.MSBsplineCurve, centroid: MSPyBentleyGeom.DPoint3d, fraction0: float, fraction1: float) -> float
        """
        ...
    
    def Zero(*args, **kwargs):
        """
        Zero(self: MSPyBentleyGeom.MSBsplineCurve) -> None
        
        <summary>Zero out the curve. This is customarily applied immediately
        after allocation on stack or heap. This does NOT free memory from
        prior contents. </summary>
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    
    @property
    def display(self: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.BsplineDisplay:
        ...
    @display.setter
    def display(self: MSPyBentleyGeom.MSBsplineCurve, arg0: MSPyBentleyGeom.BsplineDisplay) -> None:
        ...
    
    eKNOTPOS_AFTER_FINAL: KnotPosition
    
    eKNOTPOS_BEFORE_START: KnotPosition
    
    eKNOTPOS_FINAL: KnotPosition
    
    eKNOTPOS_INTERIOR: KnotPosition
    
    eKNOTPOS_INTERVAL: KnotPosition
    
    eKNOTPOS_START: KnotPosition
    
    @property
    def params(self: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.BsplineParam:
        ...
    @params.setter
    def params(self: MSPyBentleyGeom.MSBsplineCurve, arg0: MSPyBentleyGeom.BsplineParam) -> None:
        ...
    
    @property
    def rational(self: MSPyBentleyGeom.MSBsplineCurve) -> int:
        ...
    @rational.setter
    def rational(self: MSPyBentleyGeom.MSBsplineCurve, arg0: int) -> None:
        ...
    
    @property
    def type(self: MSPyBentleyGeom.MSBsplineCurve) -> int:
        ...
    @type.setter
    def type(self: MSPyBentleyGeom.MSBsplineCurve, arg0: int) -> None:
        ...
    
class MSBsplineCurveArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.MSBsplineCurveArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.MSBsplineCurveArray, arg0: MSPyBentleyGeom.MSBsplineCurveArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.MSBsplineCurveArray, arg0: Iterable) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.MSBsplineCurveArray, x: MSPyBentleyGeom.MSBsplineCurve) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.MSBsplineCurveArray) -> None
        
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.MSBsplineCurveArray, L: MSPyBentleyGeom.MSBsplineCurveArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.MSBsplineCurveArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.MSBsplineCurveArray, i: int, x: MSPyBentleyGeom.MSBsplineCurve) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.MSBsplineCurveArray) -> MSPyBentleyGeom.MSBsplineCurve
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.MSBsplineCurveArray, i: int) -> MSPyBentleyGeom.MSBsplineCurve
        
        Remove and return the item at index ``i``
        """
        ...
    
class MSBsplineCurvePtrArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.MSBsplineCurvePtrArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.MSBsplineCurvePtrArray, arg0: MSPyBentleyGeom.MSBsplineCurvePtrArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.MSBsplineCurvePtrArray, arg0: Iterable) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.MSBsplineCurvePtrArray, x: MSPyBentleyGeom.RefCountedMSBsplineCurve) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.MSBsplineCurvePtrArray) -> None
        
        Clear the contents
        """
        ...
    
    def count(*args, **kwargs):
        """
        count(self: MSPyBentleyGeom.MSBsplineCurvePtrArray, x: MSPyBentleyGeom.RefCountedMSBsplineCurve) -> int
        
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.MSBsplineCurvePtrArray, L: MSPyBentleyGeom.MSBsplineCurvePtrArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.MSBsplineCurvePtrArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.MSBsplineCurvePtrArray, i: int, x: MSPyBentleyGeom.RefCountedMSBsplineCurve) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.MSBsplineCurvePtrArray) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.MSBsplineCurvePtrArray, i: int) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(*args, **kwargs):
        """
        remove(self: MSPyBentleyGeom.MSBsplineCurvePtrArray, x: MSPyBentleyGeom.RefCountedMSBsplineCurve) -> None
        
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class MSBsplineSurface:
    """
    None
    """

    def AddKnot(*args, **kwargs):
        """
        AddKnot(self: MSPyBentleyGeom.MSBsplineSurface, unnormalizedKnotValue: float, newMultiplicity: int, direction: int) -> int
        
        Add a given knot value to the B-spline surface in given direction.
        newMultiplicity is the desired final multiplicity of a knot that may
        already exist.
        """
        ...
    
    def AddTrimBoundary(*args, **kwargs):
        """
        AddTrimBoundary(*args, **kwargs)
        Overloaded function.
        
        1. AddTrimBoundary(self: MSPyBentleyGeom.MSBsplineSurface, uvPoints: MSPyBentleyGeom.DPoint2dArray) -> bool
        
        Add a uv polyline trim boundary.
        
        2. AddTrimBoundary(self: MSPyBentleyGeom.MSBsplineSurface, xyzPoints: MSPyBentleyGeom.DPoint3dArray) -> bool
        
        Add a uv polyline trim boundary.
        """
        ...
    
    def Allocate(*args, **kwargs):
        """
        Allocate(self: MSPyBentleyGeom.MSBsplineSurface) -> int
        
        Allocate memory arrays to match the current counts.
        """
        ...
    
    def AllocateUKnots(*args, **kwargs):
        """
        AllocateUKnots(self: MSPyBentleyGeom.MSBsplineSurface) -> int
        
        Allocate uKnots. Prior knot buffer is freed if present (do not call on
        pre-zeroed surface!!)
        """
        ...
    
    def AllocateVKnots(*args, **kwargs):
        """
        AllocateVKnots(self: MSPyBentleyGeom.MSBsplineSurface) -> int
        
        Allocate vKnots. Prior knot buffer is freed if present (do not call on
        pre-zeroed surface!!)
        """
        ...
    
    def AreUKnotsValid(*args, **kwargs):
        """
        AreUKnotsValid(self: MSPyBentleyGeom.MSBsplineSurface, clampingRequired: bool) -> bool
        
        Return the true allocated size of the pole array....
        """
        ...
    
    def AreVKnotsValid(*args, **kwargs):
        """
        AreVKnotsValid(self: MSPyBentleyGeom.MSBsplineSurface, clampingRequired: bool) -> bool
        """
        ...
    
    def BoundaryLoopArea(*args, **kwargs):
        """
        BoundaryLoopArea(self: MSPyBentleyGeom.MSBsplineSurface, boundaryIndex: int) -> float
        
        Return the area of a single boundary loop ..
        """
        ...
    
    def CleanKnots(*args, **kwargs):
        """
        CleanKnots(self: MSPyBentleyGeom.MSBsplineSurface) -> int
        
        Clean all unnecessary knots.
        """
        ...
    
    def Clone(*args, **kwargs):
        """
        Clone(self: MSPyBentleyGeom.MSBsplineSurface) -> MSPyBentleyGeom.RefCountedMSBsplineSurface
        """
        ...
    
    def ClosestPoint(*args, **kwargs):
        """
        ClosestPoint(self: MSPyBentleyGeom.MSBsplineSurface, surfacePoint: MSPyBentleyGeom.DPoint3d, surfaceUV: MSPyBentleyGeom.DPoint2d, spacePoint: MSPyBentleyGeom.DPoint3d) -> None
        
        Find closest point on surface
        """
        ...
    
    def ComputePrincipalAreaMoments(*args, **kwargs):
        """
        ComputePrincipalAreaMoments(self: MSPyBentleyGeom.MSBsplineSurface, centroid: MSPyBentleyGeom.DVec3d, axes: Bentley.RotMatrix, momentxyz: MSPyBentleyGeom.DVec3d) -> tuple
        """
        ...
    
    def ComputeSecondMomentAreaProducts(*args, **kwargs):
        """
        ComputeSecondMomentAreaProducts(self: MSPyBentleyGeom.MSBsplineSurface, products: MSPyBentleyGeom.DMatrix4d) -> bool
        
        Return the integrals of products of inertia [xx xy xz x; xy yy yz y;
        xz yz zz 1] * dA
        """
        ...
    
    def ComputeUniformUKnots(*args, **kwargs):
        """
        ComputeUniformUKnots(self: MSPyBentleyGeom.MSBsplineSurface) -> bool
        
        Compute uniformly spaced knots. This uses counts from params.
        
        Returns:
        false if param counts are not set.
        """
        ...
    
    def ComputeUniformVKnots(*args, **kwargs):
        """
        ComputeUniformVKnots(self: MSPyBentleyGeom.MSBsplineSurface) -> bool
        
        Compute uniformly spaced knots. This uses counts from params.
        
        Returns:
        false if param counts are not set.
        """
        ...
    
    def ControlPolygonFractionToControlPolygonDPoint3d(*args, **kwargs):
        """
        ControlPolygonFractionToControlPolygonDPoint3d(self: MSPyBentleyGeom.MSBsplineSurface, i: int, j: int, u: float, v: float) -> MSPyBentleyGeom.ValidatedDPoint3d
        
        Calculate the control polygon point at fractional position within a
        control polygon quad.
        """
        ...
    
    def ControlPolygonFractionToControlPolygonDPoint4d(*args, **kwargs):
        """
        ControlPolygonFractionToControlPolygonDPoint4d(self: MSPyBentleyGeom.MSBsplineSurface, i: int, j: int, u: float, v: float) -> MSPyBentleyGeom.ValidatedDPoint4d
        
        Calculate the control polygon point at fractional position within a
        control polygon quad.
        """
        ...
    
    def ControlPolygonFractionToKnot(*args, **kwargs):
        """
        ControlPolygonFractionToKnot(self: MSPyBentleyGeom.MSBsplineSurface, i: int, j: int, u: float, v: float) -> MSPyBentleyGeom.ValidatedDPoint2d
        
        Calculate the knot values at fractional position within a control
        polygon quad.
        """
        ...
    
    def CopyClosed(*args, **kwargs):
        """
        CopyClosed(self: MSPyBentleyGeom.MSBsplineSurface, source: MSPyBentleyGeom.MSBsplineSurface, edge: int) -> int
        
        Create B-spline surface by closing a open B-spline surface.
        """
        ...
    
    def CopyFrom(*args, **kwargs):
        """
        CopyFrom(self: MSPyBentleyGeom.MSBsplineSurface, source: MSPyBentleyGeom.MSBsplineSurface) -> int
        
        Allocate memory for the B-spline surface and copies all data from the
        input B-spline surface.
        """
        ...
    
    def CopyOpen(*args, **kwargs):
        """
        CopyOpen(self: MSPyBentleyGeom.MSBsplineSurface, source: MSPyBentleyGeom.MSBsplineSurface, unnormalizedKnot: float, edge: int) -> int
        
        Create B-spline surface by opening a closed B-spline surface about
        given direction.
        """
        ...
    
    def CopyReversed(*args, **kwargs):
        """
        CopyReversed(self: MSPyBentleyGeom.MSBsplineSurface, source: MSPyBentleyGeom.MSBsplineSurface, edge: int) -> int
        
        Create B-spline surface by reversing the given direction of surface.
        """
        ...
    
    def Create(*args, **kwargs):
        """
        Create() -> MSPyBentleyGeom.RefCountedMSBsplineSurface
        """
        ...
    
    def CreateCapture(*args, **kwargs):
        """
        CreateCapture(self: MSPyBentleyGeom.MSBsplineSurface) -> MSPyBentleyGeom.RefCountedMSBsplineSurface
        
        Returns a smart pointer to an MSBsplineSurface on the heap. Copy bits
        from instance, zero the instance.
        """
        ...
    
    def CreateCatmullRom(*args, **kwargs):
        """
        CreateCatmullRom(points: MSPyBentleyGeom.DPoint3dArray, numU: int, numV: int, uv: MSPyBentleyGeom.DPoint2dArray) -> MSPyBentleyGeom.RefCountedMSBsplineSurface
        """
        ...
    
    def CreateCopyTransformed(*args, **kwargs):
        """
        CreateCopyTransformed(self: MSPyBentleyGeom.MSBsplineSurface, transform: Bentley.Transform) -> MSPyBentleyGeom.RefCountedMSBsplineSurface
        
        Clone as new refcounted pointer.
        """
        ...
    
    def CreateFromPolesAndOrder(*args, **kwargs):
        """
        CreateFromPolesAndOrder(pointVector: MSPyBentleyGeom.DPoint3dArray, weightVector: MSPyBentley.DoubleArray, uKnotVector: MSPyBentley.DoubleArray, uOrder: int, numUPoints: int, uClosed: bool, vKnotVector: MSPyBentley.DoubleArray, vOrder: int, numVPoints: int, vClosed: bool, inputPolesAlreadyWeighted: bool) -> MSPyBentleyGeom.RefCountedMSBsplineSurface
        """
        ...
    
    def CreateLinearSweep(*args, **kwargs):
        """
        CreateLinearSweep(*args, **kwargs)
        Overloaded function.
        
        1. CreateLinearSweep(primitive: MSPyBentleyGeom.ICurvePrimitive, delta: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.RefCountedMSBsplineSurface
        
        Create a linear sweep from a (single) base curve. Fails (i.e. returns
        NULL) if the primitive has children.
        
        Parameter ``[in]``:
        primitive base curve to be swept
        
        Parameter ``[in]``:
        delta sweep direction.
        
        2. CreateLinearSweep(primitive: MSPyBentleyGeom.MSBsplineCurve, delta: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.RefCountedMSBsplineSurface
        
        Create a linear sweep from a (single) base curve. Fails (i.e. returns
        NULL) if the primitive has children.
        
        Parameter ``[in]``:
        primitive base curve to be swept
        
        Parameter ``[in]``:
        delta sweep direction.
        
        3. CreateLinearSweep(surfaces: MSPyBentleyGeom.MSBsplineSurfacePtrArray, baseCurves: MSPyBentleyGeom.CurveVector, delta: MSPyBentleyGeom.DVec3d) -> bool
        
        Create a linear sweep from a (single) base curve. Fails (i.e. returns
        NULL) if the primitive has children.
        
        Parameter ``[in]``:
        primitive base curve to be swept
        
        Parameter ``[in]``:
        delta sweep direction.
        """
        ...
    
    def CreateRotationalSweep(*args, **kwargs):
        """
        CreateRotationalSweep(*args, **kwargs)
        Overloaded function.
        
        1. CreateRotationalSweep(primitive: MSPyBentleyGeom.ICurvePrimitive, center: MSPyBentleyGeom.DPoint3d, axis: MSPyBentleyGeom.DVec3d, sweepRadians: float) -> MSPyBentleyGeom.RefCountedMSBsplineSurface
        
        2. CreateRotationalSweep(primitive: MSPyBentleyGeom.MSBsplineCurve, center: MSPyBentleyGeom.DPoint3d, axis: MSPyBentleyGeom.DVec3d, sweepRadians: float) -> MSPyBentleyGeom.RefCountedMSBsplineSurface
        
        3. CreateRotationalSweep(surfaces: MSPyBentleyGeom.MSBsplineSurfacePtrArray, baseCurves: MSPyBentleyGeom.CurveVector, center: MSPyBentleyGeom.DPoint3d, axis: MSPyBentleyGeom.DVec3d, sweepRadians: float) -> bool
        """
        ...
    
    def CreateRuled(*args, **kwargs):
        """
        CreateRuled(curveA: MSPyBentleyGeom.ICurvePrimitive, curveB: MSPyBentleyGeom.ICurvePrimitive) -> MSPyBentleyGeom.RefCountedMSBsplineSurface
        
        Create a linear sweep from a ruled surface between two curves. Fails
        (i.e. returns NULL) if the primitives have children or are not
        compatible.
        
        Parameter ``[in]``:
        curveA first curve
        
        Parameter ``[in]``:
        curveB second curve
        """
        ...
    
    def CreateTrimmedDisk(*args, **kwargs):
        """
        CreateTrimmedDisk(ellipse: MSPyBentleyGeom.DEllipse3d) -> MSPyBentleyGeom.RefCountedMSBsplineSurface
        
        Create a planar (bilinear) surface for the parallelogram around the
        ellipse. Insert a trim curve for the ellipse.
        
        Parameter ``[in]``:
        ellipse space ellipse
        """
        ...
    
    def CreateTrimmedSurfaces(*args, **kwargs):
        """
        CreateTrimmedSurfaces(*args, **kwargs)
        Overloaded function.
        
        1. CreateTrimmedSurfaces(surfaces: MSPyBentleyGeom.MSBsplineSurfacePtrArray, source: MSPyBentleyGeom.CurveVector, options: MSPyBentleyGeom.IFacetOptions = None) -> bool
        
        2. CreateTrimmedSurfaces(surfaces: MSPyBentleyGeom.MSBsplineSurfacePtrArray, source: Bentley.ISolidPrimitive, options: MSPyBentleyGeom.IFacetOptions = None) -> bool
        """
        ...
    
    def CreateTubeSurface(*args, **kwargs):
        """
        CreateTubeSurface(baseCurve: MSPyBentleyGeom.MSBsplineCurve, translateBaseCurve: bool, traceCurve: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.RefCountedMSBsplineSurface
        
        Create a surface swept along a trace curve.
        
        Parameter ``[in]``:
        baseCurve base contour
        
        Parameter ``[in]``:
        translateBaseCurve true to translate section, false to rotate with
        trace
        
        Parameter ``[in]``:
        traceCurve path to sweep
        """
        ...
    
    def DeleteBoundaries(*args, **kwargs):
        """
        DeleteBoundaries(self: MSPyBentleyGeom.MSBsplineSurface) -> None
        
        Remove all trim boundaries.
        """
        ...
    
    def ElevateDegree(*args, **kwargs):
        """
        ElevateDegree(self: MSPyBentleyGeom.MSBsplineSurface, newDegree: int, edge: int) -> int
        
        Elevate the degree (increases the order) of the B-spline surface in
        given direction.
        """
        ...
    
    def EvaluateAllPartials(*args, **kwargs):
        """
        EvaluateAllPartials(self: MSPyBentleyGeom.MSBsplineSurface, xyz: MSPyBentleyGeom.DPoint3d, dPdU: MSPyBentleyGeom.DVec3d, dPdV: MSPyBentleyGeom.DVec3d, dPdUU: MSPyBentleyGeom.DVec3d, dPdVV: MSPyBentleyGeom.DVec3d, dPdUv: MSPyBentleyGeom.DVec3d, normal: MSPyBentleyGeom.DVec3d, u: float, v: float) -> None
        """
        ...
    
    def EvaluateNormalizedFrame(*args, **kwargs):
        """
        EvaluateNormalizedFrame(self: MSPyBentleyGeom.MSBsplineSurface, transform: Bentley.Transform, u: float, v: float) -> bool
        
        Calculate a coordinate frame on the surface.
        
        Parameter ``[in]``:
        u u parameter
        
        Parameter ``[in]``:
        v v parameter.
        
        Parameter ``[out]``:
        transform transform with (a) origin at surface point, (b) x axis
        in u direction, (c) y axis perpendicular to x and in the surface
        tangent plane, (d) z axis normal to surface. Return false if
        tangent vectors are parallel or zero.
        """
        ...
    
    def EvaluatePoint(*args, **kwargs):
        """
        EvaluatePoint(*args, **kwargs)
        Overloaded function.
        
        1. EvaluatePoint(self: MSPyBentleyGeom.MSBsplineSurface, xyz: MSPyBentleyGeom.DPoint3d, u: float, v: float) -> None
        
        2. EvaluatePoint(self: MSPyBentleyGeom.MSBsplineSurface, xyz: MSPyBentleyGeom.DPoint3d, dPdU: MSPyBentleyGeom.DVec3d, dPdV: MSPyBentleyGeom.DVec3d, u: float, v: float) -> None
        """
        ...
    
    def EvaluatePointAndUnitNormal(*args, **kwargs):
        """
        EvaluatePointAndUnitNormal(self: MSPyBentleyGeom.MSBsplineSurface, ray: MSPyBentleyGeom.DRay3d, u: float, v: float) -> bool
        
        Calculate the point and unit normal on the B-spline surface at the
        input u and v parameter values. Return false if tangent vectors are
        parallel or zero.
        """
        ...
    
    def EvaluatePrincipalCurvature(*args, **kwargs):
        """
        EvaluatePrincipalCurvature(self: MSPyBentleyGeom.MSBsplineSurface, xyz: MSPyBentleyGeom.DPoint3d, unitA: MSPyBentleyGeom.DVec3d, unitB: MSPyBentleyGeom.DVec3d, u: float, v: float) -> tuple
        """
        ...
    
    def EvaluateUniformGrid(*args, **kwargs):
        """
        EvaluateUniformGrid(*args, **kwargs)
        Overloaded function.
        
        1. EvaluateUniformGrid(self: MSPyBentleyGeom.MSBsplineSurface, numUPoint: int, numVPoint: int, uParams: MSPyBentley.DoubleArray, vParams: MSPyBentley.DoubleArray, gridPoints: MSPyBentleyGeom.DPoint3dArray) -> None
        
        2. EvaluateUniformGrid(self: MSPyBentleyGeom.MSBsplineSurface, numUPoint: int, numVPoint: int, uvParams: MSPyBentleyGeom.DPoint2dArray, gridPoints: MSPyBentleyGeom.DPoint3dArray) -> None
        """
        ...
    
    def ExtractTo(*args, **kwargs):
        """
        ExtractTo(self: MSPyBentleyGeom.MSBsplineSurface, dest: MSPyBentleyGeom.MSBsplineSurface) -> None
        
        Copy bits into simple structure. Caller instance zeroed.
        """
        ...
    
    def FindKnotInterval(*args, **kwargs):
        """
        FindKnotInterval(self: MSPyBentleyGeom.MSBsplineSurface, knotValue: float, direction: int) -> int
        """
        ...
    
    def FixupBoundaryLoopParity(*args, **kwargs):
        """
        FixupBoundaryLoopParity(self: MSPyBentleyGeom.MSBsplineSurface) -> None
        
        Analyze loop parity among all boundary loops. Replace as " complete "
        loop set -- no implicit 01 outer boundary.
        """
        ...
    
    def FractionToKnot(*args, **kwargs):
        """
        FractionToKnot(self: MSPyBentleyGeom.MSBsplineSurface, f: float, direction: int) -> float
        
        Return the knot value at a fractional parameter about given
        direction...
        """
        ...
    
    def GetBoundaryUV(*args, **kwargs):
        """
        GetBoundaryUV(self: MSPyBentleyGeom.MSBsplineSurface, boundaryIndex: int, pointIndex: int) -> MSPyBentleyGeom.DPoint2d
        """
        ...
    
    def GetIntervalCounts(*args, **kwargs):
        """
        GetIntervalCounts(self: MSPyBentleyGeom.MSBsplineSurface) -> tuple
        """
        ...
    
    def GetIsUClosed(*args, **kwargs):
        """
        GetIsUClosed(self: MSPyBentleyGeom.MSBsplineSurface) -> bool
        
        return the u direction periodic state.
        """
        ...
    
    def GetIsVClosed(*args, **kwargs):
        """
        GetIsVClosed(self: MSPyBentleyGeom.MSBsplineSurface) -> bool
        
        return the v direction periodic state.
        """
        ...
    
    def GetIsoUCurve(*args, **kwargs):
        """
        GetIsoUCurve(self: MSPyBentleyGeom.MSBsplineSurface, u: float) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        
        Get the (untrimmed) v-direction curve at u
        """
        ...
    
    def GetIsoUCurveSegments(*args, **kwargs):
        """
        GetIsoUCurveSegments(self: MSPyBentleyGeom.MSBsplineSurface, u: float, segments: MSPyBentleyGeom.MSBsplineCurvePtrArray) -> None
        
        Get scan line intersections at constant u.
        """
        ...
    
    def GetIsoULineVIntersections(*args, **kwargs):
        """
        GetIsoULineVIntersections(self: MSPyBentleyGeom.MSBsplineSurface, u: float, vParams: MSPyBentley.DoubleArray) -> None
        
        Get scan line intersections at constant u.
        """
        ...
    
    def GetIsoVCurve(*args, **kwargs):
        """
        GetIsoVCurve(self: MSPyBentleyGeom.MSBsplineSurface, v: float) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        
        Get the (untrimmed) u-direction curve at v
        """
        ...
    
    def GetIsoVCurveSegments(*args, **kwargs):
        """
        GetIsoVCurveSegments(self: MSPyBentleyGeom.MSBsplineSurface, v: float, segments: MSPyBentleyGeom.MSBsplineCurvePtrArray) -> None
        
        Get scan line intersections at constant v.
        """
        ...
    
    def GetIsoVLineUIntersections(*args, **kwargs):
        """
        GetIsoVLineUIntersections(self: MSPyBentleyGeom.MSBsplineSurface, v: float, uParams: MSPyBentley.DoubleArray) -> None
        
        Get scan line intersections at constant v.
        """
        ...
    
    def GetKnotRange(*args, **kwargs):
        """
        GetKnotRange(self: MSPyBentleyGeom.MSBsplineSurface, direction: int) -> tuple
        """
        ...
    
    def GetNumBounds(*args, **kwargs):
        """
        GetNumBounds(self: MSPyBentleyGeom.MSBsplineSurface) -> int
        """
        ...
    
    def GetNumPointsInBoundary(*args, **kwargs):
        """
        GetNumPointsInBoundary(self: MSPyBentleyGeom.MSBsplineSurface, boundaryIndex: int) -> int
        
        return the number of ponits in a boundary.
        """
        ...
    
    def GetNumPoles(*args, **kwargs):
        """
        GetNumPoles(self: MSPyBentleyGeom.MSBsplineSurface) -> int
        
        return the product of u and v direction poles counts.
        """
        ...
    
    def GetNumUKnots(*args, **kwargs):
        """
        GetNumUKnots(self: MSPyBentleyGeom.MSBsplineSurface) -> int
        
        return the u direction knot count.
        """
        ...
    
    def GetNumUPoles(*args, **kwargs):
        """
        GetNumUPoles(self: MSPyBentleyGeom.MSBsplineSurface) -> int
        
        return the u direction pole count.
        """
        ...
    
    def GetNumVKnots(*args, **kwargs):
        """
        GetNumVKnots(self: MSPyBentleyGeom.MSBsplineSurface) -> int
        
        return the v direction knot count.
        """
        ...
    
    def GetNumVPoles(*args, **kwargs):
        """
        GetNumVPoles(self: MSPyBentleyGeom.MSBsplineSurface) -> int
        
        return the v direction pole count.
        """
        ...
    
    def GetParameterRegion(*args, **kwargs):
        """
        GetParameterRegion(self: MSPyBentleyGeom.MSBsplineSurface) -> tuple
        """
        ...
    
    def GetPole(*args, **kwargs):
        """
        GetPole(*args, **kwargs)
        Overloaded function.
        
        1. GetPole(self: MSPyBentleyGeom.MSBsplineSurface, i: int) -> MSPyBentleyGeom.DPoint3d
        
        2. GetPole(self: MSPyBentleyGeom.MSBsplineSurface, i: int, j: int) -> MSPyBentleyGeom.DPoint3d
        """
        ...
    
    def GetPoleDPoint4d(*args, **kwargs):
        """
        GetPoleDPoint4d(*args, **kwargs)
        Overloaded function.
        
        1. GetPoleDPoint4d(self: MSPyBentleyGeom.MSBsplineSurface, i: int) -> MSPyBentleyGeom.DPoint4d
        
        2. GetPoleDPoint4d(self: MSPyBentleyGeom.MSBsplineSurface, i: int, j: int) -> MSPyBentleyGeom.DPoint4d
        """
        ...
    
    def GetPoleRange(*args, **kwargs):
        """
        GetPoleRange(*args, **kwargs)
        Overloaded function.
        
        1. GetPoleRange(self: MSPyBentleyGeom.MSBsplineSurface, range: MSPyBentleyGeom.DRange3d) -> None
        
        Get the range of the poles of the B-spline surface.
        
        2. GetPoleRange(self: MSPyBentleyGeom.MSBsplineSurface, range: MSPyBentleyGeom.DRange3d, transform: Bentley.Transform) -> None
        
        Get the range of the poles of the B-spline surface.
        """
        ...
    
    def GetPoles(*args, **kwargs):
        """
        GetPoles(self: MSPyBentleyGeom.MSBsplineSurface, outData: MSPyBentleyGeom.DPoint3dArray) -> None
        
        Copy all poles out into caller array.
        """
        ...
    
    def GetPolygonColumnAsCurve(*args, **kwargs):
        """
        GetPolygonColumnAsCurve(self: MSPyBentleyGeom.MSBsplineSurface, index: int) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        
        Copy poles from a column into a curve structure. index -1 is
        understood as " end "
        """
        ...
    
    def GetPolygonDisplay(*args, **kwargs):
        """
        GetPolygonDisplay(self: MSPyBentleyGeom.MSBsplineSurface) -> bool
        """
        ...
    
    def GetPolygonRowAsCurve(*args, **kwargs):
        """
        GetPolygonRowAsCurve(self: MSPyBentleyGeom.MSBsplineSurface, index: int) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        
        Copy poles from a row into a curve structure. index -1 is understood
        as " end "
        """
        ...
    
    def GetPrincipalExtents(*args, **kwargs):
        """
        GetPrincipalExtents(self: MSPyBentleyGeom.MSBsplineSurface, extends: Bentley.Transform) -> bool
        
        Return a transform whose columns are along edges parallel to the
        principal axes and sized to include the poles from the translation
        point.
        """
        ...
    
    def GetSupport(*args, **kwargs):
        """
        GetSupport(self: MSPyBentleyGeom.MSBsplineSurface, outPoles: MSPyBentleyGeom.DPoint4dArray, outUKnots: MSPyBentley.DoubleArray, outVKnots: MSPyBentley.DoubleArray, uIndex: int, vIndex: int) -> bool
        
        Extract the poles and knots that support a single bezier patch ...
        
        Parameter ``[out]``:
        outPoles{uOrder X vOrder} poles
        
        Parameter ``[out]``:
        outUKnots{2*(uOrder-1)} knots
        
        Parameter ``[out]``:
        outVKnots{2*(vOrder-1)} knots
        
        Parameter ``[in]``:
        uIndex index of bezier to extract.
        
        Parameter ``[in]``:
        vIndex index of bezier to extract. @DotNetMethodExclude
        """
        ...
    
    def GetSurfaceDisplay(*args, **kwargs):
        """
        GetSurfaceDisplay(self: MSPyBentleyGeom.MSBsplineSurface) -> bool
        """
        ...
    
    def GetUKnot(*args, **kwargs):
        """
        GetUKnot(self: MSPyBentleyGeom.MSBsplineSurface, outData: int) -> float
        """
        ...
    
    def GetUKnots(*args, **kwargs):
        """
        GetUKnots(self: MSPyBentleyGeom.MSBsplineSurface, knots: MSPyBentley.DoubleArray) -> None
        """
        ...
    
    def GetUOrder(*args, **kwargs):
        """
        GetUOrder(self: MSPyBentleyGeom.MSBsplineSurface) -> int
        
        return the u direction order.
        """
        ...
    
    def GetUVBoundaryCurves(*args, **kwargs):
        """
        GetUVBoundaryCurves(self: MSPyBentleyGeom.MSBsplineSurface, addOuterLoopsIfActive: bool, preferCurves: bool) -> MSPyBentleyGeom.CurveVector
        
        Return current uv boundary data. This returns a parity region.
        """
        ...
    
    def GetUVBoundaryLoops(*args, **kwargs):
        """
        GetUVBoundaryLoops(*args, **kwargs)
        Overloaded function.
        
        1. GetUVBoundaryLoops(self: MSPyBentleyGeom.MSBsplineSurface, uvBoundaries: MSPyBentleyGeom.DPoint2dVecArray, addOuterLoopsIfActive: bool) -> None
        
        2. GetUVBoundaryLoops(self: MSPyBentleyGeom.MSBsplineSurface, uvBoundaries: MSPyBentleyGeom.DPoint2dVecArray, addOuterLoopsIfActive: bool, cleanupParity: bool) -> None
        """
        ...
    
    def GetUnWeightedPole(*args, **kwargs):
        """
        GetUnWeightedPole(*args, **kwargs)
        Overloaded function.
        
        1. GetUnWeightedPole(self: MSPyBentleyGeom.MSBsplineSurface, i: int, j: int) -> MSPyBentleyGeom.DPoint3d
        
        2. GetUnWeightedPole(self: MSPyBentleyGeom.MSBsplineSurface, i: int) -> MSPyBentleyGeom.DPoint3d
        """
        ...
    
    def GetUnWeightedPoles(*args, **kwargs):
        """
        GetUnWeightedPoles(self: MSPyBentleyGeom.MSBsplineSurface, outData: MSPyBentleyGeom.DPoint3dArray) -> None
        
        Copy all poles out into caller array, dividing each by its weight
        """
        ...
    
    def GetUnstructuredBoundaryCurves(*args, **kwargs):
        """
        GetUnstructuredBoundaryCurves(*args, **kwargs)
        Overloaded function.
        
        1. GetUnstructuredBoundaryCurves(self: MSPyBentleyGeom.MSBsplineSurface, tolerance: float, cubicFit: bool) -> MSPyBentleyGeom.CurveVector
        
        2. GetUnstructuredBoundaryCurves(self: MSPyBentleyGeom.MSBsplineSurface, tolerance: float, cubicFit: bool, addOuterLoopIfActive: bool) -> MSPyBentleyGeom.CurveVector
        """
        ...
    
    def GetVKnot(*args, **kwargs):
        """
        GetVKnot(self: MSPyBentleyGeom.MSBsplineSurface, outData: int) -> float
        """
        ...
    
    def GetVKnots(*args, **kwargs):
        """
        GetVKnots(self: MSPyBentleyGeom.MSBsplineSurface, knots: MSPyBentley.DoubleArray) -> None
        """
        ...
    
    def GetVOrder(*args, **kwargs):
        """
        GetVOrder(self: MSPyBentleyGeom.MSBsplineSurface) -> int
        
        return the v direction order.
        """
        ...
    
    def GetWeight(*args, **kwargs):
        """
        GetWeight(*args, **kwargs)
        Overloaded function.
        
        1. GetWeight(self: MSPyBentleyGeom.MSBsplineSurface, i: int) -> float
        
        2. GetWeight(self: MSPyBentleyGeom.MSBsplineSurface, i: int, j: int) -> float
        """
        ...
    
    def GetWeights(*args, **kwargs):
        """
        GetWeights(self: MSPyBentleyGeom.MSBsplineSurface, outData: MSPyBentley.DoubleArray) -> None
        
        Copy all weights out into caller array.
        """
        ...
    
    def HasValidBoundaryAllocation(*args, **kwargs):
        """
        HasValidBoundaryAllocation(self: MSPyBentleyGeom.MSBsplineSurface) -> bool
        """
        ...
    
    def HasValidCountsAndAllocations(*args, **kwargs):
        """
        HasValidCountsAndAllocations(self: MSPyBentleyGeom.MSBsplineSurface) -> bool
        """
        ...
    
    def HasValidOrder(*args, **kwargs):
        """
        HasValidOrder(self: MSPyBentleyGeom.MSBsplineSurface) -> bool
        """
        ...
    
    def HasValidPoleAllocation(*args, **kwargs):
        """
        HasValidPoleAllocation(self: MSPyBentleyGeom.MSBsplineSurface) -> bool
        """
        ...
    
    def HasValidPoleCounts(*args, **kwargs):
        """
        HasValidPoleCounts(self: MSPyBentleyGeom.MSBsplineSurface) -> bool
        """
        ...
    
    def HasValidWeightAllocation(*args, **kwargs):
        """
        HasValidWeightAllocation(self: MSPyBentleyGeom.MSBsplineSurface) -> bool
        """
        ...
    
    def HasWeights(*args, **kwargs):
        """
        HasWeights(self: MSPyBentleyGeom.MSBsplineSurface) -> bool
        
        ask if this is a " rational " (weighted) surface.
        """
        ...
    
    def InitFromPointsAndOrder(*args, **kwargs):
        """
        InitFromPointsAndOrder(self: MSPyBentleyGeom.MSBsplineSurface, uOrder: int, vOrder: int, uNumPoles: int, vNumPoles: int, points: MSPyBentleyGeom.DPoint3d) -> int
        
        Initialize the B-spline surface from point array and U/V order.
        """
        ...
    
    def IntersectRay(*args, **kwargs):
        """
        IntersectRay(*args, **kwargs)
        Overloaded function.
        
        1. IntersectRay(self: MSPyBentleyGeom.MSBsplineSurface, intersectionPoints: MSPyBentleyGeom.DPoint3dArray, rayParameters: MSPyBentley.DoubleArray, surfaceParameters: MSPyBentleyGeom.DPoint2dArray, ray: MSPyBentleyGeom.DRay3d) -> None
        
        2. IntersectRay(self: MSPyBentleyGeom.MSBsplineSurface, intersectionPoints: MSPyBentleyGeom.DPoint3dArray, rayParameters: MSPyBentley.DoubleArray, surfaceParameters: MSPyBentleyGeom.DPoint2dArray, ray: MSPyBentleyGeom.DRay3d, rayInterval: MSPyBentleyGeom.DRange1d) -> None
        """
        ...
    
    def IsBidirectionalTranslation(*args, **kwargs):
        """
        IsBidirectionalTranslation(self: MSPyBentleyGeom.MSBsplineSurface, relativeTolerance: float = 0.0) -> bool
        
        Check whether the u curves are all translations of the first u curve.
        (If this is true, the v curves are also translations of the first v
        curve0)
        
        Parameter ``[in]``:
        relativeTolerance tolerance as a fraction of the largest
        coordinate.
        """
        ...
    
    def IsDegenerateEdge(*args, **kwargs):
        """
        IsDegenerateEdge(self: MSPyBentleyGeom.MSBsplineSurface, edgeCode: int, tolerance: float) -> bool
        
        Check whether an edge of the surface degenerates to a single point.
        """
        ...
    
    def IsOuterBoundaryActive(*args, **kwargs):
        """
        IsOuterBoundaryActive(self: MSPyBentleyGeom.MSBsplineSurface) -> bool
        
        Returns:
        the state of the outer boundary flag.
        """
        ...
    
    def IsPhysicallyClosed(*args, **kwargs):
        """
        IsPhysicallyClosed(self: MSPyBentleyGeom.MSBsplineSurface) -> tuple
        """
        ...
    
    def IsPlanarBilinear(*args, **kwargs):
        """
        IsPlanarBilinear(*args, **kwargs)
        Overloaded function.
        
        1. IsPlanarBilinear(self: MSPyBentleyGeom.MSBsplineSurface) -> bool
        
        Check whether the B-spline surface is bilinear and each face of the
        control polygon is planar, with tight system tolerance
        (Angle.SmallAngle (
        
        2. IsPlanarBilinear(self: MSPyBentleyGeom.MSBsplineSurface, angleTol: float) -> bool
        
        Check whether the B-spline surface is bilinear and each face of the
        control polygon is planar, with tight system tolerance
        (Angle.SmallAngle (
        """
        ...
    
    def IsPlane(*args, **kwargs):
        """
        IsPlane(self: MSPyBentleyGeom.MSBsplineSurface) -> bool
        
        Check whether the poles are entirely within a plane. This does not
        check for goofy direction changes -- just planarity.
        """
        ...
    
    def IsSameStructure(*args, **kwargs):
        """
        IsSameStructure(self: MSPyBentleyGeom.MSBsplineSurface, other: MSPyBentleyGeom.MSBsplineSurface) -> bool
        
        Compare all non-coordinate data.
        """
        ...
    
    def IsSameStructureAndGeometry(*args, **kwargs):
        """
        IsSameStructureAndGeometry(self: MSPyBentleyGeom.MSBsplineSurface, other: MSPyBentleyGeom.MSBsplineSurface, tolerance: float) -> bool
        
        Compare all data.
        """
        ...
    
    def IsSolid(*args, **kwargs):
        """
        IsSolid(self: MSPyBentleyGeom.MSBsplineSurface, tolerance: float) -> bool
        
        Check whether the B-spline surface encloses a valid space.
        """
        ...
    
    @property
    def IsUClosed(arg0: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        ...
    
    @property
    def IsVClosed(arg0: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        ...
    
    def KnotToBlendFunctions(*args, **kwargs):
        """
        KnotToBlendFunctions(self: MSPyBentleyGeom.MSBsplineSurface, blend: float, blendDerivatives: float, u: float, direction: int) -> int
        """
        ...
    
    def KnotToFraction(*args, **kwargs):
        """
        KnotToFraction(self: MSPyBentleyGeom.MSBsplineSurface, knot: float, direction: int) -> float
        
        Return the fractional parameter corresponding to a knot value ...
        """
        ...
    
    def LoftingSurface(*args, **kwargs):
        """
        LoftingSurface(self: MSPyBentleyGeom.MSBsplineSurface, pCurves: MSPyBentleyGeom.MSBsplineCurve, pStartNormal: MSPyBentleyGeom.DVec3d, pEndNormal: MSPyBentleyGeom.DVec3d, numCurves: int, approxComp: bool, closed: bool, smoothStart: bool, smoothEnd: bool, chordLength: bool, applyComp: bool, tolerance: float) -> int
        """
        ...
    
    def MakeBezier(*args, **kwargs):
        """
        MakeBezier(self: MSPyBentleyGeom.MSBsplineSurface, outSurface: MSPyBentleyGeom.MSBsplineSurface) -> int
        
        Create equivalent Bezier surface for the B-spline surface.
        """
        ...
    
    def MakeBeziers(*args, **kwargs):
        """
        MakeBeziers(self: MSPyBentleyGeom.MSBsplineSurface, beziers: Bentley.Bstdcxx.bvector<Bentley.MSBsplineSurface,Bentley.BentleyAllocator<Bentley.MSBsplineSurface> >) -> int
        
        Create a series of Bezier surfaces for the B-spline surface.
        """
        ...
    
    def MakeClosed(*args, **kwargs):
        """
        MakeClosed(self: MSPyBentleyGeom.MSBsplineSurface, direction: int) -> int
        
        Close the open B-spline surface about the given direction.
        """
        ...
    
    def MakeOpen(*args, **kwargs):
        """
        MakeOpen(self: MSPyBentleyGeom.MSBsplineSurface, uv: float, direction: int) -> int
        
        Open the closed B-spline surface about the given direction.
        """
        ...
    
    def MakeRational(*args, **kwargs):
        """
        MakeRational(self: MSPyBentleyGeom.MSBsplineSurface) -> int
        
        Make an equivalent rational B-spline surface.
        """
        ...
    
    def MakeReversed(*args, **kwargs):
        """
        MakeReversed(self: MSPyBentleyGeom.MSBsplineSurface, direction: int) -> int
        
        Reserve the given direction of the surface.
        """
        ...
    
    def NormalizeKnots(*args, **kwargs):
        """
        NormalizeKnots(self: MSPyBentleyGeom.MSBsplineSurface) -> None
        
        Normalize knots to 01 (both directions)
        """
        ...
    
    def NormalizeSurface(*args, **kwargs):
        """
        NormalizeSurface(self: MSPyBentleyGeom.MSBsplineSurface) -> None
        
        Scale and translate the parameter range of the surface and its
        boundary loops so all parameters are between 0 and 1.
        """
        ...
    
    @property
    def NumBounds(arg0: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    
    @property
    def NumPoles(arg0: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    
    @property
    def NumUKnots(arg0: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    
    @property
    def NumUPoles(arg0: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    
    @property
    def NumVKnots(arg0: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    
    @property
    def NumVPoles(arg0: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    
    @property
    def PolygonDisplay(arg0: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        ...
    @PolygonDisplay.setter
    def PolygonDisplay(arg0: MSPyBentleyGeom.MSBsplineSurface, arg1: bool) -> None:
        ...
    
    def Populate(*args, **kwargs):
        """
        Populate(self: MSPyBentleyGeom.MSBsplineSurface, pointVector: MSPyBentleyGeom.DPoint3dArray, weightVector: MSPyBentley.DoubleArray, uKnotVector: MSPyBentley.DoubleArray, uOrder: int, numUPoints: int, uClosed: bool, vKnotVector: MSPyBentley.DoubleArray, vOrder: int, numVPoints: int, vClosed: bool, inputPolesAlreadyWeighted: bool) -> int
        """
        ...
    
    def ReleaseMem(*args, **kwargs):
        """
        ReleaseMem(self: MSPyBentleyGeom.MSBsplineSurface) -> None
        
        Free memory allocated for the poles, weights and knot vector of a
        B-spline surface.
        """
        ...
    
    def RemoveKnotsBounded(*args, **kwargs):
        """
        RemoveKnotsBounded(self: MSPyBentleyGeom.MSBsplineSurface, dir: int, tol: float) -> int
        
        Remove all removable knots with the tolerance constraint.
        """
        ...
    
    def Resolution(*args, **kwargs):
        """
        Resolution(*args, **kwargs)
        Overloaded function.
        
        1. Resolution(self: MSPyBentleyGeom.MSBsplineSurface) -> float
        
        Get the resolution of the B-spline surface.
        
        2. Resolution(self: MSPyBentleyGeom.MSBsplineSurface, abstol: float, reltol: float) -> float
        
        Get the resolution of the B-spline surface.
        """
        ...
    
    def SetNumRules(*args, **kwargs):
        """
        SetNumRules(self: MSPyBentleyGeom.MSBsplineSurface, numU: int, numV: int) -> None
        """
        ...
    
    def SetOuterBoundaryActive(*args, **kwargs):
        """
        SetOuterBoundaryActive(self: MSPyBentleyGeom.MSBsplineSurface, active: bool) -> None
        
        Parameter ``[in]``:
        active If true, the outer boundary is active as an (implicit) trim
        boundary, so the outermost explict boundary acts as a hole.
        """
        ...
    
    def SetPole(*args, **kwargs):
        """
        SetPole(*args, **kwargs)
        Overloaded function.
        
        1. SetPole(self: MSPyBentleyGeom.MSBsplineSurface, index: int, value: MSPyBentleyGeom.DPoint3d) -> bool
        
        set pole by index. returns false if index out of range.
        @DotNetMethodExclude
        
        2. SetPole(self: MSPyBentleyGeom.MSBsplineSurface, i: int, j: int, value: MSPyBentleyGeom.DPoint3d) -> bool
        
        set pole by index. returns false if index out of range.
        @DotNetMethodExclude
        
        3. SetPole(self: MSPyBentleyGeom.MSBsplineSurface, i: int, x: float, y: float, z: float) -> bool
        
        set pole by index. returns false if index out of range.
        @DotNetMethodExclude
        """
        ...
    
    def SetPolygonDisplay(*args, **kwargs):
        """
        SetPolygonDisplay(self: MSPyBentleyGeom.MSBsplineSurface, display: bool) -> None
        """
        ...
    
    def SetReWeightedPole(*args, **kwargs):
        """
        SetReWeightedPole(*args, **kwargs)
        Overloaded function.
        
        1. SetReWeightedPole(self: MSPyBentleyGeom.MSBsplineSurface, index: int, value: MSPyBentleyGeom.DPoint3d) -> bool
        
        set pole by index. returns false if index out of range. If the surface
        is weighted, the current weight is multiplied into the input pole.
        
        2. SetReWeightedPole(self: MSPyBentleyGeom.MSBsplineSurface, i: int, j: int, value: MSPyBentleyGeom.DPoint3d) -> bool
        
        set pole by index. returns false if index out of range. If the surface
        is weighted, the current weight is multiplied into the input pole.
        """
        ...
    
    def SetSurfaceDisplay(*args, **kwargs):
        """
        SetSurfaceDisplay(self: MSPyBentleyGeom.MSBsplineSurface, display: bool) -> None
        """
        ...
    
    def SetTrim(*args, **kwargs):
        """
        SetTrim(self: MSPyBentleyGeom.MSBsplineSurface, cruves: MSPyBentleyGeom.CurveVector) -> None
        
        Delete previous trim and add new trim.
        """
        ...
    
    def SetUKnots(*args, **kwargs):
        """
        SetUKnots(self: MSPyBentleyGeom.MSBsplineSurface, index: int, value: float, n: int) -> bool
        
        set uKnotw by index. returns false if any index out of range.
        @DotNetMethodExclude
        """
        ...
    
    def SetUParamsWithUniformKnots(*args, **kwargs):
        """
        SetUParamsWithUniformKnots(self: MSPyBentleyGeom.MSBsplineSurface, numPoles: int, order: int, closed: bool) -> bool
        
        Install counts and set up uniform knots in u direction.
        """
        ...
    
    def SetVKnots(*args, **kwargs):
        """
        SetVKnots(self: MSPyBentleyGeom.MSBsplineSurface, index: int, value: float, n: int) -> bool
        
        set vKnotw by index. returns false if any index out of range.
        @DotNetMethodExclude
        """
        ...
    
    def SetVParamsWithUniformKnots(*args, **kwargs):
        """
        SetVParamsWithUniformKnots(self: MSPyBentleyGeom.MSBsplineSurface, numPoles: int, order: int, closed: bool) -> bool
        
        Install counts and set up uniform knots in v direction.
        """
        ...
    
    def SetWeight(*args, **kwargs):
        """
        SetWeight(self: MSPyBentleyGeom.MSBsplineSurface, index: int, w: float) -> bool
        
        set weight by index. returns false if index out of range.
        @DotNetMethodExclude
        """
        ...
    
    def SetWeights(*args, **kwargs):
        """
        SetWeights(self: MSPyBentleyGeom.MSBsplineSurface, index: int, value: float, n: int) -> bool
        
        set weight by index. returns false if any index out of range.
        @DotNetMethodExclude
        """
        ...
    
    @property
    def SurfaceDisplay(arg0: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        ...
    @SurfaceDisplay.setter
    def SurfaceDisplay(arg0: MSPyBentleyGeom.MSBsplineSurface, arg1: bool) -> None:
        ...
    
    def SwapUV(*args, **kwargs):
        """
        SwapUV(self: MSPyBentleyGeom.MSBsplineSurface) -> int
        
        Swap the U/V direction of the surface.
        """
        ...
    
    def TransformPoles(*args, **kwargs):
        """
        TransformPoles(self: MSPyBentleyGeom.MSBsplineSurface, transform: Bentley.Transform, i0: int, j0: int, numI: int, numJ: int) -> None
        
        Transform a block of poles wtih start index i0,j0
        """
        ...
    
    def TransformSurface(*args, **kwargs):
        """
        TransformSurface(self: MSPyBentleyGeom.MSBsplineSurface, transform: Bentley.Transform) -> int
        
        Transform the B-spline surface.
        """
        ...
    
    def TryGetBoundaryUV(*args, **kwargs):
        """
        TryGetBoundaryUV(self: MSPyBentleyGeom.MSBsplineSurface, boundaryIndex: int, pointIndex: int, uv: MSPyBentleyGeom.DPoint2d) -> bool
        """
        ...
    
    def TryGetUnWeightedPole(*args, **kwargs):
        """
        TryGetUnWeightedPole(*args, **kwargs)
        Overloaded function.
        
        1. TryGetUnWeightedPole(self: MSPyBentleyGeom.MSBsplineSurface, i: int, i: int, xyz: MSPyBentleyGeom.DPoint3d) -> bool
        
        Try to dereference index i,j.
        
        2. TryGetUnWeightedPole(self: MSPyBentleyGeom.MSBsplineSurface, i: int, xyz: MSPyBentleyGeom.DPoint3d) -> bool
        
        Try to dereference index i,j.
        """
        ...
    
    @property
    def UOrder(arg0: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    
    def UnWeightPoles(*args, **kwargs):
        """
        UnWeightPoles(self: MSPyBentleyGeom.MSBsplineSurface) -> None
        
        if the surface is rational, divide (wx,wy,wz) style poles by the
        weights
        """
        ...
    
    @property
    def VOrder(arg0: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    
    def WeightPoles(*args, **kwargs):
        """
        WeightPoles(self: MSPyBentleyGeom.MSBsplineSurface) -> None
        
        if the surface is rational, multiply (wx,wy,wz) style poles by the
        weights
        """
        ...
    
    def Zero(*args, **kwargs):
        """
        Zero(self: MSPyBentleyGeom.MSBsplineSurface) -> None
        
        zero out the surface
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.MSBsplineSurface) -> None:
        ...
    
    @property
    def display(self: MSPyBentleyGeom.MSBsplineSurface) -> MSPyBentleyGeom.BsplineDisplay:
        ...
    @display.setter
    def display(self: MSPyBentleyGeom.MSBsplineSurface, arg0: MSPyBentleyGeom.BsplineDisplay) -> None:
        ...
    
    @property
    def holeOrigin(self: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    @holeOrigin.setter
    def holeOrigin(self: MSPyBentleyGeom.MSBsplineSurface, arg0: int) -> None:
        ...
    
    @property
    def numBounds(self: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    @numBounds.setter
    def numBounds(self: MSPyBentleyGeom.MSBsplineSurface, arg0: int) -> None:
        ...
    
    @property
    def poles(arg0: MSPyBentleyGeom.MSBsplineSurface) -> numpy.typing.NDArray:
        ...
    @poles.setter
    def poles(arg0: MSPyBentleyGeom.MSBsplineSurface, arg1: numpy.typing.NDArray) -> None:
        ...
    
    @property
    def rational(self: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    @rational.setter
    def rational(self: MSPyBentleyGeom.MSBsplineSurface, arg0: int) -> None:
        ...
    
    @property
    def type(self: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    @type.setter
    def type(self: MSPyBentleyGeom.MSBsplineSurface, arg0: int) -> None:
        ...
    
    @property
    def uKnots(arg0: MSPyBentleyGeom.MSBsplineSurface) -> numpy.typing.NDArray:
        ...
    @uKnots.setter
    def uKnots(arg0: MSPyBentleyGeom.MSBsplineSurface, arg1: numpy.typing.NDArray) -> None:
        ...
    
    @property
    def uParams(self: MSPyBentleyGeom.MSBsplineSurface) -> MSPyBentleyGeom.BsplineParam:
        ...
    @uParams.setter
    def uParams(self: MSPyBentleyGeom.MSBsplineSurface, arg0: MSPyBentleyGeom.BsplineParam) -> None:
        ...
    
    @property
    def vKnots(arg0: MSPyBentleyGeom.MSBsplineSurface) -> numpy.typing.NDArray:
        ...
    @vKnots.setter
    def vKnots(arg0: MSPyBentleyGeom.MSBsplineSurface, arg1: numpy.typing.NDArray) -> None:
        ...
    
    @property
    def vParams(self: MSPyBentleyGeom.MSBsplineSurface) -> MSPyBentleyGeom.BsplineParam:
        ...
    @vParams.setter
    def vParams(self: MSPyBentleyGeom.MSBsplineSurface, arg0: MSPyBentleyGeom.BsplineParam) -> None:
        ...
    
    @property
    def weights(arg0: MSPyBentleyGeom.MSBsplineSurface) -> numpy.typing.NDArray:
        ...
    @weights.setter
    def weights(arg0: MSPyBentleyGeom.MSBsplineSurface, arg1: numpy.typing.NDArray) -> None:
        ...
    
class MSBsplineSurfacePtrArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.MSBsplineSurfacePtrArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.MSBsplineSurfacePtrArray, arg0: MSPyBentleyGeom.MSBsplineSurfacePtrArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.MSBsplineSurfacePtrArray, arg0: Iterable) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.MSBsplineSurfacePtrArray, x: MSPyBentleyGeom.RefCountedMSBsplineSurface) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.MSBsplineSurfacePtrArray) -> None
        
        Clear the contents
        """
        ...
    
    def count(*args, **kwargs):
        """
        count(self: MSPyBentleyGeom.MSBsplineSurfacePtrArray, x: MSPyBentleyGeom.RefCountedMSBsplineSurface) -> int
        
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.MSBsplineSurfacePtrArray, L: MSPyBentleyGeom.MSBsplineSurfacePtrArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.MSBsplineSurfacePtrArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.MSBsplineSurfacePtrArray, i: int, x: MSPyBentleyGeom.RefCountedMSBsplineSurface) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.MSBsplineSurfacePtrArray) -> MSPyBentleyGeom.RefCountedMSBsplineSurface
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.MSBsplineSurfacePtrArray, i: int) -> MSPyBentleyGeom.RefCountedMSBsplineSurface
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(*args, **kwargs):
        """
        remove(self: MSPyBentleyGeom.MSBsplineSurfacePtrArray, x: MSPyBentleyGeom.RefCountedMSBsplineSurface) -> None
        
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class MSInterpolationCurve:
    """
    None
    """

    def AllocateFitPoints(*args, **kwargs):
        """
        AllocateFitPoints(self: MSPyBentleyGeom.MSInterpolationCurve, count: int, data: MSPyBentleyGeom.DPoint3d = None) -> int
        
        Allocate specified number of fit points. Optionally copy in points
        from buffer.
        """
        ...
    
    def AllocateKnots(*args, **kwargs):
        """
        AllocateKnots(self: MSPyBentleyGeom.MSInterpolationCurve, count: int, data: float = None) -> int
        
        Allocate specified number of knots. Optionally copy in knots from
        buffer.
        """
        ...
    
    def AlmostEqual(*args, **kwargs):
        """
        AlmostEqual(self: MSPyBentleyGeom.MSInterpolationCurve, other: MSPyBentleyGeom.MSInterpolationCurve, tolerance: float) -> bool
        """
        ...
    
    def CopyFrom(*args, **kwargs):
        """
        CopyFrom(self: MSPyBentleyGeom.MSInterpolationCurve, source: MSPyBentleyGeom.MSInterpolationCurve) -> int
        
        Allocate memory for the B-spline curve and copies all data from the
        input inerpolation curve.
        """
        ...
    
    def Create(*args, **kwargs):
        """
        Create() -> MSPyBentleyGeom.RefCountedMSInterpolationCurve
        """
        ...
    
    def GetOrder(*args, **kwargs):
        """
        GetOrder(self: MSPyBentleyGeom.MSInterpolationCurve) -> int
        """
        ...
    
    def InitFromPointsAndEndTangents(*args, **kwargs):
        """
        InitFromPointsAndEndTangents(self: MSPyBentleyGeom.MSInterpolationCurve, inPoints: MSPyBentleyGeom.DPoint3dArray, removeData: bool, removeTol: float, endTangents: MSPyBentleyGeom.DPoint3d, closedCurve: bool, colinearTangents: bool, chordLenTangents: bool, naturalTangents: bool) -> int
        """
        ...
    
    @property
    def Order(arg0: MSPyBentleyGeom.MSInterpolationCurve) -> int:
        ...
    
    def Populate(*args, **kwargs):
        """
        Populate(*args, **kwargs)
        Overloaded function.
        
        1. Populate(self: MSPyBentleyGeom.MSInterpolationCurve, order: int, periodic: bool, isChordLenKnots: int, isColinearTangents: int, isChordLenTangents: int, isNaturalTangents: int, fitPoints: List[MSPyBentleyGeom.DPoint3d], knots: List[float], startTangent: MSPyBentleyGeom.DVec3d, endTangent: MSPyBentleyGeom.DVec3d) -> int
        
        2. Populate(self: MSPyBentleyGeom.MSInterpolationCurve, order: int, periodic: bool, isChordLenKnots: int, isColinearTangents: int, isChordLenTangents: int, isNaturalTangents: int, fitPoints: List[MSPyBentleyGeom.DPoint3d], knots: List[float]) -> int
        """
        ...
    
    def ReleaseMem(*args, **kwargs):
        """
        ReleaseMem(self: MSPyBentleyGeom.MSInterpolationCurve) -> None
        
        Free the memory allocated to the poles of the interpolation curve.
        """
        ...
    
    def Zero(*args, **kwargs):
        """
        Zero(self: MSPyBentleyGeom.MSInterpolationCurve) -> None
        
        Clear to zero state. DOES NOT RELEASE MEMORY.
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.MSInterpolationCurve) -> None:
        ...
    
class MeshAnnotation:
    """
    None
    """

    def Description(*args, **kwargs):
        """
        Description(self: MSPyBentleyGeom.MeshAnnotation) -> str
        """
        ...
    
    @property
    def Fail(self: MSPyBentleyGeom.MeshAnnotation) -> int:
        ...
    @Fail.setter
    def Fail(self: MSPyBentleyGeom.MeshAnnotation, arg0: int) -> None:
        ...
    
    def IncrementFail(*args, **kwargs):
        """
        IncrementFail(self: MSPyBentleyGeom.MeshAnnotation) -> None
        """
        ...
    
    def IncrementPass(*args, **kwargs):
        """
        IncrementPass(self: MSPyBentleyGeom.MeshAnnotation) -> None
        """
        ...
    
    @property
    def Pass(self: MSPyBentleyGeom.MeshAnnotation) -> int:
        ...
    @Pass.setter
    def Pass(self: MSPyBentleyGeom.MeshAnnotation, arg0: int) -> None:
        ...
    
    def Record(*args, **kwargs):
        """
        Record(*args, **kwargs)
        Overloaded function.
        
        1. Record(self: MSPyBentleyGeom.MeshAnnotation, index: int, tag: int) -> None
        
        2. Record(self: MSPyBentleyGeom.MeshAnnotation, index: int, tag: MSPyBentleyGeom.DPoint3d) -> None
        
        3. Record(self: MSPyBentleyGeom.MeshAnnotation, index: int, tag: int) -> None
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.MeshAnnotation, arg0: str) -> None:
        """
        name
        """
        ...
    
class MeshAnnotationArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.MeshAnnotationArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.MeshAnnotationArray, arg0: MSPyBentleyGeom.MeshAnnotationArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.MeshAnnotationArray, arg0: Iterable) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.MeshAnnotationArray, x: MSPyBentleyGeom.MeshAnnotation) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.MeshAnnotationArray) -> None
        
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.MeshAnnotationArray, L: MSPyBentleyGeom.MeshAnnotationArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.MeshAnnotationArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.MeshAnnotationArray, i: int, x: MSPyBentleyGeom.MeshAnnotation) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.MeshAnnotationArray) -> MSPyBentleyGeom.MeshAnnotation
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.MeshAnnotationArray, i: int) -> MSPyBentleyGeom.MeshAnnotation
        
        Remove and return the item at index ``i``
        """
        ...
    
class MeshAnnotationVector:
    """
    None
    """

    def GetTotalFail(*args, **kwargs):
        """
        GetTotalFail(self: MSPyBentleyGeom.MeshAnnotationVector) -> int
        
        Query the total number of tests failed.
        """
        ...
    
    def GetTotalPass(*args, **kwargs):
        """
        GetTotalPass(self: MSPyBentleyGeom.MeshAnnotationVector) -> int
        
        Query the total number of tests passed.
        """
        ...
    
    @property
    def TotalFail(arg0: MSPyBentleyGeom.MeshAnnotationVector) -> int:
        ...
    
    @property
    def TotalPass(arg0: MSPyBentleyGeom.MeshAnnotationVector) -> int:
        ...
    
    def __init__(self: MSPyBentleyGeom.MeshAnnotationVector, recordAllTestDescriptions: bool) -> None:
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.MeshAnnotationArray, x: MSPyBentleyGeom.MeshAnnotation) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.MeshAnnotationArray) -> None
        
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.MeshAnnotationArray, L: MSPyBentleyGeom.MeshAnnotationArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.MeshAnnotationArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.MeshAnnotationArray, i: int, x: MSPyBentleyGeom.MeshAnnotation) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.MeshAnnotationArray) -> MSPyBentleyGeom.MeshAnnotation
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.MeshAnnotationArray, i: int) -> MSPyBentleyGeom.MeshAnnotation
        
        Remove and return the item at index ``i``
        """
        ...
    
NO_EDGE: int

OFFSET_ARC_CUSP: int

OFFSET_CHAMFER_CUSP: int

OFFSET_JUMP_CUSP: int

OFFSET_PARABOLA_CUSP: int

OFFSET_POINT_CUSP: int

PI: float

POSITION_CONTINUITY: int

class PartialCurveDetail:
    """
    None
    """

    def ChildFractionToParentFraction(*args, **kwargs):
        """
        ChildFractionToParentFraction(self: MSPyBentleyGeom.PartialCurveDetail, f: float) -> float
        
        map a local fraction into the parent fraction.
        """
        ...
    
    def IsSingleFraction(*args, **kwargs):
        """
        IsSingleFraction(self: MSPyBentleyGeom.PartialCurveDetail) -> bool
        
        Test if the partial curve fraction range is a single fraction.
        """
        ...
    
    def ParentFractionToChildFraction(*args, **kwargs):
        """
        ParentFractionToChildFraction(self: MSPyBentleyGeom.PartialCurveDetail, parentFraction: float) -> tuple
        
        (attempt to) map a parent fraction back to the child interval. This
        fails if the child is a single point.
        """
        ...
    
    def UpdateFraction1AndUserData(*args, **kwargs):
        """
        UpdateFraction1AndUserData(self: MSPyBentleyGeom.PartialCurveDetail, f1: float, newData: int) -> None
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.PartialCurveDetail) -> None
        
        2. __init__(self: MSPyBentleyGeom.PartialCurveDetail, parentCurve: Bentley.ICurvePrimitive, fraction0: float, fraction1: float, userData: int) -> None
        
        3. __init__(self: MSPyBentleyGeom.PartialCurveDetail, parentCurve: Bentley.ICurvePrimitive, interval: Bentley.DSegment1d, userData: int = 0) -> None
        
        4. __init__(self: MSPyBentleyGeom.PartialCurveDetail, parent: MSPyBentleyGeom.PartialCurveDetail, f0: float, f1: float) -> None
        """
        ...
    
    @property
    def fraction0(self: MSPyBentleyGeom.PartialCurveDetail) -> float:
        ...
    @fraction0.setter
    def fraction0(self: MSPyBentleyGeom.PartialCurveDetail, arg0: float) -> None:
        ...
    
    @property
    def fraction1(self: MSPyBentleyGeom.PartialCurveDetail) -> float:
        ...
    @fraction1.setter
    def fraction1(self: MSPyBentleyGeom.PartialCurveDetail, arg0: float) -> None:
        ...
    
    @property
    def parentCurve(self: MSPyBentleyGeom.PartialCurveDetail) -> Bentley.ICurvePrimitive:
        ...
    @parentCurve.setter
    def parentCurve(self: MSPyBentleyGeom.PartialCurveDetail, arg0: Bentley.ICurvePrimitive) -> None:
        ...
    
    @property
    def userData(self: MSPyBentleyGeom.PartialCurveDetail) -> int:
        ...
    @userData.setter
    def userData(self: MSPyBentleyGeom.PartialCurveDetail, arg0: int) -> None:
        ...
    
class PathLocationDetail:
    """
    None
    """

    @property
    def CurveLocationDetail(arg0: MSPyBentleyGeom.PathLocationDetail) -> MSPyBentleyGeom.CurveLocationDetail:
        ...
    
    def DistanceFromPathStart(*args, **kwargs):
        """
        DistanceFromPathStart(self: MSPyBentleyGeom.PathLocationDetail) -> float
        
        Query the stored distance to path start. Note that this is not a
        recompute -- just a member access.
        """
        ...
    
    def DistanceSquaredToPoint(*args, **kwargs):
        """
        DistanceSquaredToPoint(self: MSPyBentleyGeom.PathLocationDetail, xyz: Bentley.DPoint3d) -> float
        
        distance squared to given point.
        """
        ...
    
    def DistanceToPoint(*args, **kwargs):
        """
        DistanceToPoint(*args, **kwargs)
        Overloaded function.
        
        1. DistanceToPoint(self: MSPyBentleyGeom.PathLocationDetail, other: MSPyBentleyGeom.PathLocationDetail) -> float
        
        distance between points of this and other detail.
        
        2. DistanceToPoint(self: MSPyBentleyGeom.PathLocationDetail, xyz: Bentley.DPoint3d) -> float
        
        distance between points of this and other detail.
        """
        ...
    
    def FractionToPositionLocationDetail(*args, **kwargs):
        """
        FractionToPositionLocationDetail(self: MSPyBentleyGeom.PathLocationDetail, f: float, evaluateDistance: bool = True) -> MSPyBentleyGeom.PathLocationDetail
        """
        ...
    
    def GetCurveLocationDetail(*args, **kwargs):
        """
        GetCurveLocationDetail(self: MSPyBentleyGeom.PathLocationDetail) -> MSPyBentleyGeom.CurveLocationDetail
        
        Query CurveLocationDetail with fractional position for queries
        """
        ...
    
    def GetPrimitiveIndex(*args, **kwargs):
        """
        GetPrimitiveIndex(self: MSPyBentleyGeom.PathLocationDetail) -> int
        
        Get the index of this detail's curve within its containing
        CurveVectorWithDistanceIndex
        """
        ...
    
    def HasCurve(*args, **kwargs):
        """
        HasCurve(self: MSPyBentleyGeom.PathLocationDetail) -> bool
        
        Test if there is a curve.
        """
        ...
    
    def IsLessThan_ByPathDistance(*args, **kwargs):
        """
        IsLessThan_ByPathDistance(dataA: MSPyBentleyGeom.PathLocationDetail, dataB: MSPyBentleyGeom.PathLocationDetail) -> bool
        
        Comparison using only the stored distance.
        """
        ...
    
    def Point(*args, **kwargs):
        """
        Point(self: MSPyBentleyGeom.PathLocationDetail) -> Bentley.DPoint3d
        
        Query xyz coordinates
        """
        ...
    
    def PointAndUnitTangent(*args, **kwargs):
        """
        PointAndUnitTangent(self: MSPyBentleyGeom.PathLocationDetail, unitTangent: Bentley.DVec3d) -> Bentley.DPoint3d
        
        Query xyz coordinates and normalized tangent vector. (This reevaluates
        the curve)
        """
        ...
    
    @property
    def PrimitiveIndex(arg0: MSPyBentleyGeom.PathLocationDetail) -> int:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.PathLocationDetail) -> None
        
        2. __init__(self: MSPyBentleyGeom.PathLocationDetail, other: MSPyBentleyGeom.PathLocationDetail) -> None
        
        3. __init__(self: MSPyBentleyGeom.PathLocationDetail, curveDetail: MSPyBentleyGeom.CurveLocationDetail, pathIndex: int = -1, distance: float = 1.7976931348623157e+308) -> None
        
        4. __init__(self: MSPyBentleyGeom.PathLocationDetail, curveDetail: MSPyBentleyGeom.CurveLocationDetail, pathIndex: int, distance: float = 1.7976931348623157e+308) -> None
        
        5. __init__(self: MSPyBentleyGeom.PathLocationDetail, distance: float) -> None
        """
        ...
    
class Point2d:
    """
    None
    """

    def __init__(self: MSPyBentleyGeom.Point2d) -> None:
        ...
    
    @property
    def x(self: MSPyBentleyGeom.Point2d) -> int:
        ...
    @x.setter
    def x(self: MSPyBentleyGeom.Point2d, arg0: int) -> None:
        ...
    
    @property
    def y(self: MSPyBentleyGeom.Point2d) -> int:
        ...
    @y.setter
    def y(self: MSPyBentleyGeom.Point2d, arg0: int) -> None:
        ...
    
class Point2dArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.Point2dArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.Point2dArray, arg0: MSPyBentleyGeom.Point2dArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.Point2dArray, arg0: Iterable) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.Point2dArray, x: MSPyBentleyGeom.Point2d) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.Point2dArray) -> None
        
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.Point2dArray, L: MSPyBentleyGeom.Point2dArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.Point2dArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.Point2dArray, i: int, x: MSPyBentleyGeom.Point2d) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.Point2dArray) -> MSPyBentleyGeom.Point2d
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.Point2dArray, i: int) -> MSPyBentleyGeom.Point2d
        
        Remove and return the item at index ``i``
        """
        ...
    
class Point3d:
    """
    None
    """

    def __init__(self: MSPyBentleyGeom.Point3d) -> None:
        ...
    
    @property
    def x(self: MSPyBentleyGeom.Point3d) -> int:
        ...
    @x.setter
    def x(self: MSPyBentleyGeom.Point3d, arg0: int) -> None:
        ...
    
    @property
    def y(self: MSPyBentleyGeom.Point3d) -> int:
        ...
    @y.setter
    def y(self: MSPyBentleyGeom.Point3d, arg0: int) -> None:
        ...
    
    @property
    def z(self: MSPyBentleyGeom.Point3d) -> int:
        ...
    @z.setter
    def z(self: MSPyBentleyGeom.Point3d, arg0: int) -> None:
        ...
    
class Point3dArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.Point3dArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.Point3dArray, arg0: MSPyBentleyGeom.Point3dArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.Point3dArray, arg0: Iterable) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.Point3dArray, x: MSPyBentleyGeom.Point3d) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.Point3dArray) -> None
        
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.Point3dArray, L: MSPyBentleyGeom.Point3dArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.Point3dArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.Point3dArray, i: int, x: MSPyBentleyGeom.Point3d) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.Point3dArray) -> MSPyBentleyGeom.Point3d
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.Point3dArray, i: int) -> MSPyBentleyGeom.Point3d
        
        Remove and return the item at index ``i``
        """
        ...
    
class PolyfaceEdgeChain:
    """
    None
    """

    def AddIndex(*args, **kwargs):
        """
        AddIndex(self: MSPyBentleyGeom.PolyfaceEdgeChain, index: int) -> None
        
        add an index.
        """
        ...
    
    def AddZeroBasedIndices(*args, **kwargs):
        """
        AddZeroBasedIndices(self: MSPyBentleyGeom.PolyfaceEdgeChain, indices: MSPyBentley.UInt64Array) -> None
        
        add indices
        """
        ...
    
    def GetId(*args, **kwargs):
        """
        GetId(self: MSPyBentleyGeom.PolyfaceEdgeChain) -> MSPyBentleyGeom.CurveTopologyId
        
        query the CurveTopologyId
        """
        ...
    
    def GetIndex(*args, **kwargs):
        """
        GetIndex(self: MSPyBentleyGeom.PolyfaceEdgeChain, arg0: MSPyBentley.Int32Array) -> int
        """
        ...
    
    def GetIndexCount(*args, **kwargs):
        """
        GetIndexCount(self: MSPyBentleyGeom.PolyfaceEdgeChain) -> int
        
        Query the number of indices.
        """
        ...
    
    @property
    def Id(arg0: MSPyBentleyGeom.PolyfaceEdgeChain) -> MSPyBentleyGeom.CurveTopologyId:
        ...
    
    @property
    def IndexCount(arg0: MSPyBentleyGeom.PolyfaceEdgeChain) -> int:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.PolyfaceEdgeChain) -> None
        
        2. __init__(self: MSPyBentleyGeom.PolyfaceEdgeChain, id: MSPyBentleyGeom.CurveTopologyId) -> None
        
        3. __init__(self: MSPyBentleyGeom.PolyfaceEdgeChain, id: MSPyBentleyGeom.CurveTopologyId, index0: int, index1: int) -> None
        """
        ...
    
class PolyfaceEdgeChainArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.PolyfaceEdgeChainArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.PolyfaceEdgeChainArray, arg0: MSPyBentleyGeom.PolyfaceEdgeChainArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.PolyfaceEdgeChainArray, arg0: Iterable) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.PolyfaceEdgeChainArray, x: MSPyBentleyGeom.PolyfaceEdgeChain) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.PolyfaceEdgeChainArray) -> None
        
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.PolyfaceEdgeChainArray, L: MSPyBentleyGeom.PolyfaceEdgeChainArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.PolyfaceEdgeChainArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.PolyfaceEdgeChainArray, i: int, x: MSPyBentleyGeom.PolyfaceEdgeChain) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.PolyfaceEdgeChainArray) -> MSPyBentleyGeom.PolyfaceEdgeChain
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.PolyfaceEdgeChainArray, i: int) -> MSPyBentleyGeom.PolyfaceEdgeChain
        
        Remove and return the item at index ``i``
        """
        ...
    
class PolyfaceHeader:
    """
    None
    """

    def ActivateVectorsForIndexing(*args, **kwargs):
        """
        ActivateVectorsForIndexing(self: MSPyBentleyGeom.PolyfaceHeader, source: MSPyBentleyGeom.PolyfaceQuery) -> None
        
        Set active flags so this polyface carries data and indices for all the
        data in source.
        """
        ...
    
    def ActivateVectorsForPolylineIndexing(*args, **kwargs):
        """
        ActivateVectorsForPolylineIndexing(self: MSPyBentleyGeom.PolyfaceHeader, source: MSPyBentleyGeom.PolyfaceQuery) -> None
        
        Set active flags so this polyface carries data and indices for
        polylines compatible with source.
        """
        ...
    
    def AddEdgeChains(*args, **kwargs):
        """
        AddEdgeChains(self: MSPyBentleyGeom.PolyfaceHeader, drawMethodIndex: int) -> Bentley.BentleyStatus
        
        Add Edge Chains
        """
        ...
    
    def AddIfMatchedLayout(*args, **kwargs):
        """
        AddIfMatchedLayout(self: MSPyBentleyGeom.PolyfaceHeader, source: MSPyBentleyGeom.PolyfaceQuery) -> bool
        
        Add all content of source to this polyface. This does NOT attempt to
        recognize duplicate coordinate data.
        
        Returns:
        false if mismatched data -- e.g. arrays present on one but not the
        other.
        """
        ...
    
    def AddIndexedFacet(*args, **kwargs):
        """
        AddIndexedFacet(self: MSPyBentleyGeom.PolyfaceHeader, pointIndices: MSPyBentley.Int32Array, normalIndices: MSPyBentley.Int32Array, paramIndices: MSPyBentley.Int32Array, colorIndices: MSPyBentley.Int32Array) -> bool
        """
        ...
    
    def AddPolygon(*args, **kwargs):
        """
        AddPolygon(*args, **kwargs)
        Overloaded function.
        
        1. AddPolygon(self: MSPyBentleyGeom.PolyfaceHeader, xyz: MSPyBentleyGeom.DPoint3dArray, normal: MSPyBentleyGeom.DVec3dArray = None, param: MSPyBentleyGeom.DPoint2dArray = None) -> bool
        
        2. AddPolygon(self: MSPyBentleyGeom.PolyfaceHeader, xyz: MSPyBentleyGeom.DPoint3dArray, visitor: Bentley.PolyfaceVisitor, mapping: MSPyBentleyGeom.IndexedParameterMap) -> bool
        
        3. AddPolygon(self: MSPyBentleyGeom.PolyfaceHeader, xyz: MSPyBentleyGeom.DPoint3dArray, worldToParameterSpace: MSPyBentleyGeom.Transform, normal: MSPyBentleyGeom.DVec3d, compressNormal: bool, reverseXYZ: bool) -> bool
        """
        ...
    
    def AddToTaggedPolygons(*args, **kwargs):
        """
        AddToTaggedPolygons(*args, **kwargs)
        Overloaded function.
        
        1. AddToTaggedPolygons(self: MSPyBentleyGeom.PolyfaceQuery, polygons: Bentley.Bstdcxx.bvector<Bentley.TaggedPolygon,Bentley.BentleyAllocator<Bentley.TaggedPolygon> >, indexA: int, numWrap: int, selectRange: MSPyBentleyGeom.DRange3d = None) -> None
        
        2. AddToTaggedPolygons(self: MSPyBentleyGeom.PolyfaceQuery, polygons: Bentley.Bstdcxx.bvector<Bentley.TaggedPolygon,Bentley.BentleyAllocator<Bentley.TaggedPolygon> >, indexA: int, numWrap: int, filer: Bentley.IPolyfaceVisitorFilter) -> None
        """
        ...
    
    def BuildApproximateNormals(*args, **kwargs):
        """
        BuildApproximateNormals(self: MSPyBentleyGeom.PolyfaceHeader, maxSignelEdgeAngle: float = 0.2, maxAccumulatedAngle: float = 0.3, markAllTransitionsVisible: bool = True) -> bool
        """
        ...
    
    def BuildPerFaceFaceData(*args, **kwargs):
        """
        BuildPerFaceFaceData(self: MSPyBentleyGeom.PolyfaceHeader) -> bool
        
        Compute face data for each facet.
        """
        ...
    
    def BuildPerFaceNormals(*args, **kwargs):
        """
        BuildPerFaceNormals(self: MSPyBentleyGeom.PolyfaceHeader) -> bool
        
        Compute a normal vector for each faceet. Install indices.
        """
        ...
    
    def BuildPerFaceParameters(*args, **kwargs):
        """
        BuildPerFaceParameters(self: MSPyBentleyGeom.PolyfaceHeader, selector: MSPyBentleyGeom.LocalCoordinateSelect) -> bool
        
        Compute local coordinates within each facet.
        
        Returns:
        true if parameters computed.
        """
        ...
    
    def ClearAllArrays(*args, **kwargs):
        """
        ClearAllArrays(self: MSPyBentleyGeom.PolyfaceVectors) -> None
        
        clear all arrays (but flags stay unchanged)
        """
        ...
    
    def ClearAllIndexVectors(*args, **kwargs):
        """
        ClearAllIndexVectors(self: MSPyBentleyGeom.PolyfaceHeader) -> None
        
        Clear all index vectors.
        """
        ...
    
    def ClearAllVectors(*args, **kwargs):
        """
        ClearAllVectors(self: MSPyBentleyGeom.PolyfaceHeader) -> None
        
        Clear all facets.
        """
        ...
    
    def ClearNormals(*args, **kwargs):
        """
        ClearNormals(self: MSPyBentleyGeom.PolyfaceHeader, active: bool) -> None
        
        Clear current normal data.
        
        Parameter ``[in]``:
        active active state (true/false) to be applied after clearing.
        """
        ...
    
    def ClearParameters(*args, **kwargs):
        """
        ClearParameters(self: MSPyBentleyGeom.PolyfaceHeader, active: bool) -> None
        
        Clear current param data.
        
        Parameter ``[in]``:
        active active state (true/false) to be applied after clearing.
        """
        ...
    
    def ClearTags(*args, **kwargs):
        """
        ClearTags(self: MSPyBentleyGeom.PolyfaceHeader, numPerFace: int, meshStyle: int) -> None
        
        Initial setup for tag data in blocked vectors. Points are active.
        Point indices are active if style is MESH_ELM_STYLE_INDEXED_FACE_LOOPS
        All other coordinate and index arrays are NOT active. TwoSided is
        true.
        """
        ...
    
    def ClipPolyfaceToClipPlanes(*args, **kwargs):
        """
        ClipPolyfaceToClipPlanes(insideClip: Bentley.PolyfaceHeader, outsideClip: Bentley.PolyfaceHeader, targetMesh: MSPyBentleyGeom.PolyfaceQuery, clipPlanes: MSPyBentleyGeom.ClipPlaneSet, formNewFacesOnClipPlanes: bool) -> bool
        """
        ...
    
    def ClipToPlaneSetIntersection(*args, **kwargs):
        """
        ClipToPlaneSetIntersection(self: MSPyBentleyGeom.PolyfaceQuery, planeSets: Bentley.Bstdcxx.bvector<Bentley.ClipPlaneSet,Bentley.BentleyAllocator<Bentley.ClipPlaneSet> >, output: MSPyBentleyGeom.PolyfaceQuery.IClipToPlaneSetOutput, trangulateOutput: bool) -> int
        
        @description Clip polyface to intersection of an array of plane sets.
        """
        ...
    
    def Clone(*args, **kwargs):
        """
        Clone(self: MSPyBentleyGeom.PolyfaceQuery) -> Bentley.PolyfaceHeader
        
        Return a PolyfaceHeader with the same contents.
        """
        ...
    
    def CloneAsVariableSizeIndexed(*args, **kwargs):
        """
        CloneAsVariableSizeIndexed(self: MSPyBentleyGeom.PolyfaceQuery, source: MSPyBentleyGeom.PolyfaceQuery) -> Bentley.PolyfaceHeader
        
        Return a PolyfaceHeader, with variable length faces.
        """
        ...
    
    def CloneWithDegenerateFacetsRemoved(*args, **kwargs):
        """
        CloneWithDegenerateFacetsRemoved(self: MSPyBentleyGeom.PolyfaceHeader) -> MSPyBentleyGeom.PolyfaceHeader
        """
        ...
    
    def CloneWithFacetsInRandomOrder(*args, **kwargs):
        """
        CloneWithFacetsInRandomOrder(self: MSPyBentleyGeom.PolyfaceHeader) -> MSPyBentleyGeom.PolyfaceHeader
        """
        ...
    
    def CloneWithIndexedDuplicatesRemoved(*args, **kwargs):
        """
        CloneWithIndexedDuplicatesRemoved(self: MSPyBentleyGeom.PolyfaceHeader) -> MSPyBentleyGeom.PolyfaceHeader
        
        Search the mesh for facets that identical sets of point indices.
        Return a clone with only one copy of each.
        """
        ...
    
    def CloneWithMaximalPlanarFacets(*args, **kwargs):
        """
        CloneWithMaximalPlanarFacets(self: MSPyBentleyGeom.PolyfaceHeader, mergeCoplanarFacets: bool, mergeColinearEdges: bool) -> MSPyBentleyGeom.PolyfaceHeader
        
        Search for adjacent, coplanar facets. Merge to get maximual planar
        facets. Optionally remove vertices that have only two incident and
        colinear edges. This uses an very tight (Angle.SmallAngle()) angle
        tolerance. Use CloneWithMaximalPlanarFacetsExt for looser tolerance.
        """
        ...
    
    def CloneWithMaximalPlanarFacetsExt(*args, **kwargs):
        """
        CloneWithMaximalPlanarFacetsExt(self: MSPyBentleyGeom.PolyfaceHeader, mergeCoplanarFacets: bool, mergeColinearEdges: bool, planarityToleranceRadians: float = 1e-08, maxPass: int = 1) -> MSPyBentleyGeom.PolyfaceHeader
        """
        ...
    
    def CloneWithSidePanelsInserted(*args, **kwargs):
        """
        CloneWithSidePanelsInserted(meshes: MSPyBentleyGeom.PolyfaceHeaderPtrArray, viewDirection: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.PolyfaceHeader
        
        * Input an array of meshes expected to have boundary segments are
        separated by " missing side panels " as viewed in a certain direction.
        
        * return a (separate, new) mesh with the side panels added. Additional
        midEdge vertices are inserted into the original facets if T vertices
        are present.
        
        * CreateSidePanelsForViewDirection creaates the panels
        
        * CloneWithTVertexFixup does touchup for extra vertices.
        """
        ...
    
    def CloneWithTVertexFixup(*args, **kwargs):
        """
        CloneWithTVertexFixup(meshes: MSPyBentleyGeom.PolyfaceHeaderPtrArray, options: MSPyBentleyGeom.IFacetOptions = None, onEdgeTolerance: float = 0.0) -> MSPyBentleyGeom.PolyfaceHeader
        
        Clone the meshes as a single mesh, inserting vertices along edges
        where vertices from other facets create T-Vertex topology
        """
        ...
    
    def CloneWithTranslatedFacets(*args, **kwargs):
        """
        CloneWithTranslatedFacets(self: MSPyBentleyGeom.PolyfaceHeader, activeReadIndex: MSPyBentley.UInt64Array, vector: MSPyBentleyGeom.DVec3d, mode: MSPyBentleyGeom.PolyfaceHeader.FacetTranslationMode) -> MSPyBentleyGeom.PolyfaceHeader
        """
        ...
    
    def ClusteredVertexDecimate(*args, **kwargs):
        """
        ClusteredVertexDecimate(self: MSPyBentleyGeom.PolyfaceQuery, tolerance: float) -> Bentley.PolyfaceHeader
        
        @description Fas clustered vertex decimator - used during tile
        generation.
        """
        ...
    
    def CollectAdjacentFacetAndPointIndices(*args, **kwargs):
        """
        CollectAdjacentFacetAndPointIndices(self: MSPyBentleyGeom.PolyfaceHeader, activeReadIndex: MSPyBentley.UInt64Array, fringeReadIndex: MSPyBentley.UInt64Array, activePointIndex: MSPyBentley.UInt64Array) -> None
        
        Collect indices of (1) adjacent facets and (2) points within the
        active facets.
        """
        ...
    
    def CollectCounts(*args, **kwargs):
        """
        CollectCounts(self: MSPyBentleyGeom.PolyfaceQuery) -> tuple
        """
        ...
    
    def CollectEdgeMateData(*args, **kwargs):
        """
        CollectEdgeMateData(self: MSPyBentleyGeom.PolyfaceHeader, segments: Bentley.Bstdcxx.bvector<Bentley.FacetEdgeDetail,Bentley.BentleyAllocator<Bentley.FacetEdgeDetail> >, includeMatched: bool = False, returnSingleEdgeReadIndex: bool = False) -> None
        
        Create segments containing edges of this polyface. The returned array
        indicates
        
        * segment coordinates
        
        * a readIndex. Based on the returnSingleEdgeReadIndex value, his can
        be either the base readIndex for the whole facet, or the detail read
        index for the individual edge.
        
        * clusterIndex. Shared edges will return the same cluster index.
        
        * number of edges in the cluster. If collecting only unmatched edges,
        this normally be 1, but can be
        
        Parameter ``[out]``:
        segments array of segment data.
        
        Parameter ``[in]``:
        includeMatched true to include interior segemnts that have mates.
        
        Parameter ``[in]``:
        returnSingleEdgeReadIndex if true, return read index to the base
        of the individual edge. If false, return readIndex for the entire
        facet. (The entire facet index is prefered for calling
        visitor->MoveToReadIndex ())
        """
        ...
    
    def CollectPerFaceCounts(*args, **kwargs):
        """
        CollectPerFaceCounts(self: MSPyBentleyGeom.PolyfaceQuery) -> tuple
        """
        ...
    
    def CollectSegments(*args, **kwargs):
        """
        CollectSegments(self: MSPyBentleyGeom.PolyfaceQuery, segments: MSPyBentleyGeom.DSegment3dArray, omitInvisible: bool) -> None
        
        Collect individual segments for each distinct edge.
        
        Parameter ``[out]``:
        segments array to receive segments.
        
        Parameter ``[in]``:
        omitInvisibles true to hide segments that are not visible (due to
        negated indices)
        """
        ...
    
    @property
    def ColorCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    def ColorIndex(*args, **kwargs):
        """
        ColorIndex(self: MSPyBentleyGeom.PolyfaceHeader) -> MSPyBentleyGeom.BlockedVectorInt
        
        Return a reference to the color index vector. Completion of color
        dereference depends on additional data in DoubleColor, IntColor, or
        ColorTable
        """
        ...
    
    def ColorTable(*args, **kwargs):
        """
        ColorTable(self: MSPyBentleyGeom.PolyfaceHeader) -> MSPyBentleyGeom.BlockedVectorUInt32
        
        Return a reference to the array of color table as integer table
        select.
        """
        ...
    
    def CompactIndexArrays(*args, **kwargs):
        """
        CompactIndexArrays(self: MSPyBentleyGeom.PolyfaceHeader) -> bool
        
        Revise index structure to minimize array lengths.
        
        Returns:
        true if any changes were made.
        """
        ...
    
    def Compress(*args, **kwargs):
        """
        Compress(*args, **kwargs)
        Overloaded function.
        
        1. Compress(self: MSPyBentleyGeom.PolyfaceHeader) -> None
        
        Compress duplicate coordinate data, with default realtive tolerances.
        
        2. Compress(self: MSPyBentleyGeom.PolyfaceHeader, pointAbsTol: float, normalAbsTol: float = -1.0, paramAbsTol: float = -1.0, relTol: float = -1.0) -> None
        
        Compress duplicate coordinate data, with default realtive tolerances.
        """
        ...
    
    def ComputeOffset(*args, **kwargs):
        """
        ComputeOffset(self: MSPyBentleyGeom.PolyfaceHeader, options: MSPyBentleyGeom.PolyfaceHeader.OffsetOptions, distance1: float, distance2: float, outputOffset1: bool = True, outputOffset2: bool = True, outputSideFacets: bool = True) -> MSPyBentleyGeom.PolyfaceHeader
        """
        ...
    
    def ComputeOverAndUnderXY(*args, **kwargs):
        """
        ComputeOverAndUnderXY(polyfaceA: Bentley.PolyfaceHeader, filterA: Bentley.IPolyfaceVisitorFilter, polyfaceB: Bentley.PolyfaceHeader, filterB: Bentley.IPolyfaceVisitorFilter, polyfaceAOverB: Bentley.PolyfaceHeader, polyfaceBUnderA: Bentley.PolyfaceHeader, computeAndApplyTransform: bool = True) -> None
        """
        ...
    
    def ComputePrincipalAreaMoments(*args, **kwargs):
        """
        ComputePrincipalAreaMoments(self: MSPyBentleyGeom.PolyfaceQuery, centroid: MSPyBentleyGeom.DPoint3d, axes: MSPyBentleyGeom.RotMatrix, momentxyz: MSPyBentleyGeom.DVec3d) -> tuple
        """
        ...
    
    def ComputePrincipalMoments(*args, **kwargs):
        """
        ComputePrincipalMoments(self: MSPyBentleyGeom.PolyfaceQuery, centroid: MSPyBentleyGeom.DPoint3d, axes: MSPyBentleyGeom.RotMatrix, momentxyz: MSPyBentleyGeom.DVec3d, forcePositiveVolume: bool = False) -> tuple
        """
        ...
    
    def ComputePrincipalMomentsAllowMissingSideFacets(*args, **kwargs):
        """
        ComputePrincipalMomentsAllowMissingSideFacets(self: MSPyBentleyGeom.PolyfaceQuery, centroid: MSPyBentleyGeom.DPoint3d, axes: MSPyBentleyGeom.RotMatrix, momentxyz: MSPyBentleyGeom.DVec3d, forcePositiveVolume: bool, relativeTolerance: float = 1e-08) -> tuple
        """
        ...
    
    def ComputePunch(*args, **kwargs):
        """
        ComputePunch(punch: MSPyBentleyGeom.PolyfaceQuery, target: MSPyBentleyGeom.PolyfaceQuery, keepInside: bool, result: Bentley.Bstdcxx.bvector<Bentley.RefCountedPtr<Bentley.PolyfaceHeader>,Bentley.BentleyAllocator<Bentley.RefCountedPtr<Bentley.PolyfaceHeader> > >) -> None
        
        @description " Punch " through target polygons.
        
        Parameter ``[in]``:
        punch punch polygons
        
        Parameter ``[in]``:
        target target polygons
        
        Parameter ``[in]``:
        keepInside true to return the target mesh parts that are inside
        the punch, false to return outside parts.
        
        Parameter ``[out]``:
        result punched mesh
        """
        ...
    
    def ComputePunchXYByPlaneSets(*args, **kwargs):
        """
        ComputePunchXYByPlaneSets(punch: MSPyBentleyGeom.PolyfaceQuery, target: MSPyBentleyGeom.PolyfaceQuery, inside: Bentley.PolyfaceHeader, outside: Bentley.PolyfaceHeader, debugMesh: Bentley.PolyfaceHeader = None) -> None
        
        [in] each facet of this is used as a " punch " [in] facets to be split
        by the punch. [out] (target intersect punch) [out] (target outsideOf
        punch) [out] optional meshes for debugging
        """
        ...
    
    def ComputeSingleSheetCutFill(*args, **kwargs):
        """
        ComputeSingleSheetCutFill(dtmMesh: MSPyBentleyGeom.PolyfaceHeader, roadMesh: MSPyBentleyGeom.PolyfaceHeader, viewVector: MSPyBentleyGeom.DVec3d, option: MSPyBentleyGeom.PolyfaceHeader.ComputeSingleSheetOption) -> tuple
        """
        ...
    
    class ComputeSingleSheetOption:
        """
        Members:
        
        eBoth
        
        eCutMeshOnly
        
        eFillMeshOnly
        """
    
        def __init__(self: MSPyBentleyGeom.PolyfaceHeader.ComputeSingleSheetOption, value: int) -> None:
            ...
        
        eBoth: ComputeSingleSheetOption
        
        eCutMeshOnly: ComputeSingleSheetOption
        
        eFillMeshOnly: ComputeSingleSheetOption
        
        @property
        def name(self: handle) -> str:
            ...
        
        @property
        def value(arg0: MSPyBentleyGeom.PolyfaceHeader.ComputeSingleSheetOption) -> int:
            ...
        
    def ComputeUndercut(*args, **kwargs):
        """
        ComputeUndercut(polyfaceA: Bentley.PolyfaceHeader, filterA: Bentley.IPolyfaceVisitorFilter, polyfaceB: Bentley.PolyfaceHeader, filterB: Bentley.IPolyfaceVisitorFilter, undercutPolyface: Bentley.PolyfaceHeader) -> None
        
        @description Compute volumes where polyfaceB undercuts polyfaceA
        """
        ...
    
    def ConstructOrderingForLongEdgeRemoval(*args, **kwargs):
        """
        ConstructOrderingForLongEdgeRemoval(self: MSPyBentleyGeom.PolyfaceHeader, readIndexSequence: MSPyBentley.UInt64Array, maxEdgeLength: float = 0.0) -> bool
        
        Determine a facet order such that the LAST facets are the first to be
        removed when applying the logic " Remove the longest exterior edge first " ul> li> If this is applied to facets of a triangulation (whose
        outer boundary is convex), the successive outer boundaries are
        polygons that contain short edges and have inlets where there are long
        edges on the outside. The readIndexSequence contains sequences of
        readIndices for the shuffled facets. li> Suppose a facet
        
        * initially has vertices, params, normals, and colors indicated at
        (consecutive) readIndices [a b c]
        
        * the edges from b to c is chosen for removal
        
        li> li>That facet will appear as [b c a SIZE_MAX]. ul>
        """
        ...
    
    def ConvertTableColorToColorIndices(*args, **kwargs):
        """
        ConvertTableColorToColorIndices(self: MSPyBentleyGeom.PolyfaceHeader, faceToTableColor: MSPyBentleyGeom.BlockedVectorInt, vertexToTableColor: MSPyBentleyGeom.BlockedVectorInt) -> bool
        
        Build color indices as face loops (as needed) Return false if no
        conversion or if point index tables asked for more table indices than
        present in the TableColor arrays.
        """
        ...
    
    def ConvertToVariableSizeSignedOneBasedIndexedFaceLoops(*args, **kwargs):
        """
        ConvertToVariableSizeSignedOneBasedIndexedFaceLoops(self: MSPyBentleyGeom.PolyfaceHeader) -> bool
        
        Convert the mesh indexing to signed, one-based, variable size face
        loops.
        """
        ...
    
    def CopyAllActiveFlagsFrom(*args, **kwargs):
        """
        CopyAllActiveFlagsFrom(self: MSPyBentleyGeom.PolyfaceVectors, source: MSPyBentleyGeom.PolyfaceVectors) -> None
        
        Copy active flags from the various arrays of the source.
        """
        ...
    
    def CopyAllActiveFlagsFromQuery(*args, **kwargs):
        """
        CopyAllActiveFlagsFromQuery(self: MSPyBentleyGeom.PolyfaceVectors, source: MSPyBentleyGeom.PolyfaceQuery) -> None
        
        In PolyfaceQuery, determine active status from pointers. This is only
        valid if the PolyfaceQuery has already been filled !!!
        """
        ...
    
    def CopyFrom(*args, **kwargs):
        """
        CopyFrom(self: MSPyBentleyGeom.PolyfaceHeader, source: MSPyBentleyGeom.PolyfaceQuery) -> None
        
        Clear current data, append data from (readonly) source
        """
        ...
    
    def CopyPartitions(*args, **kwargs):
        """
        CopyPartitions(*args, **kwargs)
        Overloaded function.
        
        1. CopyPartitions(self: MSPyBentleyGeom.PolyfaceHeader, blockedReadIndex: MSPyBentley.Int64Array, submeshArray: MSPyBentleyGeom.PolyfaceHeaderPtrArray) -> bool
        
        2. CopyPartitions(self: MSPyBentleyGeom.PolyfaceHeader, blockedReadIndex: MSPyBentley.Int64VecArray, submeshArray: MSPyBentleyGeom.PolyfaceHeaderPtrArray) -> bool
        """
        ...
    
    def CopyTo(*args, **kwargs):
        """
        CopyTo(self: MSPyBentleyGeom.PolyfaceHeader, dest: MSPyBentleyGeom.PolyfaceHeader) -> None
        
        Copy all data to another header.
        """
        ...
    
    def CountSharedEdges(*args, **kwargs):
        """
        CountSharedEdges(self: MSPyBentleyGeom.PolyfaceQuery, ignoreSliverFaces: bool) -> tuple
        """
        ...
    
    def CreateFixedBlockCoordinates(*args, **kwargs):
        """
        CreateFixedBlockCoordinates(numPerFaces: int) -> MSPyBentleyGeom.PolyfaceHeader
        
        Create a (smart pointer to a) new (empty) PolyfaceHeader, with each
        facet defined by 3 or 4 unindexed points as indicated by the arg.
        
        Returns:
        invalid if numPerFace is other than 3 or 4.
        """
        ...
    
    def CreateFixedBlockIndexed(*args, **kwargs):
        """
        CreateFixedBlockIndexed(numPerBlock: int) -> MSPyBentleyGeom.PolyfaceHeader
        
        Create a (smart pointer to a) new (empty) PolyfaceHeader, with fixed
        number of indices per face
        
        Returns:
        invalid if numPerBlock is less than 3.
        """
        ...
    
    def CreateFromTaggedPolygons(*args, **kwargs):
        """
        CreateFromTaggedPolygons(polygons: Bentley.Bstdcxx.bvector<Bentley.TaggedPolygon,Bentley.BentleyAllocator<Bentley.TaggedPolygon> >) -> MSPyBentleyGeom.PolyfaceHeader
        
        Create a (indexed) polyface containing all polygons from a
        TaggedPolygonVector
        """
        ...
    
    def CreateIndexedMesh(*args, **kwargs):
        """
        CreateIndexedMesh(numPerFace: int, points: MSPyBentleyGeom.DPoint3dArray, indexData: MSPyBentley.Int32Array) -> MSPyBentleyGeom.PolyfaceHeader
        
        Create a mesh with (just) point and index data.
        """
        ...
    
    def CreateQuadGrid(*args, **kwargs):
        """
        CreateQuadGrid(numPerRow: int) -> MSPyBentleyGeom.PolyfaceHeader
        
        Create a (smart pointer to a) new (empty) PolyfaceHeader, with
        quadrilaterals defined by points in a grid.
        
        Returns:
        invalid if numPerRow<2.
        """
        ...
    
    def CreateRegularPolyhedron(*args, **kwargs):
        """
        CreateRegularPolyhedron(radius: float, polyhedronSelect: int, radiusSelect: int, transform: MSPyBentleyGeom.Transform = None) -> MSPyBentleyGeom.PolyfaceHeader
        
        Create a classic polyhedron, i.e. one of
        
        * 0 = Tetrahedron
        
        * 1 = Cube
        
        * 2 = Octahedron
        
        * 3 = Dodecahedron
        
        * 4 = Icosahedron
        
        The polyhedron is " in a sphere ", with measurement indicated by
        
        * 0 = measure radius to vertices
        
        * 1 = radius to midedge, orient with x axis to mid-edge (see 101)
        
        * 2 = radius to midface
        
        * 100 = radius to vertex, but orient cube and octahedron with square
        cross section in xy plane.
        
        * 101 = radius to midedge, but orient cube and octahedron with square
        cross section in xy plane.
        
        * 102 = radius to midface, but orient cube and octahedron with square
        cross section in xy plane.
        
        The orientation is as follows:
        
        * For selection 100, 101 and 102 for cube and octahedron, a square
        cross section is parallel to the xy plane.
        
        * For all other cases (0,1,2 for all polyhedra, and 101,101,102 for
        other than cube and octahedron)
        
        * A vertex, mid-edge, or centroid point (respective to the
        measurement) is on the positive x axis
        
        * Another edge of an incident face is in the y direction.
        
        * Hence when viewed from positive x towards center, there will be a
        horizontal edge
        
        * on a face with a vertex on the x axis.
        
        Parameter ``[in]``:
        radius radius of sphere
        
        Parameter ``[in]``:
        polyhedronSelect integer selector, as enumerated above.
        
        Parameter ``[in]``:
        radiusSelect control of sphere radius, as enumerated above.
        
        Parameter ``[in]``:
        transform optional transform to place the sphere.
        """
        ...
    
    def CreateRegularPolyhedronWithSubtriangulation(*args, **kwargs):
        """
        CreateRegularPolyhedronWithSubtriangulation(radius: float, polyhedronSelect: int, numExtraVerticesInBaseEdges: int, transform: MSPyBentleyGeom.Transform) -> MSPyBentleyGeom.PolyfaceHeader
        """
        ...
    
    def CreateSidePanelsForViewDirection(*args, **kwargs):
        """
        CreateSidePanelsForViewDirection(meshes: MSPyBentleyGeom.PolyfaceHeaderPtrArray, viewDirection: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.PolyfaceHeader
        
        Input an array of meshes expected to have boundary segments are
        separated by " missing side panels " as viewed in a certain direction.
        return a (separate, new) mesh with only the side panels.
        """
        ...
    
    def CreateTriangleGrid(*args, **kwargs):
        """
        CreateTriangleGrid(numPerRow: int) -> MSPyBentleyGeom.PolyfaceHeader
        
        Create a (smart pointer to a) new (empty) PolyfaceHeader, with
        quadrilaterals defined by points in a grid, and then each quad is
        split to triangle.
        
        Returns:
        invalid if numPerRow<2.
        """
        ...
    
    def CreateUnifiedIndexMesh(*args, **kwargs):
        """
        CreateUnifiedIndexMesh(source: MSPyBentleyGeom.PolyfaceQuery) -> MSPyBentleyGeom.PolyfaceHeader
        
        Copy all data to a new mesh, reorganizing so that all data arrays have
        the same index structure. This is a memory-efficient structure ONLY
        for smooth surfaces such as bspline, cylinder, sphere. This is a
        highly inefficent structure for any mesh with interior edges.
        Unfortunately it is a common mesh structure in exchange formats.
        """
        ...
    
    def CreateVariableSizeIndexed(*args, **kwargs):
        """
        CreateVariableSizeIndexed() -> MSPyBentleyGeom.PolyfaceHeader
        
        Create a (smart pointer to a) new (empty) PolyfaceHeader, with
        variable length faces. This is the most common mesh style.
        """
        ...
    
    def CreateVerticalPanelsBetweenSegments(*args, **kwargs):
        """
        CreateVerticalPanelsBetweenSegments(segments: Bentley.Bstdcxx.bvector<Bentley.FacetEdgeDetail,Bentley.BentleyAllocator<Bentley.FacetEdgeDetail> >) -> MSPyBentleyGeom.PolyfaceHeader
        """
        ...
    
    def CreateXYTriangulation(*args, **kwargs):
        """
        CreateXYTriangulation(points: MSPyBentleyGeom.DPoint3dArray, fringeExpansionFactor: float = 0.1, retainFringeTriangles: bool = False) -> MSPyBentleyGeom.PolyfaceHeader
        
        Create a triangulation of points as viewed in xy. Add the triangles to
        the polyface. (Other than sharing vertices with matched xy, this does
        not coordinate in any way with prior mesh contents.)
        
        Parameter ``[in]``:
        points candidate points
        
        Parameter ``[in]``:
        fringeExpansionFactor fractional factor (usually 0.10 to 0.20) for
        defining a surrounding rectangle. The z of this triangle is at the
        low z of all the points.
        
        Parameter ``[in]``:
        retainFringeTriangles true to keep the fringe triangles. If false,
        any edge that reaches the outer rectangle is deleted.
        """
        ...
    
    def DirectionalAreaAndVolume(*args, **kwargs):
        """
        DirectionalAreaAndVolume(self: MSPyBentleyGeom.PolyfaceQuery, origin: MSPyBentleyGeom.DPoint3d, areaXYZ: MSPyBentleyGeom.DVec3d, volumeXYZ: MSPyBentleyGeom.DVec3d, centroidX: MSPyBentleyGeom.DVec3d, centroidY: MSPyBentleyGeom.DVec3d, centroidZ: MSPyBentleyGeom.DVec3d) -> None
        
        Compute areas, centroids, volumes of projections onto principal
        planes.
        """
        ...
    
    def DirectionalVolumeIntegrals(*args, **kwargs):
        """
        DirectionalVolumeIntegrals(self: MSPyBentleyGeom.PolyfaceQuery, polyface: MSPyBentleyGeom.PolyfaceQuery, pData: MSPyBentleyGeom.DirectionalVolumeData, directionalProducts: MSPyBentleyGeom.DMatrix4d, origin: MSPyBentleyGeom.DPoint3d) -> None
        
        @description Compute (many) integrals of volume properties, using
        directional formulas that will give correct results (and confidence
        indicators) when " some " facets are missing
        
        Parameter ``[in]``:
        polyface facets for integration
        
        Parameter ``[out]``:
        pData array (allocated by caller) of various integrals:
        
        * pData[0], pData[1], pData[2] = view along respective axes. Use
        signed area, so result should be zero if all facets are present to
        cancel.
        
        * pData[0], pData[1], pData[2] = view along respective axes. Use
        absolute area, so result should be useful for setting tolerances.
        
        * pData[6] = full 3d area.
        
        Parameter ``[out]``:
        directionalProducts array of products integrals wrt origin.
        Allocated by caller.
        
        Parameter ``[out]``:
        origin origin used for directonal integrals. (Directional
        integrals are " from the principal " planes through this origin.)
        """
        ...
    
    def DoubleColor(*args, **kwargs):
        """
        DoubleColor(self: MSPyBentleyGeom.PolyfaceHeader) -> MSPyBentleyGeom.BlockedVectorRgbFactor
        
        Return a reference to the vector of color-via-RgbFactor structs.
        """
        ...
    
    def DrapeLinestring(*args, **kwargs):
        """
        DrapeLinestring(self: MSPyBentleyGeom.PolyfaceQuery, spacePoints: MSPyBentleyGeom.DPoint3dArray, direction: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.CurveVector
        
        Project linestring in given direction to intersection with facets.
        Return as a curve vector.
        
        Parameter ``[in]``:
        spacePoints points to project onto the polyface
        
        Parameter ``[in]``:
        direction direction to project.
        """
        ...
    
    def EdgeChain(*args, **kwargs):
        """
        EdgeChain(self: MSPyBentleyGeom.PolyfaceHeader) -> MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain
        
        Return a reference to the edge chain index vector.
        """
        ...
    
    @property
    def EdgeChainCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    def EnsureFloatColor(*args, **kwargs):
        """
        EnsureFloatColor(self: MSPyBentleyGeom.PolyfaceQuery) -> bool
        
        If float colors are not already present, build them from double
        colors. Returns false if the implementing class is read only.
        """
        ...
    
    def ExcavateFacetsWithLongBoundaryEdges(*args, **kwargs):
        """
        ExcavateFacetsWithLongBoundaryEdges(self: MSPyBentleyGeom.PolyfaceHeader, maxEdgeLength: float = 0.0) -> bool
        
        * Find facets with boundary edges longer than maxEdgeLength.
        
        * Remove the facets.
        
        * Continue searching for long edges in the newly exposed facets.
        
        * If the initial facets are an xy triangulation of points (with the
        convex hull outer boundary), the first removals creates a non-convex
        outer boundary. Later removals can create islands of facets.
        """
        ...
    
    def ExtractBoundaryStrings(*args, **kwargs):
        """
        ExtractBoundaryStrings(self: MSPyBentleyGeom.PolyfaceHeader) -> tuple
        """
        ...
    
    def ExtractTopologicalBoundaryStrings(*args, **kwargs):
        """
        ExtractTopologicalBoundaryStrings(self: MSPyBentleyGeom.PolyfaceHeader) -> tuple
        """
        ...
    
    @property
    def FaceCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    def FaceData(*args, **kwargs):
        """
        FaceData(self: MSPyBentleyGeom.PolyfaceHeader) -> MSPyBentleyGeom.BlockedVectorFacetFaceData
        
        Return a reference to the face information.
        """
        ...
    
    def FaceIndex(*args, **kwargs):
        """
        FaceIndex(self: MSPyBentleyGeom.PolyfaceHeader) -> MSPyBentleyGeom.BlockedVectorInt
        
        Return a reference to the face index vector.
        """
        ...
    
    @property
    def FaceIndexCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    class FacetTranslationMode:
        """
        Members:
        
        eJustTranslatePoints
        
        eTranslatePointsAndAddSweepFaces
        
        eTranslatePointsAndTriangulateFringeFaces
        """
    
        def __init__(self: MSPyBentleyGeom.PolyfaceHeader.FacetTranslationMode, value: int) -> None:
            ...
        
        eJustTranslatePoints: FacetTranslationMode
        
        eTranslatePointsAndAddSweepFaces: FacetTranslationMode
        
        eTranslatePointsAndTriangulateFringeFaces: FacetTranslationMode
        
        @property
        def name(self: handle) -> str:
            ...
        
        @property
        def value(arg0: MSPyBentleyGeom.PolyfaceHeader.FacetTranslationMode) -> int:
            ...
        
    def FindOrAddColorTable(*args, **kwargs):
        """
        FindOrAddColorTable(self: MSPyBentleyGeom.PolyfaceVectors, tableIndex: int) -> int
        
        Find or add a color table. * Activate if needed. * This is a linear
        search !
        """
        ...
    
    def FixupVertexNormalDirectionToFaceOrientation(*args, **kwargs):
        """
        FixupVertexNormalDirectionToFaceOrientation(self: MSPyBentleyGeom.PolyfaceHeader, summary: MSPyBentleyGeom.MeshAnnotationVector, makeChanges: bool) -> bool
        
        Inspect and correct the direction of " at vertex " normals relative to
        the ordering of vertices around facets. Returns true if any changes
        were made. The summary vector will contain entries indicating:ul>
        li>Early exit if fails assertion " Mesh should ( but does not ) have both NormalIndex and Normal ( ) data " li>Quiet warning, not a change
        trigger:" Ignoring facet whose facet normal cannot be computed from vertex coordinates " li>Quiet warning, not a change trigger:" Ignoring out of range normal index " li>Quiet warning of change trigger:" vertex normal has both positive and negative incident facets A new negated normal is introduced " li>Quiet warning of change trigger:" All incident facets normals are reverse of vertex normal - - normal is negated " li>Quiet warning, not a change trigger:" unused normal coordinates " li> ul>
        """
        ...
    
    def FloatColor(*args, **kwargs):
        """
        FloatColor(self: MSPyBentleyGeom.PolyfaceHeader) -> MSPyBentleyGeom.BlockedVectorFloatRgb
        
        Return a reference to the array of float rgb colors.
        """
        ...
    
    def GetColorCount(*args, **kwargs):
        """
        GetColorCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Return the number of colors.
        """
        ...
    
    def GetColorIndexAt(*args, **kwargs):
        """
        GetColorIndexAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int, resolveToDefaults: bool = False) -> tuple
        """
        ...
    
    def GetColorTableAt(*args, **kwargs):
        """
        GetColorTableAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple
        """
        ...
    
    def GetDoubleColorAt(*args, **kwargs):
        """
        GetDoubleColorAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple
        """
        ...
    
    def GetEdgeChainAt(*args, **kwargs):
        """
        GetEdgeChainAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple
        """
        ...
    
    def GetEdgeChainCount(*args, **kwargs):
        """
        GetEdgeChainCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Return the number of edge chains.
        """
        ...
    
    def GetFaceCount(*args, **kwargs):
        """
        GetFaceCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Return the number of faces. Note that this is not a " facet " count --
        many facets can reference the same containing face in the parent
        geometry.
        """
        ...
    
    def GetFaceDataAt(*args, **kwargs):
        """
        GetFaceDataAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple
        """
        ...
    
    def GetFaceIndexAt(*args, **kwargs):
        """
        GetFaceIndexAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int, resolveToDefaults: bool = False) -> tuple
        """
        ...
    
    def GetFaceIndexCount(*args, **kwargs):
        """
        GetFaceIndexCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Return the number of face data indices
        """
        ...
    
    def GetFloatColorAt(*args, **kwargs):
        """
        GetFloatColorAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple
        """
        ...
    
    def GetIlluminationName(*args, **kwargs):
        """
        GetIlluminationName(self: MSPyBentleyGeom.PolyfaceQuery) -> str
        """
        ...
    
    def GetIntColorAt(*args, **kwargs):
        """
        GetIntColorAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple
        """
        ...
    
    def GetMediumTolerance(*args, **kwargs):
        """
        GetMediumTolerance(self: MSPyBentleyGeom.PolyfaceQuery) -> float
        
        Return a tolerance appropriate for medium accuracy calculations (8
        digits relative)
        """
        ...
    
    def GetMeshStyle(*args, **kwargs):
        """
        GetMeshStyle(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Query the mesh style (MESH_ELM_STYLE_INDEXED_FACE_LOOPS etc)
        """
        ...
    
    def GetNormalAt(*args, **kwargs):
        """
        GetNormalAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple
        """
        ...
    
    def GetNormalCount(*args, **kwargs):
        """
        GetNormalCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Return the number of normals.
        """
        ...
    
    def GetNormalIndexAt(*args, **kwargs):
        """
        GetNormalIndexAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int, resolveToDefaults: bool = False) -> tuple
        """
        ...
    
    def GetNumFacet(*args, **kwargs):
        """
        GetNumFacet(self: MSPyBentleyGeom.PolyfaceQuery) -> tuple
        """
        ...
    
    def GetNumPerFace(*args, **kwargs):
        """
        GetNumPerFace(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Query the nominal number of facets per face. If this is 0 or 1, facets
        are variable size and separated by 0 as terminator. If larger the
        indices are blocked (with 0 as pad if needed)
        """
        ...
    
    def GetNumPerRow(*args, **kwargs):
        """
        GetNumPerRow(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Query the row size for gridded mesh (quad or triangular)
        """
        ...
    
    def GetParamAt(*args, **kwargs):
        """
        GetParamAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple
        """
        ...
    
    def GetParamCount(*args, **kwargs):
        """
        GetParamCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Return the number of parameters.
        """
        ...
    
    def GetParamIndexAt(*args, **kwargs):
        """
        GetParamIndexAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int, resolveToDefaults: bool = False) -> tuple
        """
        ...
    
    def GetPointAt(*args, **kwargs):
        """
        GetPointAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple
        """
        ...
    
    def GetPointCount(*args, **kwargs):
        """
        GetPointCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Return the number of points.
        """
        ...
    
    def GetPointIndexAt(*args, **kwargs):
        """
        GetPointIndexAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple
        """
        ...
    
    def GetPointIndexCount(*args, **kwargs):
        """
        GetPointIndexCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Return the number of point indices.
        """
        ...
    
    def GetTextureId(*args, **kwargs):
        """
        GetTextureId(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Return a pointer to contiguous texture id.
        """
        ...
    
    def GetTightTolerance(*args, **kwargs):
        """
        GetTightTolerance(self: MSPyBentleyGeom.PolyfaceQuery) -> float
        
        Return a tolerance appropriate for high accuracy calculations (12 or
        more digits relative)
        """
        ...
    
    def GetTwoSided(*args, **kwargs):
        """
        GetTwoSided(self: MSPyBentleyGeom.PolyfaceQuery) -> bool
        
        Query if facets are considered two sided. (If not, outward normal can
        be used to cull backfaces)
        """
        ...
    
    def HasConvexFacets(*args, **kwargs):
        """
        HasConvexFacets(self: MSPyBentleyGeom.PolyfaceQuery) -> bool
        
        Check convexity
        """
        ...
    
    def HasFacets(*args, **kwargs):
        """
        HasFacets(self: MSPyBentleyGeom.PolyfaceQuery) -> bool
        
        Test if any facets are defined (Specifically, true if the point index
        set is nonempty).
        """
        ...
    
    def HasIndexErrors(*args, **kwargs):
        """
        HasIndexErrors(*args, **kwargs)
        Overloaded function.
        
        1. HasIndexErrors(self: MSPyBentleyGeom.PolyfaceQuery, descripton: MSPyBentleyGeom.MeshAnnotationVector) -> bool
        
        Apply various checks for indexing structure.
        
        Returns:
        true if any errors were found.
        
        2. HasIndexErrors(self: MSPyBentleyGeom.PolyfaceQuery) -> bool
        
        Apply various checks for indexing structure.
        
        Returns:
        true if any errors were found.
        """
        ...
    
    def HealVerticalPanels(*args, **kwargs):
        """
        HealVerticalPanels(polyface: MSPyBentleyGeom.PolyfaceQuery, tryVerticalPanels: bool, trySpaceTriangulation: bool, healedPolyface: Bentley.PolyfaceHeader) -> int
        
        Attempt to heal vertical gaps in a mesh.
        
        Parameter ``[in]``:
        polyface original polyface
        
        Parameter ``[in]``:
        tryVerticalPanels true to seek pure vertical panels
        
        Parameter ``[in]``:
        trySpaceTriangulation true to seek triangulation of any missing
        faces, as viewed from any direction found useful.
        
        Parameter ``[out]``:
        healedPolyface modified polyface. This is NOT constructed if no
        panels can be added.
        
        Returns:
        number of facets added
        """
        ...
    
    class IClipToPlaneSetOutput:
        """
        None
        """
    
        def __init__(*args, **kwargs):
            """
            Initialize self.  See help(type(self)) for accurate signature.
            """
            ...
        
    def IdentifyDuplicates(*args, **kwargs):
        """
        IdentifyDuplicates(self: MSPyBentleyGeom.PolyfaceHeader, nonduplicatedFacetReadIndex: MSPyBentley.Int64Array, duplicatedFacetFirstReadIndex: MSPyBentley.Int64Array, duplicatedFacetAdditionalReadIndex: MSPyBentley.Int64Array, baseIndexForAdditionalReadIndex: MSPyBentley.Int64Array) -> None
        """
        ...
    
    def IlluminationName(*args, **kwargs):
        """
        IlluminationName(self: MSPyBentleyGeom.PolyfaceHeader) -> MSPyBentley.WString
        
        Return a reference to the illumination name string.
        """
        ...
    
    def InspectFaces(*args, **kwargs):
        """
        InspectFaces(self: MSPyBentleyGeom.PolyfaceQuery) -> tuple
        """
        ...
    
    def IntColor(*args, **kwargs):
        """
        IntColor(self: MSPyBentleyGeom.PolyfaceHeader) -> MSPyBentleyGeom.BlockedVectorUInt32
        
        Return a reference to the array of color as integers.
        """
        ...
    
    def IsClosedByEdgePairing(*args, **kwargs):
        """
        IsClosedByEdgePairing(self: MSPyBentleyGeom.PolyfaceQuery) -> bool
        
        Test if vertex indices around faces indicate watertight closure.
        """
        ...
    
    def IsPlanarWithinSuperfacets(*args, **kwargs):
        """
        IsPlanarWithinSuperfacets(self: MSPyBentleyGeom.PolyfaceHeader, tolerance: float = -1.0) -> bool
        
        Determines if each visible facet (a super facet) is planar within
        tolerance.
        
        Parameter ``[in]``:
        tolerance. If a negative number is provided, the tolerance used is
        a small fraction of the diagonal range.
        
        Returns:
        true iff each super facet is planar within tolerance.
        """
        ...
    
    def IsSameStructureAndGeometry(*args, **kwargs):
        """
        IsSameStructureAndGeometry(self: MSPyBentleyGeom.PolyfaceQuery, other: MSPyBentleyGeom.PolyfaceQuery, tolerance: float) -> bool
        
        Test for AlmostEqual () conditions.
        """
        ...
    
    def IsTriangulated(*args, **kwargs):
        """
        IsTriangulated(self: MSPyBentleyGeom.PolyfaceQuery) -> bool
        
        Test if all facets are 3 sided
        """
        ...
    
    def IsVariableSizeIndexed(*args, **kwargs):
        """
        IsVariableSizeIndexed(self: MSPyBentleyGeom.PolyfaceQuery) -> bool
        
        Test if this mesh is vaiable sized indexed.
        """
        ...
    
    def LargestCoordinate(*args, **kwargs):
        """
        LargestCoordinate(self: MSPyBentleyGeom.PolyfaceQuery) -> float
        
        Query largest absolute coordinate
        """
        ...
    
    def LocalDecimation(*args, **kwargs):
        """
        LocalDecimation(self: MSPyBentleyGeom.PolyfaceHeader, abstol: float, rangeFractionTol: float) -> int
        
        Returns:
        number of collapses.
        """
        ...
    
    def MarkAllEdgesVisible(*args, **kwargs):
        """
        MarkAllEdgesVisible(self: MSPyBentleyGeom.PolyfaceHeader) -> None
        
        Mark all edges visible.
        """
        ...
    
    def MarkDiagonalEdgesInvisible(*args, **kwargs):
        """
        MarkDiagonalEdgesInvisible(self: MSPyBentleyGeom.PolyfaceHeader, smoothAngle: float, edgeLengthFactor: float = 1.001, maxEdgesInFacetForDiagonalRules: int = 3) -> bool
        
        mark edges invisible by smoothAngle and silhoutte conditions, and
        additionally requrie them to be " diagonals ". The conditions for a
        diagonal are 1) longer than each other edge of the facet by at least
        edgeLengthFactor 2) at most maxEdgesInFacet This is specifically
        intended for civil road meshes which have slightly twisted quads that
        must be triangulated for calculations. If triangulated, both the
        transverse edges and diagonals would get hidden by usual dihedral
        angle rules. This hides the diagonals but leaves the simple transverse
        edges visible.
        """
        ...
    
    def MarkInvisibleEdges(*args, **kwargs):
        """
        MarkInvisibleEdges(*args, **kwargs)
        Overloaded function.
        
        1. MarkInvisibleEdges(self: MSPyBentleyGeom.PolyfaceHeader, smoothAngle: float, silhouetteVector: MSPyBentleyGeom.DVec3d) -> bool
        
        Mark edges invisible (negative index) if dihedral angle between
        normals is small. If normals are present they are used. If not
        present, per-face normals are computed and used (but then removed)
        
        2. MarkInvisibleEdges(self: MSPyBentleyGeom.PolyfaceHeader, smoothAngle: float) -> bool
        
        Mark edges invisible (negative index) if dihedral angle between
        normals is small. If normals are present they are used. If not
        present, per-face normals are computed and used (but then removed)
        """
        ...
    
    def MarkTopologicalBoundariesVisible(*args, **kwargs):
        """
        MarkTopologicalBoundariesVisible(self: MSPyBentleyGeom.PolyfaceHeader, preserveOtherVisibility: bool) -> bool
        
        Expose topological boundaries
        
        Returns:
        true if any edges were changed.
        """
        ...
    
    @property
    def MediumTolerance(arg0: MSPyBentleyGeom.PolyfaceQuery) -> float:
        ...
    
    def MergeAndCollectVolumes(*args, **kwargs):
        """
        MergeAndCollectVolumes(*args, **kwargs)
        Overloaded function.
        
        1. MergeAndCollectVolumes(meshA: MSPyBentleyGeom.PolyfaceQuery, meshB: MSPyBentleyGeom.PolyfaceQuery, enclosedVolumes: Bentley.Bstdcxx.bvector<Bentley.RefCountedPtr<Bentley.PolyfaceHeader>,Bentley.BentleyAllocator<Bentley.RefCountedPtr<Bentley.PolyfaceHeader> > >) -> None
        
        2. MergeAndCollectVolumes(inputMesh: Bentley.Bstdcxx.bvector<Bentley.RefCountedPtr<Bentley.PolyfaceHeader>,Bentley.BentleyAllocator<Bentley.RefCountedPtr<Bentley.PolyfaceHeader> > >, enclosedVolumes: Bentley.Bstdcxx.bvector<Bentley.RefCountedPtr<Bentley.PolyfaceHeader>,Bentley.BentleyAllocator<Bentley.RefCountedPtr<Bentley.PolyfaceHeader> > >) -> None
        """
        ...
    
    @property
    def MeshStyle(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    def Normal(*args, **kwargs):
        """
        Normal(self: MSPyBentleyGeom.PolyfaceHeader) -> MSPyBentleyGeom.BlockedVectorDVec3d
        
        Return a reference to the normal vector.
        """
        ...
    
    @property
    def NormalCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    def NormalIndex(*args, **kwargs):
        """
        NormalIndex(self: MSPyBentleyGeom.PolyfaceHeader) -> MSPyBentleyGeom.BlockedVectorInt
        
        Return a reference to the normal index vector.
        """
        ...
    
    @property
    def NumPerFace(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    @property
    def NumPerRow(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    class OffsetOptions:
        """
        None
        """
    
        def __init__(self: MSPyBentleyGeom.PolyfaceHeader.OffsetOptions) -> None:
            ...
        
        @property
        def maxAccumulatedAngle(self: MSPyBentleyGeom.PolyfaceHeader.OffsetOptions) -> MSPyBentleyGeom.Angle:
            ...
        @maxAccumulatedAngle.setter
        def maxAccumulatedAngle(self: MSPyBentleyGeom.PolyfaceHeader.OffsetOptions, arg0: MSPyBentleyGeom.Angle) -> None:
            ...
        
        @property
        def maxChamferAngle(self: MSPyBentleyGeom.PolyfaceHeader.OffsetOptions) -> MSPyBentleyGeom.Angle:
            ...
        @maxChamferAngle.setter
        def maxChamferAngle(self: MSPyBentleyGeom.PolyfaceHeader.OffsetOptions, arg0: MSPyBentleyGeom.Angle) -> None:
            ...
        
        @property
        def maxSingleEdgeAngle(self: MSPyBentleyGeom.PolyfaceHeader.OffsetOptions) -> MSPyBentleyGeom.Angle:
            ...
        @maxSingleEdgeAngle.setter
        def maxSingleEdgeAngle(self: MSPyBentleyGeom.PolyfaceHeader.OffsetOptions, arg0: MSPyBentleyGeom.Angle) -> None:
            ...
        
        @property
        def useStoredNormals(self: MSPyBentleyGeom.PolyfaceHeader.OffsetOptions) -> bool:
            ...
        @useStoredNormals.setter
        def useStoredNormals(self: MSPyBentleyGeom.PolyfaceHeader.OffsetOptions, arg0: bool) -> None:
            ...
        
    def OrientAndCollectManifoldComponents(*args, **kwargs):
        """
        OrientAndCollectManifoldComponents(self: MSPyBentleyGeom.PolyfaceHeader, componentReadIncices: MSPyBentley.UInt64VecArray, messages: MSPyBentleyGeom.MeshAnnotationVector) -> bool
        
        [out] arrays of read indices within components [out] array of status
        messages
        """
        ...
    
    def Param(*args, **kwargs):
        """
        Param(self: MSPyBentleyGeom.PolyfaceHeader) -> MSPyBentleyGeom.BlockedVectorDPoint2d
        
        Return a reference to the param (texture space) coordinate vector.
        """
        ...
    
    @property
    def ParamCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    def ParamIndex(*args, **kwargs):
        """
        ParamIndex(self: MSPyBentleyGeom.PolyfaceHeader) -> MSPyBentleyGeom.BlockedVectorInt
        
        Return a reference to the param index vector.
        """
        ...
    
    def ParamRange(*args, **kwargs):
        """
        ParamRange(self: MSPyBentleyGeom.PolyfaceQuery) -> MSPyBentleyGeom.DRange2d
        
        Return range of the parameters.
        """
        ...
    
    def PartitionByConnectivity(*args, **kwargs):
        """
        PartitionByConnectivity(*args, **kwargs)
        Overloaded function.
        
        1. PartitionByConnectivity(self: MSPyBentleyGeom.PolyfaceHeader, connectivityType: int, submeshArray: MSPyBentleyGeom.PolyfaceHeaderPtrArray) -> bool
        
        2. PartitionByConnectivity(self: MSPyBentleyGeom.PolyfaceHeader, connectivityType: int, submeshArray: MSPyBentley.Int64Array) -> bool
        """
        ...
    
    def PartitionByXYRange(*args, **kwargs):
        """
        PartitionByXYRange(*args, **kwargs)
        Overloaded function.
        
        1. PartitionByXYRange(self: MSPyBentleyGeom.PolyfaceHeader, targetFaceCount: int, targetMeshCount: int, submeshArray: MSPyBentleyGeom.PolyfaceHeaderPtrArray) -> bool
        
        2. PartitionByXYRange(self: MSPyBentleyGeom.PolyfaceHeader, targetFaceCount: int, targetMeshCount: int, blockedReadIndexArray: MSPyBentley.Int64Array) -> bool
        """
        ...
    
    def PartitionMaintainFaceOrder(*args, **kwargs):
        """
        PartitionMaintainFaceOrder(*args, **kwargs)
        Overloaded function.
        
        1. PartitionMaintainFaceOrder(self: MSPyBentleyGeom.PolyfaceHeader, targetFaceCount: int, targetMeshCount: int, submeshArray: MSPyBentleyGeom.PolyfaceHeaderPtrArray) -> bool
        
        2. PartitionMaintainFaceOrder(self: MSPyBentleyGeom.PolyfaceHeader, targetFaceCount: int, targetMeshCount: int, blockedReadIndexArray: MSPyBentley.Int64Array) -> bool
        """
        ...
    
    def PartitionReadIndicesByNormal(*args, **kwargs):
        """
        PartitionReadIndicesByNormal(self: MSPyBentleyGeom.PolyfaceHeader, vector: MSPyBentleyGeom.DVec3d, readIndices: MSPyBentley.Int64VecArray) -> bool
        
        Return indices of subsets with consistent forward and reverse
        visibility for given vector.
        
        Parameter ``[in]``:
        vector viewing direction vector
        
        Parameter ``[out]``:
        readIndices read indices for forward, reverse, and perpendicular
        facets
        
        Returns:
        false if vector is 000.
        """
        ...
    
    def PickFacetsByStroke(*args, **kwargs):
        """
        PickFacetsByStroke(self: MSPyBentleyGeom.PolyfaceQuery, eyePoint: MSPyBentleyGeom.DPoint4d, point0: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d, pickDetail: MSPyBentleyGeom.FacetLocationDetailArray, exitAfterFirstPick: bool) -> bool
        
        Search for facets that are touched by a stroke. returns true if valid
        point data and one or more facets selected.
        """
        ...
    
    def PlaneSlice(*args, **kwargs):
        """
        PlaneSlice(self: MSPyBentleyGeom.PolyfaceQuery, sectionPlane: MSPyBentleyGeom.DPlane3d, formRegions: bool, markEdgeFraction: bool = False) -> MSPyBentleyGeom.CurveVector
        
        Cut with a plane. (Prototype) Return as a curve vector. Optionally
        structure as area-bounding loops.
        
        Parameter ``[in]``:
        sectionPlane plane to cut the mesh.
        
        Parameter ``[in]``:
        formRegions true to look for closed loops and structure the return
        as a loop or parity CurveVector.
        
        Parameter ``[in]``:
        markEdgeFractions true to attache FacetEdgeLocationDetailVector to
        the linestrings.
        """
        ...
    
    def Point(*args, **kwargs):
        """
        Point(self: MSPyBentleyGeom.PolyfaceHeader) -> MSPyBentleyGeom.BlockedVectorDPoint3d
        
        Copy all contents to destination vectors Return a reference to the
        point (vertex) coordinate vector.
        """
        ...
    
    @property
    def PointCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    def PointIndex(*args, **kwargs):
        """
        PointIndex(self: MSPyBentleyGeom.PolyfaceHeader) -> MSPyBentleyGeom.BlockedVectorInt
        
        Return a reference to the point (vertex) index vector.
        """
        ...
    
    @property
    def PointIndexCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    def PointRange(*args, **kwargs):
        """
        PointRange(self: MSPyBentleyGeom.PolyfaceQuery) -> MSPyBentleyGeom.DRange3d
        
        Return range of the points.
        """
        ...
    
    def RemoveTwoEdgeFacesFromVariableSizeOneBasedMesh(*args, **kwargs):
        """
        RemoveTwoEdgeFacesFromVariableSizeOneBasedMesh(self: MSPyBentleyGeom.PolyfaceHeader) -> None
        
        Find and remove faces with 2 or fewer edges. This operates only on
        VariableSizeOneBasedMeshes -- caller responsible for converting to
        that if needed.
        """
        ...
    
    def ReplicateMissingIndexArrays(*args, **kwargs):
        """
        ReplicateMissingIndexArrays(self: MSPyBentleyGeom.PolyfaceHeader) -> None
        
        If (1) param, normal, or color indices are missing and (2) their
        respective data arrays have size match with points, fill up the index
        array as duplicate of the pointIndex
        """
        ...
    
    def ReverseIndicesAllFaces(*args, **kwargs):
        """
        ReverseIndicesAllFaces(self: MSPyBentleyGeom.PolyfaceQuery, negateNormals: bool = True, flipMarked: bool = True, flipUnMarked: bool = True, normalIndexAction: MSPyBentleyGeom.BlockedVectorInt.IndexAction = <IndexAction.eNone: 0>) -> bool
        """
        ...
    
    def ReverseIndicesOneFace(*args, **kwargs):
        """
        ReverseIndicesOneFace(self: MSPyBentleyGeom.PolyfaceQuery, iFirst: int, iLast: int, normalArrayIndexAction: MSPyBentleyGeom.BlockedVectorInt.IndexAction = <IndexAction.eNone: 0>) -> None
        
        Reverse a single face loop in parallel index arrays.
        
        Remark:
        s A face loop is reversed after the 1st index:the 2nd/last
        indices are swapped, the 3rd/penultimate indices are swapped, etc.
        
        Parameter ``[in]``:
        iFirst 0-based offset to the first index in the face loop
        
        Parameter ``[in]``:
        iLast 0-based offset to the last index of the face loop.
        
        Parameter ``[in]``:
        normalArrayIndexAction selects action in normal array. This can be
        
        * IndexAction.None -- leave the index value unchanged
        
        * IndexAction.ForcePositive -- change to positive
        
        * IndexAction.ForceNegative -- change to negative
        
        * IndexAction.Negate -- change to negative of its current sign
        """
        ...
    
    def ReverseNormals(*args, **kwargs):
        """
        ReverseNormals(self: MSPyBentleyGeom.PolyfaceHeader) -> None
        
        Reverse (negate) all stored normals. Note that this does NOT change
        index order.
        """
        ...
    
    def SearchClosestApproach(*args, **kwargs):
        """
        SearchClosestApproach(*args, **kwargs)
        Overloaded function.
        
        1. SearchClosestApproach(polyfaceA: MSPyBentleyGeom.PolyfaceQuery, polyfaceB: MSPyBentleyGeom.PolyfaceQuery, maxDistance: float, segment: MSPyBentleyGeom.DSegment3d) -> bool
        
        2. SearchClosestApproach(polyfaceA: MSPyBentleyGeom.PolyfaceQuery, maxDistance: float, segment: MSPyBentleyGeom.DSegment3d, normalTestRadius: float) -> bool
        
        3. SearchClosestApproach(polyfaceA: MSPyBentleyGeom.PolyfaceQuery, maxDistance: float, segment: MSPyBentleyGeom.DSegment3d) -> bool
        """
        ...
    
    def SearchClosestApproachToLinestring(*args, **kwargs):
        """
        SearchClosestApproachToLinestring(polyfaceA: MSPyBentleyGeom.PolyfaceQuery, points: MSPyBentleyGeom.DPoint3dArray, segment: MSPyBentleyGeom.DSegment3d) -> bool
        """
        ...
    
    def SelectBlockedIndices(*args, **kwargs):
        """
        SelectBlockedIndices(blockedReadIndex: MSPyBentley.Int64Array, selectedReadIndex: MSPyBentley.Int64Array, keepIfSelected: bool, blockedReadIndexOut: MSPyBentley.Int64Array) -> None
        
        Copy selected blocks of read indices to a new blocked index array.
        
        Parameter ``[in]``:
        blockedReadIndex Array of read indices with -1 as terminator
        between blocks that are to go to the same destination mesh.
        
        Parameter ``[in]``:
        selectedReadIndex Array of read indices for choosing blocks.
        
        Parameter ``[in]``:
        keepIfSelected indicates what to do with a block when it contains
        an index that is in the selectedReadIndexArray.
        
        * true means when a block contains a selected read index it is copied.
        
        * false means when a block contains a selected read indexc it is
        ignored.
        
        Parameter ``[out]``:
        blockedReadIndexOut array containing only the accepted blocks
        """
        ...
    
    def SelectMeshesByVolumeSign(*args, **kwargs):
        """
        SelectMeshesByVolumeSign(inputVolumes: Bentley.Bstdcxx.bvector<Bentley.RefCountedPtr<Bentley.PolyfaceHeader>,Bentley.BentleyAllocator<Bentley.RefCountedPtr<Bentley.PolyfaceHeader> > >, negativeVolumeMeshes: Bentley.Bstdcxx.bvector<Bentley.RefCountedPtr<Bentley.PolyfaceHeader>,Bentley.BentleyAllocator<Bentley.RefCountedPtr<Bentley.PolyfaceHeader> > >, zeroVolumeMeshes: Bentley.Bstdcxx.bvector<Bentley.RefCountedPtr<Bentley.PolyfaceHeader>,Bentley.BentleyAllocator<Bentley.RefCountedPtr<Bentley.PolyfaceHeader> > >, positiveVolumeMeshes: Bentley.Bstdcxx.bvector<Bentley.RefCountedPtr<Bentley.PolyfaceHeader>,Bentley.BentleyAllocator<Bentley.RefCountedPtr<Bentley.PolyfaceHeader> > >) -> None
        """
        ...
    
    def SetActiveFlagsByAvailableData(*args, **kwargs):
        """
        SetActiveFlagsByAvailableData(self: MSPyBentleyGeom.PolyfaceHeader) -> None
        
        Make each active flag true/false according to available data. Point,
        Normal, Param, DoubleColor, FloatColor, IntColor, and ColorTable,
        FaceIndex, FaceData look only at their own data. Indices look at their
        own size and that of respective indexed arrays.
        """
        ...
    
    def SetIlluminationName(*args, **kwargs):
        """
        SetIlluminationName(self: MSPyBentleyGeom.PolyfaceHeader, name: str) -> None
        
        Set the illumination name string
        """
        ...
    
    def SetMeshStyle(*args, **kwargs):
        """
        SetMeshStyle(self: MSPyBentleyGeom.PolyfaceVectors, meshStyle: int) -> None
        
        Set the facet data style.
        """
        ...
    
    def SetNewFaceData(*args, **kwargs):
        """
        SetNewFaceData(self: MSPyBentleyGeom.PolyfaceHeader, faceData: MSPyBentleyGeom.FacetFaceData, endIndex: int = 0) -> None
        
        Set face data for all facets added since last call to SetNewFaceData.
        (endIndex = 0 for all facets).
        """
        ...
    
    def SetNumPerFace(*args, **kwargs):
        """
        SetNumPerFace(self: MSPyBentleyGeom.PolyfaceVectors, numPerFace: int) -> None
        
        Set the index blocking count
        """
        ...
    
    def SetNumPerRow(*args, **kwargs):
        """
        SetNumPerRow(self: MSPyBentleyGeom.PolyfaceVectors, numPerRow: int) -> None
        
        Set the row count for gridded facets.
        """
        ...
    
    def SetTextureId(*args, **kwargs):
        """
        SetTextureId(self: MSPyBentleyGeom.PolyfaceHeader, id: int) -> None
        
        Set the texture id.
        """
        ...
    
    def SetTwoSided(*args, **kwargs):
        """
        SetTwoSided(self: MSPyBentleyGeom.PolyfaceVectors, twoSided: bool) -> None
        
        Set the flag for twosided facets
        """
        ...
    
    def SplitByFlood(*args, **kwargs):
        """
        SplitByFlood(self: MSPyBentleyGeom.PolyfaceHeader, optionsA: Bentley.FacetSplitByFloodOptions, optionsB: Bentley.FacetSplitByFloodOptions, blockedReadIndexArray: MSPyBentley.Int64VecArray) -> None
        
        Return blocks of read indices for " islands " of facets surrounded by
        " channels " The search process is:
        
        * choose any start facet.
        
        * expand outward from that facet to neighbors.
        
        * repeat the expansion to the level indicated by
        optionsA.m_layerThickness
        
        * treat all facets there as an " A " group.
        
        * expand outward from the fringe of the island by
        optionsB.m_layerThickness layers.
        
        * treat all facets in this (wide front) expansion there as a " B "
        group.
        
        * Seed the next round of " A " facets by a single facet beyond the
        fringe of the recent " B " step.
        
        Note that because the " optionsA " step starts with a single seed (plus
        its expanding layers) it produces compact " islands ". Becasue
        " optionsB " step starts with a wide front of facets it produces larger
        layered regions. The " A " and " B " groups are returned under control of
        the m_outputSelect part of its options.
        
        * m_outputSelect == 0:leave that group out completely.
        
        * m_outputSelect == 1:collect all groups as a single partition.
        
        * m_outputSelect == 2:collect each group as a small isolated
        partition.
        
        * BUT -- if both are zero, both are switched to 1.
        
        Parameter ``[out]``:
        blockedReadIndexArray read indices for individual faces, separated
        by (-1).
        """
        ...
    
    def SplitByMaxEdgeLength(*args, **kwargs):
        """
        SplitByMaxEdgeLength(self: MSPyBentleyGeom.PolyfaceHeader, splitLength: float, splits: MSPyBentleyGeom.PolyfaceHeaderPtrArray) -> bool
        
        * Find the maximum edge length of each facet.
        
        * Split into two sets of facets with that criteria.
        
        * Note that removal can happen anywhere in the mesh.
        
        * use ExcavateFacetsWithBoundaryEdges to remove only edges reachable
        by crossing long edges from a long starting edge on the boundary.
        """
        ...
    
    def SumDirectedAreas(*args, **kwargs):
        """
        SumDirectedAreas(self: MSPyBentleyGeom.PolyfaceQuery, vectorToEye: MSPyBentleyGeom.DVec3d) -> tuple
        """
        ...
    
    def SumDirectedAreasDetailed(*args, **kwargs):
        """
        SumDirectedAreasDetailed(self: MSPyBentleyGeom.PolyfaceQuery, vectorToEye: MSPyBentleyGeom.DVec3d) -> tuple
        """
        ...
    
    def SumFacetAreas(*args, **kwargs):
        """
        SumFacetAreas(self: MSPyBentleyGeom.PolyfaceQuery) -> float
        
        Return the sum of facet areas. There is no check for planarity.
        """
        ...
    
    def SumFacetFirstAreaMoments(*args, **kwargs):
        """
        SumFacetFirstAreaMoments(self: MSPyBentleyGeom.PolyfaceQuery, origin: MSPyBentleyGeom.DPoint3d, moments1: MSPyBentleyGeom.DVec3d) -> float
        
        Return the sum of facet areas. Return moment with respect to origin.
        """
        ...
    
    def SumFacetSecondAreaMomentProducts(*args, **kwargs):
        """
        SumFacetSecondAreaMomentProducts(self: MSPyBentleyGeom.PolyfaceQuery, origin: MSPyBentleyGeom.DPoint3d, products: MSPyBentleyGeom.DMatrix4d) -> float
        
        Return the sum of facet areas. Return moment products with respect to
        origin.
        """
        ...
    
    def SumTetrahedralFirstMoments(*args, **kwargs):
        """
        SumTetrahedralFirstMoments(self: MSPyBentleyGeom.PolyfaceQuery, origin: MSPyBentleyGeom.DPoint3d, moments: MSPyBentleyGeom.DVec3d) -> float
        
        Return the sum of tetrahedral moments from the specified origin. If
        the mesh is closed and all facets are simply connected planar, this is
        the moment around the origin. (The facets and volume are not require
        to be convex.)
        
        Parameter ``[in]``:
        origin origin for tetrahedra.
        
        Parameter ``[out]``:
        moments sum of (x,y,z) dV
        
        Returns:
        summed volume
        """
        ...
    
    def SumTetrahedralMomentProducts(*args, **kwargs):
        """
        SumTetrahedralMomentProducts(self: MSPyBentleyGeom.PolyfaceQuery, worldToLocal: MSPyBentleyGeom.Transform, moment1: MSPyBentleyGeom.DVec3d, products: MSPyBentleyGeom.RotMatrix) -> float
        """
        ...
    
    def SumTetrahedralVolumes(*args, **kwargs):
        """
        SumTetrahedralVolumes(self: MSPyBentleyGeom.PolyfaceQuery, origin: MSPyBentleyGeom.DPoint3d) -> float
        
        Return the sum of tetrahedral volumes from the specified origin. If
        the mesh is closed and all facets are simply connected planar, this is
        the signed enclosed volume. (The facets and volume are not require to
        be convex.)
        """
        ...
    
    def SweepLinestringToMesh(*args, **kwargs):
        """
        SweepLinestringToMesh(self: MSPyBentleyGeom.PolyfaceQuery, xyzOut: MSPyBentleyGeom.DPoint3dArray, linestringIndexOut: MSPyBentley.Int32Array, meshIndexOut: MSPyBentley.Int32Array, linestringPoints: MSPyBentleyGeom.DPoint3dArray, sweepDirection: MSPyBentleyGeom.DVec3d) -> None
        
        @description Compute intersections (line strings) of this mesh with a
        swept linestring
        
        Parameter ``[out]``:
        xyzOut array of points on the intersection linestrings.
        DISCONNECTS separate multiple linestrings.
        
        Parameter ``[out]``:
        linestringIndexOut for each xyzOut[i], the index of the input
        segment that it came from.
        
        Parameter ``[out]``:
        meshIndexOut for each xyzOut[i], the mesh read index it came from.
        
        Parameter ``[in]``:
        linestringPoints points to sweep.
        
        Parameter ``[in]``:
        sweepDirection sweep direction
        """
        ...
    
    def SweepToSolid(*args, **kwargs):
        """
        SweepToSolid(self: MSPyBentleyGeom.PolyfaceHeader, sweepVector: MSPyBentleyGeom.DVec3d, triangulateSides: bool) -> bool
        
        Sweep the existing mesh promote to a solid
        
        Returns:
        false if the input mesh has inconsistent visibility -- i.e. side
        or mixture of forward and back facing facets.
        """
        ...
    
    def TerminateAllActiveIndexVectors(*args, **kwargs):
        """
        TerminateAllActiveIndexVectors(self: MSPyBentleyGeom.PolyfaceHeader) -> None
        
        Add terminator to all active index vectors.
        """
        ...
    
    @property
    def TextureId(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    @property
    def TightTolerance(arg0: MSPyBentleyGeom.PolyfaceQuery) -> float:
        ...
    
    def Transform(*args, **kwargs):
        """
        Transform(self: MSPyBentleyGeom.PolyfaceHeader, transform: MSPyBentleyGeom.Transform, reverseIndicesIfMirrored: bool = True) -> None
        """
        ...
    
    def TranslateSelectedFacets(*args, **kwargs):
        """
        TranslateSelectedFacets(self: MSPyBentleyGeom.PolyfaceHeader, activeReadIndex: MSPyBentley.UInt64Array, vector: MSPyBentleyGeom.DVec3d, mode: MSPyBentleyGeom.PolyfaceHeader.FacetTranslationMode) -> None
        
        Apply a translation to a subset of facets.
        """
        ...
    
    def Triangulate(*args, **kwargs):
        """
        Triangulate(*args, **kwargs)
        Overloaded function.
        
        1. Triangulate(self: MSPyBentleyGeom.PolyfaceHeader) -> Bentley.BentleyStatus
        
        Triangulate faces. return SUCCESS if all faces triangulated.
        
        Remark:
        this should return bool.
        
        2. Triangulate(self: MSPyBentleyGeom.PolyfaceHeader, maxEdge: int) -> bool
        
        Triangulate faces. return SUCCESS if all faces triangulated.
        
        Remark:
        this should return bool.
        
        3. Triangulate(self: MSPyBentleyGeom.PolyfaceHeader, maxEdge: int, hideNewEdges: bool, filter: Bentley.IPolyfaceVisitorFilter) -> bool
        
        Triangulate faces. return SUCCESS if all faces triangulated.
        
        Remark:
        this should return bool.
        """
        ...
    
    def TryEvaluateEdge(*args, **kwargs):
        """
        TryEvaluateEdge(self: MSPyBentleyGeom.PolyfaceQuery, position: MSPyBentleyGeom.FacetEdgeLocationDetail, xyz: MSPyBentleyGeom.DPoint3d) -> bool
        
        Try to convert the index and edge fraction of a
        FacetEdgeLocationDetail to a point.
        """
        ...
    
    def TryGetFacetFaceDataAtReadIndex(*args, **kwargs):
        """
        TryGetFacetFaceDataAtReadIndex(self: MSPyBentleyGeom.PolyfaceQuery, readIndex: int, data: MSPyBentleyGeom.FacetFaceData) -> tuple
        """
        ...
    
    def TryGetMaxSingleFacetLocalXYLength(*args, **kwargs):
        """
        TryGetMaxSingleFacetLocalXYLength(self: MSPyBentleyGeom.PolyfaceHeader, xySize: MSPyBentleyGeom.DVec2d) -> bool
        
        Compute the lengths of the longest horizontal and vertical direction
        size of any single facet, using the local coordinate system along the
        first edge of the facet for directions.
        
        Parameter ``[out]``:
        xySize sizes in u, v directions.
        """
        ...
    
    def TryGetMaxSingleFacetParamLength(*args, **kwargs):
        """
        TryGetMaxSingleFacetParamLength(self: MSPyBentleyGeom.PolyfaceHeader, uvLength: MSPyBentleyGeom.DVec2d) -> bool
        
        Compute the lengths of the longest u and v direction size of any
        single facet, looking only at the stored param.
        
        Parameter ``[out]``:
        uvLength sizes in u, v directions.
        
        Returns:
        false if the facets do not have params
        """
        ...
    
    def TryGetNormalAtReadIndex(*args, **kwargs):
        """
        TryGetNormalAtReadIndex(self: MSPyBentleyGeom.PolyfaceQuery, readIndex: int, data: MSPyBentleyGeom.DVec3d) -> bool
        
        Try to access normal coordinates through a readIndex in the
        normalIndex array.
        """
        ...
    
    def TryGetParamAtReadIndex(*args, **kwargs):
        """
        TryGetParamAtReadIndex(self: MSPyBentleyGeom.PolyfaceQuery, readIndex: int, data: MSPyBentleyGeom.DPoint2d) -> bool
        
        Try to access param coordinates through a readIndex in the paramIndex
        array.
        """
        ...
    
    def TryGetPointAtReadIndex(*args, **kwargs):
        """
        TryGetPointAtReadIndex(self: MSPyBentleyGeom.PolyfaceQuery, readIndex: int, data: MSPyBentleyGeom.DPoint3d) -> bool
        
        Try to access point coordinates through a readIndex in the pointIndex
        array.
        """
        ...
    
    @property
    def TwoSided(arg0: MSPyBentleyGeom.PolyfaceQuery) -> bool:
        ...
    
    def ValidatedVolume(*args, **kwargs):
        """
        ValidatedVolume(self: MSPyBentleyGeom.PolyfaceQuery) -> MSPyBentleyGeom.ValidatedDouble
        
        Test if the mesh passes IsClosedByEdgePairing, and compute volume if
        so.
        """
        ...
    
    def VisibleParts(*args, **kwargs):
        """
        VisibleParts(source: MSPyBentleyGeom.PolyfaceHeaderPtrArray, vectorToEye: MSPyBentleyGeom.DVec3d, dest: MSPyBentleyGeom.PolyfaceHeader, localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform) -> None
        
        Create a polyface containing all visible parts for a flat view of
        among multiple meshes.
        """
        ...
    
    def VolumeFromBoreData(*args, **kwargs):
        """
        VolumeFromBoreData(segments: MSPyBentleyGeom.DSegment3dArray, topFacetReadIndex: MSPyBentley.Int64Array, bottomFacetReadIndex: MSPyBentley.Int64Array, sideFacetReadIndex: MSPyBentley.Int64Array) -> tuple
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    
    eBoth: ComputeSingleSheetOption
    
    eCutMeshOnly: ComputeSingleSheetOption
    
    eFillMeshOnly: ComputeSingleSheetOption
    
    eJustTranslatePoints: FacetTranslationMode
    
    eTranslatePointsAndAddSweepFaces: FacetTranslationMode
    
    eTranslatePointsAndTriangulateFringeFaces: FacetTranslationMode
    
class PolyfaceHeaderPtrArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.PolyfaceHeaderPtrArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.PolyfaceHeaderPtrArray, arg0: MSPyBentleyGeom.PolyfaceHeaderPtrArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.PolyfaceHeaderPtrArray, arg0: Iterable) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.PolyfaceHeaderPtrArray, x: MSPyBentleyGeom.PolyfaceHeader) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.PolyfaceHeaderPtrArray) -> None
        
        Clear the contents
        """
        ...
    
    def count(*args, **kwargs):
        """
        count(self: MSPyBentleyGeom.PolyfaceHeaderPtrArray, x: MSPyBentleyGeom.PolyfaceHeader) -> int
        
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.PolyfaceHeaderPtrArray, L: MSPyBentleyGeom.PolyfaceHeaderPtrArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.PolyfaceHeaderPtrArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.PolyfaceHeaderPtrArray, i: int, x: MSPyBentleyGeom.PolyfaceHeader) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.PolyfaceHeaderPtrArray) -> MSPyBentleyGeom.PolyfaceHeader
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.PolyfaceHeaderPtrArray, i: int) -> MSPyBentleyGeom.PolyfaceHeader
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(*args, **kwargs):
        """
        remove(self: MSPyBentleyGeom.PolyfaceHeaderPtrArray, x: MSPyBentleyGeom.PolyfaceHeader) -> None
        
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class PolyfaceQuery:
    """
    None
    """

    def AddToTaggedPolygons(*args, **kwargs):
        """
        AddToTaggedPolygons(*args, **kwargs)
        Overloaded function.
        
        1. AddToTaggedPolygons(self: MSPyBentleyGeom.PolyfaceQuery, polygons: Bentley.Bstdcxx.bvector<Bentley.TaggedPolygon,Bentley.BentleyAllocator<Bentley.TaggedPolygon> >, indexA: int, numWrap: int, selectRange: MSPyBentleyGeom.DRange3d = None) -> None
        
        2. AddToTaggedPolygons(self: MSPyBentleyGeom.PolyfaceQuery, polygons: Bentley.Bstdcxx.bvector<Bentley.TaggedPolygon,Bentley.BentleyAllocator<Bentley.TaggedPolygon> >, indexA: int, numWrap: int, filer: Bentley.IPolyfaceVisitorFilter) -> None
        """
        ...
    
    def ClipPolyfaceToClipPlanes(*args, **kwargs):
        """
        ClipPolyfaceToClipPlanes(insideClip: Bentley.PolyfaceHeader, outsideClip: Bentley.PolyfaceHeader, targetMesh: MSPyBentleyGeom.PolyfaceQuery, clipPlanes: MSPyBentleyGeom.ClipPlaneSet, formNewFacesOnClipPlanes: bool) -> bool
        """
        ...
    
    def ClipToPlaneSetIntersection(*args, **kwargs):
        """
        ClipToPlaneSetIntersection(self: MSPyBentleyGeom.PolyfaceQuery, planeSets: Bentley.Bstdcxx.bvector<Bentley.ClipPlaneSet,Bentley.BentleyAllocator<Bentley.ClipPlaneSet> >, output: MSPyBentleyGeom.PolyfaceQuery.IClipToPlaneSetOutput, trangulateOutput: bool) -> int
        
        @description Clip polyface to intersection of an array of plane sets.
        """
        ...
    
    def Clone(*args, **kwargs):
        """
        Clone(self: MSPyBentleyGeom.PolyfaceQuery) -> Bentley.PolyfaceHeader
        
        Return a PolyfaceHeader with the same contents.
        """
        ...
    
    def CloneAsVariableSizeIndexed(*args, **kwargs):
        """
        CloneAsVariableSizeIndexed(self: MSPyBentleyGeom.PolyfaceQuery, source: MSPyBentleyGeom.PolyfaceQuery) -> Bentley.PolyfaceHeader
        
        Return a PolyfaceHeader, with variable length faces.
        """
        ...
    
    def ClusteredVertexDecimate(*args, **kwargs):
        """
        ClusteredVertexDecimate(self: MSPyBentleyGeom.PolyfaceQuery, tolerance: float) -> Bentley.PolyfaceHeader
        
        @description Fas clustered vertex decimator - used during tile
        generation.
        """
        ...
    
    def CollectCounts(*args, **kwargs):
        """
        CollectCounts(self: MSPyBentleyGeom.PolyfaceQuery) -> tuple
        """
        ...
    
    def CollectPerFaceCounts(*args, **kwargs):
        """
        CollectPerFaceCounts(self: MSPyBentleyGeom.PolyfaceQuery) -> tuple
        """
        ...
    
    def CollectSegments(*args, **kwargs):
        """
        CollectSegments(self: MSPyBentleyGeom.PolyfaceQuery, segments: MSPyBentleyGeom.DSegment3dArray, omitInvisible: bool) -> None
        
        Collect individual segments for each distinct edge.
        
        Parameter ``[out]``:
        segments array to receive segments.
        
        Parameter ``[in]``:
        omitInvisibles true to hide segments that are not visible (due to
        negated indices)
        """
        ...
    
    @property
    def ColorCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    def ComputeOverAndUnderXY(*args, **kwargs):
        """
        ComputeOverAndUnderXY(polyfaceA: Bentley.PolyfaceHeader, filterA: Bentley.IPolyfaceVisitorFilter, polyfaceB: Bentley.PolyfaceHeader, filterB: Bentley.IPolyfaceVisitorFilter, polyfaceAOverB: Bentley.PolyfaceHeader, polyfaceBUnderA: Bentley.PolyfaceHeader, computeAndApplyTransform: bool = True) -> None
        """
        ...
    
    def ComputePrincipalAreaMoments(*args, **kwargs):
        """
        ComputePrincipalAreaMoments(self: MSPyBentleyGeom.PolyfaceQuery, centroid: MSPyBentleyGeom.DPoint3d, axes: MSPyBentleyGeom.RotMatrix, momentxyz: MSPyBentleyGeom.DVec3d) -> tuple
        """
        ...
    
    def ComputePrincipalMoments(*args, **kwargs):
        """
        ComputePrincipalMoments(self: MSPyBentleyGeom.PolyfaceQuery, centroid: MSPyBentleyGeom.DPoint3d, axes: MSPyBentleyGeom.RotMatrix, momentxyz: MSPyBentleyGeom.DVec3d, forcePositiveVolume: bool = False) -> tuple
        """
        ...
    
    def ComputePrincipalMomentsAllowMissingSideFacets(*args, **kwargs):
        """
        ComputePrincipalMomentsAllowMissingSideFacets(self: MSPyBentleyGeom.PolyfaceQuery, centroid: MSPyBentleyGeom.DPoint3d, axes: MSPyBentleyGeom.RotMatrix, momentxyz: MSPyBentleyGeom.DVec3d, forcePositiveVolume: bool, relativeTolerance: float = 1e-08) -> tuple
        """
        ...
    
    def ComputePunch(*args, **kwargs):
        """
        ComputePunch(punch: MSPyBentleyGeom.PolyfaceQuery, target: MSPyBentleyGeom.PolyfaceQuery, keepInside: bool, result: Bentley.Bstdcxx.bvector<Bentley.RefCountedPtr<Bentley.PolyfaceHeader>,Bentley.BentleyAllocator<Bentley.RefCountedPtr<Bentley.PolyfaceHeader> > >) -> None
        
        @description " Punch " through target polygons.
        
        Parameter ``[in]``:
        punch punch polygons
        
        Parameter ``[in]``:
        target target polygons
        
        Parameter ``[in]``:
        keepInside true to return the target mesh parts that are inside
        the punch, false to return outside parts.
        
        Parameter ``[out]``:
        result punched mesh
        """
        ...
    
    def ComputePunchXYByPlaneSets(*args, **kwargs):
        """
        ComputePunchXYByPlaneSets(punch: MSPyBentleyGeom.PolyfaceQuery, target: MSPyBentleyGeom.PolyfaceQuery, inside: Bentley.PolyfaceHeader, outside: Bentley.PolyfaceHeader, debugMesh: Bentley.PolyfaceHeader = None) -> None
        
        [in] each facet of this is used as a " punch " [in] facets to be split
        by the punch. [out] (target intersect punch) [out] (target outsideOf
        punch) [out] optional meshes for debugging
        """
        ...
    
    def ComputeUndercut(*args, **kwargs):
        """
        ComputeUndercut(polyfaceA: Bentley.PolyfaceHeader, filterA: Bentley.IPolyfaceVisitorFilter, polyfaceB: Bentley.PolyfaceHeader, filterB: Bentley.IPolyfaceVisitorFilter, undercutPolyface: Bentley.PolyfaceHeader) -> None
        
        @description Compute volumes where polyfaceB undercuts polyfaceA
        """
        ...
    
    def CountSharedEdges(*args, **kwargs):
        """
        CountSharedEdges(self: MSPyBentleyGeom.PolyfaceQuery, ignoreSliverFaces: bool) -> tuple
        """
        ...
    
    def DirectionalAreaAndVolume(*args, **kwargs):
        """
        DirectionalAreaAndVolume(self: MSPyBentleyGeom.PolyfaceQuery, origin: MSPyBentleyGeom.DPoint3d, areaXYZ: MSPyBentleyGeom.DVec3d, volumeXYZ: MSPyBentleyGeom.DVec3d, centroidX: MSPyBentleyGeom.DVec3d, centroidY: MSPyBentleyGeom.DVec3d, centroidZ: MSPyBentleyGeom.DVec3d) -> None
        
        Compute areas, centroids, volumes of projections onto principal
        planes.
        """
        ...
    
    def DirectionalVolumeIntegrals(*args, **kwargs):
        """
        DirectionalVolumeIntegrals(self: MSPyBentleyGeom.PolyfaceQuery, polyface: MSPyBentleyGeom.PolyfaceQuery, pData: MSPyBentleyGeom.DirectionalVolumeData, directionalProducts: MSPyBentleyGeom.DMatrix4d, origin: MSPyBentleyGeom.DPoint3d) -> None
        
        @description Compute (many) integrals of volume properties, using
        directional formulas that will give correct results (and confidence
        indicators) when " some " facets are missing
        
        Parameter ``[in]``:
        polyface facets for integration
        
        Parameter ``[out]``:
        pData array (allocated by caller) of various integrals:
        
        * pData[0], pData[1], pData[2] = view along respective axes. Use
        signed area, so result should be zero if all facets are present to
        cancel.
        
        * pData[0], pData[1], pData[2] = view along respective axes. Use
        absolute area, so result should be useful for setting tolerances.
        
        * pData[6] = full 3d area.
        
        Parameter ``[out]``:
        directionalProducts array of products integrals wrt origin.
        Allocated by caller.
        
        Parameter ``[out]``:
        origin origin used for directonal integrals. (Directional
        integrals are " from the principal " planes through this origin.)
        """
        ...
    
    def DrapeLinestring(*args, **kwargs):
        """
        DrapeLinestring(self: MSPyBentleyGeom.PolyfaceQuery, spacePoints: MSPyBentleyGeom.DPoint3dArray, direction: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.CurveVector
        
        Project linestring in given direction to intersection with facets.
        Return as a curve vector.
        
        Parameter ``[in]``:
        spacePoints points to project onto the polyface
        
        Parameter ``[in]``:
        direction direction to project.
        """
        ...
    
    @property
    def EdgeChainCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    def EnsureFloatColor(*args, **kwargs):
        """
        EnsureFloatColor(self: MSPyBentleyGeom.PolyfaceQuery) -> bool
        
        If float colors are not already present, build them from double
        colors. Returns false if the implementing class is read only.
        """
        ...
    
    @property
    def FaceCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    @property
    def FaceIndexCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    def GetColorCount(*args, **kwargs):
        """
        GetColorCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Return the number of colors.
        """
        ...
    
    def GetColorIndexAt(*args, **kwargs):
        """
        GetColorIndexAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int, resolveToDefaults: bool = False) -> tuple
        """
        ...
    
    def GetColorTableAt(*args, **kwargs):
        """
        GetColorTableAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple
        """
        ...
    
    def GetDoubleColorAt(*args, **kwargs):
        """
        GetDoubleColorAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple
        """
        ...
    
    def GetEdgeChainAt(*args, **kwargs):
        """
        GetEdgeChainAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple
        """
        ...
    
    def GetEdgeChainCount(*args, **kwargs):
        """
        GetEdgeChainCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Return the number of edge chains.
        """
        ...
    
    def GetFaceCount(*args, **kwargs):
        """
        GetFaceCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Return the number of faces. Note that this is not a " facet " count --
        many facets can reference the same containing face in the parent
        geometry.
        """
        ...
    
    def GetFaceDataAt(*args, **kwargs):
        """
        GetFaceDataAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple
        """
        ...
    
    def GetFaceIndexAt(*args, **kwargs):
        """
        GetFaceIndexAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int, resolveToDefaults: bool = False) -> tuple
        """
        ...
    
    def GetFaceIndexCount(*args, **kwargs):
        """
        GetFaceIndexCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Return the number of face data indices
        """
        ...
    
    def GetFloatColorAt(*args, **kwargs):
        """
        GetFloatColorAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple
        """
        ...
    
    def GetIlluminationName(*args, **kwargs):
        """
        GetIlluminationName(self: MSPyBentleyGeom.PolyfaceQuery) -> str
        """
        ...
    
    def GetIntColorAt(*args, **kwargs):
        """
        GetIntColorAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple
        """
        ...
    
    def GetMediumTolerance(*args, **kwargs):
        """
        GetMediumTolerance(self: MSPyBentleyGeom.PolyfaceQuery) -> float
        
        Return a tolerance appropriate for medium accuracy calculations (8
        digits relative)
        """
        ...
    
    def GetMeshStyle(*args, **kwargs):
        """
        GetMeshStyle(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Query the mesh style (MESH_ELM_STYLE_INDEXED_FACE_LOOPS etc)
        """
        ...
    
    def GetNormalAt(*args, **kwargs):
        """
        GetNormalAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple
        """
        ...
    
    def GetNormalCount(*args, **kwargs):
        """
        GetNormalCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Return the number of normals.
        """
        ...
    
    def GetNormalIndexAt(*args, **kwargs):
        """
        GetNormalIndexAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int, resolveToDefaults: bool = False) -> tuple
        """
        ...
    
    def GetNumFacet(*args, **kwargs):
        """
        GetNumFacet(self: MSPyBentleyGeom.PolyfaceQuery) -> tuple
        """
        ...
    
    def GetNumPerFace(*args, **kwargs):
        """
        GetNumPerFace(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Query the nominal number of facets per face. If this is 0 or 1, facets
        are variable size and separated by 0 as terminator. If larger the
        indices are blocked (with 0 as pad if needed)
        """
        ...
    
    def GetNumPerRow(*args, **kwargs):
        """
        GetNumPerRow(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Query the row size for gridded mesh (quad or triangular)
        """
        ...
    
    def GetParamAt(*args, **kwargs):
        """
        GetParamAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple
        """
        ...
    
    def GetParamCount(*args, **kwargs):
        """
        GetParamCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Return the number of parameters.
        """
        ...
    
    def GetParamIndexAt(*args, **kwargs):
        """
        GetParamIndexAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int, resolveToDefaults: bool = False) -> tuple
        """
        ...
    
    def GetPointAt(*args, **kwargs):
        """
        GetPointAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple
        """
        ...
    
    def GetPointCount(*args, **kwargs):
        """
        GetPointCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Return the number of points.
        """
        ...
    
    def GetPointIndexAt(*args, **kwargs):
        """
        GetPointIndexAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple
        """
        ...
    
    def GetPointIndexCount(*args, **kwargs):
        """
        GetPointIndexCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Return the number of point indices.
        """
        ...
    
    def GetTextureId(*args, **kwargs):
        """
        GetTextureId(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Return a pointer to contiguous texture id.
        """
        ...
    
    def GetTightTolerance(*args, **kwargs):
        """
        GetTightTolerance(self: MSPyBentleyGeom.PolyfaceQuery) -> float
        
        Return a tolerance appropriate for high accuracy calculations (12 or
        more digits relative)
        """
        ...
    
    def GetTwoSided(*args, **kwargs):
        """
        GetTwoSided(self: MSPyBentleyGeom.PolyfaceQuery) -> bool
        
        Query if facets are considered two sided. (If not, outward normal can
        be used to cull backfaces)
        """
        ...
    
    def HasConvexFacets(*args, **kwargs):
        """
        HasConvexFacets(self: MSPyBentleyGeom.PolyfaceQuery) -> bool
        
        Check convexity
        """
        ...
    
    def HasFacets(*args, **kwargs):
        """
        HasFacets(self: MSPyBentleyGeom.PolyfaceQuery) -> bool
        
        Test if any facets are defined (Specifically, true if the point index
        set is nonempty).
        """
        ...
    
    def HasIndexErrors(*args, **kwargs):
        """
        HasIndexErrors(*args, **kwargs)
        Overloaded function.
        
        1. HasIndexErrors(self: MSPyBentleyGeom.PolyfaceQuery, descripton: MSPyBentleyGeom.MeshAnnotationVector) -> bool
        
        Apply various checks for indexing structure.
        
        Returns:
        true if any errors were found.
        
        2. HasIndexErrors(self: MSPyBentleyGeom.PolyfaceQuery) -> bool
        
        Apply various checks for indexing structure.
        
        Returns:
        true if any errors were found.
        """
        ...
    
    def HealVerticalPanels(*args, **kwargs):
        """
        HealVerticalPanels(polyface: MSPyBentleyGeom.PolyfaceQuery, tryVerticalPanels: bool, trySpaceTriangulation: bool, healedPolyface: Bentley.PolyfaceHeader) -> int
        
        Attempt to heal vertical gaps in a mesh.
        
        Parameter ``[in]``:
        polyface original polyface
        
        Parameter ``[in]``:
        tryVerticalPanels true to seek pure vertical panels
        
        Parameter ``[in]``:
        trySpaceTriangulation true to seek triangulation of any missing
        faces, as viewed from any direction found useful.
        
        Parameter ``[out]``:
        healedPolyface modified polyface. This is NOT constructed if no
        panels can be added.
        
        Returns:
        number of facets added
        """
        ...
    
    class IClipToPlaneSetOutput:
        """
        None
        """
    
        def __init__(*args, **kwargs):
            """
            Initialize self.  See help(type(self)) for accurate signature.
            """
            ...
        
    def InspectFaces(*args, **kwargs):
        """
        InspectFaces(self: MSPyBentleyGeom.PolyfaceQuery) -> tuple
        """
        ...
    
    def IsClosedByEdgePairing(*args, **kwargs):
        """
        IsClosedByEdgePairing(self: MSPyBentleyGeom.PolyfaceQuery) -> bool
        
        Test if vertex indices around faces indicate watertight closure.
        """
        ...
    
    def IsSameStructureAndGeometry(*args, **kwargs):
        """
        IsSameStructureAndGeometry(self: MSPyBentleyGeom.PolyfaceQuery, other: MSPyBentleyGeom.PolyfaceQuery, tolerance: float) -> bool
        
        Test for AlmostEqual () conditions.
        """
        ...
    
    def IsTriangulated(*args, **kwargs):
        """
        IsTriangulated(self: MSPyBentleyGeom.PolyfaceQuery) -> bool
        
        Test if all facets are 3 sided
        """
        ...
    
    def IsVariableSizeIndexed(*args, **kwargs):
        """
        IsVariableSizeIndexed(self: MSPyBentleyGeom.PolyfaceQuery) -> bool
        
        Test if this mesh is vaiable sized indexed.
        """
        ...
    
    def LargestCoordinate(*args, **kwargs):
        """
        LargestCoordinate(self: MSPyBentleyGeom.PolyfaceQuery) -> float
        
        Query largest absolute coordinate
        """
        ...
    
    @property
    def MediumTolerance(arg0: MSPyBentleyGeom.PolyfaceQuery) -> float:
        ...
    
    def MergeAndCollectVolumes(*args, **kwargs):
        """
        MergeAndCollectVolumes(*args, **kwargs)
        Overloaded function.
        
        1. MergeAndCollectVolumes(meshA: MSPyBentleyGeom.PolyfaceQuery, meshB: MSPyBentleyGeom.PolyfaceQuery, enclosedVolumes: Bentley.Bstdcxx.bvector<Bentley.RefCountedPtr<Bentley.PolyfaceHeader>,Bentley.BentleyAllocator<Bentley.RefCountedPtr<Bentley.PolyfaceHeader> > >) -> None
        
        2. MergeAndCollectVolumes(inputMesh: Bentley.Bstdcxx.bvector<Bentley.RefCountedPtr<Bentley.PolyfaceHeader>,Bentley.BentleyAllocator<Bentley.RefCountedPtr<Bentley.PolyfaceHeader> > >, enclosedVolumes: Bentley.Bstdcxx.bvector<Bentley.RefCountedPtr<Bentley.PolyfaceHeader>,Bentley.BentleyAllocator<Bentley.RefCountedPtr<Bentley.PolyfaceHeader> > >) -> None
        """
        ...
    
    @property
    def MeshStyle(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    @property
    def NormalCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    @property
    def NumPerFace(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    @property
    def NumPerRow(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    @property
    def ParamCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    def ParamRange(*args, **kwargs):
        """
        ParamRange(self: MSPyBentleyGeom.PolyfaceQuery) -> MSPyBentleyGeom.DRange2d
        
        Return range of the parameters.
        """
        ...
    
    def PickFacetsByStroke(*args, **kwargs):
        """
        PickFacetsByStroke(self: MSPyBentleyGeom.PolyfaceQuery, eyePoint: MSPyBentleyGeom.DPoint4d, point0: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d, pickDetail: MSPyBentleyGeom.FacetLocationDetailArray, exitAfterFirstPick: bool) -> bool
        
        Search for facets that are touched by a stroke. returns true if valid
        point data and one or more facets selected.
        """
        ...
    
    def PlaneSlice(*args, **kwargs):
        """
        PlaneSlice(self: MSPyBentleyGeom.PolyfaceQuery, sectionPlane: MSPyBentleyGeom.DPlane3d, formRegions: bool, markEdgeFraction: bool = False) -> MSPyBentleyGeom.CurveVector
        
        Cut with a plane. (Prototype) Return as a curve vector. Optionally
        structure as area-bounding loops.
        
        Parameter ``[in]``:
        sectionPlane plane to cut the mesh.
        
        Parameter ``[in]``:
        formRegions true to look for closed loops and structure the return
        as a loop or parity CurveVector.
        
        Parameter ``[in]``:
        markEdgeFractions true to attache FacetEdgeLocationDetailVector to
        the linestrings.
        """
        ...
    
    @property
    def PointCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    @property
    def PointIndexCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    def PointRange(*args, **kwargs):
        """
        PointRange(self: MSPyBentleyGeom.PolyfaceQuery) -> MSPyBentleyGeom.DRange3d
        
        Return range of the points.
        """
        ...
    
    def ReverseIndicesAllFaces(*args, **kwargs):
        """
        ReverseIndicesAllFaces(self: MSPyBentleyGeom.PolyfaceQuery, negateNormals: bool = True, flipMarked: bool = True, flipUnMarked: bool = True, normalIndexAction: MSPyBentleyGeom.BlockedVectorInt.IndexAction = <IndexAction.eNone: 0>) -> bool
        """
        ...
    
    def ReverseIndicesOneFace(*args, **kwargs):
        """
        ReverseIndicesOneFace(self: MSPyBentleyGeom.PolyfaceQuery, iFirst: int, iLast: int, normalArrayIndexAction: MSPyBentleyGeom.BlockedVectorInt.IndexAction = <IndexAction.eNone: 0>) -> None
        
        Reverse a single face loop in parallel index arrays.
        
        Remark:
        s A face loop is reversed after the 1st index:the 2nd/last
        indices are swapped, the 3rd/penultimate indices are swapped, etc.
        
        Parameter ``[in]``:
        iFirst 0-based offset to the first index in the face loop
        
        Parameter ``[in]``:
        iLast 0-based offset to the last index of the face loop.
        
        Parameter ``[in]``:
        normalArrayIndexAction selects action in normal array. This can be
        
        * IndexAction.None -- leave the index value unchanged
        
        * IndexAction.ForcePositive -- change to positive
        
        * IndexAction.ForceNegative -- change to negative
        
        * IndexAction.Negate -- change to negative of its current sign
        """
        ...
    
    def SearchClosestApproach(*args, **kwargs):
        """
        SearchClosestApproach(*args, **kwargs)
        Overloaded function.
        
        1. SearchClosestApproach(polyfaceA: MSPyBentleyGeom.PolyfaceQuery, polyfaceB: MSPyBentleyGeom.PolyfaceQuery, maxDistance: float, segment: MSPyBentleyGeom.DSegment3d) -> bool
        
        2. SearchClosestApproach(polyfaceA: MSPyBentleyGeom.PolyfaceQuery, maxDistance: float, segment: MSPyBentleyGeom.DSegment3d, normalTestRadius: float) -> bool
        
        3. SearchClosestApproach(polyfaceA: MSPyBentleyGeom.PolyfaceQuery, maxDistance: float, segment: MSPyBentleyGeom.DSegment3d) -> bool
        """
        ...
    
    def SearchClosestApproachToLinestring(*args, **kwargs):
        """
        SearchClosestApproachToLinestring(polyfaceA: MSPyBentleyGeom.PolyfaceQuery, points: MSPyBentleyGeom.DPoint3dArray, segment: MSPyBentleyGeom.DSegment3d) -> bool
        """
        ...
    
    def SelectMeshesByVolumeSign(*args, **kwargs):
        """
        SelectMeshesByVolumeSign(inputVolumes: Bentley.Bstdcxx.bvector<Bentley.RefCountedPtr<Bentley.PolyfaceHeader>,Bentley.BentleyAllocator<Bentley.RefCountedPtr<Bentley.PolyfaceHeader> > >, negativeVolumeMeshes: Bentley.Bstdcxx.bvector<Bentley.RefCountedPtr<Bentley.PolyfaceHeader>,Bentley.BentleyAllocator<Bentley.RefCountedPtr<Bentley.PolyfaceHeader> > >, zeroVolumeMeshes: Bentley.Bstdcxx.bvector<Bentley.RefCountedPtr<Bentley.PolyfaceHeader>,Bentley.BentleyAllocator<Bentley.RefCountedPtr<Bentley.PolyfaceHeader> > >, positiveVolumeMeshes: Bentley.Bstdcxx.bvector<Bentley.RefCountedPtr<Bentley.PolyfaceHeader>,Bentley.BentleyAllocator<Bentley.RefCountedPtr<Bentley.PolyfaceHeader> > >) -> None
        """
        ...
    
    def SumDirectedAreas(*args, **kwargs):
        """
        SumDirectedAreas(self: MSPyBentleyGeom.PolyfaceQuery, vectorToEye: MSPyBentleyGeom.DVec3d) -> tuple
        """
        ...
    
    def SumDirectedAreasDetailed(*args, **kwargs):
        """
        SumDirectedAreasDetailed(self: MSPyBentleyGeom.PolyfaceQuery, vectorToEye: MSPyBentleyGeom.DVec3d) -> tuple
        """
        ...
    
    def SumFacetAreas(*args, **kwargs):
        """
        SumFacetAreas(self: MSPyBentleyGeom.PolyfaceQuery) -> float
        
        Return the sum of facet areas. There is no check for planarity.
        """
        ...
    
    def SumFacetFirstAreaMoments(*args, **kwargs):
        """
        SumFacetFirstAreaMoments(self: MSPyBentleyGeom.PolyfaceQuery, origin: MSPyBentleyGeom.DPoint3d, moments1: MSPyBentleyGeom.DVec3d) -> float
        
        Return the sum of facet areas. Return moment with respect to origin.
        """
        ...
    
    def SumFacetSecondAreaMomentProducts(*args, **kwargs):
        """
        SumFacetSecondAreaMomentProducts(self: MSPyBentleyGeom.PolyfaceQuery, origin: MSPyBentleyGeom.DPoint3d, products: MSPyBentleyGeom.DMatrix4d) -> float
        
        Return the sum of facet areas. Return moment products with respect to
        origin.
        """
        ...
    
    def SumTetrahedralFirstMoments(*args, **kwargs):
        """
        SumTetrahedralFirstMoments(self: MSPyBentleyGeom.PolyfaceQuery, origin: MSPyBentleyGeom.DPoint3d, moments: MSPyBentleyGeom.DVec3d) -> float
        
        Return the sum of tetrahedral moments from the specified origin. If
        the mesh is closed and all facets are simply connected planar, this is
        the moment around the origin. (The facets and volume are not require
        to be convex.)
        
        Parameter ``[in]``:
        origin origin for tetrahedra.
        
        Parameter ``[out]``:
        moments sum of (x,y,z) dV
        
        Returns:
        summed volume
        """
        ...
    
    def SumTetrahedralMomentProducts(*args, **kwargs):
        """
        SumTetrahedralMomentProducts(self: MSPyBentleyGeom.PolyfaceQuery, worldToLocal: MSPyBentleyGeom.Transform, moment1: MSPyBentleyGeom.DVec3d, products: MSPyBentleyGeom.RotMatrix) -> float
        """
        ...
    
    def SumTetrahedralVolumes(*args, **kwargs):
        """
        SumTetrahedralVolumes(self: MSPyBentleyGeom.PolyfaceQuery, origin: MSPyBentleyGeom.DPoint3d) -> float
        
        Return the sum of tetrahedral volumes from the specified origin. If
        the mesh is closed and all facets are simply connected planar, this is
        the signed enclosed volume. (The facets and volume are not require to
        be convex.)
        """
        ...
    
    def SweepLinestringToMesh(*args, **kwargs):
        """
        SweepLinestringToMesh(self: MSPyBentleyGeom.PolyfaceQuery, xyzOut: MSPyBentleyGeom.DPoint3dArray, linestringIndexOut: MSPyBentley.Int32Array, meshIndexOut: MSPyBentley.Int32Array, linestringPoints: MSPyBentleyGeom.DPoint3dArray, sweepDirection: MSPyBentleyGeom.DVec3d) -> None
        
        @description Compute intersections (line strings) of this mesh with a
        swept linestring
        
        Parameter ``[out]``:
        xyzOut array of points on the intersection linestrings.
        DISCONNECTS separate multiple linestrings.
        
        Parameter ``[out]``:
        linestringIndexOut for each xyzOut[i], the index of the input
        segment that it came from.
        
        Parameter ``[out]``:
        meshIndexOut for each xyzOut[i], the mesh read index it came from.
        
        Parameter ``[in]``:
        linestringPoints points to sweep.
        
        Parameter ``[in]``:
        sweepDirection sweep direction
        """
        ...
    
    @property
    def TextureId(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    @property
    def TightTolerance(arg0: MSPyBentleyGeom.PolyfaceQuery) -> float:
        ...
    
    def TryEvaluateEdge(*args, **kwargs):
        """
        TryEvaluateEdge(self: MSPyBentleyGeom.PolyfaceQuery, position: MSPyBentleyGeom.FacetEdgeLocationDetail, xyz: MSPyBentleyGeom.DPoint3d) -> bool
        
        Try to convert the index and edge fraction of a
        FacetEdgeLocationDetail to a point.
        """
        ...
    
    def TryGetFacetFaceDataAtReadIndex(*args, **kwargs):
        """
        TryGetFacetFaceDataAtReadIndex(self: MSPyBentleyGeom.PolyfaceQuery, readIndex: int, data: MSPyBentleyGeom.FacetFaceData) -> tuple
        """
        ...
    
    def TryGetNormalAtReadIndex(*args, **kwargs):
        """
        TryGetNormalAtReadIndex(self: MSPyBentleyGeom.PolyfaceQuery, readIndex: int, data: MSPyBentleyGeom.DVec3d) -> bool
        
        Try to access normal coordinates through a readIndex in the
        normalIndex array.
        """
        ...
    
    def TryGetParamAtReadIndex(*args, **kwargs):
        """
        TryGetParamAtReadIndex(self: MSPyBentleyGeom.PolyfaceQuery, readIndex: int, data: MSPyBentleyGeom.DPoint2d) -> bool
        
        Try to access param coordinates through a readIndex in the paramIndex
        array.
        """
        ...
    
    def TryGetPointAtReadIndex(*args, **kwargs):
        """
        TryGetPointAtReadIndex(self: MSPyBentleyGeom.PolyfaceQuery, readIndex: int, data: MSPyBentleyGeom.DPoint3d) -> bool
        
        Try to access point coordinates through a readIndex in the pointIndex
        array.
        """
        ...
    
    @property
    def TwoSided(arg0: MSPyBentleyGeom.PolyfaceQuery) -> bool:
        ...
    
    def ValidatedVolume(*args, **kwargs):
        """
        ValidatedVolume(self: MSPyBentleyGeom.PolyfaceQuery) -> MSPyBentleyGeom.ValidatedDouble
        
        Test if the mesh passes IsClosedByEdgePairing, and compute volume if
        so.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    
class PolyfaceQueryCarrier:
    """
    None
    """

    def AddToTaggedPolygons(*args, **kwargs):
        """
        AddToTaggedPolygons(*args, **kwargs)
        Overloaded function.
        
        1. AddToTaggedPolygons(self: MSPyBentleyGeom.PolyfaceQuery, polygons: Bentley.Bstdcxx.bvector<Bentley.TaggedPolygon,Bentley.BentleyAllocator<Bentley.TaggedPolygon> >, indexA: int, numWrap: int, selectRange: MSPyBentleyGeom.DRange3d = None) -> None
        
        2. AddToTaggedPolygons(self: MSPyBentleyGeom.PolyfaceQuery, polygons: Bentley.Bstdcxx.bvector<Bentley.TaggedPolygon,Bentley.BentleyAllocator<Bentley.TaggedPolygon> >, indexA: int, numWrap: int, filer: Bentley.IPolyfaceVisitorFilter) -> None
        """
        ...
    
    def ClipPolyfaceToClipPlanes(*args, **kwargs):
        """
        ClipPolyfaceToClipPlanes(insideClip: Bentley.PolyfaceHeader, outsideClip: Bentley.PolyfaceHeader, targetMesh: MSPyBentleyGeom.PolyfaceQuery, clipPlanes: MSPyBentleyGeom.ClipPlaneSet, formNewFacesOnClipPlanes: bool) -> bool
        """
        ...
    
    def ClipToPlaneSetIntersection(*args, **kwargs):
        """
        ClipToPlaneSetIntersection(self: MSPyBentleyGeom.PolyfaceQuery, planeSets: Bentley.Bstdcxx.bvector<Bentley.ClipPlaneSet,Bentley.BentleyAllocator<Bentley.ClipPlaneSet> >, output: MSPyBentleyGeom.PolyfaceQuery.IClipToPlaneSetOutput, trangulateOutput: bool) -> int
        
        @description Clip polyface to intersection of an array of plane sets.
        """
        ...
    
    def Clone(*args, **kwargs):
        """
        Clone(self: MSPyBentleyGeom.PolyfaceQuery) -> Bentley.PolyfaceHeader
        
        Return a PolyfaceHeader with the same contents.
        """
        ...
    
    def CloneAsVariableSizeIndexed(*args, **kwargs):
        """
        CloneAsVariableSizeIndexed(self: MSPyBentleyGeom.PolyfaceQuery, source: MSPyBentleyGeom.PolyfaceQuery) -> Bentley.PolyfaceHeader
        
        Return a PolyfaceHeader, with variable length faces.
        """
        ...
    
    def ClusteredVertexDecimate(*args, **kwargs):
        """
        ClusteredVertexDecimate(self: MSPyBentleyGeom.PolyfaceQuery, tolerance: float) -> Bentley.PolyfaceHeader
        
        @description Fas clustered vertex decimator - used during tile
        generation.
        """
        ...
    
    def CollectCounts(*args, **kwargs):
        """
        CollectCounts(self: MSPyBentleyGeom.PolyfaceQuery) -> tuple
        """
        ...
    
    def CollectPerFaceCounts(*args, **kwargs):
        """
        CollectPerFaceCounts(self: MSPyBentleyGeom.PolyfaceQuery) -> tuple
        """
        ...
    
    def CollectSegments(*args, **kwargs):
        """
        CollectSegments(self: MSPyBentleyGeom.PolyfaceQuery, segments: MSPyBentleyGeom.DSegment3dArray, omitInvisible: bool) -> None
        
        Collect individual segments for each distinct edge.
        
        Parameter ``[out]``:
        segments array to receive segments.
        
        Parameter ``[in]``:
        omitInvisibles true to hide segments that are not visible (due to
        negated indices)
        """
        ...
    
    @property
    def ColorCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    def ComputeOverAndUnderXY(*args, **kwargs):
        """
        ComputeOverAndUnderXY(polyfaceA: Bentley.PolyfaceHeader, filterA: Bentley.IPolyfaceVisitorFilter, polyfaceB: Bentley.PolyfaceHeader, filterB: Bentley.IPolyfaceVisitorFilter, polyfaceAOverB: Bentley.PolyfaceHeader, polyfaceBUnderA: Bentley.PolyfaceHeader, computeAndApplyTransform: bool = True) -> None
        """
        ...
    
    def ComputePrincipalAreaMoments(*args, **kwargs):
        """
        ComputePrincipalAreaMoments(self: MSPyBentleyGeom.PolyfaceQuery, centroid: MSPyBentleyGeom.DPoint3d, axes: MSPyBentleyGeom.RotMatrix, momentxyz: MSPyBentleyGeom.DVec3d) -> tuple
        """
        ...
    
    def ComputePrincipalMoments(*args, **kwargs):
        """
        ComputePrincipalMoments(self: MSPyBentleyGeom.PolyfaceQuery, centroid: MSPyBentleyGeom.DPoint3d, axes: MSPyBentleyGeom.RotMatrix, momentxyz: MSPyBentleyGeom.DVec3d, forcePositiveVolume: bool = False) -> tuple
        """
        ...
    
    def ComputePrincipalMomentsAllowMissingSideFacets(*args, **kwargs):
        """
        ComputePrincipalMomentsAllowMissingSideFacets(self: MSPyBentleyGeom.PolyfaceQuery, centroid: MSPyBentleyGeom.DPoint3d, axes: MSPyBentleyGeom.RotMatrix, momentxyz: MSPyBentleyGeom.DVec3d, forcePositiveVolume: bool, relativeTolerance: float = 1e-08) -> tuple
        """
        ...
    
    def ComputePunch(*args, **kwargs):
        """
        ComputePunch(punch: MSPyBentleyGeom.PolyfaceQuery, target: MSPyBentleyGeom.PolyfaceQuery, keepInside: bool, result: Bentley.Bstdcxx.bvector<Bentley.RefCountedPtr<Bentley.PolyfaceHeader>,Bentley.BentleyAllocator<Bentley.RefCountedPtr<Bentley.PolyfaceHeader> > >) -> None
        
        @description " Punch " through target polygons.
        
        Parameter ``[in]``:
        punch punch polygons
        
        Parameter ``[in]``:
        target target polygons
        
        Parameter ``[in]``:
        keepInside true to return the target mesh parts that are inside
        the punch, false to return outside parts.
        
        Parameter ``[out]``:
        result punched mesh
        """
        ...
    
    def ComputePunchXYByPlaneSets(*args, **kwargs):
        """
        ComputePunchXYByPlaneSets(punch: MSPyBentleyGeom.PolyfaceQuery, target: MSPyBentleyGeom.PolyfaceQuery, inside: Bentley.PolyfaceHeader, outside: Bentley.PolyfaceHeader, debugMesh: Bentley.PolyfaceHeader = None) -> None
        
        [in] each facet of this is used as a " punch " [in] facets to be split
        by the punch. [out] (target intersect punch) [out] (target outsideOf
        punch) [out] optional meshes for debugging
        """
        ...
    
    def ComputeUndercut(*args, **kwargs):
        """
        ComputeUndercut(polyfaceA: Bentley.PolyfaceHeader, filterA: Bentley.IPolyfaceVisitorFilter, polyfaceB: Bentley.PolyfaceHeader, filterB: Bentley.IPolyfaceVisitorFilter, undercutPolyface: Bentley.PolyfaceHeader) -> None
        
        @description Compute volumes where polyfaceB undercuts polyfaceA
        """
        ...
    
    def CountSharedEdges(*args, **kwargs):
        """
        CountSharedEdges(self: MSPyBentleyGeom.PolyfaceQuery, ignoreSliverFaces: bool) -> tuple
        """
        ...
    
    def DirectionalAreaAndVolume(*args, **kwargs):
        """
        DirectionalAreaAndVolume(self: MSPyBentleyGeom.PolyfaceQuery, origin: MSPyBentleyGeom.DPoint3d, areaXYZ: MSPyBentleyGeom.DVec3d, volumeXYZ: MSPyBentleyGeom.DVec3d, centroidX: MSPyBentleyGeom.DVec3d, centroidY: MSPyBentleyGeom.DVec3d, centroidZ: MSPyBentleyGeom.DVec3d) -> None
        
        Compute areas, centroids, volumes of projections onto principal
        planes.
        """
        ...
    
    def DirectionalVolumeIntegrals(*args, **kwargs):
        """
        DirectionalVolumeIntegrals(self: MSPyBentleyGeom.PolyfaceQuery, polyface: MSPyBentleyGeom.PolyfaceQuery, pData: MSPyBentleyGeom.DirectionalVolumeData, directionalProducts: MSPyBentleyGeom.DMatrix4d, origin: MSPyBentleyGeom.DPoint3d) -> None
        
        @description Compute (many) integrals of volume properties, using
        directional formulas that will give correct results (and confidence
        indicators) when " some " facets are missing
        
        Parameter ``[in]``:
        polyface facets for integration
        
        Parameter ``[out]``:
        pData array (allocated by caller) of various integrals:
        
        * pData[0], pData[1], pData[2] = view along respective axes. Use
        signed area, so result should be zero if all facets are present to
        cancel.
        
        * pData[0], pData[1], pData[2] = view along respective axes. Use
        absolute area, so result should be useful for setting tolerances.
        
        * pData[6] = full 3d area.
        
        Parameter ``[out]``:
        directionalProducts array of products integrals wrt origin.
        Allocated by caller.
        
        Parameter ``[out]``:
        origin origin used for directonal integrals. (Directional
        integrals are " from the principal " planes through this origin.)
        """
        ...
    
    def DrapeLinestring(*args, **kwargs):
        """
        DrapeLinestring(self: MSPyBentleyGeom.PolyfaceQuery, spacePoints: MSPyBentleyGeom.DPoint3dArray, direction: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.CurveVector
        
        Project linestring in given direction to intersection with facets.
        Return as a curve vector.
        
        Parameter ``[in]``:
        spacePoints points to project onto the polyface
        
        Parameter ``[in]``:
        direction direction to project.
        """
        ...
    
    @property
    def EdgeChainCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    def EnsureFloatColor(*args, **kwargs):
        """
        EnsureFloatColor(self: MSPyBentleyGeom.PolyfaceQuery) -> bool
        
        If float colors are not already present, build them from double
        colors. Returns false if the implementing class is read only.
        """
        ...
    
    @property
    def FaceCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    @property
    def FaceIndexCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    def GetColorCount(*args, **kwargs):
        """
        GetColorCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Return the number of colors.
        """
        ...
    
    def GetColorIndexAt(*args, **kwargs):
        """
        GetColorIndexAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int, resolveToDefaults: bool = False) -> tuple
        """
        ...
    
    def GetColorTableAt(*args, **kwargs):
        """
        GetColorTableAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple
        """
        ...
    
    def GetDoubleColorAt(*args, **kwargs):
        """
        GetDoubleColorAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple
        """
        ...
    
    def GetEdgeChainAt(*args, **kwargs):
        """
        GetEdgeChainAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple
        """
        ...
    
    def GetEdgeChainCount(*args, **kwargs):
        """
        GetEdgeChainCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Return the number of edge chains.
        """
        ...
    
    def GetFaceCount(*args, **kwargs):
        """
        GetFaceCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Return the number of faces. Note that this is not a " facet " count --
        many facets can reference the same containing face in the parent
        geometry.
        """
        ...
    
    def GetFaceDataAt(*args, **kwargs):
        """
        GetFaceDataAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple
        """
        ...
    
    def GetFaceIndexAt(*args, **kwargs):
        """
        GetFaceIndexAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int, resolveToDefaults: bool = False) -> tuple
        """
        ...
    
    def GetFaceIndexCount(*args, **kwargs):
        """
        GetFaceIndexCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Return the number of face data indices
        """
        ...
    
    def GetFloatColorAt(*args, **kwargs):
        """
        GetFloatColorAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple
        """
        ...
    
    def GetIlluminationName(*args, **kwargs):
        """
        GetIlluminationName(self: MSPyBentleyGeom.PolyfaceQuery) -> str
        """
        ...
    
    def GetIntColorAt(*args, **kwargs):
        """
        GetIntColorAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple
        """
        ...
    
    def GetMediumTolerance(*args, **kwargs):
        """
        GetMediumTolerance(self: MSPyBentleyGeom.PolyfaceQuery) -> float
        
        Return a tolerance appropriate for medium accuracy calculations (8
        digits relative)
        """
        ...
    
    def GetMeshStyle(*args, **kwargs):
        """
        GetMeshStyle(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Query the mesh style (MESH_ELM_STYLE_INDEXED_FACE_LOOPS etc)
        """
        ...
    
    def GetNormalAt(*args, **kwargs):
        """
        GetNormalAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple
        """
        ...
    
    def GetNormalCount(*args, **kwargs):
        """
        GetNormalCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Return the number of normals.
        """
        ...
    
    def GetNormalIndexAt(*args, **kwargs):
        """
        GetNormalIndexAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int, resolveToDefaults: bool = False) -> tuple
        """
        ...
    
    def GetNumFacet(*args, **kwargs):
        """
        GetNumFacet(self: MSPyBentleyGeom.PolyfaceQuery) -> tuple
        """
        ...
    
    def GetNumPerFace(*args, **kwargs):
        """
        GetNumPerFace(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Query the nominal number of facets per face. If this is 0 or 1, facets
        are variable size and separated by 0 as terminator. If larger the
        indices are blocked (with 0 as pad if needed)
        """
        ...
    
    def GetNumPerRow(*args, **kwargs):
        """
        GetNumPerRow(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Query the row size for gridded mesh (quad or triangular)
        """
        ...
    
    def GetParamAt(*args, **kwargs):
        """
        GetParamAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple
        """
        ...
    
    def GetParamCount(*args, **kwargs):
        """
        GetParamCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Return the number of parameters.
        """
        ...
    
    def GetParamIndexAt(*args, **kwargs):
        """
        GetParamIndexAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int, resolveToDefaults: bool = False) -> tuple
        """
        ...
    
    def GetPointAt(*args, **kwargs):
        """
        GetPointAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple
        """
        ...
    
    def GetPointCount(*args, **kwargs):
        """
        GetPointCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Return the number of points.
        """
        ...
    
    def GetPointIndexAt(*args, **kwargs):
        """
        GetPointIndexAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple
        """
        ...
    
    def GetPointIndexCount(*args, **kwargs):
        """
        GetPointIndexCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Return the number of point indices.
        """
        ...
    
    def GetTextureId(*args, **kwargs):
        """
        GetTextureId(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Return a pointer to contiguous texture id.
        """
        ...
    
    def GetTightTolerance(*args, **kwargs):
        """
        GetTightTolerance(self: MSPyBentleyGeom.PolyfaceQuery) -> float
        
        Return a tolerance appropriate for high accuracy calculations (12 or
        more digits relative)
        """
        ...
    
    def GetTwoSided(*args, **kwargs):
        """
        GetTwoSided(self: MSPyBentleyGeom.PolyfaceQuery) -> bool
        
        Query if facets are considered two sided. (If not, outward normal can
        be used to cull backfaces)
        """
        ...
    
    def HasConvexFacets(*args, **kwargs):
        """
        HasConvexFacets(self: MSPyBentleyGeom.PolyfaceQuery) -> bool
        
        Check convexity
        """
        ...
    
    def HasFacets(*args, **kwargs):
        """
        HasFacets(self: MSPyBentleyGeom.PolyfaceQuery) -> bool
        
        Test if any facets are defined (Specifically, true if the point index
        set is nonempty).
        """
        ...
    
    def HasIndexErrors(*args, **kwargs):
        """
        HasIndexErrors(*args, **kwargs)
        Overloaded function.
        
        1. HasIndexErrors(self: MSPyBentleyGeom.PolyfaceQuery, descripton: MSPyBentleyGeom.MeshAnnotationVector) -> bool
        
        Apply various checks for indexing structure.
        
        Returns:
        true if any errors were found.
        
        2. HasIndexErrors(self: MSPyBentleyGeom.PolyfaceQuery) -> bool
        
        Apply various checks for indexing structure.
        
        Returns:
        true if any errors were found.
        """
        ...
    
    def HealVerticalPanels(*args, **kwargs):
        """
        HealVerticalPanels(polyface: MSPyBentleyGeom.PolyfaceQuery, tryVerticalPanels: bool, trySpaceTriangulation: bool, healedPolyface: Bentley.PolyfaceHeader) -> int
        
        Attempt to heal vertical gaps in a mesh.
        
        Parameter ``[in]``:
        polyface original polyface
        
        Parameter ``[in]``:
        tryVerticalPanels true to seek pure vertical panels
        
        Parameter ``[in]``:
        trySpaceTriangulation true to seek triangulation of any missing
        faces, as viewed from any direction found useful.
        
        Parameter ``[out]``:
        healedPolyface modified polyface. This is NOT constructed if no
        panels can be added.
        
        Returns:
        number of facets added
        """
        ...
    
    class IClipToPlaneSetOutput:
        """
        None
        """
    
        def __init__(*args, **kwargs):
            """
            Initialize self.  See help(type(self)) for accurate signature.
            """
            ...
        
    def InspectFaces(*args, **kwargs):
        """
        InspectFaces(self: MSPyBentleyGeom.PolyfaceQuery) -> tuple
        """
        ...
    
    def IsClosedByEdgePairing(*args, **kwargs):
        """
        IsClosedByEdgePairing(self: MSPyBentleyGeom.PolyfaceQuery) -> bool
        
        Test if vertex indices around faces indicate watertight closure.
        """
        ...
    
    def IsSameStructureAndGeometry(*args, **kwargs):
        """
        IsSameStructureAndGeometry(self: MSPyBentleyGeom.PolyfaceQuery, other: MSPyBentleyGeom.PolyfaceQuery, tolerance: float) -> bool
        
        Test for AlmostEqual () conditions.
        """
        ...
    
    def IsTriangulated(*args, **kwargs):
        """
        IsTriangulated(self: MSPyBentleyGeom.PolyfaceQuery) -> bool
        
        Test if all facets are 3 sided
        """
        ...
    
    def IsVariableSizeIndexed(*args, **kwargs):
        """
        IsVariableSizeIndexed(self: MSPyBentleyGeom.PolyfaceQuery) -> bool
        
        Test if this mesh is vaiable sized indexed.
        """
        ...
    
    def LargestCoordinate(*args, **kwargs):
        """
        LargestCoordinate(self: MSPyBentleyGeom.PolyfaceQuery) -> float
        
        Query largest absolute coordinate
        """
        ...
    
    @property
    def MediumTolerance(arg0: MSPyBentleyGeom.PolyfaceQuery) -> float:
        ...
    
    def MergeAndCollectVolumes(*args, **kwargs):
        """
        MergeAndCollectVolumes(*args, **kwargs)
        Overloaded function.
        
        1. MergeAndCollectVolumes(meshA: MSPyBentleyGeom.PolyfaceQuery, meshB: MSPyBentleyGeom.PolyfaceQuery, enclosedVolumes: Bentley.Bstdcxx.bvector<Bentley.RefCountedPtr<Bentley.PolyfaceHeader>,Bentley.BentleyAllocator<Bentley.RefCountedPtr<Bentley.PolyfaceHeader> > >) -> None
        
        2. MergeAndCollectVolumes(inputMesh: Bentley.Bstdcxx.bvector<Bentley.RefCountedPtr<Bentley.PolyfaceHeader>,Bentley.BentleyAllocator<Bentley.RefCountedPtr<Bentley.PolyfaceHeader> > >, enclosedVolumes: Bentley.Bstdcxx.bvector<Bentley.RefCountedPtr<Bentley.PolyfaceHeader>,Bentley.BentleyAllocator<Bentley.RefCountedPtr<Bentley.PolyfaceHeader> > >) -> None
        """
        ...
    
    @property
    def MeshStyle(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    @property
    def NormalCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    @property
    def NumPerFace(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    @property
    def NumPerRow(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    @property
    def ParamCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    def ParamRange(*args, **kwargs):
        """
        ParamRange(self: MSPyBentleyGeom.PolyfaceQuery) -> MSPyBentleyGeom.DRange2d
        
        Return range of the parameters.
        """
        ...
    
    def PickFacetsByStroke(*args, **kwargs):
        """
        PickFacetsByStroke(self: MSPyBentleyGeom.PolyfaceQuery, eyePoint: MSPyBentleyGeom.DPoint4d, point0: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d, pickDetail: MSPyBentleyGeom.FacetLocationDetailArray, exitAfterFirstPick: bool) -> bool
        
        Search for facets that are touched by a stroke. returns true if valid
        point data and one or more facets selected.
        """
        ...
    
    def PlaneSlice(*args, **kwargs):
        """
        PlaneSlice(self: MSPyBentleyGeom.PolyfaceQuery, sectionPlane: MSPyBentleyGeom.DPlane3d, formRegions: bool, markEdgeFraction: bool = False) -> MSPyBentleyGeom.CurveVector
        
        Cut with a plane. (Prototype) Return as a curve vector. Optionally
        structure as area-bounding loops.
        
        Parameter ``[in]``:
        sectionPlane plane to cut the mesh.
        
        Parameter ``[in]``:
        formRegions true to look for closed loops and structure the return
        as a loop or parity CurveVector.
        
        Parameter ``[in]``:
        markEdgeFractions true to attache FacetEdgeLocationDetailVector to
        the linestrings.
        """
        ...
    
    @property
    def PointCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    @property
    def PointIndexCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    def PointRange(*args, **kwargs):
        """
        PointRange(self: MSPyBentleyGeom.PolyfaceQuery) -> MSPyBentleyGeom.DRange3d
        
        Return range of the points.
        """
        ...
    
    def ReverseIndicesAllFaces(*args, **kwargs):
        """
        ReverseIndicesAllFaces(self: MSPyBentleyGeom.PolyfaceQuery, negateNormals: bool = True, flipMarked: bool = True, flipUnMarked: bool = True, normalIndexAction: MSPyBentleyGeom.BlockedVectorInt.IndexAction = <IndexAction.eNone: 0>) -> bool
        """
        ...
    
    def ReverseIndicesOneFace(*args, **kwargs):
        """
        ReverseIndicesOneFace(self: MSPyBentleyGeom.PolyfaceQuery, iFirst: int, iLast: int, normalArrayIndexAction: MSPyBentleyGeom.BlockedVectorInt.IndexAction = <IndexAction.eNone: 0>) -> None
        
        Reverse a single face loop in parallel index arrays.
        
        Remark:
        s A face loop is reversed after the 1st index:the 2nd/last
        indices are swapped, the 3rd/penultimate indices are swapped, etc.
        
        Parameter ``[in]``:
        iFirst 0-based offset to the first index in the face loop
        
        Parameter ``[in]``:
        iLast 0-based offset to the last index of the face loop.
        
        Parameter ``[in]``:
        normalArrayIndexAction selects action in normal array. This can be
        
        * IndexAction.None -- leave the index value unchanged
        
        * IndexAction.ForcePositive -- change to positive
        
        * IndexAction.ForceNegative -- change to negative
        
        * IndexAction.Negate -- change to negative of its current sign
        """
        ...
    
    def SearchClosestApproach(*args, **kwargs):
        """
        SearchClosestApproach(*args, **kwargs)
        Overloaded function.
        
        1. SearchClosestApproach(polyfaceA: MSPyBentleyGeom.PolyfaceQuery, polyfaceB: MSPyBentleyGeom.PolyfaceQuery, maxDistance: float, segment: MSPyBentleyGeom.DSegment3d) -> bool
        
        2. SearchClosestApproach(polyfaceA: MSPyBentleyGeom.PolyfaceQuery, maxDistance: float, segment: MSPyBentleyGeom.DSegment3d, normalTestRadius: float) -> bool
        
        3. SearchClosestApproach(polyfaceA: MSPyBentleyGeom.PolyfaceQuery, maxDistance: float, segment: MSPyBentleyGeom.DSegment3d) -> bool
        """
        ...
    
    def SearchClosestApproachToLinestring(*args, **kwargs):
        """
        SearchClosestApproachToLinestring(polyfaceA: MSPyBentleyGeom.PolyfaceQuery, points: MSPyBentleyGeom.DPoint3dArray, segment: MSPyBentleyGeom.DSegment3d) -> bool
        """
        ...
    
    def SelectMeshesByVolumeSign(*args, **kwargs):
        """
        SelectMeshesByVolumeSign(inputVolumes: Bentley.Bstdcxx.bvector<Bentley.RefCountedPtr<Bentley.PolyfaceHeader>,Bentley.BentleyAllocator<Bentley.RefCountedPtr<Bentley.PolyfaceHeader> > >, negativeVolumeMeshes: Bentley.Bstdcxx.bvector<Bentley.RefCountedPtr<Bentley.PolyfaceHeader>,Bentley.BentleyAllocator<Bentley.RefCountedPtr<Bentley.PolyfaceHeader> > >, zeroVolumeMeshes: Bentley.Bstdcxx.bvector<Bentley.RefCountedPtr<Bentley.PolyfaceHeader>,Bentley.BentleyAllocator<Bentley.RefCountedPtr<Bentley.PolyfaceHeader> > >, positiveVolumeMeshes: Bentley.Bstdcxx.bvector<Bentley.RefCountedPtr<Bentley.PolyfaceHeader>,Bentley.BentleyAllocator<Bentley.RefCountedPtr<Bentley.PolyfaceHeader> > >) -> None
        """
        ...
    
    def SumDirectedAreas(*args, **kwargs):
        """
        SumDirectedAreas(self: MSPyBentleyGeom.PolyfaceQuery, vectorToEye: MSPyBentleyGeom.DVec3d) -> tuple
        """
        ...
    
    def SumDirectedAreasDetailed(*args, **kwargs):
        """
        SumDirectedAreasDetailed(self: MSPyBentleyGeom.PolyfaceQuery, vectorToEye: MSPyBentleyGeom.DVec3d) -> tuple
        """
        ...
    
    def SumFacetAreas(*args, **kwargs):
        """
        SumFacetAreas(self: MSPyBentleyGeom.PolyfaceQuery) -> float
        
        Return the sum of facet areas. There is no check for planarity.
        """
        ...
    
    def SumFacetFirstAreaMoments(*args, **kwargs):
        """
        SumFacetFirstAreaMoments(self: MSPyBentleyGeom.PolyfaceQuery, origin: MSPyBentleyGeom.DPoint3d, moments1: MSPyBentleyGeom.DVec3d) -> float
        
        Return the sum of facet areas. Return moment with respect to origin.
        """
        ...
    
    def SumFacetSecondAreaMomentProducts(*args, **kwargs):
        """
        SumFacetSecondAreaMomentProducts(self: MSPyBentleyGeom.PolyfaceQuery, origin: MSPyBentleyGeom.DPoint3d, products: MSPyBentleyGeom.DMatrix4d) -> float
        
        Return the sum of facet areas. Return moment products with respect to
        origin.
        """
        ...
    
    def SumTetrahedralFirstMoments(*args, **kwargs):
        """
        SumTetrahedralFirstMoments(self: MSPyBentleyGeom.PolyfaceQuery, origin: MSPyBentleyGeom.DPoint3d, moments: MSPyBentleyGeom.DVec3d) -> float
        
        Return the sum of tetrahedral moments from the specified origin. If
        the mesh is closed and all facets are simply connected planar, this is
        the moment around the origin. (The facets and volume are not require
        to be convex.)
        
        Parameter ``[in]``:
        origin origin for tetrahedra.
        
        Parameter ``[out]``:
        moments sum of (x,y,z) dV
        
        Returns:
        summed volume
        """
        ...
    
    def SumTetrahedralMomentProducts(*args, **kwargs):
        """
        SumTetrahedralMomentProducts(self: MSPyBentleyGeom.PolyfaceQuery, worldToLocal: MSPyBentleyGeom.Transform, moment1: MSPyBentleyGeom.DVec3d, products: MSPyBentleyGeom.RotMatrix) -> float
        """
        ...
    
    def SumTetrahedralVolumes(*args, **kwargs):
        """
        SumTetrahedralVolumes(self: MSPyBentleyGeom.PolyfaceQuery, origin: MSPyBentleyGeom.DPoint3d) -> float
        
        Return the sum of tetrahedral volumes from the specified origin. If
        the mesh is closed and all facets are simply connected planar, this is
        the signed enclosed volume. (The facets and volume are not require to
        be convex.)
        """
        ...
    
    def SweepLinestringToMesh(*args, **kwargs):
        """
        SweepLinestringToMesh(self: MSPyBentleyGeom.PolyfaceQuery, xyzOut: MSPyBentleyGeom.DPoint3dArray, linestringIndexOut: MSPyBentley.Int32Array, meshIndexOut: MSPyBentley.Int32Array, linestringPoints: MSPyBentleyGeom.DPoint3dArray, sweepDirection: MSPyBentleyGeom.DVec3d) -> None
        
        @description Compute intersections (line strings) of this mesh with a
        swept linestring
        
        Parameter ``[out]``:
        xyzOut array of points on the intersection linestrings.
        DISCONNECTS separate multiple linestrings.
        
        Parameter ``[out]``:
        linestringIndexOut for each xyzOut[i], the index of the input
        segment that it came from.
        
        Parameter ``[out]``:
        meshIndexOut for each xyzOut[i], the mesh read index it came from.
        
        Parameter ``[in]``:
        linestringPoints points to sweep.
        
        Parameter ``[in]``:
        sweepDirection sweep direction
        """
        ...
    
    @property
    def TextureId(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    @property
    def TightTolerance(arg0: MSPyBentleyGeom.PolyfaceQuery) -> float:
        ...
    
    def TryEvaluateEdge(*args, **kwargs):
        """
        TryEvaluateEdge(self: MSPyBentleyGeom.PolyfaceQuery, position: MSPyBentleyGeom.FacetEdgeLocationDetail, xyz: MSPyBentleyGeom.DPoint3d) -> bool
        
        Try to convert the index and edge fraction of a
        FacetEdgeLocationDetail to a point.
        """
        ...
    
    def TryGetFacetFaceDataAtReadIndex(*args, **kwargs):
        """
        TryGetFacetFaceDataAtReadIndex(self: MSPyBentleyGeom.PolyfaceQuery, readIndex: int, data: MSPyBentleyGeom.FacetFaceData) -> tuple
        """
        ...
    
    def TryGetNormalAtReadIndex(*args, **kwargs):
        """
        TryGetNormalAtReadIndex(self: MSPyBentleyGeom.PolyfaceQuery, readIndex: int, data: MSPyBentleyGeom.DVec3d) -> bool
        
        Try to access normal coordinates through a readIndex in the
        normalIndex array.
        """
        ...
    
    def TryGetParamAtReadIndex(*args, **kwargs):
        """
        TryGetParamAtReadIndex(self: MSPyBentleyGeom.PolyfaceQuery, readIndex: int, data: MSPyBentleyGeom.DPoint2d) -> bool
        
        Try to access param coordinates through a readIndex in the paramIndex
        array.
        """
        ...
    
    def TryGetPointAtReadIndex(*args, **kwargs):
        """
        TryGetPointAtReadIndex(self: MSPyBentleyGeom.PolyfaceQuery, readIndex: int, data: MSPyBentleyGeom.DPoint3d) -> bool
        
        Try to access point coordinates through a readIndex in the pointIndex
        array.
        """
        ...
    
    @property
    def TwoSided(arg0: MSPyBentleyGeom.PolyfaceQuery) -> bool:
        ...
    
    def ValidatedVolume(*args, **kwargs):
        """
        ValidatedVolume(self: MSPyBentleyGeom.PolyfaceQuery) -> MSPyBentleyGeom.ValidatedDouble
        
        Test if the mesh passes IsClosedByEdgePairing, and compute volume if
        so.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    
class PolyfaceVectors:
    """
    None
    """

    def AddToTaggedPolygons(*args, **kwargs):
        """
        AddToTaggedPolygons(*args, **kwargs)
        Overloaded function.
        
        1. AddToTaggedPolygons(self: MSPyBentleyGeom.PolyfaceQuery, polygons: Bentley.Bstdcxx.bvector<Bentley.TaggedPolygon,Bentley.BentleyAllocator<Bentley.TaggedPolygon> >, indexA: int, numWrap: int, selectRange: MSPyBentleyGeom.DRange3d = None) -> None
        
        2. AddToTaggedPolygons(self: MSPyBentleyGeom.PolyfaceQuery, polygons: Bentley.Bstdcxx.bvector<Bentley.TaggedPolygon,Bentley.BentleyAllocator<Bentley.TaggedPolygon> >, indexA: int, numWrap: int, filer: Bentley.IPolyfaceVisitorFilter) -> None
        """
        ...
    
    def ClearAllArrays(*args, **kwargs):
        """
        ClearAllArrays(self: MSPyBentleyGeom.PolyfaceVectors) -> None
        
        clear all arrays (but flags stay unchanged)
        """
        ...
    
    def ClipPolyfaceToClipPlanes(*args, **kwargs):
        """
        ClipPolyfaceToClipPlanes(insideClip: Bentley.PolyfaceHeader, outsideClip: Bentley.PolyfaceHeader, targetMesh: MSPyBentleyGeom.PolyfaceQuery, clipPlanes: MSPyBentleyGeom.ClipPlaneSet, formNewFacesOnClipPlanes: bool) -> bool
        """
        ...
    
    def ClipToPlaneSetIntersection(*args, **kwargs):
        """
        ClipToPlaneSetIntersection(self: MSPyBentleyGeom.PolyfaceQuery, planeSets: Bentley.Bstdcxx.bvector<Bentley.ClipPlaneSet,Bentley.BentleyAllocator<Bentley.ClipPlaneSet> >, output: MSPyBentleyGeom.PolyfaceQuery.IClipToPlaneSetOutput, trangulateOutput: bool) -> int
        
        @description Clip polyface to intersection of an array of plane sets.
        """
        ...
    
    def Clone(*args, **kwargs):
        """
        Clone(self: MSPyBentleyGeom.PolyfaceQuery) -> Bentley.PolyfaceHeader
        
        Return a PolyfaceHeader with the same contents.
        """
        ...
    
    def CloneAsVariableSizeIndexed(*args, **kwargs):
        """
        CloneAsVariableSizeIndexed(self: MSPyBentleyGeom.PolyfaceQuery, source: MSPyBentleyGeom.PolyfaceQuery) -> Bentley.PolyfaceHeader
        
        Return a PolyfaceHeader, with variable length faces.
        """
        ...
    
    def ClusteredVertexDecimate(*args, **kwargs):
        """
        ClusteredVertexDecimate(self: MSPyBentleyGeom.PolyfaceQuery, tolerance: float) -> Bentley.PolyfaceHeader
        
        @description Fas clustered vertex decimator - used during tile
        generation.
        """
        ...
    
    def CollectCounts(*args, **kwargs):
        """
        CollectCounts(self: MSPyBentleyGeom.PolyfaceQuery) -> tuple
        """
        ...
    
    def CollectPerFaceCounts(*args, **kwargs):
        """
        CollectPerFaceCounts(self: MSPyBentleyGeom.PolyfaceQuery) -> tuple
        """
        ...
    
    def CollectSegments(*args, **kwargs):
        """
        CollectSegments(self: MSPyBentleyGeom.PolyfaceQuery, segments: MSPyBentleyGeom.DSegment3dArray, omitInvisible: bool) -> None
        
        Collect individual segments for each distinct edge.
        
        Parameter ``[out]``:
        segments array to receive segments.
        
        Parameter ``[in]``:
        omitInvisibles true to hide segments that are not visible (due to
        negated indices)
        """
        ...
    
    @property
    def ColorCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    def ComputeOverAndUnderXY(*args, **kwargs):
        """
        ComputeOverAndUnderXY(polyfaceA: Bentley.PolyfaceHeader, filterA: Bentley.IPolyfaceVisitorFilter, polyfaceB: Bentley.PolyfaceHeader, filterB: Bentley.IPolyfaceVisitorFilter, polyfaceAOverB: Bentley.PolyfaceHeader, polyfaceBUnderA: Bentley.PolyfaceHeader, computeAndApplyTransform: bool = True) -> None
        """
        ...
    
    def ComputePrincipalAreaMoments(*args, **kwargs):
        """
        ComputePrincipalAreaMoments(self: MSPyBentleyGeom.PolyfaceQuery, centroid: MSPyBentleyGeom.DPoint3d, axes: MSPyBentleyGeom.RotMatrix, momentxyz: MSPyBentleyGeom.DVec3d) -> tuple
        """
        ...
    
    def ComputePrincipalMoments(*args, **kwargs):
        """
        ComputePrincipalMoments(self: MSPyBentleyGeom.PolyfaceQuery, centroid: MSPyBentleyGeom.DPoint3d, axes: MSPyBentleyGeom.RotMatrix, momentxyz: MSPyBentleyGeom.DVec3d, forcePositiveVolume: bool = False) -> tuple
        """
        ...
    
    def ComputePrincipalMomentsAllowMissingSideFacets(*args, **kwargs):
        """
        ComputePrincipalMomentsAllowMissingSideFacets(self: MSPyBentleyGeom.PolyfaceQuery, centroid: MSPyBentleyGeom.DPoint3d, axes: MSPyBentleyGeom.RotMatrix, momentxyz: MSPyBentleyGeom.DVec3d, forcePositiveVolume: bool, relativeTolerance: float = 1e-08) -> tuple
        """
        ...
    
    def ComputePunch(*args, **kwargs):
        """
        ComputePunch(punch: MSPyBentleyGeom.PolyfaceQuery, target: MSPyBentleyGeom.PolyfaceQuery, keepInside: bool, result: Bentley.Bstdcxx.bvector<Bentley.RefCountedPtr<Bentley.PolyfaceHeader>,Bentley.BentleyAllocator<Bentley.RefCountedPtr<Bentley.PolyfaceHeader> > >) -> None
        
        @description " Punch " through target polygons.
        
        Parameter ``[in]``:
        punch punch polygons
        
        Parameter ``[in]``:
        target target polygons
        
        Parameter ``[in]``:
        keepInside true to return the target mesh parts that are inside
        the punch, false to return outside parts.
        
        Parameter ``[out]``:
        result punched mesh
        """
        ...
    
    def ComputePunchXYByPlaneSets(*args, **kwargs):
        """
        ComputePunchXYByPlaneSets(punch: MSPyBentleyGeom.PolyfaceQuery, target: MSPyBentleyGeom.PolyfaceQuery, inside: Bentley.PolyfaceHeader, outside: Bentley.PolyfaceHeader, debugMesh: Bentley.PolyfaceHeader = None) -> None
        
        [in] each facet of this is used as a " punch " [in] facets to be split
        by the punch. [out] (target intersect punch) [out] (target outsideOf
        punch) [out] optional meshes for debugging
        """
        ...
    
    def ComputeUndercut(*args, **kwargs):
        """
        ComputeUndercut(polyfaceA: Bentley.PolyfaceHeader, filterA: Bentley.IPolyfaceVisitorFilter, polyfaceB: Bentley.PolyfaceHeader, filterB: Bentley.IPolyfaceVisitorFilter, undercutPolyface: Bentley.PolyfaceHeader) -> None
        
        @description Compute volumes where polyfaceB undercuts polyfaceA
        """
        ...
    
    def CopyAllActiveFlagsFrom(*args, **kwargs):
        """
        CopyAllActiveFlagsFrom(self: MSPyBentleyGeom.PolyfaceVectors, source: MSPyBentleyGeom.PolyfaceVectors) -> None
        
        Copy active flags from the various arrays of the source.
        """
        ...
    
    def CopyAllActiveFlagsFromQuery(*args, **kwargs):
        """
        CopyAllActiveFlagsFromQuery(self: MSPyBentleyGeom.PolyfaceVectors, source: MSPyBentleyGeom.PolyfaceQuery) -> None
        
        In PolyfaceQuery, determine active status from pointers. This is only
        valid if the PolyfaceQuery has already been filled !!!
        """
        ...
    
    def CountSharedEdges(*args, **kwargs):
        """
        CountSharedEdges(self: MSPyBentleyGeom.PolyfaceQuery, ignoreSliverFaces: bool) -> tuple
        """
        ...
    
    def DirectionalAreaAndVolume(*args, **kwargs):
        """
        DirectionalAreaAndVolume(self: MSPyBentleyGeom.PolyfaceQuery, origin: MSPyBentleyGeom.DPoint3d, areaXYZ: MSPyBentleyGeom.DVec3d, volumeXYZ: MSPyBentleyGeom.DVec3d, centroidX: MSPyBentleyGeom.DVec3d, centroidY: MSPyBentleyGeom.DVec3d, centroidZ: MSPyBentleyGeom.DVec3d) -> None
        
        Compute areas, centroids, volumes of projections onto principal
        planes.
        """
        ...
    
    def DirectionalVolumeIntegrals(*args, **kwargs):
        """
        DirectionalVolumeIntegrals(self: MSPyBentleyGeom.PolyfaceQuery, polyface: MSPyBentleyGeom.PolyfaceQuery, pData: MSPyBentleyGeom.DirectionalVolumeData, directionalProducts: MSPyBentleyGeom.DMatrix4d, origin: MSPyBentleyGeom.DPoint3d) -> None
        
        @description Compute (many) integrals of volume properties, using
        directional formulas that will give correct results (and confidence
        indicators) when " some " facets are missing
        
        Parameter ``[in]``:
        polyface facets for integration
        
        Parameter ``[out]``:
        pData array (allocated by caller) of various integrals:
        
        * pData[0], pData[1], pData[2] = view along respective axes. Use
        signed area, so result should be zero if all facets are present to
        cancel.
        
        * pData[0], pData[1], pData[2] = view along respective axes. Use
        absolute area, so result should be useful for setting tolerances.
        
        * pData[6] = full 3d area.
        
        Parameter ``[out]``:
        directionalProducts array of products integrals wrt origin.
        Allocated by caller.
        
        Parameter ``[out]``:
        origin origin used for directonal integrals. (Directional
        integrals are " from the principal " planes through this origin.)
        """
        ...
    
    def DrapeLinestring(*args, **kwargs):
        """
        DrapeLinestring(self: MSPyBentleyGeom.PolyfaceQuery, spacePoints: MSPyBentleyGeom.DPoint3dArray, direction: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.CurveVector
        
        Project linestring in given direction to intersection with facets.
        Return as a curve vector.
        
        Parameter ``[in]``:
        spacePoints points to project onto the polyface
        
        Parameter ``[in]``:
        direction direction to project.
        """
        ...
    
    @property
    def EdgeChainCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    def EnsureFloatColor(*args, **kwargs):
        """
        EnsureFloatColor(self: MSPyBentleyGeom.PolyfaceQuery) -> bool
        
        If float colors are not already present, build them from double
        colors. Returns false if the implementing class is read only.
        """
        ...
    
    @property
    def FaceCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    @property
    def FaceIndexCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    def FindOrAddColorTable(*args, **kwargs):
        """
        FindOrAddColorTable(self: MSPyBentleyGeom.PolyfaceVectors, tableIndex: int) -> int
        
        Find or add a color table. * Activate if needed. * This is a linear
        search !
        """
        ...
    
    def GetColorCount(*args, **kwargs):
        """
        GetColorCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Return the number of colors.
        """
        ...
    
    def GetColorIndexAt(*args, **kwargs):
        """
        GetColorIndexAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int, resolveToDefaults: bool = False) -> tuple
        """
        ...
    
    def GetColorTableAt(*args, **kwargs):
        """
        GetColorTableAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple
        """
        ...
    
    def GetDoubleColorAt(*args, **kwargs):
        """
        GetDoubleColorAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple
        """
        ...
    
    def GetEdgeChainAt(*args, **kwargs):
        """
        GetEdgeChainAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple
        """
        ...
    
    def GetEdgeChainCount(*args, **kwargs):
        """
        GetEdgeChainCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Return the number of edge chains.
        """
        ...
    
    def GetFaceCount(*args, **kwargs):
        """
        GetFaceCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Return the number of faces. Note that this is not a " facet " count --
        many facets can reference the same containing face in the parent
        geometry.
        """
        ...
    
    def GetFaceDataAt(*args, **kwargs):
        """
        GetFaceDataAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple
        """
        ...
    
    def GetFaceIndexAt(*args, **kwargs):
        """
        GetFaceIndexAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int, resolveToDefaults: bool = False) -> tuple
        """
        ...
    
    def GetFaceIndexCount(*args, **kwargs):
        """
        GetFaceIndexCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Return the number of face data indices
        """
        ...
    
    def GetFloatColorAt(*args, **kwargs):
        """
        GetFloatColorAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple
        """
        ...
    
    def GetIlluminationName(*args, **kwargs):
        """
        GetIlluminationName(self: MSPyBentleyGeom.PolyfaceQuery) -> str
        """
        ...
    
    def GetIntColorAt(*args, **kwargs):
        """
        GetIntColorAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple
        """
        ...
    
    def GetMediumTolerance(*args, **kwargs):
        """
        GetMediumTolerance(self: MSPyBentleyGeom.PolyfaceQuery) -> float
        
        Return a tolerance appropriate for medium accuracy calculations (8
        digits relative)
        """
        ...
    
    def GetMeshStyle(*args, **kwargs):
        """
        GetMeshStyle(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Query the mesh style (MESH_ELM_STYLE_INDEXED_FACE_LOOPS etc)
        """
        ...
    
    def GetNormalAt(*args, **kwargs):
        """
        GetNormalAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple
        """
        ...
    
    def GetNormalCount(*args, **kwargs):
        """
        GetNormalCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Return the number of normals.
        """
        ...
    
    def GetNormalIndexAt(*args, **kwargs):
        """
        GetNormalIndexAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int, resolveToDefaults: bool = False) -> tuple
        """
        ...
    
    def GetNumFacet(*args, **kwargs):
        """
        GetNumFacet(self: MSPyBentleyGeom.PolyfaceQuery) -> tuple
        """
        ...
    
    def GetNumPerFace(*args, **kwargs):
        """
        GetNumPerFace(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Query the nominal number of facets per face. If this is 0 or 1, facets
        are variable size and separated by 0 as terminator. If larger the
        indices are blocked (with 0 as pad if needed)
        """
        ...
    
    def GetNumPerRow(*args, **kwargs):
        """
        GetNumPerRow(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Query the row size for gridded mesh (quad or triangular)
        """
        ...
    
    def GetParamAt(*args, **kwargs):
        """
        GetParamAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple
        """
        ...
    
    def GetParamCount(*args, **kwargs):
        """
        GetParamCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Return the number of parameters.
        """
        ...
    
    def GetParamIndexAt(*args, **kwargs):
        """
        GetParamIndexAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int, resolveToDefaults: bool = False) -> tuple
        """
        ...
    
    def GetPointAt(*args, **kwargs):
        """
        GetPointAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple
        """
        ...
    
    def GetPointCount(*args, **kwargs):
        """
        GetPointCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Return the number of points.
        """
        ...
    
    def GetPointIndexAt(*args, **kwargs):
        """
        GetPointIndexAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple
        """
        ...
    
    def GetPointIndexCount(*args, **kwargs):
        """
        GetPointIndexCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Return the number of point indices.
        """
        ...
    
    def GetTextureId(*args, **kwargs):
        """
        GetTextureId(self: MSPyBentleyGeom.PolyfaceQuery) -> int
        
        Return a pointer to contiguous texture id.
        """
        ...
    
    def GetTightTolerance(*args, **kwargs):
        """
        GetTightTolerance(self: MSPyBentleyGeom.PolyfaceQuery) -> float
        
        Return a tolerance appropriate for high accuracy calculations (12 or
        more digits relative)
        """
        ...
    
    def GetTwoSided(*args, **kwargs):
        """
        GetTwoSided(self: MSPyBentleyGeom.PolyfaceQuery) -> bool
        
        Query if facets are considered two sided. (If not, outward normal can
        be used to cull backfaces)
        """
        ...
    
    def HasConvexFacets(*args, **kwargs):
        """
        HasConvexFacets(self: MSPyBentleyGeom.PolyfaceQuery) -> bool
        
        Check convexity
        """
        ...
    
    def HasFacets(*args, **kwargs):
        """
        HasFacets(self: MSPyBentleyGeom.PolyfaceQuery) -> bool
        
        Test if any facets are defined (Specifically, true if the point index
        set is nonempty).
        """
        ...
    
    def HasIndexErrors(*args, **kwargs):
        """
        HasIndexErrors(*args, **kwargs)
        Overloaded function.
        
        1. HasIndexErrors(self: MSPyBentleyGeom.PolyfaceQuery, descripton: MSPyBentleyGeom.MeshAnnotationVector) -> bool
        
        Apply various checks for indexing structure.
        
        Returns:
        true if any errors were found.
        
        2. HasIndexErrors(self: MSPyBentleyGeom.PolyfaceQuery) -> bool
        
        Apply various checks for indexing structure.
        
        Returns:
        true if any errors were found.
        """
        ...
    
    def HealVerticalPanels(*args, **kwargs):
        """
        HealVerticalPanels(polyface: MSPyBentleyGeom.PolyfaceQuery, tryVerticalPanels: bool, trySpaceTriangulation: bool, healedPolyface: Bentley.PolyfaceHeader) -> int
        
        Attempt to heal vertical gaps in a mesh.
        
        Parameter ``[in]``:
        polyface original polyface
        
        Parameter ``[in]``:
        tryVerticalPanels true to seek pure vertical panels
        
        Parameter ``[in]``:
        trySpaceTriangulation true to seek triangulation of any missing
        faces, as viewed from any direction found useful.
        
        Parameter ``[out]``:
        healedPolyface modified polyface. This is NOT constructed if no
        panels can be added.
        
        Returns:
        number of facets added
        """
        ...
    
    class IClipToPlaneSetOutput:
        """
        None
        """
    
        def __init__(*args, **kwargs):
            """
            Initialize self.  See help(type(self)) for accurate signature.
            """
            ...
        
    def InspectFaces(*args, **kwargs):
        """
        InspectFaces(self: MSPyBentleyGeom.PolyfaceQuery) -> tuple
        """
        ...
    
    def IsClosedByEdgePairing(*args, **kwargs):
        """
        IsClosedByEdgePairing(self: MSPyBentleyGeom.PolyfaceQuery) -> bool
        
        Test if vertex indices around faces indicate watertight closure.
        """
        ...
    
    def IsSameStructureAndGeometry(*args, **kwargs):
        """
        IsSameStructureAndGeometry(self: MSPyBentleyGeom.PolyfaceQuery, other: MSPyBentleyGeom.PolyfaceQuery, tolerance: float) -> bool
        
        Test for AlmostEqual () conditions.
        """
        ...
    
    def IsTriangulated(*args, **kwargs):
        """
        IsTriangulated(self: MSPyBentleyGeom.PolyfaceQuery) -> bool
        
        Test if all facets are 3 sided
        """
        ...
    
    def IsVariableSizeIndexed(*args, **kwargs):
        """
        IsVariableSizeIndexed(self: MSPyBentleyGeom.PolyfaceQuery) -> bool
        
        Test if this mesh is vaiable sized indexed.
        """
        ...
    
    def LargestCoordinate(*args, **kwargs):
        """
        LargestCoordinate(self: MSPyBentleyGeom.PolyfaceQuery) -> float
        
        Query largest absolute coordinate
        """
        ...
    
    @property
    def MediumTolerance(arg0: MSPyBentleyGeom.PolyfaceQuery) -> float:
        ...
    
    def MergeAndCollectVolumes(*args, **kwargs):
        """
        MergeAndCollectVolumes(*args, **kwargs)
        Overloaded function.
        
        1. MergeAndCollectVolumes(meshA: MSPyBentleyGeom.PolyfaceQuery, meshB: MSPyBentleyGeom.PolyfaceQuery, enclosedVolumes: Bentley.Bstdcxx.bvector<Bentley.RefCountedPtr<Bentley.PolyfaceHeader>,Bentley.BentleyAllocator<Bentley.RefCountedPtr<Bentley.PolyfaceHeader> > >) -> None
        
        2. MergeAndCollectVolumes(inputMesh: Bentley.Bstdcxx.bvector<Bentley.RefCountedPtr<Bentley.PolyfaceHeader>,Bentley.BentleyAllocator<Bentley.RefCountedPtr<Bentley.PolyfaceHeader> > >, enclosedVolumes: Bentley.Bstdcxx.bvector<Bentley.RefCountedPtr<Bentley.PolyfaceHeader>,Bentley.BentleyAllocator<Bentley.RefCountedPtr<Bentley.PolyfaceHeader> > >) -> None
        """
        ...
    
    @property
    def MeshStyle(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    @property
    def NormalCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    @property
    def NumPerFace(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    @property
    def NumPerRow(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    @property
    def ParamCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    def ParamRange(*args, **kwargs):
        """
        ParamRange(self: MSPyBentleyGeom.PolyfaceQuery) -> MSPyBentleyGeom.DRange2d
        
        Return range of the parameters.
        """
        ...
    
    def PickFacetsByStroke(*args, **kwargs):
        """
        PickFacetsByStroke(self: MSPyBentleyGeom.PolyfaceQuery, eyePoint: MSPyBentleyGeom.DPoint4d, point0: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d, pickDetail: MSPyBentleyGeom.FacetLocationDetailArray, exitAfterFirstPick: bool) -> bool
        
        Search for facets that are touched by a stroke. returns true if valid
        point data and one or more facets selected.
        """
        ...
    
    def PlaneSlice(*args, **kwargs):
        """
        PlaneSlice(self: MSPyBentleyGeom.PolyfaceQuery, sectionPlane: MSPyBentleyGeom.DPlane3d, formRegions: bool, markEdgeFraction: bool = False) -> MSPyBentleyGeom.CurveVector
        
        Cut with a plane. (Prototype) Return as a curve vector. Optionally
        structure as area-bounding loops.
        
        Parameter ``[in]``:
        sectionPlane plane to cut the mesh.
        
        Parameter ``[in]``:
        formRegions true to look for closed loops and structure the return
        as a loop or parity CurveVector.
        
        Parameter ``[in]``:
        markEdgeFractions true to attache FacetEdgeLocationDetailVector to
        the linestrings.
        """
        ...
    
    @property
    def PointCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    @property
    def PointIndexCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    def PointRange(*args, **kwargs):
        """
        PointRange(self: MSPyBentleyGeom.PolyfaceQuery) -> MSPyBentleyGeom.DRange3d
        
        Return range of the points.
        """
        ...
    
    def ReverseIndicesAllFaces(*args, **kwargs):
        """
        ReverseIndicesAllFaces(self: MSPyBentleyGeom.PolyfaceQuery, negateNormals: bool = True, flipMarked: bool = True, flipUnMarked: bool = True, normalIndexAction: MSPyBentleyGeom.BlockedVectorInt.IndexAction = <IndexAction.eNone: 0>) -> bool
        """
        ...
    
    def ReverseIndicesOneFace(*args, **kwargs):
        """
        ReverseIndicesOneFace(self: MSPyBentleyGeom.PolyfaceQuery, iFirst: int, iLast: int, normalArrayIndexAction: MSPyBentleyGeom.BlockedVectorInt.IndexAction = <IndexAction.eNone: 0>) -> None
        
        Reverse a single face loop in parallel index arrays.
        
        Remark:
        s A face loop is reversed after the 1st index:the 2nd/last
        indices are swapped, the 3rd/penultimate indices are swapped, etc.
        
        Parameter ``[in]``:
        iFirst 0-based offset to the first index in the face loop
        
        Parameter ``[in]``:
        iLast 0-based offset to the last index of the face loop.
        
        Parameter ``[in]``:
        normalArrayIndexAction selects action in normal array. This can be
        
        * IndexAction.None -- leave the index value unchanged
        
        * IndexAction.ForcePositive -- change to positive
        
        * IndexAction.ForceNegative -- change to negative
        
        * IndexAction.Negate -- change to negative of its current sign
        """
        ...
    
    def SearchClosestApproach(*args, **kwargs):
        """
        SearchClosestApproach(*args, **kwargs)
        Overloaded function.
        
        1. SearchClosestApproach(polyfaceA: MSPyBentleyGeom.PolyfaceQuery, polyfaceB: MSPyBentleyGeom.PolyfaceQuery, maxDistance: float, segment: MSPyBentleyGeom.DSegment3d) -> bool
        
        2. SearchClosestApproach(polyfaceA: MSPyBentleyGeom.PolyfaceQuery, maxDistance: float, segment: MSPyBentleyGeom.DSegment3d, normalTestRadius: float) -> bool
        
        3. SearchClosestApproach(polyfaceA: MSPyBentleyGeom.PolyfaceQuery, maxDistance: float, segment: MSPyBentleyGeom.DSegment3d) -> bool
        """
        ...
    
    def SearchClosestApproachToLinestring(*args, **kwargs):
        """
        SearchClosestApproachToLinestring(polyfaceA: MSPyBentleyGeom.PolyfaceQuery, points: MSPyBentleyGeom.DPoint3dArray, segment: MSPyBentleyGeom.DSegment3d) -> bool
        """
        ...
    
    def SelectMeshesByVolumeSign(*args, **kwargs):
        """
        SelectMeshesByVolumeSign(inputVolumes: Bentley.Bstdcxx.bvector<Bentley.RefCountedPtr<Bentley.PolyfaceHeader>,Bentley.BentleyAllocator<Bentley.RefCountedPtr<Bentley.PolyfaceHeader> > >, negativeVolumeMeshes: Bentley.Bstdcxx.bvector<Bentley.RefCountedPtr<Bentley.PolyfaceHeader>,Bentley.BentleyAllocator<Bentley.RefCountedPtr<Bentley.PolyfaceHeader> > >, zeroVolumeMeshes: Bentley.Bstdcxx.bvector<Bentley.RefCountedPtr<Bentley.PolyfaceHeader>,Bentley.BentleyAllocator<Bentley.RefCountedPtr<Bentley.PolyfaceHeader> > >, positiveVolumeMeshes: Bentley.Bstdcxx.bvector<Bentley.RefCountedPtr<Bentley.PolyfaceHeader>,Bentley.BentleyAllocator<Bentley.RefCountedPtr<Bentley.PolyfaceHeader> > >) -> None
        """
        ...
    
    def SetMeshStyle(*args, **kwargs):
        """
        SetMeshStyle(self: MSPyBentleyGeom.PolyfaceVectors, meshStyle: int) -> None
        
        Set the facet data style.
        """
        ...
    
    def SetNumPerFace(*args, **kwargs):
        """
        SetNumPerFace(self: MSPyBentleyGeom.PolyfaceVectors, numPerFace: int) -> None
        
        Set the index blocking count
        """
        ...
    
    def SetNumPerRow(*args, **kwargs):
        """
        SetNumPerRow(self: MSPyBentleyGeom.PolyfaceVectors, numPerRow: int) -> None
        
        Set the row count for gridded facets.
        """
        ...
    
    def SetTwoSided(*args, **kwargs):
        """
        SetTwoSided(self: MSPyBentleyGeom.PolyfaceVectors, twoSided: bool) -> None
        
        Set the flag for twosided facets
        """
        ...
    
    def SumDirectedAreas(*args, **kwargs):
        """
        SumDirectedAreas(self: MSPyBentleyGeom.PolyfaceQuery, vectorToEye: MSPyBentleyGeom.DVec3d) -> tuple
        """
        ...
    
    def SumDirectedAreasDetailed(*args, **kwargs):
        """
        SumDirectedAreasDetailed(self: MSPyBentleyGeom.PolyfaceQuery, vectorToEye: MSPyBentleyGeom.DVec3d) -> tuple
        """
        ...
    
    def SumFacetAreas(*args, **kwargs):
        """
        SumFacetAreas(self: MSPyBentleyGeom.PolyfaceQuery) -> float
        
        Return the sum of facet areas. There is no check for planarity.
        """
        ...
    
    def SumFacetFirstAreaMoments(*args, **kwargs):
        """
        SumFacetFirstAreaMoments(self: MSPyBentleyGeom.PolyfaceQuery, origin: MSPyBentleyGeom.DPoint3d, moments1: MSPyBentleyGeom.DVec3d) -> float
        
        Return the sum of facet areas. Return moment with respect to origin.
        """
        ...
    
    def SumFacetSecondAreaMomentProducts(*args, **kwargs):
        """
        SumFacetSecondAreaMomentProducts(self: MSPyBentleyGeom.PolyfaceQuery, origin: MSPyBentleyGeom.DPoint3d, products: MSPyBentleyGeom.DMatrix4d) -> float
        
        Return the sum of facet areas. Return moment products with respect to
        origin.
        """
        ...
    
    def SumTetrahedralFirstMoments(*args, **kwargs):
        """
        SumTetrahedralFirstMoments(self: MSPyBentleyGeom.PolyfaceQuery, origin: MSPyBentleyGeom.DPoint3d, moments: MSPyBentleyGeom.DVec3d) -> float
        
        Return the sum of tetrahedral moments from the specified origin. If
        the mesh is closed and all facets are simply connected planar, this is
        the moment around the origin. (The facets and volume are not require
        to be convex.)
        
        Parameter ``[in]``:
        origin origin for tetrahedra.
        
        Parameter ``[out]``:
        moments sum of (x,y,z) dV
        
        Returns:
        summed volume
        """
        ...
    
    def SumTetrahedralMomentProducts(*args, **kwargs):
        """
        SumTetrahedralMomentProducts(self: MSPyBentleyGeom.PolyfaceQuery, worldToLocal: MSPyBentleyGeom.Transform, moment1: MSPyBentleyGeom.DVec3d, products: MSPyBentleyGeom.RotMatrix) -> float
        """
        ...
    
    def SumTetrahedralVolumes(*args, **kwargs):
        """
        SumTetrahedralVolumes(self: MSPyBentleyGeom.PolyfaceQuery, origin: MSPyBentleyGeom.DPoint3d) -> float
        
        Return the sum of tetrahedral volumes from the specified origin. If
        the mesh is closed and all facets are simply connected planar, this is
        the signed enclosed volume. (The facets and volume are not require to
        be convex.)
        """
        ...
    
    def SweepLinestringToMesh(*args, **kwargs):
        """
        SweepLinestringToMesh(self: MSPyBentleyGeom.PolyfaceQuery, xyzOut: MSPyBentleyGeom.DPoint3dArray, linestringIndexOut: MSPyBentley.Int32Array, meshIndexOut: MSPyBentley.Int32Array, linestringPoints: MSPyBentleyGeom.DPoint3dArray, sweepDirection: MSPyBentleyGeom.DVec3d) -> None
        
        @description Compute intersections (line strings) of this mesh with a
        swept linestring
        
        Parameter ``[out]``:
        xyzOut array of points on the intersection linestrings.
        DISCONNECTS separate multiple linestrings.
        
        Parameter ``[out]``:
        linestringIndexOut for each xyzOut[i], the index of the input
        segment that it came from.
        
        Parameter ``[out]``:
        meshIndexOut for each xyzOut[i], the mesh read index it came from.
        
        Parameter ``[in]``:
        linestringPoints points to sweep.
        
        Parameter ``[in]``:
        sweepDirection sweep direction
        """
        ...
    
    @property
    def TextureId(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    @property
    def TightTolerance(arg0: MSPyBentleyGeom.PolyfaceQuery) -> float:
        ...
    
    def TryEvaluateEdge(*args, **kwargs):
        """
        TryEvaluateEdge(self: MSPyBentleyGeom.PolyfaceQuery, position: MSPyBentleyGeom.FacetEdgeLocationDetail, xyz: MSPyBentleyGeom.DPoint3d) -> bool
        
        Try to convert the index and edge fraction of a
        FacetEdgeLocationDetail to a point.
        """
        ...
    
    def TryGetFacetFaceDataAtReadIndex(*args, **kwargs):
        """
        TryGetFacetFaceDataAtReadIndex(self: MSPyBentleyGeom.PolyfaceQuery, readIndex: int, data: MSPyBentleyGeom.FacetFaceData) -> tuple
        """
        ...
    
    def TryGetNormalAtReadIndex(*args, **kwargs):
        """
        TryGetNormalAtReadIndex(self: MSPyBentleyGeom.PolyfaceQuery, readIndex: int, data: MSPyBentleyGeom.DVec3d) -> bool
        
        Try to access normal coordinates through a readIndex in the
        normalIndex array.
        """
        ...
    
    def TryGetParamAtReadIndex(*args, **kwargs):
        """
        TryGetParamAtReadIndex(self: MSPyBentleyGeom.PolyfaceQuery, readIndex: int, data: MSPyBentleyGeom.DPoint2d) -> bool
        
        Try to access param coordinates through a readIndex in the paramIndex
        array.
        """
        ...
    
    def TryGetPointAtReadIndex(*args, **kwargs):
        """
        TryGetPointAtReadIndex(self: MSPyBentleyGeom.PolyfaceQuery, readIndex: int, data: MSPyBentleyGeom.DPoint3d) -> bool
        
        Try to access point coordinates through a readIndex in the pointIndex
        array.
        """
        ...
    
    @property
    def TwoSided(arg0: MSPyBentleyGeom.PolyfaceQuery) -> bool:
        ...
    
    def ValidatedVolume(*args, **kwargs):
        """
        ValidatedVolume(self: MSPyBentleyGeom.PolyfaceQuery) -> MSPyBentleyGeom.ValidatedDouble
        
        Test if the mesh passes IsClosedByEdgePairing, and compute volume if
        so.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    
class PolyfaceVisitor:
    """
    None
    """

    def AccumulateScaledData(*args, **kwargs):
        """
        AccumulateScaledData(self: MSPyBentleyGeom.PolyfaceVisitor, detail: MSPyBentleyGeom.FacetLocationDetail, vertexIndex: int, fraction: float) -> bool
        
        accumualted a (multiple of) all numeric data to a detail. Copy integer
        color and table number unchanged.
        """
        ...
    
    def AddCoordinatesFromFacetLocationDetail(*args, **kwargs):
        """
        AddCoordinatesFromFacetLocationDetail(self: MSPyBentleyGeom.PolyfaceVisitor, detail: MSPyBentleyGeom.FacetLocationDetail) -> bool
        
        add coordinate data from a vertex described by a facet location
        detail.
        """
        ...
    
    def AdvanceToFacetBySearchPoint(*args, **kwargs):
        """
        AdvanceToFacetBySearchPoint(*args, **kwargs)
        Overloaded function.
        
        1. AdvanceToFacetBySearchPoint(self: MSPyBentleyGeom.PolyfaceVisitor, xyz: MSPyBentleyGeom.DPoint3d, tolerance: float, facetPoint: MSPyBentleyGeom.DPoint3d) -> bool
        
        Call AdvanceToNextFace repeatedly, returning when a face is found
        within tolerance of search point.
        
        Parameter ``[in]``:
        xyz search point
        
        Parameter ``[in]``:
        tolerance proximity tolerance.
        
        Parameter ``[out]``:
        facetPoint nearest point on facet
        
        return false if all faces have been visited.
        
        2. AdvanceToFacetBySearchPoint(self: MSPyBentleyGeom.PolyfaceVisitor, xyz: MSPyBentleyGeom.DPoint3d, tolerance: float, facetPoint: MSPyBentleyGeom.DPoint3d) -> tuple
        
        Call AdvanceToNextFace repeatedly, returning when a face is found
        within tolerance of search point.
        
        Parameter ``[in]``:
        xyz search point
        
        Parameter ``[in]``:
        tolerance proximity tolerance.
        
        Parameter ``[out]``:
        facetPoint nearest point on facet
        
        return false if all faces have been visited.
        """
        ...
    
    def AdvanceToFacetBySearchRay(*args, **kwargs):
        """
        AdvanceToFacetBySearchRay(*args, **kwargs)
        Overloaded function.
        
        1. AdvanceToFacetBySearchRay(self: MSPyBentleyGeom.PolyfaceVisitor, ray: MSPyBentleyGeom.DRay3d, tolerance: float, facetPoint: MSPyBentleyGeom.DPoint3d) -> tuple
        
        Call AdvanceToNextFace repeatedly, returning when a face is found
        within tolerance of a pick ray.
        
        Parameter ``[in]``:
        ray ray
        
        Parameter ``[in]``:
        tolerance proximity tolerance.
        
        Parameter ``[out]``:
        facetPoint pierce point on facet.
        
        Parameter ``[out]``:
        rayFraction parameter along ray. return false if all faces have
        been visited.
        
        2. AdvanceToFacetBySearchRay(self: MSPyBentleyGeom.PolyfaceVisitor, ray: MSPyBentleyGeom.DRay3d, tolerance: float, facetPoint: MSPyBentleyGeom.DPoint3d, edgePoint: MSPyBentleyGeom.DPoint3d) -> tuple
        
        Call AdvanceToNextFace repeatedly, returning when a face is found
        within tolerance of a pick ray.
        
        Parameter ``[in]``:
        ray ray
        
        Parameter ``[in]``:
        tolerance proximity tolerance.
        
        Parameter ``[out]``:
        facetPoint pierce point on facet.
        
        Parameter ``[out]``:
        rayFraction parameter along ray. return false if all faces have
        been visited.
        
        3. AdvanceToFacetBySearchRay(self: MSPyBentleyGeom.PolyfaceVisitor, ray: MSPyBentleyGeom.DRay3d, detail: MSPyBentleyGeom.FacetLocationDetail) -> bool
        
        Call AdvanceToNextFace repeatedly, returning when a face is found
        within tolerance of a pick ray.
        
        Parameter ``[in]``:
        ray ray
        
        Parameter ``[in]``:
        tolerance proximity tolerance.
        
        Parameter ``[out]``:
        facetPoint pierce point on facet.
        
        Parameter ``[out]``:
        rayFraction parameter along ray. return false if all faces have
        been visited.
        """
        ...
    
    def AdvanceToNextFace(*args, **kwargs):
        """
        AdvanceToNextFace(self: MSPyBentleyGeom.PolyfaceVisitor) -> bool
        
        Read the next face from the attached mesh. return false if all faces
        have been visited.
        """
        ...
    
    def Attach(*args, **kwargs):
        """
        Attach(parentMesh: MSPyBentleyGeom.PolyfaceQuery, allData: bool = True) -> MSPyBentleyGeom.PolyfaceVisitor
        
        Save data for traversing the given parentMesh
        """
        ...
    
    def ClearAllArrays(*args, **kwargs):
        """
        ClearAllArrays(self: MSPyBentleyGeom.PolyfaceVisitor) -> None
        
        Clear all arrays in the visitor.
        """
        ...
    
    def ClearFacet(*args, **kwargs):
        """
        ClearFacet(self: MSPyBentleyGeom.PolyfaceVisitor) -> None
        
        Clear all arrays in the visitor. This is used before
        AddVertexByReadIndex.
        """
        ...
    
    def ClientColorIndex(*args, **kwargs):
        """
        ClientColorIndex(self: MSPyBentleyGeom.PolyfaceVisitor) -> MSPyBentleyGeom.BlockedVectorInt
        
        Get reference to the blocked array of zero-based indices into client
        mesh colors
        """
        ...
    
    def ClientFaceIndex(*args, **kwargs):
        """
        ClientFaceIndex(self: MSPyBentleyGeom.PolyfaceVisitor) -> MSPyBentleyGeom.BlockedVectorInt
        
        Get reference to the blocked array of zero-based indices into client
        mesh faces.
        """
        ...
    
    def ClientNormalIndex(*args, **kwargs):
        """
        ClientNormalIndex(self: MSPyBentleyGeom.PolyfaceVisitor) -> MSPyBentleyGeom.BlockedVectorInt
        
        Get reference to the blocked array of zero-based indices into client
        mesh normals.
        """
        ...
    
    def ClientParamIndex(*args, **kwargs):
        """
        ClientParamIndex(self: MSPyBentleyGeom.PolyfaceVisitor) -> MSPyBentleyGeom.BlockedVectorInt
        
        Get reference to the blocked array of zero-based indices into client
        mesh params.
        """
        ...
    
    def ClientPointIndex(*args, **kwargs):
        """
        ClientPointIndex(self: MSPyBentleyGeom.PolyfaceVisitor) -> MSPyBentleyGeom.BlockedVectorInt
        
        The client indices are zero-based indices into the client mesh data.
        Get reference to the blocked array of zero-based indices into client
        mesh points.
        """
        ...
    
    def ColorTable(*args, **kwargs):
        """
        ColorTable(self: MSPyBentleyGeom.PolyfaceVisitor) -> MSPyBentleyGeom.BlockedVectorUInt32
        
        Get reference to the Point array with blocking data.
        """
        ...
    
    def CompressClosePoints(*args, **kwargs):
        """
        CompressClosePoints(self: MSPyBentleyGeom.PolyfaceVisitor, tolerance: float) -> None
        
        Compress adjacent points (including last/first) within tolerance.
        """
        ...
    
    def CopyData(*args, **kwargs):
        """
        CopyData(self: MSPyBentleyGeom.PolyfaceVisitor, fromIndex: int, toIndex: int) -> None
        
        Copy all data from one index to another.
        """
        ...
    
    def DoubleColor(*args, **kwargs):
        """
        DoubleColor(self: MSPyBentleyGeom.PolyfaceVisitor) -> MSPyBentleyGeom.BlockedVectorRgbFactor
        
        Get reference to the double color array with blocking data.
        """
        ...
    
    def FloatColor(*args, **kwargs):
        """
        FloatColor(self: MSPyBentleyGeom.PolyfaceVisitor) -> MSPyBentleyGeom.BlockedVectorFloatRgb
        
        Get reference to the FloatRbg array with blocking data.
        """
        ...
    
    def GetClientPolyfaceQuery(*args, **kwargs):
        """
        GetClientPolyfaceQuery(self: MSPyBentleyGeom.PolyfaceVisitor) -> MSPyBentleyGeom.PolyfaceQuery
        """
        ...
    
    def GetNumWrap(*args, **kwargs):
        """
        GetNumWrap(self: MSPyBentleyGeom.PolyfaceVisitor) -> int
        
        return the number or wraparound vertices that are added to the arrays.
        """
        ...
    
    def GetReadIndex(*args, **kwargs):
        """
        GetReadIndex(self: MSPyBentleyGeom.PolyfaceVisitor) -> int
        
        Return the readIndex (current position within client facets). This
        value can be used to return here via MoveToFacetByReadIndex
        
        Returns:
        readIndex in facet.
        """
        ...
    
    def IlluminationName(*args, **kwargs):
        """
        IlluminationName(self: MSPyBentleyGeom.PolyfaceVisitor) -> MSPyBentley.WString
        
        Get reference to the illumination name
        """
        ...
    
    def IndexPosition(*args, **kwargs):
        """
        IndexPosition(self: MSPyBentleyGeom.PolyfaceVisitor) -> MSPyBentley.UInt64Array
        
        return the (reference to) the array indicating where vertex indices
        were read from the attached mesh.
        """
        ...
    
    def IntColor(*args, **kwargs):
        """
        IntColor(self: MSPyBentleyGeom.PolyfaceVisitor) -> MSPyBentleyGeom.BlockedVectorUInt32
        
        Get reference to the integer color array with blocking data.
        """
        ...
    
    def IntepolateDataOnEdge(*args, **kwargs):
        """
        IntepolateDataOnEdge(self: MSPyBentleyGeom.PolyfaceVisitor, detail: MSPyBentleyGeom.FacetLocationDetail, vertexIndex: int, edgeFraction: float = 0.0, a: float = 0.0) -> bool
        
        interpolate all possible data along an edge of the current facet.
        """
        ...
    
    def LoadCyclicVertexData(*args, **kwargs):
        """
        LoadCyclicVertexData(self: MSPyBentleyGeom.PolyfaceVisitor, detail: MSPyBentleyGeom.FacetLocationDetail, index: int) -> bool
        """
        ...
    
    def LoadVertexData(*args, **kwargs):
        """
        LoadVertexData(self: MSPyBentleyGeom.PolyfaceVisitor, detail: MSPyBentleyGeom.FacetLocationDetail, index: int) -> bool
        
        Copy all data from a particular vertex (indexed within the visitor)
        into a facet location detail.
        
        Parameter ``[out]``:
        detail destination for copied data.
        
        Parameter ``[in]``:
        index index within data arrays for the visitor.
        """
        ...
    
    def MoveToFacetByReadIndex(*args, **kwargs):
        """
        MoveToFacetByReadIndex(self: MSPyBentleyGeom.PolyfaceVisitor, readIndex: int) -> bool
        
        Focus on facet with specified readIndex.
        
        Parameter ``[in]``:
        readIndex readIndex in facet.
        """
        ...
    
    def Normal(*args, **kwargs):
        """
        Normal(self: MSPyBentleyGeom.PolyfaceVisitor) -> MSPyBentleyGeom.BlockedVectorDVec3d
        
        Get reference to the normal array with blocking data.
        """
        ...
    
    def NumEdgesThisFace(*args, **kwargs):
        """
        NumEdgesThisFace(self: MSPyBentleyGeom.PolyfaceVisitor) -> int
        
        return the number of edges on the current face.
        """
        ...
    
    @property
    def NumWrap(arg0: MSPyBentleyGeom.PolyfaceVisitor) -> int:
        ...
    @NumWrap.setter
    def NumWrap(arg0: MSPyBentleyGeom.PolyfaceVisitor, arg1: int) -> None:
        ...
    
    def Param(*args, **kwargs):
        """
        Param(self: MSPyBentleyGeom.PolyfaceVisitor) -> MSPyBentleyGeom.BlockedVectorDPoint2d
        
        Get reference to the param array with blocking data.
        """
        ...
    
    def Point(*args, **kwargs):
        """
        Point(self: MSPyBentleyGeom.PolyfaceVisitor) -> MSPyBentleyGeom.BlockedVectorDPoint3d
        
        Get reference to the Point array with blocking data.
        """
        ...
    
    def PushFaceData(*args, **kwargs):
        """
        PushFaceData(self: MSPyBentleyGeom.PolyfaceVisitor, source: MSPyBentleyGeom.PolyfaceVisitor, i0: int) -> int
        
        Copy face data (point, normal, param, color, visible) from specified
        index of source. Active state is checked in receiver. Index is not
        checked.
        
        return the index of new point.
        """
        ...
    
    def PushIndexData(*args, **kwargs):
        """
        PushIndexData(self: MSPyBentleyGeom.PolyfaceVisitor, source: MSPyBentleyGeom.PolyfaceVisitor, i0: int) -> None
        
        In source, copy index data (point, normal, param, color) from
        specified index of source. Active state is checked in receiver. Index
        is not checked.
        """
        ...
    
    def PushInterpolatedFaceData(*args, **kwargs):
        """
        PushInterpolatedFaceData(self: MSPyBentleyGeom.PolyfaceVisitor, source: MSPyBentleyGeom.PolyfaceVisitor, i0: int, fraction: float, i1: int, suppressVisibility: bool = False) -> int
        
        In source, interpolate between specified indices of face data. Active
        state is checked in receiver. Index is not checked.
        
        return the index of new point.
        """
        ...
    
    def Reset(*args, **kwargs):
        """
        Reset(self: MSPyBentleyGeom.PolyfaceVisitor) -> None
        
        Reset to beginning of attached mesh, i.e. to read facets again.
        """
        ...
    
    def SetNumWrap(*args, **kwargs):
        """
        SetNumWrap(self: MSPyBentleyGeom.PolyfaceVisitor, numWrap: int) -> None
        
        Set the number of wraparound vertices to be added to faces when they
        are read.
        """
        ...
    
    def TrimData(*args, **kwargs):
        """
        TrimData(self: MSPyBentleyGeom.PolyfaceVisitor, newSize: int) -> None
        
        Trim all arrays to newSize.
        """
        ...
    
    def TrimFaceData(*args, **kwargs):
        """
        TrimFaceData(self: MSPyBentleyGeom.PolyfaceVisitor, index0: int, count: int) -> None
        
        Trim all face data arrays, retaining{count} values starting at
        {index0}
        """
        ...
    
    def TryAddVertexByReadIndex(*args, **kwargs):
        """
        TryAddVertexByReadIndex(self: MSPyBentleyGeom.PolyfaceVisitor, readIndex: int) -> bool
        
        Go to the source mesh at specified readIndex. Bring all it's data into
        a new vertex in the visitor.
        
        Returns:
        false if not a valid readIndex for the client array, or if the
        client array has a zero (terminator) there, or if the client is
        not fully indexed.
        """
        ...
    
    def TryDRay3dIntersectionToFacetLocationDetail(*args, **kwargs):
        """
        TryDRay3dIntersectionToFacetLocationDetail(self: MSPyBentleyGeom.PolyfaceVisitor, ray: MSPyBentleyGeom.DRay3d, detail: MSPyBentleyGeom.FacetLocationDetail) -> bool
        
        Find a uv location within the facet. Compute all available data there.
        returns false if the facet does not have params or if there are not
        edges on both sides along the scan lines.
        
        Parameter ``[in]``:
        ray ray to intersect with facet.
        
        Parameter ``[in]``:
        detail all coordinate data at this parametric coordinate.
        """
        ...
    
    def TryFindCloseFacetPoint(*args, **kwargs):
        """
        TryFindCloseFacetPoint(self: MSPyBentleyGeom.PolyfaceVisitor, spacePoint: MSPyBentleyGeom.DPoint3d, tolerance: float, fractionPoint: MSPyBentleyGeom.DPoint3d) -> bool
        
        Test if a point is close to a facet.
        
        Parameter ``[in]``:
        spacePoint test point.
        
        Parameter ``[in]``:
        tolerance tolerance for identifying a hit.
        
        Parameter ``[out]``:
        facetPoint point on facet.
        
        return true if a hit was found.
        """
        ...
    
    def TryFindFacetRayIntersection(*args, **kwargs):
        """
        TryFindFacetRayIntersection(self: MSPyBentleyGeom.PolyfaceVisitor, ray: MSPyBentleyGeom.DRay3d, tolerance: float, facetPoint: MSPyBentleyGeom.DPoint3d) -> tuple
        
        Test if ray pierces facet or come close to an edge or vertex.
        
        Parameter ``[in]``:
        ray test ray.
        
        Parameter ``[in]``:
        tolerance tolerance for edge/vertex passby
        
        Parameter ``[out]``:
        facetPoint point on facet.
        
        Parameter ``[out]``:
        rayFraction parameter along ray
        
        return true if a hit was found.
        """
        ...
    
    def TryGetClientZeroBasedColorIndex(*args, **kwargs):
        """
        TryGetClientZeroBasedColorIndex(self: MSPyBentleyGeom.PolyfaceVisitor, zeroBasedVisitorIndex: int) -> tuple
        
        access zero-based color index for an vertex within the curent face.
        """
        ...
    
    def TryGetClientZeroBasedNormalIndex(*args, **kwargs):
        """
        TryGetClientZeroBasedNormalIndex(self: MSPyBentleyGeom.PolyfaceVisitor, zeroBasedVisitorIndex: int) -> tuple
        
        access zero-based normal index for an vertex within the curent face.
        """
        ...
    
    def TryGetClientZeroBasedParamIndex(*args, **kwargs):
        """
        TryGetClientZeroBasedParamIndex(self: MSPyBentleyGeom.PolyfaceVisitor, zeroBasedVisitorIndex: int) -> tuple
        
        access zero-based param index for an vertex within the curent face.
        """
        ...
    
    def TryGetClientZeroBasedPointIndex(*args, **kwargs):
        """
        TryGetClientZeroBasedPointIndex(self: MSPyBentleyGeom.PolyfaceVisitor, zeroBasedVisitorIndex: int) -> tuple
        
        access zero-based point index and visibility flag for an vertex within
        the current face.
        """
        ...
    
    def TryGetDistanceParameter(*args, **kwargs):
        """
        TryGetDistanceParameter(self: MSPyBentleyGeom.PolyfaceVisitor, index: int, distanceParam: MSPyBentleyGeom.DPoint2d) -> bool
        
        get a distance based parameter at an index within the current facet
        """
        ...
    
    def TryGetEdgePoint(*args, **kwargs):
        """
        TryGetEdgePoint(self: MSPyBentleyGeom.PolyfaceVisitor, edgeIndex: int, f: float, xyz: MSPyBentleyGeom.DPoint3d) -> bool
        
        interpolate a point on an edge. Edge index is interpretted cyclically
        (within the current face)
        """
        ...
    
    def TryGetFacetAreaMomentProducts(*args, **kwargs):
        """
        TryGetFacetAreaMomentProducts(self: MSPyBentleyGeom.PolyfaceVisitor, origin: MSPyBentleyGeom.DPoint3d, products: MSPyBentleyGeom.DMatrix4d) -> bool
        
        return true if products of inertia for an AREA integral over the facet
        can be computed.
        """
        ...
    
    def TryGetFacetCentroidNormalAndArea(*args, **kwargs):
        """
        TryGetFacetCentroidNormalAndArea(self: MSPyBentleyGeom.PolyfaceVisitor, centroid: MSPyBentleyGeom.DPoint3d, normal: MSPyBentleyGeom.DVec3d) -> tuple
        
        return true if centroid, area, and normal can be calculated for the
        current facet.
        """
        ...
    
    def TryGetLocalFrame(*args, **kwargs):
        """
        TryGetLocalFrame(self: MSPyBentleyGeom.PolyfaceVisitor, localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform, selector: MSPyBentleyGeom.LocalCoordinateSelect = <LocalCoordinateSelect.eLOCAL_COORDINATE_SCALE_01RangeBothAxes: 2>) -> bool
        
        Interogate the xy coordinates (NOT THE STORED Param() ARRAY !!!) to
        determine a local coordinate frame for the current facet. This is the
        same logic used for CurveVector.CloneInLocalCoordinates and
        PolygonOps.CoordinateFrame. That is:ul> li>The prefered x axis
        direction is parallel to the first edge. li>The prefered z direction
        is the outward normal of the xyz loop with CCW direction. li>The
        selector parameter chooses among 4 options:
        
        * LOCAL_COORDINATE_SCALE_UnitAxesAtStart -- origin at first point
        (even if not lower left!!), local axes have unit length, so local
        coordinates are real distances.
        
        * LOCAL_COORDINATE_SCALE_UnitAxesAtLowerLeft -- origin at lower left.
        All xy local coordinates are 0 or positive, and local coordinates are
        real distances along the local directions
        
        * LOCAL_COORDINATE_SCALE_01RangeBothAxes -- Shift to lower left and
        scale to both directions go 0 to 1
        
        * LOCAL_COORDINATE_SCALE_01RangeBothAxes -- Shift to lower left and
        scale so one direction goes 0 to 1, the other direction has same scale
        and its largest coordinate is positive and 1 or less.
        
        ul> Prefered x axis is parallel to the first edge.
        
        Parameter ``[out]``:
        localToWorld transform from local to world
        
        Parameter ``[out]``:
        worldToLocal transform from world to local
        
        Parameter ``[in]``:
        selector indicates preference for origin and scaling.
        """
        ...
    
    def TryGetLocalFrameAndRank(*args, **kwargs):
        """
        TryGetLocalFrameAndRank(self: MSPyBentleyGeom.PolyfaceVisitor, localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform, selector: MSPyBentleyGeom.LocalCoordinateSelect = <LocalCoordinateSelect.eLOCAL_COORDINATE_SCALE_01RangeBothAxes: 2>) -> int
        
        Like TryGetLocalFrame, but with integer return type to distinguish
        
        * 0 -- really degenerate data -- single point?
        
        * 1 -- degenerate to a line
        
        * 2 -- usual full-rank case.
        """
        ...
    
    def TryGetNormalizedParameter(*args, **kwargs):
        """
        TryGetNormalizedParameter(self: MSPyBentleyGeom.PolyfaceVisitor, index: int, normalizedParam: MSPyBentleyGeom.DPoint2d) -> bool
        
        get a normalized (0-1) parameter at an index within the current facet
        """
        ...
    
    def TryParamToFacetLocationDetail(*args, **kwargs):
        """
        TryParamToFacetLocationDetail(self: MSPyBentleyGeom.PolyfaceVisitor, uvParam: MSPyBentleyGeom.DPoint2d, detail: MSPyBentleyGeom.FacetLocationDetail) -> bool
        
        Find a uv location within the facet. Compute all available data there.
        returns false if the facet does not have params or if there are not
        edges on both sides along the scan lines.
        
        Parameter ``[in]``:
        uvParam pick parameter.
        
        Parameter ``[in]``:
        detail all coordinate data at this parametric coordinate.
        """
        ...
    
    def TryParamToScanBrackets(*args, **kwargs):
        """
        TryParamToScanBrackets(self: MSPyBentleyGeom.PolyfaceVisitor, uvParam: MSPyBentleyGeom.DPoint2d, horizontalScanBracket: MSPyBentleyGeom.FacetLocationDetailPair, verticalScanBracket: MSPyBentleyGeom.FacetLocationDetailPair) -> bool
        
        Try to locate facet edges before and after a specified param in a
        facet. returns false if the facet does not have params or if there are
        not edges on both sides along the scan lines.
        
        Parameter ``[in]``:
        uvParam pick parameter.
        
        Parameter ``[in]``:
        horizontalScanBracket edge crossing data to left and right of uv.
        
        Parameter ``[in]``:
        verticalScanBracket edge crossign data below and above.
        """
        ...
    
    def TryRecomputeNormals(*args, **kwargs):
        """
        TryRecomputeNormals(self: MSPyBentleyGeom.PolyfaceVisitor) -> bool
        
        Recompute the (coordinate) normal data based on the point coordinates.
        """
        ...
    
    def TwoSided(*args, **kwargs):
        """
        TwoSided(self: MSPyBentleyGeom.PolyfaceVisitor) -> bool
        """
        ...
    
    def Visible(*args, **kwargs):
        """
        Visible(self: MSPyBentleyGeom.PolyfaceVisitor) -> MSPyBentley.BoolArray
        
        return the (reference to) the array of per-edge visibility flags.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    
class RefCountedMSBsplineCurve:
    """
    None
    """

    def AddArcIntersectionsXY(*args, **kwargs):
        """
        AddArcIntersectionsXY(self: MSPyBentleyGeom.MSBsplineCurve, curvePoints: MSPyBentleyGeom.DPoint3dArray, curveFractions: MSPyBentley.DoubleArray, ellipsePoints: MSPyBentleyGeom.DPoint3dArray, ellipseFractions: MSPyBentley.DoubleArray, arc: MSPyBentleyGeom.DEllipse3d, extendConic: bool, matrix: MSPyBentleyGeom.DMatrix4d) -> None
        """
        ...
    
    def AddCurveIntersectionsXY(*args, **kwargs):
        """
        AddCurveIntersectionsXY(self: MSPyBentleyGeom.MSBsplineCurve, curveAPoints: MSPyBentleyGeom.DPoint3dArray, curveAFractions: MSPyBentley.DoubleArray, curveBPoints: MSPyBentleyGeom.DPoint3dArray, curveBFractions: MSPyBentley.DoubleArray, curveB: MSPyBentleyGeom.MSBsplineCurve, matrix: MSPyBentleyGeom.DMatrix4d) -> None
        """
        ...
    
    def AddCusps(*args, **kwargs):
        """
        AddCusps(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, fractionParameters: MSPyBentley.DoubleArray) -> None
        
        Find full 3d cusps.
        
        Parameter ``[out]``:
        points array to receive xyz of cusps.
        
        Parameter ``[out]``:
        fractionParameters array to receive fraction parameters of cusps.
        """
        ...
    
    def AddCuspsXY(*args, **kwargs):
        """
        AddCuspsXY(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, fractionParameters: MSPyBentley.DoubleArray, matrix: MSPyBentleyGeom.DMatrix4d) -> None
        
        Find full cusps as viewed in xy.
        
        Parameter ``[out]``:
        points array to receive xyz of cusps.
        
        Parameter ``[out]``:
        fractionParameters array to receive fraction parameters of cusps.
        
        Parameter ``[in]``:
        matrix optional transformation into viewing space.
        """
        ...
    
    def AddKnot(*args, **kwargs):
        """
        AddKnot(self: MSPyBentleyGeom.MSBsplineCurve, unnormalizedKnotValue: float, newMultiplicity: int) -> int
        
        Add a given knot value to the B-spline curve. that newMultiplicity is
        the desired final multiplicity of a knot that may already exist.
        """
        ...
    
    def AddLineIntersectionsXY(*args, **kwargs):
        """
        AddLineIntersectionsXY(*args, **kwargs)
        Overloaded function.
        
        1. AddLineIntersectionsXY(self: MSPyBentleyGeom.MSBsplineCurve, curvePoints: MSPyBentleyGeom.DPoint3dArray, curveFractions: MSPyBentley.DoubleArray, linePoints: MSPyBentleyGeom.DPoint3dArray, lineFractions: MSPyBentley.DoubleArray, segment: MSPyBentleyGeom.DSegment3d, extendSegment: bool, matrix: MSPyBentleyGeom.DMatrix4d) -> None
        
        2. AddLineIntersectionsXY(self: MSPyBentleyGeom.MSBsplineCurve, curvePoints: MSPyBentleyGeom.DPoint3dArray, curveFractions: MSPyBentley.DoubleArray, linePoints: MSPyBentleyGeom.DPoint3dArray, lineFractions: MSPyBentley.DoubleArray, segment: MSPyBentleyGeom.DSegment3d, extendSegment0: bool, extendSegment1: bool, matrix: MSPyBentleyGeom.DMatrix4d) -> None
        """
        ...
    
    def AddLinestringIntersectionsXY(*args, **kwargs):
        """
        AddLinestringIntersectionsXY(*args, **kwargs)
        Overloaded function.
        
        1. AddLinestringIntersectionsXY(self: MSPyBentleyGeom.MSBsplineCurve, curveAPoints: MSPyBentleyGeom.DPoint3dArray, curveAFractions: MSPyBentley.DoubleArray, curveBPoints: MSPyBentleyGeom.DPoint3dArray, curveBFractions: MSPyBentley.DoubleArray, lineString: MSPyBentleyGeom.DPoint3dArray, matrix: MSPyBentleyGeom.DMatrix4d) -> None
        
        2. AddLinestringIntersectionsXY(self: MSPyBentleyGeom.MSBsplineCurve, curveAPoints: MSPyBentleyGeom.DPoint3dArray, curveAFractions: MSPyBentley.DoubleArray, curveBPoints: MSPyBentleyGeom.DPoint3dArray, curveBFractions: MSPyBentley.DoubleArray, lineString: MSPyBentleyGeom.DPoint3dArray, extendLineString: bool, matrix: MSPyBentleyGeom.DMatrix4d) -> None
        """
        ...
    
    def AddPlaneIntersections(*args, **kwargs):
        """
        AddPlaneIntersections(*args, **kwargs)
        Overloaded function.
        
        1. AddPlaneIntersections(self: MSPyBentleyGeom.MSBsplineCurve, point: MSPyBentleyGeom.DPoint3dArray, fractionParameters: MSPyBentley.DoubleArray, plane: MSPyBentleyGeom.DPlane3d) -> None
        
        2. AddPlaneIntersections(self: MSPyBentleyGeom.MSBsplineCurve, point: MSPyBentleyGeom.DPoint3dArray, fractionParameters: MSPyBentley.DoubleArray, planeCoeffs: MSPyBentleyGeom.DPoint4d) -> None
        """
        ...
    
    def AddRuleSurfaceRayIntersections(*args, **kwargs):
        """
        AddRuleSurfaceRayIntersections(pickData: MSPyBentleyGeom.SolidLocationDetailArray, curveA: MSPyBentleyGeom.MSBsplineCurve, curveB: MSPyBentleyGeom.MSBsplineCurve, ray: MSPyBentleyGeom.DRay3d) -> bool
        """
        ...
    
    def AddStrokes(*args, **kwargs):
        """
        AddStrokes(*args, **kwargs)
        Overloaded function.
        
        1. AddStrokes(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, chordTol: float = 0.0, angleTol: float = 0.2, maxEdgeLength: float = 0.0, includeStartPoint: bool = True) -> None
        
        2. AddStrokes(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, derivatives: MSPyBentleyGeom.DVec3dArray = None, params: MSPyBentley.DoubleArray = None, chordTol: float = 0.0, angleTol: float = 0.2, maxEdgeLength: float = 0.0, includeStartPoint: bool = True, parameterSelect: MSPyBentleyGeom.CurveParameterMapping = <CurveParameterMapping.eCURVE_PARAMETER_MAPPING_CurveKnot: 1>) -> None
        
        3. AddStrokes(self: MSPyBentleyGeom.MSBsplineCurve, options: MSPyBentleyGeom.IFacetOptions, points: MSPyBentleyGeom.DPoint3dArray, derivatives: MSPyBentleyGeom.DVec3dArray = None, params: MSPyBentley.DoubleArray = None, includeStart: bool = True) -> None
        
        4. AddStrokes(self: MSPyBentleyGeom.MSBsplineCurve, numPoints: int, points: MSPyBentleyGeom.DPoint3dArray, derivatives: MSPyBentleyGeom.DVec3dArray = None, params: MSPyBentley.DoubleArray = None, includeStartPoint: bool = True, parameterSelect: MSPyBentleyGeom.CurveParameterMapping = <CurveParameterMapping.eCURVE_PARAMETER_MAPPING_CurveKnot: 1>) -> None
        """
        ...
    
    def AdvanceToBezierInFractionInterval(*args, **kwargs):
        """
        AdvanceToBezierInFractionInterval(self: MSPyBentleyGeom.MSBsplineCurve, segment: MSPyBentleyGeom.BCurveSegment, interval: MSPyBentleyGeom.DRange1d) -> tuple
        """
        ...
    
    def AdvanceToBezierInKnotInterval(*args, **kwargs):
        """
        AdvanceToBezierInKnotInterval(self: MSPyBentleyGeom.MSBsplineCurve, segment: MSPyBentleyGeom.BCurveSegment, interval: MSPyBentleyGeom.DRange1d) -> tuple
        """
        ...
    
    def AllParallellTangentsXY(*args, **kwargs):
        """
        AllParallellTangentsXY(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, fractions: MSPyBentley.DoubleArray, vector: MSPyBentleyGeom.DVec3d) -> None
        
        Find all curve points X where the tangents is parallel to the given
        vector.
        
        Parameter ``[out]``:
        points array to receive points.
        
        Parameter ``[out]``:
        fractions array to receive fraction parameters.
        
        Parameter ``[in]``:
        vector given direction.
        """
        ...
    
    def AllTangents(*args, **kwargs):
        """
        AllTangents(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, fractions: MSPyBentley.DoubleArray, spacePoint: MSPyBentleyGeom.DPoint3d) -> None
        
        For space point Q, find all curve points X where line XQ is tangent to
        the curve.
        
        Parameter ``[out]``:
        points array to receive points.
        
        Parameter ``[out]``:
        fractions array to receive fraction parameters.
        
        Parameter ``[in]``:
        spacePoint space point.
        """
        ...
    
    def AllTangentsXY(*args, **kwargs):
        """
        AllTangentsXY(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, fractions: MSPyBentley.DoubleArray, spacePoint: MSPyBentleyGeom.DPoint3d, matrix: MSPyBentleyGeom.DMatrix4d) -> None
        
        For space point Q (spacePoint), find all curve points X where line XQ
        is tangent to the curve.
        
        Parameter ``[out]``:
        points array to receive points.
        
        Parameter ``[out]``:
        fractions array to receive fraction parameters.
        
        Parameter ``[in]``:
        spacePoint space point.
        
        Parameter ``[in]``:
        matrix optional transformation into viewing space.
        """
        ...
    
    def Allocate(*args, **kwargs):
        """
        Allocate(*args, **kwargs)
        Overloaded function.
        
        1. Allocate(self: MSPyBentleyGeom.MSBsplineCurve) -> int
        
        Allocate memory arrays to match the current counts.
        
        2. Allocate(self: MSPyBentleyGeom.MSBsplineCurve, numPoles: int, order: int, closed: bool, rational: bool) -> int
        
        Allocate memory arrays to match the current counts.
        """
        ...
    
    def AllocateKnots(*args, **kwargs):
        """
        AllocateKnots(self: MSPyBentleyGeom.MSBsplineCurve, count: int, data: float = None) -> int
        
        <summary>Allocate knot pointer to specified count. (Optionally)copy
        data from callers buffer</summary>
        """
        ...
    
    def AllocatePoles(*args, **kwargs):
        """
        AllocatePoles(self: MSPyBentleyGeom.MSBsplineCurve, count: int, data: MSPyBentleyGeom.DPoint3d = None) -> int
        
        <summary>Allocate pole pointer to specified count. (Optionally)copy
        data from callers buffer</summary>
        """
        ...
    
    def AllocateWeights(*args, **kwargs):
        """
        AllocateWeights(self: MSPyBentleyGeom.MSBsplineCurve, count: int, data: float = None) -> int
        
        <summary>Allocate weight pointer to specified count. (Optionally)copy
        data from callers buffer</summary>
        """
        ...
    
    def AlmostEqual(*args, **kwargs):
        """
        AlmostEqual(*args, **kwargs)
        Overloaded function.
        
        1. AlmostEqual(self: MSPyBentleyGeom.MSBsplineCurve, other: MSPyBentleyGeom.MSBsplineCurve) -> bool
        
        Compare curves.
        
        2. AlmostEqual(self: MSPyBentleyGeom.MSBsplineCurve, other: MSPyBentleyGeom.MSBsplineCurve, tolerance: float) -> bool
        
        Compare curves.
        """
        ...
    
    def AppendCurve(*args, **kwargs):
        """
        AppendCurve(self: MSPyBentleyGeom.MSBsplineCurve, inCurve: MSPyBentleyGeom.MSBsplineCurve) -> int
        
        Change the B-spline curve by appending a given curve.
        """
        ...
    
    def AppendCurves(*args, **kwargs):
        """
        AppendCurves(self: MSPyBentleyGeom.MSBsplineCurve, inCurve1: MSPyBentleyGeom.MSBsplineCurve, inCurve2: MSPyBentleyGeom.MSBsplineCurve, forceContinuity: bool, reparam: bool) -> int
        
        Create the B-spline curve by appending two input curves with
        continuity and reparameterization constraints.
        """
        ...
    
    def ApproximateAnyCurve(*args, **kwargs):
        """
        ApproximateAnyCurve(self: MSPyBentleyGeom.MSBsplineCurve, inCurve: MSPyBentleyGeom.MSBsplineCurve, tolerance: float, order: int, parameterization: int, bMaintainEndTangents: bool) -> int
        
        This routine computes a B-spline curve approximated the old one.
        return ERROR if no results.
        
        Parameter ``[in]``:
        pIn Input G1 curve.
        
        Parameter ``[in]``:
        tolerance Geometric tolerance, this should be in general the chord
        height tol.
        
        Parameter ``[in]``:
        order Desired degree of the pOut, 4 is recommended.
        
        Parameter ``[in]``:
        parametrization CHORDLENGTH = 2, CENTRIPETAL = 3.
        
        Parameter ``[in]``:
        bMaintainEndTangents true to maintain the end tangents.
        """
        ...
    
    def ApproximateG1Curve(*args, **kwargs):
        """
        ApproximateG1Curve(outCurve: MSPyBentleyGeom.MSBsplineCurve, inCurve: MSPyBentleyGeom.MSBsplineCurve, degree: int, keepTangent: bool, parametrization: int, geomTol: float, paramTol: float, pointTol: float) -> int
        """
        ...
    
    def ApproximateNurbsCurve(*args, **kwargs):
        """
        ApproximateNurbsCurve(outCurve: MSPyBentleyGeom.MSBsplineCurve, inCurve: MSPyBentleyGeom.MSBsplineCurve, degree: int, keepTangent: bool, parametrization: int, tol: float) -> int
        """
        ...
    
    def AreCompatible(*args, **kwargs):
        """
        AreCompatible(curveA: MSPyBentleyGeom.MSBsplineCurve, curveB: MSPyBentleyGeom.MSBsplineCurve) -> bool
        
        <summary>Test if two curves have compatible knots, order, and pole
        count</summary>
        """
        ...
    
    def AreKnotsValid(*args, **kwargs):
        """
        AreKnotsValid(self: MSPyBentleyGeom.MSBsplineCurve, clampingRequired: bool = True) -> bool
        
        Return false if knot counts or values are invalid.
        """
        ...
    
    def AreSameKnots(*args, **kwargs):
        """
        AreSameKnots(knot0: float, knot1: float) -> bool
        
        Compare knots. Absolute tolerance 1e-8 for knots in -1..1. Relative
        tolerance 1e-8 outside.
        """
        ...
    
    def AreSameWeights(*args, **kwargs):
        """
        AreSameWeights(w0: float, w1: float) -> bool
        
        Compare weights with arbitrary but consistent tolerance.
        """
        ...
    
    def CleanKnots(*args, **kwargs):
        """
        CleanKnots(self: MSPyBentleyGeom.MSBsplineCurve) -> int
        
        Clean all unnecessary knots.
        """
        ...
    
    def ClosestPoint(*args, **kwargs):
        """
        ClosestPoint(self: MSPyBentleyGeom.MSBsplineCurve, curvePoint: MSPyBentleyGeom.DPoint3d, spacePoint: MSPyBentleyGeom.DPoint3d) -> float
        """
        ...
    
    def ClosestPointXY(*args, **kwargs):
        """
        ClosestPointXY(self: MSPyBentleyGeom.MSBsplineCurve, curvePoint: MSPyBentleyGeom.DPoint3d, spacePoint: MSPyBentleyGeom.DPoint3d, viewMatrix: MSPyBentleyGeom.DMatrix4d) -> tuple
        """
        ...
    
    def ClosestTangent(*args, **kwargs):
        """
        ClosestTangent(self: MSPyBentleyGeom.MSBsplineCurve, curvePoint: MSPyBentleyGeom.DPoint3d, spacePoint: MSPyBentleyGeom.DPoint3d, biasPoint: MSPyBentleyGeom.DPoint3d) -> tuple
        """
        ...
    
    def ClosestTangentXY(*args, **kwargs):
        """
        ClosestTangentXY(self: MSPyBentleyGeom.MSBsplineCurve, curvePoint: MSPyBentleyGeom.DPoint3d, spacePoint: MSPyBentleyGeom.DPoint3d, biasPoint: MSPyBentleyGeom.DPoint3d, matrix: MSPyBentleyGeom.DMatrix4d) -> tuple
        """
        ...
    
    def CompressKnots(*args, **kwargs):
        """
        CompressKnots(inKnot: MSPyBentley.DoubleArray, order: int, outKnot: MSPyBentley.DoubleArray, multiplicities: MSPyBentley.UInt64Array) -> tuple
        """
        ...
    
    def ComputeDerivatives(*args, **kwargs):
        """
        ComputeDerivatives(self: MSPyBentleyGeom.MSBsplineCurve, dervs: MSPyBentleyGeom.DVec3d, numDervs: int, fractionParameter: float) -> int
        
        Calculate the number of derivatives specified by numDervs of the
        B-spline curve at a particular fraction.
        """
        ...
    
    def ComputeGrevilleAbscissa(*args, **kwargs):
        """
        ComputeGrevilleAbscissa(self: MSPyBentleyGeom.MSBsplineCurve, averageKnots: MSPyBentley.DoubleArray = True) -> None
        """
        ...
    
    def ComputeInflectionPoints(*args, **kwargs):
        """
        ComputeInflectionPoints(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, params: MSPyBentley.DoubleArray) -> int
        
        Calculate the parameters and location of the all inflection points of
        a B-spline curve. @DotNetMethodExclude
        """
        ...
    
    def ComputeInflectionPointsXY(*args, **kwargs):
        """
        ComputeInflectionPointsXY(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, params: MSPyBentley.DoubleArray, transform: Bentley.RotMatrix) -> int
        
        Calculate the parameters and location of the all inflection points of
        a B-spline curve.
        """
        ...
    
    def ComputeUniformKnotGrevilleAbscissa(*args, **kwargs):
        """
        ComputeUniformKnotGrevilleAbscissa(averageKnots: MSPyBentley.DoubleArray, numInterval: int, order: int) -> None
        """
        ...
    
    def ComputeUniformKnots(*args, **kwargs):
        """
        ComputeUniformKnots(self: MSPyBentleyGeom.MSBsplineCurve) -> bool
        
        Compute uniformly spaced knots. This uses counts from params.
        
        Returns:
        false if param counts are not set.
        """
        ...
    
    def CopyClosed(*args, **kwargs):
        """
        CopyClosed(self: MSPyBentleyGeom.MSBsplineCurve, source: MSPyBentleyGeom.MSBsplineCurve) -> int
        
        Create B-spline curve by closing a open B-spline curve.
        """
        ...
    
    def CopyFractionSegment(*args, **kwargs):
        """
        CopyFractionSegment(self: MSPyBentleyGeom.MSBsplineCurve, source: MSPyBentleyGeom.MSBsplineCurve, fractionA: float, fractionB: float) -> int
        
        Create B-spline curve by extracting a part of a B-spline curve.
        """
        ...
    
    def CopyFrom(*args, **kwargs):
        """
        CopyFrom(self: MSPyBentleyGeom.MSBsplineCurve, source: MSPyBentleyGeom.MSBsplineCurve) -> int
        """
        ...
    
    def CopyOpen(*args, **kwargs):
        """
        CopyOpen(self: MSPyBentleyGeom.MSBsplineCurve, source: MSPyBentleyGeom.MSBsplineCurve, unnormalizedKnot: float) -> int
        
        Create B-spline curve by opening a closed B-spline curve.
        """
        ...
    
    def CopyReversed(*args, **kwargs):
        """
        CopyReversed(self: MSPyBentleyGeom.MSBsplineCurve, source: MSPyBentleyGeom.MSBsplineCurve) -> int
        
        Create B-spline curve by reserving the direction of a B-spline curve.
        """
        ...
    
    def CopySegment(*args, **kwargs):
        """
        CopySegment(self: MSPyBentleyGeom.MSBsplineCurve, source: MSPyBentleyGeom.MSBsplineCurve, unnormalizedKnotA: float, unnormalizedKnotB: float) -> int
        
        Create B-spline curve by extracting a part of a B-spline curve.
        """
        ...
    
    def CopyTransformed(*args, **kwargs):
        """
        CopyTransformed(self: MSPyBentleyGeom.MSBsplineCurve, source: MSPyBentleyGeom.MSBsplineCurve, transform: Bentley.Transform) -> int
        
        Create B-spline curve by transforming a B-spline curve.
        """
        ...
    
    def CountDistinctBeziers(*args, **kwargs):
        """
        CountDistinctBeziers(self: MSPyBentleyGeom.MSBsplineCurve) -> int
        
        Count the number of beziers that have non-null knot intervals.
        """
        ...
    
    def Create(*args, **kwargs):
        """
        Create() -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        """
        ...
    
    def CreateCapture(*args, **kwargs):
        """
        CreateCapture(self: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        
        <summary>Copy bits into smart pointer. Caller instance zeroed
        out.<summary>
        """
        ...
    
    def CreateCopy(*args, **kwargs):
        """
        CreateCopy(self: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        
        <summary>Return copy as smart pointer target.</summary>
        """
        ...
    
    def CreateCopyBetweenFractions(*args, **kwargs):
        """
        CreateCopyBetweenFractions(self: MSPyBentleyGeom.MSBsplineCurve, fraction0: float, fraction1: float) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        
        <summary>Copy the portion between specified fractions.</summary>
        """
        ...
    
    def CreateCopyBetweenKnots(*args, **kwargs):
        """
        CreateCopyBetweenKnots(self: MSPyBentleyGeom.MSBsplineCurve, konot0: float, knot1: float) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        
        <summary>Copy the portion between specified knots.</summary>
        """
        ...
    
    def CreateCopyBezier(*args, **kwargs):
        """
        CreateCopyBezier(self: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        
        <summary>Copy with all knots saturated.</summary>
        """
        ...
    
    def CreateCopyClosed(*args, **kwargs):
        """
        CreateCopyClosed(self: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        
        <summary>Return copy as smart pointer target; if physically closed
        revise poles to be a closed bspline</summary>
        """
        ...
    
    def CreateCopyOffsetXY(*args, **kwargs):
        """
        CreateCopyOffsetXY(self: MSPyBentleyGeom.MSBsplineCurve, offset0: float, offset1: float, options: MSPyBentleyGeom.CurveOffsetOptions) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        
        <summary>Copy with offset in XY plane.</summary>
        """
        ...
    
    def CreateCopyOpenAtFraction(*args, **kwargs):
        """
        CreateCopyOpenAtFraction(self: MSPyBentleyGeom.MSBsplineCurve, fraction: float) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        
        <summary>Return copy as smart pointer target; if closed, open it at
        fraction.</summary>
        """
        ...
    
    def CreateCopyOpenAtKnot(*args, **kwargs):
        """
        CreateCopyOpenAtKnot(self: MSPyBentleyGeom.MSBsplineCurve, knot: float) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        
        <summary>Return copy as smart pointer target; if closed, open it at
        knot.</summary>
        """
        ...
    
    def CreateCopyReversed(*args, **kwargs):
        """
        CreateCopyReversed(self: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        
        <summary>Complete copy with reversed parameterization.</summary>
        """
        ...
    
    def CreateCopyTransformed(*args, **kwargs):
        """
        CreateCopyTransformed(self: MSPyBentleyGeom.MSBsplineCurve, transform: Bentley.Transform) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        
        <summary>Copy with transform applied to poles.</summary>
        """
        ...
    
    def CreateFromInterpolationAtBasisFunctionPeaks(*args, **kwargs):
        """
        CreateFromInterpolationAtBasisFunctionPeaks(xyz: MSPyBentleyGeom.DPoint3dArray, order: int, selector: int = 0) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        """
        ...
    
    def CreateFromInterpolationAtGrevilleKnots(*args, **kwargs):
        """
        CreateFromInterpolationAtGrevilleKnots(curve: MSPyBentleyGeom.ICurvePrimitive, numPoles: int, order: int, normalizeKnots: bool, knotSelector: int = 0) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        """
        ...
    
    def CreateFromInterpolationPointsWithKnots(*args, **kwargs):
        """
        CreateFromInterpolationPointsWithKnots(xyz: MSPyBentleyGeom.DPoint3dArray, interpolationKnots: MSPyBentley.DoubleArray, curveKnots: MSPyBentley.DoubleArray, order: int) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        """
        ...
    
    def CreateFromPointsAndOrder(*args, **kwargs):
        """
        CreateFromPointsAndOrder(self: MSPyBentleyGeom.MSBsplineCurve, pointArray: MSPyBentleyGeom.DPoint3dArray, order: int, closed: bool = False) -> int
        
        Create the B-spline curve from point array and order.
        """
        ...
    
    def CreateFromPolesAndOrder(*args, **kwargs):
        """
        CreateFromPolesAndOrder(poles: MSPyBentleyGeom.DPoint3dArray, weights: MSPyBentley.DoubleArray, knots: MSPyBentley.DoubleArray, order: int, closed: bool, inputPolesAlreadyWeighted: bool = True) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        """
        ...
    
    def CreateInterpolationBetweenCurves(*args, **kwargs):
        """
        CreateInterpolationBetweenCurves(curveA: MSPyBentleyGeom.MSBsplineCurve, fraction: float, curveB: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        
        <summary>Create a curve whose poles are interpolated between the poles
        of two curves.</summary> <remarks>This will only succeed if the curves
        have the same pole, knot, and order structure</remarks>
        """
        ...
    
    @property
    def CurveDisplay(arg0: MSPyBentleyGeom.MSBsplineCurve) -> bool:
        ...
    @CurveDisplay.setter
    def CurveDisplay(arg0: MSPyBentleyGeom.MSBsplineCurve, arg1: bool) -> None:
        ...
    
    def ElevateDegree(*args, **kwargs):
        """
        ElevateDegree(self: MSPyBentleyGeom.MSBsplineCurve, newDegree: int) -> int
        
        Elevate the degree (increases the order) of the B-spline curve.
        """
        ...
    
    def ExtractCurveNormal(*args, **kwargs):
        """
        ExtractCurveNormal(self: MSPyBentleyGeom.MSBsplineCurve, normal: MSPyBentleyGeom.DVec3d, position: MSPyBentleyGeom.DPoint3d) -> tuple
        """
        ...
    
    def ExtractEndPoints(*args, **kwargs):
        """
        ExtractEndPoints(self: MSPyBentleyGeom.MSBsplineCurve, start: MSPyBentleyGeom.DPoint3d, end: MSPyBentleyGeom.DPoint3d) -> None
        
        Extract the start or end point of the B-spline curve.
        """
        ...
    
    def ExtractSegmentBetweenKnots(*args, **kwargs):
        """
        ExtractSegmentBetweenKnots(self: MSPyBentleyGeom.MSBsplineCurve, target: MSPyBentleyGeom.MSBsplineCurve, unnormalizedKnotA: float, unnormalizedKnotB: float) -> int
        
        Exteact the curve from the B-spline curve at the interval
        [unnormalizedKnotA, unnormalizedKnotB].
        """
        ...
    
    def ExtractTo(*args, **kwargs):
        """
        ExtractTo(self: MSPyBentleyGeom.MSBsplineCurve, dest: MSPyBentleyGeom.MSBsplineCurve) -> None
        
        Copy bits into simple structure. Caller instance zeroed.
        """
        ...
    
    def FindKnotInterval(*args, **kwargs):
        """
        FindKnotInterval(self: MSPyBentleyGeom.MSBsplineCurve, knotValue: float) -> int
        
        Return the index of the knot at the left of the interval containing
        specified knot. When knotValue exactly matches a knot, the returned
        index is of the knot to the left - i.e. knotValue appears at the RIGHT
        of the returned interval. (favor knot[index]<knotValue <= knot[index
        + 1])
        """
        ...
    
    def FractionAtSignedDistance(*args, **kwargs):
        """
        FractionAtSignedDistance(*args, **kwargs)
        Overloaded function.
        
        1. FractionAtSignedDistance(self: MSPyBentleyGeom.MSBsplineCurve, startParam: float, signedDistance: float) -> tuple
        
        2. FractionAtSignedDistance(self: MSPyBentleyGeom.MSBsplineCurve, worldToLocal: Bentley.RotMatrix, startParam: float, signedDistance: float) -> tuple
        """
        ...
    
    def FractionToKnot(*args, **kwargs):
        """
        FractionToKnot(self: MSPyBentleyGeom.MSBsplineCurve, f: float) -> float
        
        Return the knot value at a fractional parameter ...
        """
        ...
    
    def FractionToPoint(*args, **kwargs):
        """
        FractionToPoint(*args, **kwargs)
        Overloaded function.
        
        1. FractionToPoint(self: MSPyBentleyGeom.MSBsplineCurve, xyz: MSPyBentleyGeom.DPoint3d, f: float) -> None
        
        2. FractionToPoint(self: MSPyBentleyGeom.MSBsplineCurve, xyz: MSPyBentleyGeom.DPoint3d, tangent: MSPyBentleyGeom.DVec3d, f: float) -> None
        
        3. FractionToPoint(self: MSPyBentleyGeom.MSBsplineCurve, xyz: MSPyBentleyGeom.DPoint3d, tangent: MSPyBentleyGeom.DVec3d, f: float) -> float
        
        4. FractionToPoint(self: MSPyBentleyGeom.MSBsplineCurve, xyz: MSPyBentleyGeom.DPoint3d, dXYZ: MSPyBentleyGeom.DVec3d, ddXYZ: MSPyBentleyGeom.DVec3d, f: float) -> None
        """
        ...
    
    def FractionToPoints(*args, **kwargs):
        """
        FractionToPoints(*args, **kwargs)
        Overloaded function.
        
        1. FractionToPoints(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, numPoints: int) -> None
        
        2. FractionToPoints(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, fractions: MSPyBentley.DoubleArray) -> None
        """
        ...
    
    def GeneralLeastSquaresApproximation(*args, **kwargs):
        """
        GeneralLeastSquaresApproximation(outCurve: MSPyBentleyGeom.MSBsplineCurve, Q: MSPyBentleyGeom.DPoint3dArray, u: MSPyBentley.DoubleArray, knots: MSPyBentley.DoubleArray, numPoles: int, order: int) -> int
        """
        ...
    
    def GetBezier(*args, **kwargs):
        """
        GetBezier(self: MSPyBentleyGeom.MSBsplineCurve, segment: MSPyBentleyGeom.BCurveSegment, bezierSelect: int) -> bool
        
        Get poles for a single bezier poles from the curve. return false if
        invalid bezierSelect. Note that the bezierSelect for a high
        multiplicity knot returns true for the function but marks the interval
        as null. Normal usage is to loop over all beziers in a bspline but
        skip processing the null intervals.
        
        Parameter ``[out]``:
        segment a filled BCurveSegment.
        
        Parameter ``[in]``:
        bezierSelect selects a bezier interval within the bspline
        @DotNetMethodExclude
        """
        ...
    
    def GetC1DiscontinuousCurves(*args, **kwargs):
        """
        GetC1DiscontinuousCurves(self: MSPyBentleyGeom.MSBsplineCurve, fractions: MSPyBentley.DoubleArray, curves: MSPyBentleyGeom.MSBsplineCurvePtrArray) -> None
        
        Create copies of each segment with breaks at point or tangent changes.
        """
        ...
    
    def GetC1DiscontinuousFractions(*args, **kwargs):
        """
        GetC1DiscontinuousFractions(self: MSPyBentleyGeom.MSBsplineCurve, fractions: MSPyBentley.DoubleArray) -> None
        
        Get all C1 fractional Discontinuities. This inspects xyz and tangent
        at each knot break. (It does not look for intraknot cusps)
        @DotNetMethodExclude
        """
        ...
    
    def GetCurveDisplay(*args, **kwargs):
        """
        GetCurveDisplay(self: MSPyBentleyGeom.MSBsplineCurve) -> bool
        
        Return curve display flag.
        """
        ...
    
    def GetDisjointCurves(*args, **kwargs):
        """
        GetDisjointCurves(self: MSPyBentleyGeom.MSBsplineCurve, curves: MSPyBentleyGeom.MSBsplineCurvePtrArray) -> None
        
        Create copies of each segment with breaks at disjoint knot points.
        """
        ...
    
    def GetFrenetFrame(*args, **kwargs):
        """
        GetFrenetFrame(*args, **kwargs)
        Overloaded function.
        
        1. GetFrenetFrame(self: MSPyBentleyGeom.MSBsplineCurve, frame: MSPyBentleyGeom.DVec3d, point: MSPyBentleyGeom.DPoint3d, u: float) -> tuple
        
        2. GetFrenetFrame(self: MSPyBentleyGeom.MSBsplineCurve, frame: Bentley.Transform, u: float) -> int
        """
        ...
    
    def GetKnot(*args, **kwargs):
        """
        GetKnot(self: MSPyBentleyGeom.MSBsplineCurve, index: int) -> float
        
        return knot by index. returns 0 if out of range. (Use
        NumberAllocatedKnots to determine index range).
        """
        ...
    
    def GetKnotP(*args, **kwargs):
        """
        GetKnotP(self: MSPyBentleyGeom.MSBsplineCurve) -> float
        
        return pointer to contiguous knots. @DotNetMethodExclude
        """
        ...
    
    def GetKnotRange(*args, **kwargs):
        """
        GetKnotRange(*args, **kwargs)
        Overloaded function.
        
        1. GetKnotRange(self: MSPyBentleyGeom.MSBsplineCurve) -> tuple
        
        2. GetKnotRange(self: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.DSegment1d
        
        Return the knot values corresponding to fraction 0 and fraction 1 ...
        """
        ...
    
    def GetKnots(*args, **kwargs):
        """
        GetKnots(*args, **kwargs)
        Overloaded function.
        
        1. GetKnots(self: MSPyBentleyGeom.MSBsplineCurve, outData: MSPyBentley.DoubleArray) -> None
        
        Copy all knots out into caller array.
        
        2. GetKnots(self: MSPyBentleyGeom.MSBsplineCurve, outData: MSPyBentleyGeom.DPoint4dArray) -> None
        
        Copy all knots out into caller array.
        """
        ...
    
    def GetNumKnots(*args, **kwargs):
        """
        GetNumKnots(self: MSPyBentleyGeom.MSBsplineCurve) -> int
        """
        ...
    
    def GetNumPoles(*args, **kwargs):
        """
        GetNumPoles(self: MSPyBentleyGeom.MSBsplineCurve) -> int
        """
        ...
    
    def GetOrder(*args, **kwargs):
        """
        GetOrder(self: MSPyBentleyGeom.MSBsplineCurve) -> int
        """
        ...
    
    def GetPole(*args, **kwargs):
        """
        GetPole(self: MSPyBentleyGeom.MSBsplineCurve, index: int) -> MSPyBentleyGeom.DPoint3d
        """
        ...
    
    def GetPoleDPoint4d(*args, **kwargs):
        """
        GetPoleDPoint4d(self: MSPyBentleyGeom.MSBsplineCurve, index: int) -> MSPyBentleyGeom.DPoint4d
        
        return pole by index. returns 0 point if out of range. (Use
        NumberAllocatedPoles to determine index range). @DotNetMethodExclude
        """
        ...
    
    def GetPoleP(*args, **kwargs):
        """
        GetPoleP(self: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.DPoint3d
        
        return pointer to contiguous poles. @DotNetMethodExclude
        """
        ...
    
    def GetPoleRange(*args, **kwargs):
        """
        GetPoleRange(self: MSPyBentleyGeom.MSBsplineCurve, range: MSPyBentleyGeom.DRange3d) -> None
        
        Get the range of the poles of the B-spline curve.
        """
        ...
    
    def GetPoles(*args, **kwargs):
        """
        GetPoles(self: MSPyBentleyGeom.MSBsplineCurve, outData: MSPyBentleyGeom.DPoint3dArray) -> None
        
        Copy all poles out into caller array.
        """
        ...
    
    def GetPolygonDisplay(*args, **kwargs):
        """
        GetPolygonDisplay(self: MSPyBentleyGeom.MSBsplineCurve) -> bool
        
        Return polygon display flag.
        """
        ...
    
    def GetRange(*args, **kwargs):
        """
        GetRange(self: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.DRange3d
        
        Get the range of the B-spline curve.
        """
        ...
    
    def GetRangeOfProjectionOnRay(*args, **kwargs):
        """
        GetRangeOfProjectionOnRay(self: MSPyBentleyGeom.MSBsplineCurve, ray: MSPyBentleyGeom.DRay3d, fraction0: float = 0.0, fraction1: float = 1.0) -> MSPyBentleyGeom.DRange1d
        
        Get the range of parameters of the projection of (a fractional portion
        of the curve onto a ray return range whose low and high values are the
        extreme parameters (in ray fractions) of the projection of the curve
        onto the ray.
        
        Parameter ``[in]``:
        ray ray to project to
        
        Parameter ``[in]``:
        fraction0 start of active part of the curve
        
        Parameter ``[in]``:
        fraction1 end of active part of the curve
        """
        ...
    
    def GetRemovalKnotBound(*args, **kwargs):
        """
        GetRemovalKnotBound(curve: MSPyBentleyGeom.MSBsplineCurve, r: int, s: int) -> float
        
        Compute the bound of remove r-th knot s times
        """
        ...
    
    def GetReversePole(*args, **kwargs):
        """
        GetReversePole(self: MSPyBentleyGeom.MSBsplineCurve, index: int) -> MSPyBentleyGeom.DPoint3d
        
        return pole by index, counting from the last pole . (i.e. index 0 is
        the final weight) Returns 0 point if out of range. (Use
        NumberAllocatedPoles to determine index range). @DotNetMethodExclude
        """
        ...
    
    def GetReverseWeight(*args, **kwargs):
        """
        GetReverseWeight(self: MSPyBentleyGeom.MSBsplineCurve, index: int) -> float
        
        return weight by index, counting from the last weight. (i.e. index 0
        is the final weight) Returns 1.0 if out of range. (Use
        NumberAllocatedPoles to determine index range). @DotNetMethodExclude
        """
        ...
    
    def GetStrokeCount(*args, **kwargs):
        """
        GetStrokeCount(self: MSPyBentleyGeom.MSBsplineCurve, chordTol: float, angleTol: float, maxEdgeLength: float) -> int
        
        Compute stroke count
        """
        ...
    
    def GetTailBezierSelect(*args, **kwargs):
        """
        GetTailBezierSelect(self: MSPyBentleyGeom.MSBsplineCurve) -> int
        
        return an index to use to start " Retreat " order bezier access.
        """
        ...
    
    def GetUnWeightedPole(*args, **kwargs):
        """
        GetUnWeightedPole(self: MSPyBentleyGeom.MSBsplineCurve, index: int, reverse: bool = False) -> MSPyBentleyGeom.DPoint3d
        
        return pole by index. returns 0 point if out of range. If spline is
        weighted, the weight is divided out. If weight zero, no division
        happens. (Use NumberAllocatedPoles to determine index range).
        @DotNetMethodExclude
        """
        ...
    
    def GetUnWeightedPoles(*args, **kwargs):
        """
        GetUnWeightedPoles(self: MSPyBentleyGeom.MSBsplineCurve, outData: MSPyBentleyGeom.DPoint3dArray) -> None
        
        Copy all poles out into caller array, dividing each by its weight
        """
        ...
    
    def GetWeight(*args, **kwargs):
        """
        GetWeight(self: MSPyBentleyGeom.MSBsplineCurve, arg0: int) -> float
        
        index
        """
        ...
    
    def GetWeightP(*args, **kwargs):
        """
        GetWeightP(self: MSPyBentleyGeom.MSBsplineCurve) -> float
        
        return pointer to contiguous weights @DotNetMethodExclude
        """
        ...
    
    def GetWeightRange(*args, **kwargs):
        """
        GetWeightRange(self: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.DRange1d
        """
        ...
    
    def GetWeights(*args, **kwargs):
        """
        GetWeights(self: MSPyBentleyGeom.MSBsplineCurve, outData: MSPyBentley.DoubleArray) -> None
        
        Copy all weights out into caller array.
        """
        ...
    
    def HasValidCountsAndAllocations(*args, **kwargs):
        """
        HasValidCountsAndAllocations(self: MSPyBentleyGeom.MSBsplineCurve) -> bool
        """
        ...
    
    def HasValidKnotAllocation(*args, **kwargs):
        """
        HasValidKnotAllocation(self: MSPyBentleyGeom.MSBsplineCurve) -> bool
        """
        ...
    
    def HasValidOrder(*args, **kwargs):
        """
        HasValidOrder(self: MSPyBentleyGeom.MSBsplineCurve) -> bool
        """
        ...
    
    def HasValidPoleAllocation(*args, **kwargs):
        """
        HasValidPoleAllocation(self: MSPyBentleyGeom.MSBsplineCurve) -> bool
        """
        ...
    
    def HasValidPoleCounts(*args, **kwargs):
        """
        HasValidPoleCounts(self: MSPyBentleyGeom.MSBsplineCurve) -> bool
        """
        ...
    
    def HasValidWeightAllocation(*args, **kwargs):
        """
        HasValidWeightAllocation(self: MSPyBentleyGeom.MSBsplineCurve) -> bool
        """
        ...
    
    def HasWeights(*args, **kwargs):
        """
        HasWeights(self: MSPyBentleyGeom.MSBsplineCurve) -> bool
        
        Check whether the B-spline curve has stored weights (This does not
        check if any are other than 1.0)
        """
        ...
    
    def InitAkima(*args, **kwargs):
        """
        InitAkima(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, compressPoints: bool) -> None
        """
        ...
    
    def InitEllipticArc(*args, **kwargs):
        """
        InitEllipticArc(self: MSPyBentleyGeom.MSBsplineCurve, center: MSPyBentleyGeom.DPoint3d, rX: float, rY: float, startRadians: float = 0.0, sweepRadians: float = 6.283185307179586, axes: Bentley.RotMatrix = None) -> int
        """
        ...
    
    def InitFromBeziers(*args, **kwargs):
        """
        InitFromBeziers(self: MSPyBentleyGeom.MSBsplineCurve, beziers: MSPyBentleyGeom.MSBsplineCurveArray) -> int
        
        Create a B-spline curve from a series of Bezier curve.
        """
        ...
    
    def InitFromDEllipse3d(*args, **kwargs):
        """
        InitFromDEllipse3d(self: MSPyBentleyGeom.MSBsplineCurve, ellipse: MSPyBentleyGeom.DEllipse3d) -> int
        
        Initialize the B-spline curve for an ellipse.
        """
        ...
    
    def InitFromDPoint4dArray(*args, **kwargs):
        """
        InitFromDPoint4dArray(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint4dArray, order: int) -> None
        """
        ...
    
    def InitFromGeneralLeastSquares(*args, **kwargs):
        """
        InitFromGeneralLeastSquares(self: MSPyBentleyGeom.MSBsplineCurve, avgDistance: float, maxDistance: float, info: MSPyBentleyGeom.BsplineParam, knts: MSPyBentley.DoubleArray, pnts: MSPyBentleyGeom.DPoint3d, uValues: float, numPnts: int) -> int
        """
        ...
    
    def InitFromInterpolatePoints(*args, **kwargs):
        """
        InitFromInterpolatePoints(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3d, numPoints: int, parameterization: int, endControl: bool, sTangent: MSPyBentleyGeom.DVec3d, eTangent: MSPyBentleyGeom.DVec3d, keepTanMag: bool, order: int) -> int
        """
        ...
    
    def InitFromLeastSquaresFit(*args, **kwargs):
        """
        InitFromLeastSquaresFit(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3d, numPoints: int, endControl: bool, sTangent: MSPyBentleyGeom.DVec3d, eTangent: MSPyBentleyGeom.DVec3d, keepTanMag: bool, iterDegree: int, reqDegree: int, singleKnot: bool, tolerance: float) -> int
        """
        ...
    
    def InitFromPoints(*args, **kwargs):
        """
        InitFromPoints(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray) -> None
        """
        ...
    
    def IsClosed(*args, **kwargs):
        """
        IsClosed(self: MSPyBentleyGeom.MSBsplineCurve) -> bool
        
        Check whether the B-spline curve is periodic.
        """
        ...
    
    def IsParabola(*args, **kwargs):
        """
        IsParabola(self: MSPyBentleyGeom.MSBsplineCurve, localToWorld: Bentley.Transform, worldToLocal: Bentley.Transform, localStart: MSPyBentleyGeom.DPoint3d, localEnd: MSPyBentleyGeom.DPoint3d) -> tuple
        """
        ...
    
    def IsPhysicallyClosed(*args, **kwargs):
        """
        IsPhysicallyClosed(self: MSPyBentleyGeom.MSBsplineCurve, tolerance: float) -> bool
        
        Check whether the B-spline curve is physically closed. A B-spline
        curve may be non-periodic, but still return true if its first and last
        poles coincide.
        """
        ...
    
    def IsSameGeometry(*args, **kwargs):
        """
        IsSameGeometry(self: MSPyBentleyGeom.MSBsplineCurve, other: MSPyBentleyGeom.MSBsplineCurve) -> bool
        
        Check if the B-spline curves has same parameters with the given curve.
        """
        ...
    
    class KnotPosition:
        """
        Members:
        
        eKNOTPOS_BEFORE_START
        
        eKNOTPOS_START
        
        eKNOTPOS_INTERVAL
        
        eKNOTPOS_INTERIOR
        
        eKNOTPOS_FINAL
        
        eKNOTPOS_AFTER_FINAL
        """
    
        def __init__(self: MSPyBentleyGeom.MSBsplineCurve.KnotPosition, value: int) -> None:
            ...
        
        eKNOTPOS_AFTER_FINAL: KnotPosition
        
        eKNOTPOS_BEFORE_START: KnotPosition
        
        eKNOTPOS_FINAL: KnotPosition
        
        eKNOTPOS_INTERIOR: KnotPosition
        
        eKNOTPOS_INTERVAL: KnotPosition
        
        eKNOTPOS_START: KnotPosition
        
        @property
        def name(self: handle) -> str:
            ...
        
        @property
        def value(arg0: MSPyBentleyGeom.MSBsplineCurve.KnotPosition) -> int:
            ...
        
    def KnotRefinement(*args, **kwargs):
        """
        KnotRefinement(X: MSPyBentley.DoubleArray, curve: MSPyBentleyGeom.MSBsplineCurve) -> int
        """
        ...
    
    def KnotToBlendFunctions(*args, **kwargs):
        """
        KnotToBlendFunctions(self: MSPyBentleyGeom.MSBsplineCurve, blend: float, blendDerivatives: float, u: float) -> int
        """
        ...
    
    def KnotToFraction(*args, **kwargs):
        """
        KnotToFraction(self: MSPyBentleyGeom.MSBsplineCurve, knot: float) -> float
        
        Return the fractional parameter corresponding to a knot value ...
        """
        ...
    
    def Length(*args, **kwargs):
        """
        Length(*args, **kwargs)
        Overloaded function.
        
        1. Length(self: MSPyBentleyGeom.MSBsplineCurve) -> float
        
        compute the length of the B-spline curve.
        
        2. Length(self: MSPyBentleyGeom.MSBsplineCurve, worldToLocal: Bentley.RotMatrix) -> float
        
        compute the length of the B-spline curve.
        """
        ...
    
    def LengthBetweenFractions(*args, **kwargs):
        """
        LengthBetweenFractions(*args, **kwargs)
        Overloaded function.
        
        1. LengthBetweenFractions(self: MSPyBentleyGeom.MSBsplineCurve, startKnot: float, endKnot: float) -> float
        
        2. LengthBetweenFractions(self: MSPyBentleyGeom.MSBsplineCurve, worldToLocal: Bentley.RotMatrix, startKnot: float, endKnot: float) -> float
        """
        ...
    
    def LengthBetweenKnots(*args, **kwargs):
        """
        LengthBetweenKnots(*args, **kwargs)
        Overloaded function.
        
        1. LengthBetweenKnots(self: MSPyBentleyGeom.MSBsplineCurve, startKnot: float, endKnot: float) -> float
        
        2. LengthBetweenKnots(self: MSPyBentleyGeom.MSBsplineCurve, worldToLocal: Bentley.RotMatrix, startKnot: float, endKnot: float) -> float
        """
        ...
    
    def MakeBezier(*args, **kwargs):
        """
        MakeBezier(self: MSPyBentleyGeom.MSBsplineCurve, bezierCurve: MSPyBentleyGeom.MSBsplineCurve) -> int
        
        Create equivalent Bezier curve for the B-spline curve.
        """
        ...
    
    def MakeBeziers(*args, **kwargs):
        """
        MakeBeziers(self: MSPyBentleyGeom.MSBsplineCurve, beziers: MSPyBentleyGeom.MSBsplineCurveArray) -> int
        
        Create a series of Bezier curve for the B-spline curve.
        @DotNetMethodExclude
        """
        ...
    
    def MakeClosed(*args, **kwargs):
        """
        MakeClosed(self: MSPyBentleyGeom.MSBsplineCurve) -> int
        
        Close the open B-spline curve.
        """
        ...
    
    def MakeOpen(*args, **kwargs):
        """
        MakeOpen(self: MSPyBentleyGeom.MSBsplineCurve, u: float) -> int
        
        Open the closed B-spline curve.
        """
        ...
    
    def MakeRational(*args, **kwargs):
        """
        MakeRational(self: MSPyBentleyGeom.MSBsplineCurve) -> int
        
        Make an equivalent rational B-spline curve.
        """
        ...
    
    def MakeReversed(*args, **kwargs):
        """
        MakeReversed(self: MSPyBentleyGeom.MSBsplineCurve) -> int
        
        Reverse the direction of the B-spline curve.
        """
        ...
    
    def MapFractions(*args, **kwargs):
        """
        MapFractions(params: MSPyBentley.DoubleArray, derivatives: MSPyBentleyGeom.DVec3dArray, i0: int, knot0: float, knot1: float, select: MSPyBentleyGeom.CurveParameterMapping, curve: MSPyBentleyGeom.MSBsplineCurve) -> None
        """
        ...
    
    def MapKnots(*args, **kwargs):
        """
        MapKnots(self: MSPyBentleyGeom.MSBsplineCurve, a: float, b: float) -> bool
        
        rewrite knot values in a..b. Return true if a,b and current start,end
        define a valid scale factor
        """
        ...
    
    def NormalizeKnots(*args, **kwargs):
        """
        NormalizeKnots(self: MSPyBentleyGeom.MSBsplineCurve) -> None
        
        Normalize knots to 01
        """
        ...
    
    def PointsAtUniformArcLength(*args, **kwargs):
        """
        PointsAtUniformArcLength(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, fractions: MSPyBentley.DoubleArray, numPoints: int) -> bool
        
        Compute points at uniform arclength steps.
        
        Parameter ``[out]``:
        points array to receive points.
        
        Parameter ``[out]``:
        fractions array to receive fractions.
        
        Parameter ``[in]``:
        numPoints number of points.
        """
        ...
    
    def PointsAtUniformFractions(*args, **kwargs):
        """
        PointsAtUniformFractions(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, fractions: MSPyBentley.DoubleArray, numPoints: int) -> None
        
        Compute strokes at uniform fraction step.
        
        Parameter ``[out]``:
        points array to receive points.
        
        Parameter ``[out]``:
        fractions array to receive fractions.
        
        Parameter ``[in]``:
        numPoints number of points.
        """
        ...
    
    @property
    def PolygonDisplay(arg0: MSPyBentleyGeom.MSBsplineCurve) -> bool:
        ...
    @PolygonDisplay.setter
    def PolygonDisplay(arg0: MSPyBentleyGeom.MSBsplineCurve, arg1: bool) -> None:
        ...
    
    def PolygonLength(*args, **kwargs):
        """
        PolygonLength(self: MSPyBentleyGeom.MSBsplineCurve) -> float
        
        Compute the length of the control polygon of the B-spline curve.
        """
        ...
    
    def Populate(*args, **kwargs):
        """
        Populate(self: MSPyBentleyGeom.MSBsplineCurve, pointVector: MSPyBentleyGeom.DPoint3dArray, weightVector: MSPyBentley.DoubleArray, knotVector: MSPyBentley.DoubleArray, order: int, closed: bool, inputPolesAlreadyWeighted: bool) -> int
        """
        ...
    
    def ProjectToZFocalPlane(*args, **kwargs):
        """
        ProjectToZFocalPlane(self: MSPyBentleyGeom.MSBsplineCurve, focalLength: float) -> None
        
        convert to a weighted curve whose normalized points fall on a focal
        plane
        """
        ...
    
    @property
    def Range(arg0: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.DRange3d:
        ...
    
    def ReleaseMem(*args, **kwargs):
        """
        ReleaseMem(self: MSPyBentleyGeom.MSBsplineCurve) -> None
        
        Free memory allocated for the poles, weights and knot vector of a
        B-spline curve.
        """
        ...
    
    def RemoveKnotsBounded(*args, **kwargs):
        """
        RemoveKnotsBounded(self: MSPyBentleyGeom.MSBsplineCurve, tol: float, startPreservation: int, endPreservation: int) -> int
        
        Remove all removable knots with the tolerance and end condition
        constraints.
        """
        ...
    
    def Resolution(*args, **kwargs):
        """
        Resolution(*args, **kwargs)
        Overloaded function.
        
        1. Resolution(self: MSPyBentleyGeom.MSBsplineCurve) -> float
        
        Get a (fairly tight) tolerance for the B-spline curve.
        
        2. Resolution(self: MSPyBentleyGeom.MSBsplineCurve, abstol: float, reltol: float) -> float
        
        Get a (fairly tight) tolerance for the B-spline curve.
        """
        ...
    
    def RetreatToBezierInKnotInterval(*args, **kwargs):
        """
        RetreatToBezierInKnotInterval(self: MSPyBentleyGeom.MSBsplineCurve, segment: MSPyBentleyGeom.BCurveSegment, interval: MSPyBentleyGeom.DRange1d) -> tuple
        """
        ...
    
    def RotateCurve(*args, **kwargs):
        """
        RotateCurve(self: MSPyBentleyGeom.MSBsplineCurve, rMatrix: Bentley.RotMatrix) -> int
        
        Rotate the B-spline curve.
        """
        ...
    
    def RuledSurfaceClosestPoint(*args, **kwargs):
        """
        RuledSurfaceClosestPoint(pickData: MSPyBentleyGeom.SolidLocationDetail, curveA: MSPyBentleyGeom.MSBsplineCurve, curveB: MSPyBentleyGeom.MSBsplineCurve, spacePoint: MSPyBentleyGeom.DPoint3d) -> bool
        """
        ...
    
    def SampleG1CurveByPoints(*args, **kwargs):
        """
        SampleG1CurveByPoints(P: MSPyBentleyGeom.DPoint3dArray, up: MSPyBentley.DoubleArray, uq: MSPyBentley.DoubleArray, curve: MSPyBentleyGeom.MSBsplineCurve, par: int, Eg: float, ptol: float) -> int
        """
        ...
    
    def SearchKnot(*args, **kwargs):
        """
        SearchKnot(self: MSPyBentleyGeom.MSBsplineCurve, unnormalizedKnotValue: float) -> tuple
        """
        ...
    
    def SegmentAkimaCurve(*args, **kwargs):
        """
        SegmentAkimaCurve(self: MSPyBentleyGeom.MSBsplineCurve, segment: MSPyBentleyGeom.DPoint3dArray, akimaCurve: MSPyBentleyGeom.DPoint3dArray, transform: Bentley.Transform, param0: float, param1: float, tolerance: float = -1.0) -> bool
        """
        ...
    
    def SetCurveDisplay(*args, **kwargs):
        """
        SetCurveDisplay(self: MSPyBentleyGeom.MSBsplineCurve, value: bool) -> None
        
        Set the curve display flag.
        """
        ...
    
    def SetKnot(*args, **kwargs):
        """
        SetKnot(self: MSPyBentleyGeom.MSBsplineCurve, index: int, value: float) -> bool
        
        set weight by index. returns false if index out of range.
        @DotNetMethodExclude
        """
        ...
    
    def SetKnots(*args, **kwargs):
        """
        SetKnots(self: MSPyBentleyGeom.MSBsplineCurve, index: int, value: float, n: int) -> bool
        
        set weight by index. returns false if index out of range.
        @DotNetMethodExclude
        """
        ...
    
    def SetPole(*args, **kwargs):
        """
        SetPole(*args, **kwargs)
        Overloaded function.
        
        1. SetPole(self: MSPyBentleyGeom.MSBsplineCurve, index: int, value: MSPyBentleyGeom.DPoint3d) -> bool
        
        set pole by index. returns false if index out of range.
        @DotNetMethodExclude
        
        2. SetPole(self: MSPyBentleyGeom.MSBsplineCurve, index: int, x: float, y: float, z: float) -> bool
        
        set pole by index. returns false if index out of range.
        @DotNetMethodExclude
        """
        ...
    
    def SetPoles(*args, **kwargs):
        """
        SetPoles(self: MSPyBentleyGeom.MSBsplineCurve, index: int, value: MSPyBentleyGeom.DPoint3d, n: int) -> bool
        
        set pole by index. returns false if index out of range.
        @DotNetMethodExclude
        """
        ...
    
    def SetPolygonDisplay(*args, **kwargs):
        """
        SetPolygonDisplay(self: MSPyBentleyGeom.MSBsplineCurve, value: bool) -> None
        
        Set the polygon display flag.
        """
        ...
    
    def SetReWeightedPole(*args, **kwargs):
        """
        SetReWeightedPole(self: MSPyBentleyGeom.MSBsplineCurve, index: int, value: MSPyBentleyGeom.DPoint3d, reverse: bool = False) -> bool
        
        set pole by index. returns false if index out of range. If the curve
        is weighted, the current weight is multiplied into the input pole.
        @DotNetMethodExclude
        """
        ...
    
    def SetWeight(*args, **kwargs):
        """
        SetWeight(self: MSPyBentleyGeom.MSBsplineCurve, index: int, value: float) -> bool
        
        set weight by index. returns false if index out of range.
        @DotNetMethodExclude
        """
        ...
    
    def SetWeights(*args, **kwargs):
        """
        SetWeights(self: MSPyBentleyGeom.MSBsplineCurve, index: int, value: float, n: int) -> bool
        
        set weight by index. returns false if index out of range.
        @DotNetMethodExclude
        """
        ...
    
    def SwapContents(*args, **kwargs):
        """
        SwapContents(self: MSPyBentleyGeom.MSBsplineCurve, other: MSPyBentleyGeom.MSBsplineCurve) -> None
        
        Exchange all bits with other. Usually used to transfer poles etc and
        leave zeros behind.
        """
        ...
    
    def TransformCurve(*args, **kwargs):
        """
        TransformCurve(self: MSPyBentleyGeom.MSBsplineCurve, transform: Bentley.Transform) -> int
        
        Transform the B-spline curve.
        """
        ...
    
    def TransformCurve4d(*args, **kwargs):
        """
        TransformCurve4d(self: MSPyBentleyGeom.MSBsplineCurve, transform4d: MSPyBentleyGeom.DMatrix4d) -> int
        
        Transform the B-spline curve using a 4d transformation.
        """
        ...
    
    def TransformPoles(*args, **kwargs):
        """
        TransformPoles(*args, **kwargs)
        Overloaded function.
        
        1. TransformPoles(self: MSPyBentleyGeom.MSBsplineCurve, transform: Bentley.Transform, index: int, n: int) -> None
        
        Apply a transform to a single pole.
        
        2. TransformPoles(self: MSPyBentleyGeom.MSBsplineCurve, transform: Bentley.Transform, index: int, n: int) -> None
        
        Apply a transform to a single pole.
        """
        ...
    
    def UnWeightPoles(*args, **kwargs):
        """
        UnWeightPoles(self: MSPyBentleyGeom.MSBsplineCurve) -> None
        
        if the curve is rational, divide (wx,wy,wz) style poles by the weights
        """
        ...
    
    def WeightPoles(*args, **kwargs):
        """
        WeightPoles(self: MSPyBentleyGeom.MSBsplineCurve) -> None
        
        if the curve is rational, multiply (wx,wy,wz) style poles by the
        weights
        """
        ...
    
    def WeightedLeastSquaresFit(*args, **kwargs):
        """
        WeightedLeastSquaresFit(outCurve: MSPyBentleyGeom.MSBsplineCurve, Q: MSPyBentleyGeom.DPoint3dArray, u: MSPyBentley.DoubleArray, endControl: bool, sTangent: MSPyBentleyGeom.DVec3d, eTangent: MSPyBentleyGeom.DVec3d, numPoles: int, order: int) -> int
        """
        ...
    
    def WireCentroid(*args, **kwargs):
        """
        WireCentroid(self: MSPyBentleyGeom.MSBsplineCurve, centroid: MSPyBentleyGeom.DPoint3d, fraction0: float, fraction1: float) -> float
        """
        ...
    
    def Zero(*args, **kwargs):
        """
        Zero(self: MSPyBentleyGeom.MSBsplineCurve) -> None
        
        <summary>Zero out the curve. This is customarily applied immediately
        after allocation on stack or heap. This does NOT free memory from
        prior contents. </summary>
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    
    @property
    def display(self: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.BsplineDisplay:
        ...
    @display.setter
    def display(self: MSPyBentleyGeom.MSBsplineCurve, arg0: MSPyBentleyGeom.BsplineDisplay) -> None:
        ...
    
    eKNOTPOS_AFTER_FINAL: KnotPosition
    
    eKNOTPOS_BEFORE_START: KnotPosition
    
    eKNOTPOS_FINAL: KnotPosition
    
    eKNOTPOS_INTERIOR: KnotPosition
    
    eKNOTPOS_INTERVAL: KnotPosition
    
    eKNOTPOS_START: KnotPosition
    
    @property
    def params(self: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.BsplineParam:
        ...
    @params.setter
    def params(self: MSPyBentleyGeom.MSBsplineCurve, arg0: MSPyBentleyGeom.BsplineParam) -> None:
        ...
    
    @property
    def rational(self: MSPyBentleyGeom.MSBsplineCurve) -> int:
        ...
    @rational.setter
    def rational(self: MSPyBentleyGeom.MSBsplineCurve, arg0: int) -> None:
        ...
    
    @property
    def type(self: MSPyBentleyGeom.MSBsplineCurve) -> int:
        ...
    @type.setter
    def type(self: MSPyBentleyGeom.MSBsplineCurve, arg0: int) -> None:
        ...
    
class RefCountedMSBsplineSurface:
    """
    None
    """

    def AddKnot(*args, **kwargs):
        """
        AddKnot(self: MSPyBentleyGeom.MSBsplineSurface, unnormalizedKnotValue: float, newMultiplicity: int, direction: int) -> int
        
        Add a given knot value to the B-spline surface in given direction.
        newMultiplicity is the desired final multiplicity of a knot that may
        already exist.
        """
        ...
    
    def AddTrimBoundary(*args, **kwargs):
        """
        AddTrimBoundary(*args, **kwargs)
        Overloaded function.
        
        1. AddTrimBoundary(self: MSPyBentleyGeom.MSBsplineSurface, uvPoints: MSPyBentleyGeom.DPoint2dArray) -> bool
        
        Add a uv polyline trim boundary.
        
        2. AddTrimBoundary(self: MSPyBentleyGeom.MSBsplineSurface, xyzPoints: MSPyBentleyGeom.DPoint3dArray) -> bool
        
        Add a uv polyline trim boundary.
        """
        ...
    
    def Allocate(*args, **kwargs):
        """
        Allocate(self: MSPyBentleyGeom.MSBsplineSurface) -> int
        
        Allocate memory arrays to match the current counts.
        """
        ...
    
    def AllocateUKnots(*args, **kwargs):
        """
        AllocateUKnots(self: MSPyBentleyGeom.MSBsplineSurface) -> int
        
        Allocate uKnots. Prior knot buffer is freed if present (do not call on
        pre-zeroed surface!!)
        """
        ...
    
    def AllocateVKnots(*args, **kwargs):
        """
        AllocateVKnots(self: MSPyBentleyGeom.MSBsplineSurface) -> int
        
        Allocate vKnots. Prior knot buffer is freed if present (do not call on
        pre-zeroed surface!!)
        """
        ...
    
    def AreUKnotsValid(*args, **kwargs):
        """
        AreUKnotsValid(self: MSPyBentleyGeom.MSBsplineSurface, clampingRequired: bool) -> bool
        
        Return the true allocated size of the pole array....
        """
        ...
    
    def AreVKnotsValid(*args, **kwargs):
        """
        AreVKnotsValid(self: MSPyBentleyGeom.MSBsplineSurface, clampingRequired: bool) -> bool
        """
        ...
    
    def BoundaryLoopArea(*args, **kwargs):
        """
        BoundaryLoopArea(self: MSPyBentleyGeom.MSBsplineSurface, boundaryIndex: int) -> float
        
        Return the area of a single boundary loop ..
        """
        ...
    
    def CleanKnots(*args, **kwargs):
        """
        CleanKnots(self: MSPyBentleyGeom.MSBsplineSurface) -> int
        
        Clean all unnecessary knots.
        """
        ...
    
    def Clone(*args, **kwargs):
        """
        Clone(self: MSPyBentleyGeom.MSBsplineSurface) -> MSPyBentleyGeom.RefCountedMSBsplineSurface
        """
        ...
    
    def ClosestPoint(*args, **kwargs):
        """
        ClosestPoint(self: MSPyBentleyGeom.MSBsplineSurface, surfacePoint: MSPyBentleyGeom.DPoint3d, surfaceUV: MSPyBentleyGeom.DPoint2d, spacePoint: MSPyBentleyGeom.DPoint3d) -> None
        
        Find closest point on surface
        """
        ...
    
    def ComputePrincipalAreaMoments(*args, **kwargs):
        """
        ComputePrincipalAreaMoments(self: MSPyBentleyGeom.MSBsplineSurface, centroid: MSPyBentleyGeom.DVec3d, axes: Bentley.RotMatrix, momentxyz: MSPyBentleyGeom.DVec3d) -> tuple
        """
        ...
    
    def ComputeSecondMomentAreaProducts(*args, **kwargs):
        """
        ComputeSecondMomentAreaProducts(self: MSPyBentleyGeom.MSBsplineSurface, products: MSPyBentleyGeom.DMatrix4d) -> bool
        
        Return the integrals of products of inertia [xx xy xz x; xy yy yz y;
        xz yz zz 1] * dA
        """
        ...
    
    def ComputeUniformUKnots(*args, **kwargs):
        """
        ComputeUniformUKnots(self: MSPyBentleyGeom.MSBsplineSurface) -> bool
        
        Compute uniformly spaced knots. This uses counts from params.
        
        Returns:
        false if param counts are not set.
        """
        ...
    
    def ComputeUniformVKnots(*args, **kwargs):
        """
        ComputeUniformVKnots(self: MSPyBentleyGeom.MSBsplineSurface) -> bool
        
        Compute uniformly spaced knots. This uses counts from params.
        
        Returns:
        false if param counts are not set.
        """
        ...
    
    def ControlPolygonFractionToControlPolygonDPoint3d(*args, **kwargs):
        """
        ControlPolygonFractionToControlPolygonDPoint3d(self: MSPyBentleyGeom.MSBsplineSurface, i: int, j: int, u: float, v: float) -> MSPyBentleyGeom.ValidatedDPoint3d
        
        Calculate the control polygon point at fractional position within a
        control polygon quad.
        """
        ...
    
    def ControlPolygonFractionToControlPolygonDPoint4d(*args, **kwargs):
        """
        ControlPolygonFractionToControlPolygonDPoint4d(self: MSPyBentleyGeom.MSBsplineSurface, i: int, j: int, u: float, v: float) -> MSPyBentleyGeom.ValidatedDPoint4d
        
        Calculate the control polygon point at fractional position within a
        control polygon quad.
        """
        ...
    
    def ControlPolygonFractionToKnot(*args, **kwargs):
        """
        ControlPolygonFractionToKnot(self: MSPyBentleyGeom.MSBsplineSurface, i: int, j: int, u: float, v: float) -> MSPyBentleyGeom.ValidatedDPoint2d
        
        Calculate the knot values at fractional position within a control
        polygon quad.
        """
        ...
    
    def CopyClosed(*args, **kwargs):
        """
        CopyClosed(self: MSPyBentleyGeom.MSBsplineSurface, source: MSPyBentleyGeom.MSBsplineSurface, edge: int) -> int
        
        Create B-spline surface by closing a open B-spline surface.
        """
        ...
    
    def CopyFrom(*args, **kwargs):
        """
        CopyFrom(self: MSPyBentleyGeom.MSBsplineSurface, source: MSPyBentleyGeom.MSBsplineSurface) -> int
        
        Allocate memory for the B-spline surface and copies all data from the
        input B-spline surface.
        """
        ...
    
    def CopyOpen(*args, **kwargs):
        """
        CopyOpen(self: MSPyBentleyGeom.MSBsplineSurface, source: MSPyBentleyGeom.MSBsplineSurface, unnormalizedKnot: float, edge: int) -> int
        
        Create B-spline surface by opening a closed B-spline surface about
        given direction.
        """
        ...
    
    def CopyReversed(*args, **kwargs):
        """
        CopyReversed(self: MSPyBentleyGeom.MSBsplineSurface, source: MSPyBentleyGeom.MSBsplineSurface, edge: int) -> int
        
        Create B-spline surface by reversing the given direction of surface.
        """
        ...
    
    def Create(*args, **kwargs):
        """
        Create() -> MSPyBentleyGeom.RefCountedMSBsplineSurface
        """
        ...
    
    def CreateCapture(*args, **kwargs):
        """
        CreateCapture(self: MSPyBentleyGeom.MSBsplineSurface) -> MSPyBentleyGeom.RefCountedMSBsplineSurface
        
        Returns a smart pointer to an MSBsplineSurface on the heap. Copy bits
        from instance, zero the instance.
        """
        ...
    
    def CreateCatmullRom(*args, **kwargs):
        """
        CreateCatmullRom(points: MSPyBentleyGeom.DPoint3dArray, numU: int, numV: int, uv: MSPyBentleyGeom.DPoint2dArray) -> MSPyBentleyGeom.RefCountedMSBsplineSurface
        """
        ...
    
    def CreateCopyTransformed(*args, **kwargs):
        """
        CreateCopyTransformed(self: MSPyBentleyGeom.MSBsplineSurface, transform: Bentley.Transform) -> MSPyBentleyGeom.RefCountedMSBsplineSurface
        
        Clone as new refcounted pointer.
        """
        ...
    
    def CreateFromPolesAndOrder(*args, **kwargs):
        """
        CreateFromPolesAndOrder(pointVector: MSPyBentleyGeom.DPoint3dArray, weightVector: MSPyBentley.DoubleArray, uKnotVector: MSPyBentley.DoubleArray, uOrder: int, numUPoints: int, uClosed: bool, vKnotVector: MSPyBentley.DoubleArray, vOrder: int, numVPoints: int, vClosed: bool, inputPolesAlreadyWeighted: bool) -> MSPyBentleyGeom.RefCountedMSBsplineSurface
        """
        ...
    
    def CreateLinearSweep(*args, **kwargs):
        """
        CreateLinearSweep(*args, **kwargs)
        Overloaded function.
        
        1. CreateLinearSweep(primitive: MSPyBentleyGeom.ICurvePrimitive, delta: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.RefCountedMSBsplineSurface
        
        Create a linear sweep from a (single) base curve. Fails (i.e. returns
        NULL) if the primitive has children.
        
        Parameter ``[in]``:
        primitive base curve to be swept
        
        Parameter ``[in]``:
        delta sweep direction.
        
        2. CreateLinearSweep(primitive: MSPyBentleyGeom.MSBsplineCurve, delta: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.RefCountedMSBsplineSurface
        
        Create a linear sweep from a (single) base curve. Fails (i.e. returns
        NULL) if the primitive has children.
        
        Parameter ``[in]``:
        primitive base curve to be swept
        
        Parameter ``[in]``:
        delta sweep direction.
        
        3. CreateLinearSweep(surfaces: MSPyBentleyGeom.MSBsplineSurfacePtrArray, baseCurves: MSPyBentleyGeom.CurveVector, delta: MSPyBentleyGeom.DVec3d) -> bool
        
        Create a linear sweep from a (single) base curve. Fails (i.e. returns
        NULL) if the primitive has children.
        
        Parameter ``[in]``:
        primitive base curve to be swept
        
        Parameter ``[in]``:
        delta sweep direction.
        """
        ...
    
    def CreateRotationalSweep(*args, **kwargs):
        """
        CreateRotationalSweep(*args, **kwargs)
        Overloaded function.
        
        1. CreateRotationalSweep(primitive: MSPyBentleyGeom.ICurvePrimitive, center: MSPyBentleyGeom.DPoint3d, axis: MSPyBentleyGeom.DVec3d, sweepRadians: float) -> MSPyBentleyGeom.RefCountedMSBsplineSurface
        
        2. CreateRotationalSweep(primitive: MSPyBentleyGeom.MSBsplineCurve, center: MSPyBentleyGeom.DPoint3d, axis: MSPyBentleyGeom.DVec3d, sweepRadians: float) -> MSPyBentleyGeom.RefCountedMSBsplineSurface
        
        3. CreateRotationalSweep(surfaces: MSPyBentleyGeom.MSBsplineSurfacePtrArray, baseCurves: MSPyBentleyGeom.CurveVector, center: MSPyBentleyGeom.DPoint3d, axis: MSPyBentleyGeom.DVec3d, sweepRadians: float) -> bool
        """
        ...
    
    def CreateRuled(*args, **kwargs):
        """
        CreateRuled(curveA: MSPyBentleyGeom.ICurvePrimitive, curveB: MSPyBentleyGeom.ICurvePrimitive) -> MSPyBentleyGeom.RefCountedMSBsplineSurface
        
        Create a linear sweep from a ruled surface between two curves. Fails
        (i.e. returns NULL) if the primitives have children or are not
        compatible.
        
        Parameter ``[in]``:
        curveA first curve
        
        Parameter ``[in]``:
        curveB second curve
        """
        ...
    
    def CreateTrimmedDisk(*args, **kwargs):
        """
        CreateTrimmedDisk(ellipse: MSPyBentleyGeom.DEllipse3d) -> MSPyBentleyGeom.RefCountedMSBsplineSurface
        
        Create a planar (bilinear) surface for the parallelogram around the
        ellipse. Insert a trim curve for the ellipse.
        
        Parameter ``[in]``:
        ellipse space ellipse
        """
        ...
    
    def CreateTrimmedSurfaces(*args, **kwargs):
        """
        CreateTrimmedSurfaces(*args, **kwargs)
        Overloaded function.
        
        1. CreateTrimmedSurfaces(surfaces: MSPyBentleyGeom.MSBsplineSurfacePtrArray, source: MSPyBentleyGeom.CurveVector, options: MSPyBentleyGeom.IFacetOptions = None) -> bool
        
        2. CreateTrimmedSurfaces(surfaces: MSPyBentleyGeom.MSBsplineSurfacePtrArray, source: Bentley.ISolidPrimitive, options: MSPyBentleyGeom.IFacetOptions = None) -> bool
        """
        ...
    
    def CreateTubeSurface(*args, **kwargs):
        """
        CreateTubeSurface(baseCurve: MSPyBentleyGeom.MSBsplineCurve, translateBaseCurve: bool, traceCurve: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.RefCountedMSBsplineSurface
        
        Create a surface swept along a trace curve.
        
        Parameter ``[in]``:
        baseCurve base contour
        
        Parameter ``[in]``:
        translateBaseCurve true to translate section, false to rotate with
        trace
        
        Parameter ``[in]``:
        traceCurve path to sweep
        """
        ...
    
    def DeleteBoundaries(*args, **kwargs):
        """
        DeleteBoundaries(self: MSPyBentleyGeom.MSBsplineSurface) -> None
        
        Remove all trim boundaries.
        """
        ...
    
    def ElevateDegree(*args, **kwargs):
        """
        ElevateDegree(self: MSPyBentleyGeom.MSBsplineSurface, newDegree: int, edge: int) -> int
        
        Elevate the degree (increases the order) of the B-spline surface in
        given direction.
        """
        ...
    
    def EvaluateAllPartials(*args, **kwargs):
        """
        EvaluateAllPartials(self: MSPyBentleyGeom.MSBsplineSurface, xyz: MSPyBentleyGeom.DPoint3d, dPdU: MSPyBentleyGeom.DVec3d, dPdV: MSPyBentleyGeom.DVec3d, dPdUU: MSPyBentleyGeom.DVec3d, dPdVV: MSPyBentleyGeom.DVec3d, dPdUv: MSPyBentleyGeom.DVec3d, normal: MSPyBentleyGeom.DVec3d, u: float, v: float) -> None
        """
        ...
    
    def EvaluateNormalizedFrame(*args, **kwargs):
        """
        EvaluateNormalizedFrame(self: MSPyBentleyGeom.MSBsplineSurface, transform: Bentley.Transform, u: float, v: float) -> bool
        
        Calculate a coordinate frame on the surface.
        
        Parameter ``[in]``:
        u u parameter
        
        Parameter ``[in]``:
        v v parameter.
        
        Parameter ``[out]``:
        transform transform with (a) origin at surface point, (b) x axis
        in u direction, (c) y axis perpendicular to x and in the surface
        tangent plane, (d) z axis normal to surface. Return false if
        tangent vectors are parallel or zero.
        """
        ...
    
    def EvaluatePoint(*args, **kwargs):
        """
        EvaluatePoint(*args, **kwargs)
        Overloaded function.
        
        1. EvaluatePoint(self: MSPyBentleyGeom.MSBsplineSurface, xyz: MSPyBentleyGeom.DPoint3d, u: float, v: float) -> None
        
        2. EvaluatePoint(self: MSPyBentleyGeom.MSBsplineSurface, xyz: MSPyBentleyGeom.DPoint3d, dPdU: MSPyBentleyGeom.DVec3d, dPdV: MSPyBentleyGeom.DVec3d, u: float, v: float) -> None
        """
        ...
    
    def EvaluatePointAndUnitNormal(*args, **kwargs):
        """
        EvaluatePointAndUnitNormal(self: MSPyBentleyGeom.MSBsplineSurface, ray: MSPyBentleyGeom.DRay3d, u: float, v: float) -> bool
        
        Calculate the point and unit normal on the B-spline surface at the
        input u and v parameter values. Return false if tangent vectors are
        parallel or zero.
        """
        ...
    
    def EvaluatePrincipalCurvature(*args, **kwargs):
        """
        EvaluatePrincipalCurvature(self: MSPyBentleyGeom.MSBsplineSurface, xyz: MSPyBentleyGeom.DPoint3d, unitA: MSPyBentleyGeom.DVec3d, unitB: MSPyBentleyGeom.DVec3d, u: float, v: float) -> tuple
        """
        ...
    
    def EvaluateUniformGrid(*args, **kwargs):
        """
        EvaluateUniformGrid(*args, **kwargs)
        Overloaded function.
        
        1. EvaluateUniformGrid(self: MSPyBentleyGeom.MSBsplineSurface, numUPoint: int, numVPoint: int, uParams: MSPyBentley.DoubleArray, vParams: MSPyBentley.DoubleArray, gridPoints: MSPyBentleyGeom.DPoint3dArray) -> None
        
        2. EvaluateUniformGrid(self: MSPyBentleyGeom.MSBsplineSurface, numUPoint: int, numVPoint: int, uvParams: MSPyBentleyGeom.DPoint2dArray, gridPoints: MSPyBentleyGeom.DPoint3dArray) -> None
        """
        ...
    
    def ExtractTo(*args, **kwargs):
        """
        ExtractTo(self: MSPyBentleyGeom.MSBsplineSurface, dest: MSPyBentleyGeom.MSBsplineSurface) -> None
        
        Copy bits into simple structure. Caller instance zeroed.
        """
        ...
    
    def FindKnotInterval(*args, **kwargs):
        """
        FindKnotInterval(self: MSPyBentleyGeom.MSBsplineSurface, knotValue: float, direction: int) -> int
        """
        ...
    
    def FixupBoundaryLoopParity(*args, **kwargs):
        """
        FixupBoundaryLoopParity(self: MSPyBentleyGeom.MSBsplineSurface) -> None
        
        Analyze loop parity among all boundary loops. Replace as " complete "
        loop set -- no implicit 01 outer boundary.
        """
        ...
    
    def FractionToKnot(*args, **kwargs):
        """
        FractionToKnot(self: MSPyBentleyGeom.MSBsplineSurface, f: float, direction: int) -> float
        
        Return the knot value at a fractional parameter about given
        direction...
        """
        ...
    
    def GetBoundaryUV(*args, **kwargs):
        """
        GetBoundaryUV(self: MSPyBentleyGeom.MSBsplineSurface, boundaryIndex: int, pointIndex: int) -> MSPyBentleyGeom.DPoint2d
        """
        ...
    
    def GetIntervalCounts(*args, **kwargs):
        """
        GetIntervalCounts(self: MSPyBentleyGeom.MSBsplineSurface) -> tuple
        """
        ...
    
    def GetIsUClosed(*args, **kwargs):
        """
        GetIsUClosed(self: MSPyBentleyGeom.MSBsplineSurface) -> bool
        
        return the u direction periodic state.
        """
        ...
    
    def GetIsVClosed(*args, **kwargs):
        """
        GetIsVClosed(self: MSPyBentleyGeom.MSBsplineSurface) -> bool
        
        return the v direction periodic state.
        """
        ...
    
    def GetIsoUCurve(*args, **kwargs):
        """
        GetIsoUCurve(self: MSPyBentleyGeom.MSBsplineSurface, u: float) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        
        Get the (untrimmed) v-direction curve at u
        """
        ...
    
    def GetIsoUCurveSegments(*args, **kwargs):
        """
        GetIsoUCurveSegments(self: MSPyBentleyGeom.MSBsplineSurface, u: float, segments: MSPyBentleyGeom.MSBsplineCurvePtrArray) -> None
        
        Get scan line intersections at constant u.
        """
        ...
    
    def GetIsoULineVIntersections(*args, **kwargs):
        """
        GetIsoULineVIntersections(self: MSPyBentleyGeom.MSBsplineSurface, u: float, vParams: MSPyBentley.DoubleArray) -> None
        
        Get scan line intersections at constant u.
        """
        ...
    
    def GetIsoVCurve(*args, **kwargs):
        """
        GetIsoVCurve(self: MSPyBentleyGeom.MSBsplineSurface, v: float) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        
        Get the (untrimmed) u-direction curve at v
        """
        ...
    
    def GetIsoVCurveSegments(*args, **kwargs):
        """
        GetIsoVCurveSegments(self: MSPyBentleyGeom.MSBsplineSurface, v: float, segments: MSPyBentleyGeom.MSBsplineCurvePtrArray) -> None
        
        Get scan line intersections at constant v.
        """
        ...
    
    def GetIsoVLineUIntersections(*args, **kwargs):
        """
        GetIsoVLineUIntersections(self: MSPyBentleyGeom.MSBsplineSurface, v: float, uParams: MSPyBentley.DoubleArray) -> None
        
        Get scan line intersections at constant v.
        """
        ...
    
    def GetKnotRange(*args, **kwargs):
        """
        GetKnotRange(self: MSPyBentleyGeom.MSBsplineSurface, direction: int) -> tuple
        """
        ...
    
    def GetNumBounds(*args, **kwargs):
        """
        GetNumBounds(self: MSPyBentleyGeom.MSBsplineSurface) -> int
        """
        ...
    
    def GetNumPointsInBoundary(*args, **kwargs):
        """
        GetNumPointsInBoundary(self: MSPyBentleyGeom.MSBsplineSurface, boundaryIndex: int) -> int
        
        return the number of ponits in a boundary.
        """
        ...
    
    def GetNumPoles(*args, **kwargs):
        """
        GetNumPoles(self: MSPyBentleyGeom.MSBsplineSurface) -> int
        
        return the product of u and v direction poles counts.
        """
        ...
    
    def GetNumUKnots(*args, **kwargs):
        """
        GetNumUKnots(self: MSPyBentleyGeom.MSBsplineSurface) -> int
        
        return the u direction knot count.
        """
        ...
    
    def GetNumUPoles(*args, **kwargs):
        """
        GetNumUPoles(self: MSPyBentleyGeom.MSBsplineSurface) -> int
        
        return the u direction pole count.
        """
        ...
    
    def GetNumVKnots(*args, **kwargs):
        """
        GetNumVKnots(self: MSPyBentleyGeom.MSBsplineSurface) -> int
        
        return the v direction knot count.
        """
        ...
    
    def GetNumVPoles(*args, **kwargs):
        """
        GetNumVPoles(self: MSPyBentleyGeom.MSBsplineSurface) -> int
        
        return the v direction pole count.
        """
        ...
    
    def GetParameterRegion(*args, **kwargs):
        """
        GetParameterRegion(self: MSPyBentleyGeom.MSBsplineSurface) -> tuple
        """
        ...
    
    def GetPole(*args, **kwargs):
        """
        GetPole(*args, **kwargs)
        Overloaded function.
        
        1. GetPole(self: MSPyBentleyGeom.MSBsplineSurface, i: int) -> MSPyBentleyGeom.DPoint3d
        
        2. GetPole(self: MSPyBentleyGeom.MSBsplineSurface, i: int, j: int) -> MSPyBentleyGeom.DPoint3d
        """
        ...
    
    def GetPoleDPoint4d(*args, **kwargs):
        """
        GetPoleDPoint4d(*args, **kwargs)
        Overloaded function.
        
        1. GetPoleDPoint4d(self: MSPyBentleyGeom.MSBsplineSurface, i: int) -> MSPyBentleyGeom.DPoint4d
        
        2. GetPoleDPoint4d(self: MSPyBentleyGeom.MSBsplineSurface, i: int, j: int) -> MSPyBentleyGeom.DPoint4d
        """
        ...
    
    def GetPoleRange(*args, **kwargs):
        """
        GetPoleRange(*args, **kwargs)
        Overloaded function.
        
        1. GetPoleRange(self: MSPyBentleyGeom.MSBsplineSurface, range: MSPyBentleyGeom.DRange3d) -> None
        
        Get the range of the poles of the B-spline surface.
        
        2. GetPoleRange(self: MSPyBentleyGeom.MSBsplineSurface, range: MSPyBentleyGeom.DRange3d, transform: Bentley.Transform) -> None
        
        Get the range of the poles of the B-spline surface.
        """
        ...
    
    def GetPoles(*args, **kwargs):
        """
        GetPoles(self: MSPyBentleyGeom.MSBsplineSurface, outData: MSPyBentleyGeom.DPoint3dArray) -> None
        
        Copy all poles out into caller array.
        """
        ...
    
    def GetPolygonColumnAsCurve(*args, **kwargs):
        """
        GetPolygonColumnAsCurve(self: MSPyBentleyGeom.MSBsplineSurface, index: int) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        
        Copy poles from a column into a curve structure. index -1 is
        understood as " end "
        """
        ...
    
    def GetPolygonDisplay(*args, **kwargs):
        """
        GetPolygonDisplay(self: MSPyBentleyGeom.MSBsplineSurface) -> bool
        """
        ...
    
    def GetPolygonRowAsCurve(*args, **kwargs):
        """
        GetPolygonRowAsCurve(self: MSPyBentleyGeom.MSBsplineSurface, index: int) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        
        Copy poles from a row into a curve structure. index -1 is understood
        as " end "
        """
        ...
    
    def GetPrincipalExtents(*args, **kwargs):
        """
        GetPrincipalExtents(self: MSPyBentleyGeom.MSBsplineSurface, extends: Bentley.Transform) -> bool
        
        Return a transform whose columns are along edges parallel to the
        principal axes and sized to include the poles from the translation
        point.
        """
        ...
    
    def GetSupport(*args, **kwargs):
        """
        GetSupport(self: MSPyBentleyGeom.MSBsplineSurface, outPoles: MSPyBentleyGeom.DPoint4dArray, outUKnots: MSPyBentley.DoubleArray, outVKnots: MSPyBentley.DoubleArray, uIndex: int, vIndex: int) -> bool
        
        Extract the poles and knots that support a single bezier patch ...
        
        Parameter ``[out]``:
        outPoles{uOrder X vOrder} poles
        
        Parameter ``[out]``:
        outUKnots{2*(uOrder-1)} knots
        
        Parameter ``[out]``:
        outVKnots{2*(vOrder-1)} knots
        
        Parameter ``[in]``:
        uIndex index of bezier to extract.
        
        Parameter ``[in]``:
        vIndex index of bezier to extract. @DotNetMethodExclude
        """
        ...
    
    def GetSurfaceDisplay(*args, **kwargs):
        """
        GetSurfaceDisplay(self: MSPyBentleyGeom.MSBsplineSurface) -> bool
        """
        ...
    
    def GetUKnot(*args, **kwargs):
        """
        GetUKnot(self: MSPyBentleyGeom.MSBsplineSurface, outData: int) -> float
        """
        ...
    
    def GetUKnots(*args, **kwargs):
        """
        GetUKnots(self: MSPyBentleyGeom.MSBsplineSurface, knots: MSPyBentley.DoubleArray) -> None
        """
        ...
    
    def GetUOrder(*args, **kwargs):
        """
        GetUOrder(self: MSPyBentleyGeom.MSBsplineSurface) -> int
        
        return the u direction order.
        """
        ...
    
    def GetUVBoundaryCurves(*args, **kwargs):
        """
        GetUVBoundaryCurves(self: MSPyBentleyGeom.MSBsplineSurface, addOuterLoopsIfActive: bool, preferCurves: bool) -> MSPyBentleyGeom.CurveVector
        
        Return current uv boundary data. This returns a parity region.
        """
        ...
    
    def GetUVBoundaryLoops(*args, **kwargs):
        """
        GetUVBoundaryLoops(*args, **kwargs)
        Overloaded function.
        
        1. GetUVBoundaryLoops(self: MSPyBentleyGeom.MSBsplineSurface, uvBoundaries: MSPyBentleyGeom.DPoint2dVecArray, addOuterLoopsIfActive: bool) -> None
        
        2. GetUVBoundaryLoops(self: MSPyBentleyGeom.MSBsplineSurface, uvBoundaries: MSPyBentleyGeom.DPoint2dVecArray, addOuterLoopsIfActive: bool, cleanupParity: bool) -> None
        """
        ...
    
    def GetUnWeightedPole(*args, **kwargs):
        """
        GetUnWeightedPole(*args, **kwargs)
        Overloaded function.
        
        1. GetUnWeightedPole(self: MSPyBentleyGeom.MSBsplineSurface, i: int, j: int) -> MSPyBentleyGeom.DPoint3d
        
        2. GetUnWeightedPole(self: MSPyBentleyGeom.MSBsplineSurface, i: int) -> MSPyBentleyGeom.DPoint3d
        """
        ...
    
    def GetUnWeightedPoles(*args, **kwargs):
        """
        GetUnWeightedPoles(self: MSPyBentleyGeom.MSBsplineSurface, outData: MSPyBentleyGeom.DPoint3dArray) -> None
        
        Copy all poles out into caller array, dividing each by its weight
        """
        ...
    
    def GetUnstructuredBoundaryCurves(*args, **kwargs):
        """
        GetUnstructuredBoundaryCurves(*args, **kwargs)
        Overloaded function.
        
        1. GetUnstructuredBoundaryCurves(self: MSPyBentleyGeom.MSBsplineSurface, tolerance: float, cubicFit: bool) -> MSPyBentleyGeom.CurveVector
        
        2. GetUnstructuredBoundaryCurves(self: MSPyBentleyGeom.MSBsplineSurface, tolerance: float, cubicFit: bool, addOuterLoopIfActive: bool) -> MSPyBentleyGeom.CurveVector
        """
        ...
    
    def GetVKnot(*args, **kwargs):
        """
        GetVKnot(self: MSPyBentleyGeom.MSBsplineSurface, outData: int) -> float
        """
        ...
    
    def GetVKnots(*args, **kwargs):
        """
        GetVKnots(self: MSPyBentleyGeom.MSBsplineSurface, knots: MSPyBentley.DoubleArray) -> None
        """
        ...
    
    def GetVOrder(*args, **kwargs):
        """
        GetVOrder(self: MSPyBentleyGeom.MSBsplineSurface) -> int
        
        return the v direction order.
        """
        ...
    
    def GetWeight(*args, **kwargs):
        """
        GetWeight(*args, **kwargs)
        Overloaded function.
        
        1. GetWeight(self: MSPyBentleyGeom.MSBsplineSurface, i: int) -> float
        
        2. GetWeight(self: MSPyBentleyGeom.MSBsplineSurface, i: int, j: int) -> float
        """
        ...
    
    def GetWeights(*args, **kwargs):
        """
        GetWeights(self: MSPyBentleyGeom.MSBsplineSurface, outData: MSPyBentley.DoubleArray) -> None
        
        Copy all weights out into caller array.
        """
        ...
    
    def HasValidBoundaryAllocation(*args, **kwargs):
        """
        HasValidBoundaryAllocation(self: MSPyBentleyGeom.MSBsplineSurface) -> bool
        """
        ...
    
    def HasValidCountsAndAllocations(*args, **kwargs):
        """
        HasValidCountsAndAllocations(self: MSPyBentleyGeom.MSBsplineSurface) -> bool
        """
        ...
    
    def HasValidOrder(*args, **kwargs):
        """
        HasValidOrder(self: MSPyBentleyGeom.MSBsplineSurface) -> bool
        """
        ...
    
    def HasValidPoleAllocation(*args, **kwargs):
        """
        HasValidPoleAllocation(self: MSPyBentleyGeom.MSBsplineSurface) -> bool
        """
        ...
    
    def HasValidPoleCounts(*args, **kwargs):
        """
        HasValidPoleCounts(self: MSPyBentleyGeom.MSBsplineSurface) -> bool
        """
        ...
    
    def HasValidWeightAllocation(*args, **kwargs):
        """
        HasValidWeightAllocation(self: MSPyBentleyGeom.MSBsplineSurface) -> bool
        """
        ...
    
    def HasWeights(*args, **kwargs):
        """
        HasWeights(self: MSPyBentleyGeom.MSBsplineSurface) -> bool
        
        ask if this is a " rational " (weighted) surface.
        """
        ...
    
    def InitFromPointsAndOrder(*args, **kwargs):
        """
        InitFromPointsAndOrder(self: MSPyBentleyGeom.MSBsplineSurface, uOrder: int, vOrder: int, uNumPoles: int, vNumPoles: int, points: MSPyBentleyGeom.DPoint3d) -> int
        
        Initialize the B-spline surface from point array and U/V order.
        """
        ...
    
    def IntersectRay(*args, **kwargs):
        """
        IntersectRay(*args, **kwargs)
        Overloaded function.
        
        1. IntersectRay(self: MSPyBentleyGeom.MSBsplineSurface, intersectionPoints: MSPyBentleyGeom.DPoint3dArray, rayParameters: MSPyBentley.DoubleArray, surfaceParameters: MSPyBentleyGeom.DPoint2dArray, ray: MSPyBentleyGeom.DRay3d) -> None
        
        2. IntersectRay(self: MSPyBentleyGeom.MSBsplineSurface, intersectionPoints: MSPyBentleyGeom.DPoint3dArray, rayParameters: MSPyBentley.DoubleArray, surfaceParameters: MSPyBentleyGeom.DPoint2dArray, ray: MSPyBentleyGeom.DRay3d, rayInterval: MSPyBentleyGeom.DRange1d) -> None
        """
        ...
    
    def IsBidirectionalTranslation(*args, **kwargs):
        """
        IsBidirectionalTranslation(self: MSPyBentleyGeom.MSBsplineSurface, relativeTolerance: float = 0.0) -> bool
        
        Check whether the u curves are all translations of the first u curve.
        (If this is true, the v curves are also translations of the first v
        curve0)
        
        Parameter ``[in]``:
        relativeTolerance tolerance as a fraction of the largest
        coordinate.
        """
        ...
    
    def IsDegenerateEdge(*args, **kwargs):
        """
        IsDegenerateEdge(self: MSPyBentleyGeom.MSBsplineSurface, edgeCode: int, tolerance: float) -> bool
        
        Check whether an edge of the surface degenerates to a single point.
        """
        ...
    
    def IsOuterBoundaryActive(*args, **kwargs):
        """
        IsOuterBoundaryActive(self: MSPyBentleyGeom.MSBsplineSurface) -> bool
        
        Returns:
        the state of the outer boundary flag.
        """
        ...
    
    def IsPhysicallyClosed(*args, **kwargs):
        """
        IsPhysicallyClosed(self: MSPyBentleyGeom.MSBsplineSurface) -> tuple
        """
        ...
    
    def IsPlanarBilinear(*args, **kwargs):
        """
        IsPlanarBilinear(*args, **kwargs)
        Overloaded function.
        
        1. IsPlanarBilinear(self: MSPyBentleyGeom.MSBsplineSurface) -> bool
        
        Check whether the B-spline surface is bilinear and each face of the
        control polygon is planar, with tight system tolerance
        (Angle.SmallAngle (
        
        2. IsPlanarBilinear(self: MSPyBentleyGeom.MSBsplineSurface, angleTol: float) -> bool
        
        Check whether the B-spline surface is bilinear and each face of the
        control polygon is planar, with tight system tolerance
        (Angle.SmallAngle (
        """
        ...
    
    def IsPlane(*args, **kwargs):
        """
        IsPlane(self: MSPyBentleyGeom.MSBsplineSurface) -> bool
        
        Check whether the poles are entirely within a plane. This does not
        check for goofy direction changes -- just planarity.
        """
        ...
    
    def IsSameStructure(*args, **kwargs):
        """
        IsSameStructure(self: MSPyBentleyGeom.MSBsplineSurface, other: MSPyBentleyGeom.MSBsplineSurface) -> bool
        
        Compare all non-coordinate data.
        """
        ...
    
    def IsSameStructureAndGeometry(*args, **kwargs):
        """
        IsSameStructureAndGeometry(self: MSPyBentleyGeom.MSBsplineSurface, other: MSPyBentleyGeom.MSBsplineSurface, tolerance: float) -> bool
        
        Compare all data.
        """
        ...
    
    def IsSolid(*args, **kwargs):
        """
        IsSolid(self: MSPyBentleyGeom.MSBsplineSurface, tolerance: float) -> bool
        
        Check whether the B-spline surface encloses a valid space.
        """
        ...
    
    @property
    def IsUClosed(arg0: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        ...
    
    @property
    def IsVClosed(arg0: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        ...
    
    def KnotToBlendFunctions(*args, **kwargs):
        """
        KnotToBlendFunctions(self: MSPyBentleyGeom.MSBsplineSurface, blend: float, blendDerivatives: float, u: float, direction: int) -> int
        """
        ...
    
    def KnotToFraction(*args, **kwargs):
        """
        KnotToFraction(self: MSPyBentleyGeom.MSBsplineSurface, knot: float, direction: int) -> float
        
        Return the fractional parameter corresponding to a knot value ...
        """
        ...
    
    def LoftingSurface(*args, **kwargs):
        """
        LoftingSurface(self: MSPyBentleyGeom.MSBsplineSurface, pCurves: MSPyBentleyGeom.MSBsplineCurve, pStartNormal: MSPyBentleyGeom.DVec3d, pEndNormal: MSPyBentleyGeom.DVec3d, numCurves: int, approxComp: bool, closed: bool, smoothStart: bool, smoothEnd: bool, chordLength: bool, applyComp: bool, tolerance: float) -> int
        """
        ...
    
    def MakeBezier(*args, **kwargs):
        """
        MakeBezier(self: MSPyBentleyGeom.MSBsplineSurface, outSurface: MSPyBentleyGeom.MSBsplineSurface) -> int
        
        Create equivalent Bezier surface for the B-spline surface.
        """
        ...
    
    def MakeBeziers(*args, **kwargs):
        """
        MakeBeziers(self: MSPyBentleyGeom.MSBsplineSurface, beziers: Bentley.Bstdcxx.bvector<Bentley.MSBsplineSurface,Bentley.BentleyAllocator<Bentley.MSBsplineSurface> >) -> int
        
        Create a series of Bezier surfaces for the B-spline surface.
        """
        ...
    
    def MakeClosed(*args, **kwargs):
        """
        MakeClosed(self: MSPyBentleyGeom.MSBsplineSurface, direction: int) -> int
        
        Close the open B-spline surface about the given direction.
        """
        ...
    
    def MakeOpen(*args, **kwargs):
        """
        MakeOpen(self: MSPyBentleyGeom.MSBsplineSurface, uv: float, direction: int) -> int
        
        Open the closed B-spline surface about the given direction.
        """
        ...
    
    def MakeRational(*args, **kwargs):
        """
        MakeRational(self: MSPyBentleyGeom.MSBsplineSurface) -> int
        
        Make an equivalent rational B-spline surface.
        """
        ...
    
    def MakeReversed(*args, **kwargs):
        """
        MakeReversed(self: MSPyBentleyGeom.MSBsplineSurface, direction: int) -> int
        
        Reserve the given direction of the surface.
        """
        ...
    
    def NormalizeKnots(*args, **kwargs):
        """
        NormalizeKnots(self: MSPyBentleyGeom.MSBsplineSurface) -> None
        
        Normalize knots to 01 (both directions)
        """
        ...
    
    def NormalizeSurface(*args, **kwargs):
        """
        NormalizeSurface(self: MSPyBentleyGeom.MSBsplineSurface) -> None
        
        Scale and translate the parameter range of the surface and its
        boundary loops so all parameters are between 0 and 1.
        """
        ...
    
    @property
    def NumBounds(arg0: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    
    @property
    def NumPoles(arg0: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    
    @property
    def NumUKnots(arg0: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    
    @property
    def NumUPoles(arg0: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    
    @property
    def NumVKnots(arg0: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    
    @property
    def NumVPoles(arg0: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    
    @property
    def PolygonDisplay(arg0: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        ...
    @PolygonDisplay.setter
    def PolygonDisplay(arg0: MSPyBentleyGeom.MSBsplineSurface, arg1: bool) -> None:
        ...
    
    def Populate(*args, **kwargs):
        """
        Populate(self: MSPyBentleyGeom.MSBsplineSurface, pointVector: MSPyBentleyGeom.DPoint3dArray, weightVector: MSPyBentley.DoubleArray, uKnotVector: MSPyBentley.DoubleArray, uOrder: int, numUPoints: int, uClosed: bool, vKnotVector: MSPyBentley.DoubleArray, vOrder: int, numVPoints: int, vClosed: bool, inputPolesAlreadyWeighted: bool) -> int
        """
        ...
    
    def ReleaseMem(*args, **kwargs):
        """
        ReleaseMem(self: MSPyBentleyGeom.MSBsplineSurface) -> None
        
        Free memory allocated for the poles, weights and knot vector of a
        B-spline surface.
        """
        ...
    
    def RemoveKnotsBounded(*args, **kwargs):
        """
        RemoveKnotsBounded(self: MSPyBentleyGeom.MSBsplineSurface, dir: int, tol: float) -> int
        
        Remove all removable knots with the tolerance constraint.
        """
        ...
    
    def Resolution(*args, **kwargs):
        """
        Resolution(*args, **kwargs)
        Overloaded function.
        
        1. Resolution(self: MSPyBentleyGeom.MSBsplineSurface) -> float
        
        Get the resolution of the B-spline surface.
        
        2. Resolution(self: MSPyBentleyGeom.MSBsplineSurface, abstol: float, reltol: float) -> float
        
        Get the resolution of the B-spline surface.
        """
        ...
    
    def SetNumRules(*args, **kwargs):
        """
        SetNumRules(self: MSPyBentleyGeom.MSBsplineSurface, numU: int, numV: int) -> None
        """
        ...
    
    def SetOuterBoundaryActive(*args, **kwargs):
        """
        SetOuterBoundaryActive(self: MSPyBentleyGeom.MSBsplineSurface, active: bool) -> None
        
        Parameter ``[in]``:
        active If true, the outer boundary is active as an (implicit) trim
        boundary, so the outermost explict boundary acts as a hole.
        """
        ...
    
    def SetPole(*args, **kwargs):
        """
        SetPole(*args, **kwargs)
        Overloaded function.
        
        1. SetPole(self: MSPyBentleyGeom.MSBsplineSurface, index: int, value: MSPyBentleyGeom.DPoint3d) -> bool
        
        set pole by index. returns false if index out of range.
        @DotNetMethodExclude
        
        2. SetPole(self: MSPyBentleyGeom.MSBsplineSurface, i: int, j: int, value: MSPyBentleyGeom.DPoint3d) -> bool
        
        set pole by index. returns false if index out of range.
        @DotNetMethodExclude
        
        3. SetPole(self: MSPyBentleyGeom.MSBsplineSurface, i: int, x: float, y: float, z: float) -> bool
        
        set pole by index. returns false if index out of range.
        @DotNetMethodExclude
        """
        ...
    
    def SetPolygonDisplay(*args, **kwargs):
        """
        SetPolygonDisplay(self: MSPyBentleyGeom.MSBsplineSurface, display: bool) -> None
        """
        ...
    
    def SetReWeightedPole(*args, **kwargs):
        """
        SetReWeightedPole(*args, **kwargs)
        Overloaded function.
        
        1. SetReWeightedPole(self: MSPyBentleyGeom.MSBsplineSurface, index: int, value: MSPyBentleyGeom.DPoint3d) -> bool
        
        set pole by index. returns false if index out of range. If the surface
        is weighted, the current weight is multiplied into the input pole.
        
        2. SetReWeightedPole(self: MSPyBentleyGeom.MSBsplineSurface, i: int, j: int, value: MSPyBentleyGeom.DPoint3d) -> bool
        
        set pole by index. returns false if index out of range. If the surface
        is weighted, the current weight is multiplied into the input pole.
        """
        ...
    
    def SetSurfaceDisplay(*args, **kwargs):
        """
        SetSurfaceDisplay(self: MSPyBentleyGeom.MSBsplineSurface, display: bool) -> None
        """
        ...
    
    def SetTrim(*args, **kwargs):
        """
        SetTrim(self: MSPyBentleyGeom.MSBsplineSurface, cruves: MSPyBentleyGeom.CurveVector) -> None
        
        Delete previous trim and add new trim.
        """
        ...
    
    def SetUKnots(*args, **kwargs):
        """
        SetUKnots(self: MSPyBentleyGeom.MSBsplineSurface, index: int, value: float, n: int) -> bool
        
        set uKnotw by index. returns false if any index out of range.
        @DotNetMethodExclude
        """
        ...
    
    def SetUParamsWithUniformKnots(*args, **kwargs):
        """
        SetUParamsWithUniformKnots(self: MSPyBentleyGeom.MSBsplineSurface, numPoles: int, order: int, closed: bool) -> bool
        
        Install counts and set up uniform knots in u direction.
        """
        ...
    
    def SetVKnots(*args, **kwargs):
        """
        SetVKnots(self: MSPyBentleyGeom.MSBsplineSurface, index: int, value: float, n: int) -> bool
        
        set vKnotw by index. returns false if any index out of range.
        @DotNetMethodExclude
        """
        ...
    
    def SetVParamsWithUniformKnots(*args, **kwargs):
        """
        SetVParamsWithUniformKnots(self: MSPyBentleyGeom.MSBsplineSurface, numPoles: int, order: int, closed: bool) -> bool
        
        Install counts and set up uniform knots in v direction.
        """
        ...
    
    def SetWeight(*args, **kwargs):
        """
        SetWeight(self: MSPyBentleyGeom.MSBsplineSurface, index: int, w: float) -> bool
        
        set weight by index. returns false if index out of range.
        @DotNetMethodExclude
        """
        ...
    
    def SetWeights(*args, **kwargs):
        """
        SetWeights(self: MSPyBentleyGeom.MSBsplineSurface, index: int, value: float, n: int) -> bool
        
        set weight by index. returns false if any index out of range.
        @DotNetMethodExclude
        """
        ...
    
    @property
    def SurfaceDisplay(arg0: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        ...
    @SurfaceDisplay.setter
    def SurfaceDisplay(arg0: MSPyBentleyGeom.MSBsplineSurface, arg1: bool) -> None:
        ...
    
    def SwapUV(*args, **kwargs):
        """
        SwapUV(self: MSPyBentleyGeom.MSBsplineSurface) -> int
        
        Swap the U/V direction of the surface.
        """
        ...
    
    def TransformPoles(*args, **kwargs):
        """
        TransformPoles(self: MSPyBentleyGeom.MSBsplineSurface, transform: Bentley.Transform, i0: int, j0: int, numI: int, numJ: int) -> None
        
        Transform a block of poles wtih start index i0,j0
        """
        ...
    
    def TransformSurface(*args, **kwargs):
        """
        TransformSurface(self: MSPyBentleyGeom.MSBsplineSurface, transform: Bentley.Transform) -> int
        
        Transform the B-spline surface.
        """
        ...
    
    def TryGetBoundaryUV(*args, **kwargs):
        """
        TryGetBoundaryUV(self: MSPyBentleyGeom.MSBsplineSurface, boundaryIndex: int, pointIndex: int, uv: MSPyBentleyGeom.DPoint2d) -> bool
        """
        ...
    
    def TryGetUnWeightedPole(*args, **kwargs):
        """
        TryGetUnWeightedPole(*args, **kwargs)
        Overloaded function.
        
        1. TryGetUnWeightedPole(self: MSPyBentleyGeom.MSBsplineSurface, i: int, i: int, xyz: MSPyBentleyGeom.DPoint3d) -> bool
        
        Try to dereference index i,j.
        
        2. TryGetUnWeightedPole(self: MSPyBentleyGeom.MSBsplineSurface, i: int, xyz: MSPyBentleyGeom.DPoint3d) -> bool
        
        Try to dereference index i,j.
        """
        ...
    
    @property
    def UOrder(arg0: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    
    def UnWeightPoles(*args, **kwargs):
        """
        UnWeightPoles(self: MSPyBentleyGeom.MSBsplineSurface) -> None
        
        if the surface is rational, divide (wx,wy,wz) style poles by the
        weights
        """
        ...
    
    @property
    def VOrder(arg0: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    
    def WeightPoles(*args, **kwargs):
        """
        WeightPoles(self: MSPyBentleyGeom.MSBsplineSurface) -> None
        
        if the surface is rational, multiply (wx,wy,wz) style poles by the
        weights
        """
        ...
    
    def Zero(*args, **kwargs):
        """
        Zero(self: MSPyBentleyGeom.MSBsplineSurface) -> None
        
        zero out the surface
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    
    @property
    def display(self: MSPyBentleyGeom.MSBsplineSurface) -> MSPyBentleyGeom.BsplineDisplay:
        ...
    @display.setter
    def display(self: MSPyBentleyGeom.MSBsplineSurface, arg0: MSPyBentleyGeom.BsplineDisplay) -> None:
        ...
    
    @property
    def holeOrigin(self: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    @holeOrigin.setter
    def holeOrigin(self: MSPyBentleyGeom.MSBsplineSurface, arg0: int) -> None:
        ...
    
    @property
    def numBounds(self: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    @numBounds.setter
    def numBounds(self: MSPyBentleyGeom.MSBsplineSurface, arg0: int) -> None:
        ...
    
    @property
    def poles(arg0: MSPyBentleyGeom.MSBsplineSurface) -> numpy.typing.NDArray:
        ...
    @poles.setter
    def poles(arg0: MSPyBentleyGeom.MSBsplineSurface, arg1: numpy.typing.NDArray) -> None:
        ...
    
    @property
    def rational(self: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    @rational.setter
    def rational(self: MSPyBentleyGeom.MSBsplineSurface, arg0: int) -> None:
        ...
    
    @property
    def type(self: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    @type.setter
    def type(self: MSPyBentleyGeom.MSBsplineSurface, arg0: int) -> None:
        ...
    
    @property
    def uKnots(arg0: MSPyBentleyGeom.MSBsplineSurface) -> numpy.typing.NDArray:
        ...
    @uKnots.setter
    def uKnots(arg0: MSPyBentleyGeom.MSBsplineSurface, arg1: numpy.typing.NDArray) -> None:
        ...
    
    @property
    def uParams(self: MSPyBentleyGeom.MSBsplineSurface) -> MSPyBentleyGeom.BsplineParam:
        ...
    @uParams.setter
    def uParams(self: MSPyBentleyGeom.MSBsplineSurface, arg0: MSPyBentleyGeom.BsplineParam) -> None:
        ...
    
    @property
    def vKnots(arg0: MSPyBentleyGeom.MSBsplineSurface) -> numpy.typing.NDArray:
        ...
    @vKnots.setter
    def vKnots(arg0: MSPyBentleyGeom.MSBsplineSurface, arg1: numpy.typing.NDArray) -> None:
        ...
    
    @property
    def vParams(self: MSPyBentleyGeom.MSBsplineSurface) -> MSPyBentleyGeom.BsplineParam:
        ...
    @vParams.setter
    def vParams(self: MSPyBentleyGeom.MSBsplineSurface, arg0: MSPyBentleyGeom.BsplineParam) -> None:
        ...
    
    @property
    def weights(arg0: MSPyBentleyGeom.MSBsplineSurface) -> numpy.typing.NDArray:
        ...
    @weights.setter
    def weights(arg0: MSPyBentleyGeom.MSBsplineSurface, arg1: numpy.typing.NDArray) -> None:
        ...
    
class RefCountedMSInterpolationCurve:
    """
    None
    """

    def AllocateFitPoints(*args, **kwargs):
        """
        AllocateFitPoints(self: MSPyBentleyGeom.MSInterpolationCurve, count: int, data: MSPyBentleyGeom.DPoint3d = None) -> int
        
        Allocate specified number of fit points. Optionally copy in points
        from buffer.
        """
        ...
    
    def AllocateKnots(*args, **kwargs):
        """
        AllocateKnots(self: MSPyBentleyGeom.MSInterpolationCurve, count: int, data: float = None) -> int
        
        Allocate specified number of knots. Optionally copy in knots from
        buffer.
        """
        ...
    
    def AlmostEqual(*args, **kwargs):
        """
        AlmostEqual(self: MSPyBentleyGeom.MSInterpolationCurve, other: MSPyBentleyGeom.MSInterpolationCurve, tolerance: float) -> bool
        """
        ...
    
    def CopyFrom(*args, **kwargs):
        """
        CopyFrom(self: MSPyBentleyGeom.MSInterpolationCurve, source: MSPyBentleyGeom.MSInterpolationCurve) -> int
        
        Allocate memory for the B-spline curve and copies all data from the
        input inerpolation curve.
        """
        ...
    
    def Create(*args, **kwargs):
        """
        Create() -> MSPyBentleyGeom.RefCountedMSInterpolationCurve
        """
        ...
    
    def GetOrder(*args, **kwargs):
        """
        GetOrder(self: MSPyBentleyGeom.MSInterpolationCurve) -> int
        """
        ...
    
    def InitFromPointsAndEndTangents(*args, **kwargs):
        """
        InitFromPointsAndEndTangents(self: MSPyBentleyGeom.MSInterpolationCurve, inPoints: MSPyBentleyGeom.DPoint3dArray, removeData: bool, removeTol: float, endTangents: MSPyBentleyGeom.DPoint3d, closedCurve: bool, colinearTangents: bool, chordLenTangents: bool, naturalTangents: bool) -> int
        """
        ...
    
    @property
    def Order(arg0: MSPyBentleyGeom.MSInterpolationCurve) -> int:
        ...
    
    def Populate(*args, **kwargs):
        """
        Populate(*args, **kwargs)
        Overloaded function.
        
        1. Populate(self: MSPyBentleyGeom.MSInterpolationCurve, order: int, periodic: bool, isChordLenKnots: int, isColinearTangents: int, isChordLenTangents: int, isNaturalTangents: int, fitPoints: List[MSPyBentleyGeom.DPoint3d], knots: List[float], startTangent: MSPyBentleyGeom.DVec3d, endTangent: MSPyBentleyGeom.DVec3d) -> int
        
        2. Populate(self: MSPyBentleyGeom.MSInterpolationCurve, order: int, periodic: bool, isChordLenKnots: int, isColinearTangents: int, isChordLenTangents: int, isNaturalTangents: int, fitPoints: List[MSPyBentleyGeom.DPoint3d], knots: List[float]) -> int
        """
        ...
    
    def ReleaseMem(*args, **kwargs):
        """
        ReleaseMem(self: MSPyBentleyGeom.MSInterpolationCurve) -> None
        
        Free the memory allocated to the poles of the interpolation curve.
        """
        ...
    
    def Zero(*args, **kwargs):
        """
        Zero(self: MSPyBentleyGeom.MSInterpolationCurve) -> None
        
        Clear to zero state. DOES NOT RELEASE MEMORY.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    
class ReprojectStatus:
    """
    Members:
    
    eREPROJECT_Success
    
    eREPROJECT_CSMAPERR_OutOfUsefulRange
    
    eREPROJECT_CSMAPERR_OutOfMathematicalDomain
    
    eREPROJECT_CSMAPERR_DatumConverterNotSet
    
    eREPROJECT_CSMAPERR_VerticalDatumConversionError
    
    eREPROJECT_CSMAPERR_Error
    
    eREPROJECT_BadArgument
    
    eREPROJECT_NoChange
    
    eREPROJECT_StrokeError
    
    eREPROJECT_DataError
    
    eREPROJECT_DontValidateRange
    
    eREPROJECT_GeoCoordNotInitialized
    
    eREPROJECT_InvalidCoordSys
    """

    def __init__(self: MSPyBentleyGeom.ReprojectStatus, value: int) -> None:
        ...
    
    eREPROJECT_BadArgument: ReprojectStatus
    
    eREPROJECT_CSMAPERR_DatumConverterNotSet: ReprojectStatus
    
    eREPROJECT_CSMAPERR_Error: ReprojectStatus
    
    eREPROJECT_CSMAPERR_OutOfMathematicalDomain: ReprojectStatus
    
    eREPROJECT_CSMAPERR_OutOfUsefulRange: ReprojectStatus
    
    eREPROJECT_CSMAPERR_VerticalDatumConversionError: ReprojectStatus
    
    eREPROJECT_DataError: ReprojectStatus
    
    eREPROJECT_DontValidateRange: ReprojectStatus
    
    eREPROJECT_GeoCoordNotInitialized: ReprojectStatus
    
    eREPROJECT_InvalidCoordSys: ReprojectStatus
    
    eREPROJECT_NoChange: ReprojectStatus
    
    eREPROJECT_StrokeError: ReprojectStatus
    
    eREPROJECT_Success: ReprojectStatus
    
    @property
    def name(self: handle) -> str:
        ...
    
    @property
    def value(arg0: MSPyBentleyGeom.ReprojectStatus) -> int:
        ...
    
class RgbFactor:
    """
    None
    """

    def AddInPlace(*args, **kwargs):
        """
        AddInPlace(self: MSPyBentleyGeom.RgbFactor, other: MSPyBentleyGeom.RgbFactor) -> None
        """
        ...
    
    def From(*args, **kwargs):
        """
        From(*args, **kwargs)
        Overloaded function.
        
        1. From(data: MSPyBentleyGeom.DPoint3d) -> MSPyBentleyGeom.RgbFactor
        
        2. From(r: float, g: float, b: float) -> MSPyBentleyGeom.RgbFactor
        """
        ...
    
    def FromIntColor(*args, **kwargs):
        """
        FromIntColor(intColor: int) -> MSPyBentleyGeom.RgbFactor
        """
        ...
    
    def ScaleInPlace(*args, **kwargs):
        """
        ScaleInPlace(self: MSPyBentleyGeom.RgbFactor, a: float) -> None
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.RgbFactor) -> None:
        ...
    
    @property
    def blue(self: MSPyBentleyGeom.RgbFactor) -> float:
        ...
    @blue.setter
    def blue(self: MSPyBentleyGeom.RgbFactor, arg0: float) -> None:
        ...
    
    @property
    def green(self: MSPyBentleyGeom.RgbFactor) -> float:
        ...
    @green.setter
    def green(self: MSPyBentleyGeom.RgbFactor, arg0: float) -> None:
        ...
    
    @property
    def red(self: MSPyBentleyGeom.RgbFactor) -> float:
        ...
    @red.setter
    def red(self: MSPyBentleyGeom.RgbFactor, arg0: float) -> None:
        ...
    
class RgbFactorArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.RgbFactorArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.RgbFactorArray, arg0: MSPyBentleyGeom.RgbFactorArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.RgbFactorArray, arg0: Iterable) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.RgbFactorArray, x: MSPyBentleyGeom.RgbFactor) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.RgbFactorArray) -> None
        
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.RgbFactorArray, L: MSPyBentleyGeom.RgbFactorArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.RgbFactorArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.RgbFactorArray, i: int, x: MSPyBentleyGeom.RgbFactor) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.RgbFactorArray) -> MSPyBentleyGeom.RgbFactor
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.RgbFactorArray, i: int) -> MSPyBentleyGeom.RgbFactor
        
        Remove and return the item at index ``i``
        """
        ...
    
class RotMatrix:
    """
    None
    """

    def Add(*args, **kwargs):
        """
        Add(self: MSPyBentleyGeom.RotMatrix, delta: MSPyBentleyGeom.RotMatrix) -> None
        
        Add a matrix (componentwise, in place).
        
        Parameter ``[in]``:
        delta The matrix to add
        """
        ...
    
    def AddScaledOuterProductInPlace(*args, **kwargs):
        """
        AddScaledOuterProductInPlace(self: MSPyBentleyGeom.RotMatrix, vectorU: MSPyBentleyGeom.DVec3d, vectorV: MSPyBentleyGeom.DVec3d, scale: float) -> None
        
        Accumulates a 'rank one' matrix defined as a scale factor
        times the 'vector outer product' of two vectors, i.e. as the matrix
        {s*U*V^T}
        
        Parameter ``[in]``:
        vectorU The column vector U
        
        Parameter ``[in]``:
        vectorV The row vector V
        
        Parameter ``[in]``:
        scale The scale factor
        """
        ...
    
    def ColumnXAngleXY(*args, **kwargs):
        """
        ColumnXAngleXY(self: MSPyBentleyGeom.RotMatrix) -> float
        
        Returns the (0 or positive) angle from (1,0) to the XY vector in the
        first column.
        
        Returns:
        rotation angle (in radians) between 0 and 2Pi
        """
        ...
    
    def ConditionNumber(*args, **kwargs):
        """
        ConditionNumber(self: MSPyBentleyGeom.RotMatrix) -> float
        
        Computes an estimate of the condition of this instance matrix. Values
        near 0 are bad.
        
        Returns:
        estimated condition number.
        """
        ...
    
    def Copy(*args, **kwargs):
        """
        Copy(self: MSPyBentleyGeom.RotMatrix, arg0: MSPyBentleyGeom.RotMatrix) -> None
        
        Sets this instance matrix by copying from the matrix
        parameter.
        
        Parameter ``[in]``:
        in The source matrix
        """
        ...
    
    def Determinant(*args, **kwargs):
        """
        Determinant(self: MSPyBentleyGeom.RotMatrix) -> float
        
        Returns the determinant of the matrix.
        
        Returns:
        determinant of the matrix.
        """
        ...
    
    def DiagonalAbsRange(*args, **kwargs):
        """
        DiagonalAbsRange(*args, **kwargs)
        Overloaded function.
        
        1. DiagonalAbsRange(self: MSPyBentleyGeom.RotMatrix) -> tuple
        
        Return the (absolute value) range of entries on the
        diagonal.
        
        Parameter ``[out]``:
        minValue smallest absolute value
        
        Parameter ``[out]``:
        maxValue largest absolute value
        
        2. DiagonalAbsRange(self: MSPyBentleyGeom.RotMatrix) -> MSPyBentleyGeom.DRange1d
        
        Return the (absolute value) range of entries on the
        diagonal.
        
        Parameter ``[out]``:
        minValue smallest absolute value
        
        Parameter ``[out]``:
        maxValue largest absolute value
        """
        ...
    
    def DiagonalMaxAbs(*args, **kwargs):
        """
        DiagonalMaxAbs(self: MSPyBentleyGeom.RotMatrix) -> float
        
        return the largest absolute value on the diagonal
        """
        ...
    
    def DiagonalSignedRange(*args, **kwargs):
        """
        DiagonalSignedRange(self: MSPyBentleyGeom.RotMatrix) -> tuple
        
        Return the (signed) range of entries on the diagonal.
        
        Parameter ``[out]``:
        minValue smallest signed value
        
        Parameter ``[out]``:
        maxValue largest signed value
        """
        ...
    
    def FactorOrthogonalColumns(*args, **kwargs):
        """
        FactorOrthogonalColumns(self: MSPyBentleyGeom.RotMatrix, matrixB: MSPyBentleyGeom.RotMatrix, maxtrixV: MSPyBentleyGeom.RotMatrix) -> bool
        
        Factor the instance as a product B*V^ where B has mutually
        perpendicular columns and V is orthogonal.
        
        Parameter ``[out]``:
        matrixB orthogonal columns
        
        Parameter ``[out]``:
        matrixV transpose of right factor. (I.e. B = A*V)
        """
        ...
    
    def FactorRotateScaleRotate(*args, **kwargs):
        """
        FactorRotateScaleRotate(self: MSPyBentleyGeom.RotMatrix, rotation1: MSPyBentleyGeom.RotMatrix, scalePoint: MSPyBentleyGeom.DPoint3d, rotation2: MSPyBentleyGeom.RotMatrix) -> int
        
        Factor as{rotation1 * scale * rotation2}
        
        Returns:
        number of nonzero scales (independent columns).
        
        Parameter ``[out]``:
        rotation1 pure rotation
        
        Parameter ``[out]``:
        scalePoint scale factors, largest first.
        
        Parameter ``[out]``:
        rotation2 pure rotation
        """
        ...
    
    def From(*args, **kwargs):
        """
        From(transform: MSPyBentleyGeom.Transform) -> MSPyBentleyGeom.RotMatrix
        
        Returns a matrix copying the matrix part of the
        trasnform.
        
        Parameter ``[in]``:
        transform The transformation whose matrix part is returned
        """
        ...
    
    def From1Vector(*args, **kwargs):
        """
        From1Vector(dir: MSPyBentleyGeom.DVec3d, axis: int, normalize: bool) -> MSPyBentleyGeom.RotMatrix
        
        Initializes this instance matrix so that the indicated
        axis (axis = 0,1,or 2) is aligned with the vector dir. The normalize
        flag selects between normalized axes (all matrix columns of unit
        length) and unnormalized axes (all matrix columns of same length as
        the dir vector).
        
        Parameter ``[in]``:
        dir The fixed direction vector
        
        Parameter ``[in]``:
        axis The axis column to be aligned with direction
        
        Parameter ``[in]``:
        normalize true to have normalized columns
        
        Returns:
        true if the direction vector is nonzero.
        """
        ...
    
    def From2Vector(*args, **kwargs):
        """
        From2Vector(xVector: MSPyBentleyGeom.DVec3d, yVector: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.RotMatrix
        """
        ...
    
    def FromAxisAndRotationAngle(*args, **kwargs):
        """
        FromAxisAndRotationAngle(axis: int, radians: float) -> MSPyBentleyGeom.RotMatrix
        
        Returns a matrix of rotation about the x,y, or z axis
        (indicated by axis = 0,1, or 2) by an angle in radians.
        
        Parameter ``[in]``:
        axis The axis index 0=x, 1=y, 2=z
        
        Parameter ``[in]``:
        radians The rotation angle in radians
        """
        ...
    
    def FromColumnVectors(*args, **kwargs):
        """
        FromColumnVectors(vectorU: MSPyBentleyGeom.DVec3d, vectorV: MSPyBentleyGeom.DVec3d, vectorW: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.RotMatrix
        
        Returns a matrix with 3 vectors copied to respective
        columns.
        
        Parameter ``[in]``:
        vectorU The vector to insert in column 0
        
        Parameter ``[in]``:
        vectorV The vector to insert in column 1
        
        Parameter ``[in]``:
        vectorW The vector to insert in column 2
        """
        ...
    
    def FromDirectionAndScale(*args, **kwargs):
        """
        FromDirectionAndScale(vector: MSPyBentleyGeom.DVec3d, scale: float) -> MSPyBentleyGeom.RotMatrix
        
        Returns a matrix which scales along a vector direction.
        
        Parameter ``[in]``:
        vector The scaling direction
        
        Parameter ``[in]``:
        scale The scale factor
        """
        ...
    
    def FromPrincipleAxisRotations(*args, **kwargs):
        """
        FromPrincipleAxisRotations(inMatrix: MSPyBentleyGeom.RotMatrix, xrot: float, yrot: float, zrot: float) -> MSPyBentleyGeom.RotMatrix
        
        Returns the product{RX*RY*RZ*M} where RX, RY, and RZ are
        rotations (in radians) around X, Y, and Z axes, and M is the input
        matrix.
        
        Parameter ``[in]``:
        inMatrix The prior matrix
        
        Parameter ``[in]``:
        xrot The x axis rotation
        
        Parameter ``[in]``:
        yrot The y axis rotation
        
        Parameter ``[in]``:
        zrot The z axis rotation
        """
        ...
    
    def FromQuaternion(*args, **kwargs):
        """
        FromQuaternion(quat: MSPyBentleyGeom.DPoint4d) -> MSPyBentleyGeom.RotMatrix
        
        Parameter ``[in]``:
        quat The quaternion, stored as (xyzw)
        """
        ...
    
    def FromRotate90(*args, **kwargs):
        """
        FromRotate90(axis: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.RotMatrix
        
        Return a matrix for retation of 90 degrees about a vector.
        """
        ...
    
    def FromRowValues(*args, **kwargs):
        """
        FromRowValues(x00: float, x01: float, x02: float, x10: float, x11: float, x12: float, x20: float, x21: float, x22: float) -> MSPyBentleyGeom.RotMatrix
        
        Returns a matrix with the 9 specified coefficients given
        in " row major " order.
        
        Parameter ``[in]``:
        x00 The 00 entry
        
        Parameter ``[in]``:
        x01 The 01 entry
        
        Parameter ``[in]``:
        x02 The 02 entry
        
        Parameter ``[in]``:
        x10 The 10 entry
        
        Parameter ``[in]``:
        x11 The 11 entry
        
        Parameter ``[in]``:
        x12 The 12 entry
        
        Parameter ``[in]``:
        x20 The 20 entry
        
        Parameter ``[in]``:
        x21 The 21 entry
        
        Parameter ``[in]``:
        x22 The 22 entry
        """
        ...
    
    def FromRowVectors(*args, **kwargs):
        """
        FromRowVectors(vectorU: MSPyBentleyGeom.DVec3d, vectorV: MSPyBentleyGeom.DVec3d, vectorW: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.RotMatrix
        
        Returns a matrix with 3 vectors copied to respective
        rows.
        
        Parameter ``[in]``:
        vectorU The vector to insert in row 0
        
        Parameter ``[in]``:
        vectorV The vector to insert in row 1
        
        Parameter ``[in]``:
        vectorW The vector to insert in row 2
        """
        ...
    
    def FromScale(*args, **kwargs):
        """
        FromScale(scale: float) -> MSPyBentleyGeom.RotMatrix
        
        Returns a uniform scaling matrix.
        
        Parameter ``[in]``:
        scale The scale factor.
        """
        ...
    
    def FromScaleFactors(*args, **kwargs):
        """
        FromScaleFactors(xscale: float, yscale: float, zscale: float) -> MSPyBentleyGeom.RotMatrix
        
        Returns a scaling matrix with respective x, y, and z
        scaling factors.
        
        Parameter ``[in]``:
        xscale The x direction scale factor (00 diagonal)
        
        Parameter ``[in]``:
        yscale The y direction scale factor (11 diagonal)
        
        Parameter ``[in]``:
        zscale The z direction scale factor (22 diagonal)
        """
        ...
    
    def FromScaledOuterProduct(*args, **kwargs):
        """
        FromScaledOuterProduct(vectorU: MSPyBentleyGeom.DVec3d, vectorV: MSPyBentleyGeom.DVec3d, scale: float) -> MSPyBentleyGeom.RotMatrix
        
        Returns a 'rank one' matrix defined as a scale factor
        times the 'vector outer product' of two vectors, i.e. as the matrix
        {s*U*V^T}
        
        Parameter ``[in]``:
        vectorU The column vector U
        
        Parameter ``[in]``:
        vectorV The row vector V
        
        Parameter ``[in]``:
        scale The scale factor
        """
        ...
    
    def FromTransposeOf(*args, **kwargs):
        """
        FromTransposeOf(matrix: MSPyBentleyGeom.RotMatrix) -> MSPyBentleyGeom.RotMatrix
        
        Return (as function value) the transpose of a matrix.
        
        Parameter ``[in]``:
        matrix The input matrix
        """
        ...
    
    def FromVectorAndRotationAngle(*args, **kwargs):
        """
        FromVectorAndRotationAngle(*args, **kwargs)
        Overloaded function.
        
        1. FromVectorAndRotationAngle(axis: MSPyBentleyGeom.DVec3d, radians: float) -> MSPyBentleyGeom.RotMatrix
        
        Returns a matrix representing rotation around a vector.
        
        Parameter ``[in]``:
        axis The axis of rotation
        
        Parameter ``[in]``:
        radians The rotation angle
        
        2. FromVectorAndRotationAngle(axis: MSPyBentleyGeom.DVec3d, radians: float, deriviativeMatrix: MSPyBentleyGeom.RotMatrix) -> MSPyBentleyGeom.RotMatrix
        
        Returns a matrix representing rotation around a vector.
        
        Parameter ``[in]``:
        axis The axis of rotation
        
        Parameter ``[in]``:
        radians The rotation angle
        """
        ...
    
    def GetColumn(*args, **kwargs):
        """
        GetColumn(self: MSPyBentleyGeom.RotMatrix, vector: MSPyBentleyGeom.DVec3d, col: int) -> None
        
        Returns a point taken from a column of a matrix.
        
        Parameter ``[out]``:
        vector filled vector
        
        Parameter ``[in]``:
        col The index of column to extract. Column indices are 0, 1, 2.
        """
        ...
    
    def GetColumns(*args, **kwargs):
        """
        GetColumns(self: MSPyBentleyGeom.RotMatrix, vectorU: MSPyBentleyGeom.DVec3d, vectorV: MSPyBentleyGeom.DVec3d, vectorW: MSPyBentleyGeom.DVec3d) -> None
        
        Copies from columns of this instance matrix to
        corresponding points.
        
        Parameter ``[out]``:
        vectorU first column
        
        Parameter ``[out]``:
        vectorV second column
        
        Parameter ``[out]``:
        vectorW third column
        """
        ...
    
    def GetComponentByRowAndColumn(*args, **kwargs):
        """
        GetComponentByRowAndColumn(self: MSPyBentleyGeom.RotMatrix, row: int, col: int) -> float
        
        Returns a value from a specified row and column of the
        matrix.
        
        Parameter ``[in]``:
        row The index of row to read. Row indices are 0, 1, 2.
        
        Parameter ``[in]``:
        col The index of column to read. Column indices are 0, 1, 2.
        """
        ...
    
    def GetQuaternion(*args, **kwargs):
        """
        GetQuaternion(*args, **kwargs)
        Overloaded function.
        
        1. GetQuaternion(self: MSPyBentleyGeom.RotMatrix, quat: MSPyBentleyGeom.DPoint4d, transpose: bool) -> None
        
        Parameter ``[out]``:
        quat quaternion, stored as xyzw
        
        Parameter ``[in]``:
        transpose true if matrix is stored transposed
        
        2. GetQuaternion(self: MSPyBentleyGeom.RotMatrix, wxyzQuat: MSPyBentley.DoubleArray, transpose: bool) -> None
        
        Parameter ``[out]``:
        quat quaternion, stored as xyzw
        
        Parameter ``[in]``:
        transpose true if matrix is stored transposed
        """
        ...
    
    def GetRotationAngleAndVector(*args, **kwargs):
        """
        GetRotationAngleAndVector(self: MSPyBentleyGeom.RotMatrix, axis: MSPyBentleyGeom.DVec3d) -> float
        
        Returns the angle of rotation of this instance and sets axis to be the
        normalized vector about which this instance rotates. NOTE:this
        instance is assumed to be a (rigid body, i.e. orthogonal) rotation
        matrix. Since negating both angle and axis produces an identical
        rotation, calculations are simplified by assuming (and returning) the
        angle in [0,Pi].
        
        Parameter ``[out]``:
        axis normalized axis of rotation
        
        Returns:
        rotation angle (in radians) between 0 and Pi, inclusive
        """
        ...
    
    def GetRow(*args, **kwargs):
        """
        GetRow(self: MSPyBentleyGeom.RotMatrix, vector: MSPyBentleyGeom.DVec3d, row: int) -> None
        
        Returns a vector taken from a column of a matrix.
        
        Parameter ``[out]``:
        vector filled vector
        
        Parameter ``[in]``:
        row The index of row to extract. Row indices are 0, 1, and 2.
        """
        ...
    
    def GetRowValues(*args, **kwargs):
        """
        GetRowValues(self: MSPyBentleyGeom.RotMatrix) -> List[float[9]]
        
        Get all contents as individual doubles, moving along rows
        """
        ...
    
    def GetRowValuesXY(*args, **kwargs):
        """
        GetRowValuesXY(self: MSPyBentleyGeom.RotMatrix, arg0: MSPyBentley.DoubleArray) -> None
        
        Copies 4 doubles from xx,xy,yx,yy positions into an
        array.
        
        Parameter ``[out]``:
        data returned data -- first 2 entries in row 0, then first 2 in
        row 1.
        """
        ...
    
    def GetRows(*args, **kwargs):
        """
        GetRows(self: MSPyBentleyGeom.RotMatrix, vectorU: MSPyBentleyGeom.DVec3d, vectorV: MSPyBentleyGeom.DVec3d, vectorW: MSPyBentleyGeom.DVec3d) -> None
        
        Copies from rows of this instance matrix to corresponding
        points.
        
        Parameter ``[out]``:
        vectorU first row
        
        Parameter ``[out]``:
        vectorV second row
        
        Parameter ``[out]``:
        vectorW third row
        """
        ...
    
    def GivensColumnOp(*args, **kwargs):
        """
        GivensColumnOp(self: MSPyBentleyGeom.RotMatrix, c: float, s: float, i0: int, i1: int) -> None
        
        Apply a Givens " column operation ", i.e. post-multiply by a Givens
        rotation matrix. The Givens matrix is an identity except for the 4
        rotational entries, viz R(i0,i0)=R(i1,i1)=c R(i0,i1)=-s R(i1,i0)=s
        
        Parameter ``[in]``:
        c The cosine of givens rotation.
        
        Parameter ``[in]``:
        s The sine of givens rotation.
        
        Parameter ``[in]``:
        i0 The index of the first affected row.
        
        Parameter ``[in]``:
        i1 The index of the second affected row.
        """
        ...
    
    def GivensRowOp(*args, **kwargs):
        """
        GivensRowOp(self: MSPyBentleyGeom.RotMatrix, c: float, s: float, i0: int, i1: int) -> None
        
        Apply a Givens " row operation ", i.e. pre-multiply by a Givens rotation
        matrix. The Givens matrix is an identity except for the 4 rotational
        entries, viz R(i0,i0)=R(i1,i1)=c R(i0,i1)=s R(i1,i0)=-s
        
        Parameter ``[in]``:
        c The cosine of givens rotation.
        
        Parameter ``[in]``:
        s The sine of givens rotation.
        
        Parameter ``[in]``:
        i0 The index of the first affected row.
        
        Parameter ``[in]``:
        i1 The index of the second affected row.
        """
        ...
    
    def HyperbolicColumnOp(*args, **kwargs):
        """
        HyperbolicColumnOp(self: MSPyBentleyGeom.RotMatrix, secant: float, tangent: float, i0: int, i1: int) -> None
        
        Apply a hyperbolic " column operation ", i.e. pre-multiply by a
        hyperbolic reflection matrix The matrix is an identity except for the
        4 entries R(i0,i0)=R(i1,i1)=secant R(i0,i1)=R(i1,i0)=tangent
        
        Parameter ``[in]``:
        secant The cosine of reflection.
        
        Parameter ``[in]``:
        tangent The sine of reflection.
        
        Parameter ``[in]``:
        i0 The index of the first affected row.
        
        Parameter ``[in]``:
        i1 The index of the second affected row.
        """
        ...
    
    def HyperbolicRowOp(*args, **kwargs):
        """
        HyperbolicRowOp(self: MSPyBentleyGeom.RotMatrix, secant: float, tangent: float, i0: int, i1: int) -> None
        
        Apply a hyperbolic " row operation ", i.e. pre-multiply by a hyperbolic
        reflection matrix The matrix is an identity except for the 4 entries
        R(i0,i0)=R(i1,i1)=secant R(i0,i1)=R(i1,i0)=tangent
        
        Parameter ``[in]``:
        secant The cosine of reflection.
        
        Parameter ``[in]``:
        tangent The sine of reflection.
        
        Parameter ``[in]``:
        i0 The index of the first affected row.
        
        Parameter ``[in]``:
        i1 The index of the second affected row.
        """
        ...
    
    def InitFrom(*args, **kwargs):
        """
        InitFrom(self: MSPyBentleyGeom.RotMatrix, transform: MSPyBentleyGeom.Transform) -> None
        
        Sets this instance matrix by copying the matrix part of the trasnform.
        
        Parameter ``[in]``:
        transform The transformation whose matrix part is returned
        """
        ...
    
    def InitFrom1Vector(*args, **kwargs):
        """
        InitFrom1Vector(self: MSPyBentleyGeom.RotMatrix, dir: MSPyBentleyGeom.DVec3d, axis: int, normalize: bool) -> bool
        
        Initializes this instance matrix so that the indicated
        axis (axis = 0,1,or 2) is aligned with the vector dir. The normalize
        flag selects between normalized axes (all matrix columns of unit
        length) and unnormalized axes (all matrix columns of same length as
        the dir vector).
        
        Parameter ``[in]``:
        dir The fixed direction vector
        
        Parameter ``[in]``:
        axis The axis column to be aligned with direction
        
        Parameter ``[in]``:
        normalize true to have normalized columns
        
        Returns:
        true if the direction vector is nonzero.
        """
        ...
    
    def InitFrom2Vector(*args, **kwargs):
        """
        InitFrom2Vector(self: MSPyBentleyGeom.RotMatrix, xVector: MSPyBentleyGeom.DVec3d, yVector: MSPyBentleyGeom.DVec3d) -> None
        """
        ...
    
    def InitFromAxisAndRotationAngle(*args, **kwargs):
        """
        InitFromAxisAndRotationAngle(self: MSPyBentleyGeom.RotMatrix, axis: int, radians: float) -> None
        
        Returns a matrix of rotation about the x,y, or z axis
        (indicated by axis = 0,1, or 2) by an angle in radians.
        
        Parameter ``[in]``:
        axis The axis index 0=x, 1=y, 2=z
        
        Parameter ``[in]``:
        radians The rotation angle in radians
        """
        ...
    
    def InitFromColumnVectors(*args, **kwargs):
        """
        InitFromColumnVectors(self: MSPyBentleyGeom.RotMatrix, vectorU: MSPyBentleyGeom.DVec3d, vectorV: MSPyBentleyGeom.DVec3d, vectorW: MSPyBentleyGeom.DVec3d) -> None
        
        Returns a matrix with 3 points copied to respective
        columns.
        
        Parameter ``[in]``:
        vectorU The vector to insert in column 0
        
        Parameter ``[in]``:
        vectorV The vector to insert in column 1
        
        Parameter ``[in]``:
        vectorW The vector to insert in column 2
        """
        ...
    
    def InitFromDirectionAndScale(*args, **kwargs):
        """
        InitFromDirectionAndScale(self: MSPyBentleyGeom.RotMatrix, vector: MSPyBentleyGeom.DVec3d, scale: float) -> None
        
        Initializes a matrix which scales along a vector
        direction.
        
        Parameter ``[in]``:
        vector The scaling direction
        
        Parameter ``[in]``:
        scale The scale factor
        """
        ...
    
    def InitFromPrincipleAxisRotations(*args, **kwargs):
        """
        InitFromPrincipleAxisRotations(self: MSPyBentleyGeom.RotMatrix, inMatrix: MSPyBentleyGeom.RotMatrix, xrot: float, yrot: float, zrot: float) -> None
        
        Returns the product{RX*RY*RZ*M} where RX, RY, and RZ are
        rotations (in radians) around X, Y, and Z axes, and M is the input
        matrix.
        
        Parameter ``[in]``:
        inMatrix The prior matrix
        
        Parameter ``[in]``:
        xrot The x axis rotation
        
        Parameter ``[in]``:
        yrot The y axis rotation
        
        Parameter ``[in]``:
        zrot The z axis rotation
        """
        ...
    
    def InitFromQuaternion(*args, **kwargs):
        """
        InitFromQuaternion(*args, **kwargs)
        Overloaded function.
        
        1. InitFromQuaternion(self: MSPyBentleyGeom.RotMatrix, quat: MSPyBentleyGeom.DPoint4d) -> None
        
        Parameter ``[in]``:
        quat The quaternion, stored as (xyzw)
        
        2. InitFromQuaternion(self: MSPyBentleyGeom.RotMatrix, wxyzQuat: List[float[4]]) -> None
        """
        ...
    
    def InitFromRowValues(*args, **kwargs):
        """
        InitFromRowValues(self: MSPyBentleyGeom.RotMatrix, x00: float, x01: float, x02: float, x10: float, x11: float, x12: float, x20: float, x21: float, x22: float) -> None
        
        Initializes a matrix with the 9 specified coefficients
        given in " row major " order.
        
        Parameter ``[in]``:
        x00 The 00 entry
        
        Parameter ``[in]``:
        x01 The 01 entry
        
        Parameter ``[in]``:
        x02 The 02 entry
        
        Parameter ``[in]``:
        x10 The 10 entry
        
        Parameter ``[in]``:
        x11 The 11 entry
        
        Parameter ``[in]``:
        x12 The 12 entry
        
        Parameter ``[in]``:
        x20 The 20 entry
        
        Parameter ``[in]``:
        x21 The 21 entry
        
        Parameter ``[in]``:
        x22 The 22 entry
        """
        ...
    
    def InitFromRowValuesXY(*args, **kwargs):
        """
        InitFromRowValuesXY(*args, **kwargs)
        Overloaded function.
        
        1. InitFromRowValuesXY(self: MSPyBentleyGeom.RotMatrix, x00: float, x01: float, x10: float, x11: float) -> None
        
        Initializes a matrix with the 4 specified coefficients in
        xx,xy,yx,yy positions, and 1 in zz in " row major " order.
        
        Parameter ``[in]``:
        x00 The 00 entry
        
        Parameter ``[in]``:
        x01 The 01 entry
        
        Parameter ``[in]``:
        x10 The 10 entry
        
        Parameter ``[in]``:
        x11 The 11 entry
        
        2. InitFromRowValuesXY(self: MSPyBentleyGeom.RotMatrix, value: List[float[4]]) -> None
        """
        ...
    
    def InitFromRowVectors(*args, **kwargs):
        """
        InitFromRowVectors(self: MSPyBentleyGeom.RotMatrix, vectorU: MSPyBentleyGeom.DVec3d, vectorV: MSPyBentleyGeom.DVec3d, vectorW: MSPyBentleyGeom.DVec3d) -> None
        
        Initializes a matrix with 3 points copied to respective
        rows.
        
        Parameter ``[in]``:
        vectorU The vector to insert in row 0
        
        Parameter ``[in]``:
        vectorV The vector to insert in row 1
        
        Parameter ``[in]``:
        vectorW The vector to insert in row 2
        """
        ...
    
    def InitFromScale(*args, **kwargs):
        """
        InitFromScale(self: MSPyBentleyGeom.RotMatrix, arg0: float) -> None
        
        scale_a
        """
        ...
    
    def InitFromScaleFactors(*args, **kwargs):
        """
        InitFromScaleFactors(self: MSPyBentleyGeom.RotMatrix, xscale: float, yscale: float, zscale: float) -> None
        
        Returns a scaling matrix with respective x, y, and z
        scaling factors.
        
        Parameter ``[in]``:
        xscale The x direction scale factor
        
        Parameter ``[in]``:
        yscale The y direction scale factor
        
        Parameter ``[in]``:
        zscale The z direction scale factor
        """
        ...
    
    def InitFromScaledOuterProduct(*args, **kwargs):
        """
        InitFromScaledOuterProduct(self: MSPyBentleyGeom.RotMatrix, vectorU: MSPyBentleyGeom.DVec3d, vectorV: MSPyBentleyGeom.DVec3d, scale: float) -> None
        
        Returns a 'rank one' matrix defined as a scale factor
        times the 'vector outer product' of two vectors, i.e. as the matrix
        {s*U*V^T}
        
        Parameter ``[in]``:
        vectorU The column vector U
        
        Parameter ``[in]``:
        vectorV The row vector V
        
        Parameter ``[in]``:
        scale The scale factor
        """
        ...
    
    def InitFromVectorAndRotationAngle(*args, **kwargs):
        """
        InitFromVectorAndRotationAngle(self: MSPyBentleyGeom.RotMatrix, axis: MSPyBentleyGeom.DVec3d, radians: float) -> None
        """
        ...
    
    def InitIdentity(*args, **kwargs):
        """
        InitIdentity(self: MSPyBentleyGeom.RotMatrix) -> None
        
        Initialize an identity matrix.
        """
        ...
    
    def InitProduct(*args, **kwargs):
        """
        InitProduct(*args, **kwargs)
        Overloaded function.
        
        1. InitProduct(self: MSPyBentleyGeom.RotMatrix, rotMatrixA: MSPyBentleyGeom.RotMatrix, rotMatrixB: MSPyBentleyGeom.RotMatrix) -> None
        
        Returns the product{A*B} of two matrices.
        
        Parameter ``[in]``:
        rotMatrixA The first factor
        
        Parameter ``[in]``:
        rotMatrixB The second factor
        
        2. InitProduct(self: MSPyBentleyGeom.RotMatrix, rotMatrixA: MSPyBentleyGeom.RotMatrix, rotMatrixB: MSPyBentleyGeom.RotMatrix, rotMatrixC: MSPyBentleyGeom.RotMatrix) -> None
        
        Returns the product{A*B} of two matrices.
        
        Parameter ``[in]``:
        rotMatrixA The first factor
        
        Parameter ``[in]``:
        rotMatrixB The second factor
        
        3. InitProduct(self: MSPyBentleyGeom.RotMatrix, rotMatrixA: MSPyBentleyGeom.RotMatrix, transformB: MSPyBentleyGeom.Transform) -> None
        
        Returns the product{A*B} of two matrices.
        
        Parameter ``[in]``:
        rotMatrixA The first factor
        
        Parameter ``[in]``:
        rotMatrixB The second factor
        
        4. InitProduct(self: MSPyBentleyGeom.RotMatrix, transformA: MSPyBentleyGeom.Transform, rotMatrixB: MSPyBentleyGeom.RotMatrix) -> None
        
        Returns the product{A*B} of two matrices.
        
        Parameter ``[in]``:
        rotMatrixA The first factor
        
        Parameter ``[in]``:
        rotMatrixB The second factor
        """
        ...
    
    def InitProductRotMatrixRotMatrixTranspose(*args, **kwargs):
        """
        InitProductRotMatrixRotMatrixTranspose(self: MSPyBentleyGeom.RotMatrix, rotMatrixA: MSPyBentleyGeom.RotMatrix, rotMatrixB: MSPyBentleyGeom.RotMatrix) -> None
        
        Returns the product of rotMatrixA times the transpose of
        rotMatrixB
        
        Parameter ``[in]``:
        rotMatrixA The first factor
        
        Parameter ``[in]``:
        rotMatrixB The second factor (to be transposed)
        """
        ...
    
    def InitProductRotMatrixTransposeRotMatrix(*args, **kwargs):
        """
        InitProductRotMatrixTransposeRotMatrix(self: MSPyBentleyGeom.RotMatrix, rotMatrixA: MSPyBentleyGeom.RotMatrix, rotMatrixB: MSPyBentleyGeom.RotMatrix) -> None
        
        Returns the product of the transpose of rotMatrixA times
        rotMatrixB
        
        Parameter ``[in]``:
        rotMatrixA The first factor (to be transposed)
        
        Parameter ``[in]``:
        rotMatrixB The second factor
        """
        ...
    
    def InitRotationFromOriginXY(*args, **kwargs):
        """
        InitRotationFromOriginXY(self: MSPyBentleyGeom.RotMatrix, origin: MSPyBentleyGeom.DPoint3d, xPoint: MSPyBentleyGeom.DPoint3d, yPoint: MSPyBentleyGeom.DPoint3d) -> bool
        
        Set this instance matrix to be an orthogonal (rotation)
        matrix with column 0 in the direction from the origin to the x point,
        column 1 in the plane of the 3 points, directed so the Y point on the
        positive side, and column 2 as their cross product.
        
        Parameter ``[in]``:
        origin The reference point
        
        Parameter ``[in]``:
        xPoint The x axis target point
        
        Parameter ``[in]``:
        yPoint The 3rd point defining xy plane.
        """
        ...
    
    def InitRotationFromVectorToVector(*args, **kwargs):
        """
        InitRotationFromVectorToVector(self: MSPyBentleyGeom.RotMatrix, startVector: MSPyBentleyGeom.DVec3d, endVector: MSPyBentleyGeom.DVec3d) -> bool
        
        (conditionally) initialize the instance as the (smallest)
        rotation that moves startVector so it is in the direction of
        endVector. In the normal case where the vectors are not parallel or
        antiparallel, this is a rotation around their cross product.
        
        Returns:
        false if one or both are zero vectors.
        
        Remark:
        if the vectors are direction opposite, the rotation is around an
        arbitrarily
        """
        ...
    
    def InitTransposedFromQuaternionWXYZ(*args, **kwargs):
        """
        InitTransposedFromQuaternionWXYZ(self: MSPyBentleyGeom.RotMatrix, wxyzQuat: float) -> None
        
        Initialization, compatible with mdlRMatrix_fromQuat.
        
        Parameter ``[in]``:
        pQuatAsDoubleArray The quaternion, stored as (w,x,y,z) in an array
        of doubles.
        """
        ...
    
    def InverseOf(*args, **kwargs):
        """
        InverseOf(self: MSPyBentleyGeom.RotMatrix, forward: MSPyBentleyGeom.RotMatrix) -> bool
        
        Returns the inverse of the a matrix.
        
        Parameter ``[in]``:
        forward The input matrix
        
        Returns:
        true if the matrix is invertible.
        """
        ...
    
    def Invert(*args, **kwargs):
        """
        Invert(self: MSPyBentleyGeom.RotMatrix) -> bool
        
        Inverts this instance matrix in place.
        
        Returns:
        true if the matrix is invertible.
        """
        ...
    
    def IsDiagonal(*args, **kwargs):
        """
        IsDiagonal(self: MSPyBentleyGeom.RotMatrix) -> bool
        
        Tests if a matrix has small offdiagonal entries compared
        to diagonals. The specific test condition is that the largest off
        diagonal absolute value is less than a tight tolerance fraction times
        the largest diagonal entry.
        
        Returns:
        true if matrix is approximately diagonal
        """
        ...
    
    def IsEqual(*args, **kwargs):
        """
        IsEqual(*args, **kwargs)
        Overloaded function.
        
        1. IsEqual(self: MSPyBentleyGeom.RotMatrix, maxtrix2: MSPyBentleyGeom.RotMatrix) -> bool
        
        Tests for equality between two matrices " Equality " means
        relative error less than 1.0e-12, in the sense that each component-
        wise difference is less than 1.0e-12 times the largest absolute value
        of the components of one matrix.
        
        Parameter ``[in]``:
        matrix2 The second matrix
        
        Returns:
        true if the matrices are identical.
        
        2. IsEqual(self: MSPyBentleyGeom.RotMatrix, maxtrix2: MSPyBentleyGeom.RotMatrix, tolerance: float) -> bool
        
        Tests for equality between two matrices " Equality " means
        relative error less than 1.0e-12, in the sense that each component-
        wise difference is less than 1.0e-12 times the largest absolute value
        of the components of one matrix.
        
        Parameter ``[in]``:
        matrix2 The second matrix
        
        Returns:
        true if the matrices are identical.
        """
        ...
    
    def IsIdentity(*args, **kwargs):
        """
        IsIdentity(self: MSPyBentleyGeom.RotMatrix) -> bool
        
        Tests if a matrix is the identity matrix.
        
        Returns:
        true if matrix is approximately an identity.
        """
        ...
    
    def IsNearRigidScale(*args, **kwargs):
        """
        IsNearRigidScale(self: MSPyBentleyGeom.RotMatrix, dest: MSPyBentleyGeom.RotMatrix, primaryAxis: int = 0, tolerance: float = 1e-06) -> bool
        
        Determine if a matrix is close to a pure rotate and scale. If source
        is not near rigid, return false and copy to the output. If near an
        identity return identity. If nearly perpendicular with scales other
        than 1, clean preserving the length and direction of the primary axis.
        This is intended to be used with a crude (e.g. 1.0e-6) reltol to
        identify old DGN file matrices that are " dirty " by modern standards
        but were meant to be identity, rotation, or scaled rotations in the
        UOR era.
        
        Parameter ``[in]``:
        dest result matrix
        
        Parameter ``[in]``:
        primaryAxis axis whose orientation and direction is preserved.
        
        Parameter ``[in]``:
        tolerance relative tolerance for recognizing near-perpendicular
        conditions.
        """
        ...
    
    def IsNearSignedPermutation(*args, **kwargs):
        """
        IsNearSignedPermutation(self: MSPyBentleyGeom.RotMatrix, result: MSPyBentleyGeom.RotMatrix, tolerance: float) -> bool
        
        Test if this instance matrix does nothing more than
        exchange and possibly negate principle axes, within a tolerance.
        
        Parameter ``[out]``:
        result the nearby permutation, or the orignal matrix if none near.
        
        Parameter ``[in]``:
        tolerance tolerance for comparison to the permutation
        
        Returns:
        true if the matrix is a near permutation of the principle axes.
        """
        ...
    
    def IsOrthogonal(*args, **kwargs):
        """
        IsOrthogonal(self: MSPyBentleyGeom.RotMatrix) -> bool
        
        Test if this instance matrix is orthogonal, i.e. its
        transpose is its inverse. This class of matrices includes both rigid
        body rotations and reflections.
        
        Returns:
        true if the matrix is orthogonal.
        """
        ...
    
    def IsOrthonormal(*args, **kwargs):
        """
        IsOrthonormal(self: MSPyBentleyGeom.RotMatrix, arg0: MSPyBentleyGeom.RotMatrix, arg1: MSPyBentleyGeom.DVec3d) -> tuple
        
        Test if this instance matrix has orthonormal columns,
        i.e. its columns are all perpendicular to one another.
        
        Parameter ``[out]``:
        columns matrix containing the unit vectors along the columns.
        
        Parameter ``[out]``:
        axisScales point whose x, y, and z components are the magnitudes
        of the original columns.
        
        Parameter ``[out]``:
        axisRatio smallest axis length divided by largest.
        
        Returns:
        true if the matrix is orthonormal.
        """
        ...
    
    def IsPlanar(*args, **kwargs):
        """
        IsPlanar(self: MSPyBentleyGeom.RotMatrix, normal: MSPyBentleyGeom.DVec3d) -> bool
        
        Tests if this instance matrix has no effects
        perpendicular to any plane with the given normal. This will be true if
        the matrix represents a combination of (a) scaling perpencicular to
        the normal and (b) rotation around the normal.
        
        Parameter ``[in]``:
        normal The plane normal
        
        Returns:
        true if the matrix has no effects perpendicular to any plane with
        the given normal.
        """
        ...
    
    def IsRigid(*args, **kwargs):
        """
        IsRigid(self: MSPyBentleyGeom.RotMatrix) -> bool
        
        Test if a matrix is a rigid body rotation, i.e. its
        transpose is its inverse and it has a positive determinant.
        
        Returns:
        true if the matrix is a rigid body rotation.
        """
        ...
    
    def IsRigidScale(*args, **kwargs):
        """
        IsRigidScale(self: MSPyBentleyGeom.RotMatrix, arg0: MSPyBentleyGeom.RotMatrix) -> tuple
        
        Test if this instance matrix is composed of only rigid
        rotation and scaling.
        
        Parameter ``[out]``:
        columns matrix containing the unit vectors along the columns.
        
        Parameter ``[out]``:
        scale largest axis scale factor. If function value is true, the
        min scale is the same. Use areColumnsOrthonormal to get separate
        column scales.
        
        Returns:
        true if the matrix is orthonormal.
        """
        ...
    
    def IsSignedPermutation(*args, **kwargs):
        """
        IsSignedPermutation(self: MSPyBentleyGeom.RotMatrix) -> bool
        
        Test if this instance matrix does nothing more than
        exchange and possibly negate principle axes.
        
        Returns:
        true if the matrix is a permutation of the principle axes.
        """
        ...
    
    def IsUniformScale(*args, **kwargs):
        """
        IsUniformScale(self: MSPyBentleyGeom.RotMatrix) -> tuple
        
        Tests if a matrix has (nearly) equal diagaonal entries
        and (nearly) zero off diagonals. Tests use a tight relative tolerance.
        
        Parameter ``[out]``:
        maxScale the largest diagaonal entry
        
        Returns:
        true if matrix is approximately diagonal
        """
        ...
    
    def LowerTriangleAbsRange(*args, **kwargs):
        """
        LowerTriangleAbsRange(self: MSPyBentleyGeom.RotMatrix) -> MSPyBentleyGeom.DRange1d
        
        return the range of absolute values strictly below the
        diagonal.
        """
        ...
    
    def LowerTriangleMaxAbs(*args, **kwargs):
        """
        LowerTriangleMaxAbs(self: MSPyBentleyGeom.RotMatrix) -> float
        
        return the largest absolute value in the lower triangle.
        """
        ...
    
    def MaxAbs(*args, **kwargs):
        """
        MaxAbs(self: MSPyBentleyGeom.RotMatrix) -> float
        
        Find the largest absolute value of entries in the matrix.
        
        Returns:
        largest absolute value in matrix
        """
        ...
    
    def MaxDiff(*args, **kwargs):
        """
        MaxDiff(self: MSPyBentleyGeom.RotMatrix, matrix2: MSPyBentleyGeom.RotMatrix) -> float
        
        Returns the largest absolute value difference between
        corresponding coefficients in Matrix1 and Matrix2.
        
        Parameter ``[in]``:
        matrix2 The matrix to compare to
        
        Returns:
        largest absolute difference between the two matrices.
        """
        ...
    
    def Multiply(*args, **kwargs):
        """
        Multiply(*args, **kwargs)
        Overloaded function.
        
        1. Multiply(self: MSPyBentleyGeom.RotMatrix, outRange: MSPyBentleyGeom.DRange3d, inRange: MSPyBentleyGeom.DRange3d) -> None
        
        Computes{M*P[i]} where M is this instance matrix and each P[i] is a
        point in the input array point. Each result is placed in the
        corresponding entry in the output array result. The same array may be
        named for the input and output arrays.
        
        Parameter ``[out]``:
        result output points
        
        Parameter ``[in]``:
        point The input points
        
        Parameter ``[in]``:
        numPoint The number of points
        
        2. Multiply(self: MSPyBentleyGeom.RotMatrix, point: MSPyBentleyGeom.DPoint3d) -> None
        
        Computes{M*P[i]} where M is this instance matrix and each P[i] is a
        point in the input array point. Each result is placed in the
        corresponding entry in the output array result. The same array may be
        named for the input and output arrays.
        
        Parameter ``[out]``:
        result output points
        
        Parameter ``[in]``:
        point The input points
        
        Parameter ``[in]``:
        numPoint The number of points
        
        3. Multiply(self: MSPyBentleyGeom.RotMatrix, result: MSPyBentleyGeom.DPoint3d, point: MSPyBentleyGeom.DPoint3d) -> None
        
        Computes{M*P[i]} where M is this instance matrix and each P[i] is a
        point in the input array point. Each result is placed in the
        corresponding entry in the output array result. The same array may be
        named for the input and output arrays.
        
        Parameter ``[out]``:
        result output points
        
        Parameter ``[in]``:
        point The input points
        
        Parameter ``[in]``:
        numPoint The number of points
        
        4. Multiply(self: MSPyBentleyGeom.RotMatrix, xyzwOut: MSPyBentleyGeom.DPoint4dArray, xyzwIn: MSPyBentleyGeom.DPoint4dArray) -> None
        
        Computes{M*P[i]} where M is this instance matrix and each P[i] is a
        point in the input array point. Each result is placed in the
        corresponding entry in the output array result. The same array may be
        named for the input and output arrays.
        
        Parameter ``[out]``:
        result output points
        
        Parameter ``[in]``:
        point The input points
        
        Parameter ``[in]``:
        numPoint The number of points
        
        5. Multiply(self: MSPyBentleyGeom.RotMatrix, xyzOut: MSPyBentleyGeom.DPoint3dArray, xyzIn: MSPyBentleyGeom.DPoint3dArray) -> None
        
        Computes{M*P[i]} where M is this instance matrix and each P[i] is a
        point in the input array point. Each result is placed in the
        corresponding entry in the output array result. The same array may be
        named for the input and output arrays.
        
        Parameter ``[out]``:
        result output points
        
        Parameter ``[in]``:
        point The input points
        
        Parameter ``[in]``:
        numPoint The number of points
        
        6. Multiply(self: MSPyBentleyGeom.RotMatrix, xyOut: MSPyBentleyGeom.DPoint2dArray, xyIn: MSPyBentleyGeom.DPoint2dArray) -> None
        
        Computes{M*P[i]} where M is this instance matrix and each P[i] is a
        point in the input array point. Each result is placed in the
        corresponding entry in the output array result. The same array may be
        named for the input and output arrays.
        
        Parameter ``[out]``:
        result output points
        
        Parameter ``[in]``:
        point The input points
        
        Parameter ``[in]``:
        numPoint The number of points
        """
        ...
    
    def MultiplyComponents(*args, **kwargs):
        """
        MultiplyComponents(self: MSPyBentleyGeom.RotMatrix, result: MSPyBentleyGeom.DPoint3d, x: float, y: float, z: float) -> None
        
        Returns the product of a matrix times a point, with the
        point given as separate components.
        
        Parameter ``[out]``:
        result result of multiplication
        
        Parameter ``[in]``:
        x The x component of input point
        
        Parameter ``[in]``:
        y The y component of input point
        
        Parameter ``[in]``:
        z The z component of input point
        """
        ...
    
    def MultiplyTranspose(*args, **kwargs):
        """
        MultiplyTranspose(*args, **kwargs)
        Overloaded function.
        
        1. MultiplyTranspose(self: MSPyBentleyGeom.RotMatrix, result: MSPyBentleyGeom.DPoint3d, point: MSPyBentleyGeom.DPoint3d) -> None
        
        Returns the product of a matrix transpose times a point.
        
        Parameter ``[out]``:
        result result of the multiplication.
        
        Parameter ``[in]``:
        point The known point.
        
        2. MultiplyTranspose(self: MSPyBentleyGeom.RotMatrix, point: MSPyBentleyGeom.DPoint3d) -> None
        
        Returns the product of a matrix transpose times a point.
        
        Parameter ``[out]``:
        result result of the multiplication.
        
        Parameter ``[in]``:
        point The known point.
        
        3. MultiplyTranspose(self: MSPyBentleyGeom.RotMatrix, outXYZ: MSPyBentleyGeom.DPoint3dArray, inXYZ: MSPyBentleyGeom.DPoint3dArray) -> None
        
        Returns the product of a matrix transpose times a point.
        
        Parameter ``[out]``:
        result result of the multiplication.
        
        Parameter ``[in]``:
        point The known point.
        """
        ...
    
    def MultiplyTransposeComponents(*args, **kwargs):
        """
        MultiplyTransposeComponents(self: MSPyBentleyGeom.RotMatrix, result: MSPyBentleyGeom.DPoint3d, x: float, y: float, z: float) -> None
        
        Returns the product P = [x,y,z]*M where M is the input
        matrix and P is the product point.
        
        Parameter ``[out]``:
        result product point
        
        Parameter ``[in]``:
        x The x component
        
        Parameter ``[in]``:
        y The y component
        
        Parameter ``[in]``:
        z The z component
        """
        ...
    
    def NormalizeColumnsOf(*args, **kwargs):
        """
        NormalizeColumnsOf(self: MSPyBentleyGeom.RotMatrix, inMatrix: MSPyBentleyGeom.RotMatrix, scaleVector: MSPyBentleyGeom.DVec3d) -> None
        
        Returns a matrix whose rows are unit vectors in the same
        drection as corresponding columns of the input matrix. Also
        (optionally) stores the original column magnitudes as components of
        the point.
        
        Parameter ``[in]``:
        inMatrix The input matrix
        
        Parameter ``[out]``:
        scaleVector length of original columns
        """
        ...
    
    def NormalizeRowsOf(*args, **kwargs):
        """
        NormalizeRowsOf(self: MSPyBentleyGeom.RotMatrix, inMatrix: MSPyBentleyGeom.RotMatrix, scaleVector: MSPyBentleyGeom.DVec3d) -> None
        
        Returns a matrix whose rows are unit vectors in the same
        drection as corresponding rows of the input matrix. Also (optionally)
        stores the original row magnitudes as components of the point.
        
        Parameter ``[in]``:
        inMatrix The input matrix
        
        Parameter ``[out]``:
        scaleVector length of original rows
        """
        ...
    
    def OffDiagonalAbsRange(*args, **kwargs):
        """
        OffDiagonalAbsRange(self: MSPyBentleyGeom.RotMatrix) -> tuple
        
        Return the (absolute value) range of entries off the
        diagonal.
        
        Parameter ``[out]``:
        minValue smallest absolute value
        
        Parameter ``[out]``:
        maxValue largest absolute value
        """
        ...
    
    def OffDiagonalSignedRange(*args, **kwargs):
        """
        OffDiagonalSignedRange(self: MSPyBentleyGeom.RotMatrix) -> tuple
        
        Return the (signed) range of entries off the diagonal.
        
        Parameter ``[out]``:
        minValue smallest signed value
        
        Parameter ``[out]``:
        maxValue largest signed value
        """
        ...
    
    def RotateAndSkewFactors(*args, **kwargs):
        """
        RotateAndSkewFactors(self: MSPyBentleyGeom.RotMatrix, rotation: MSPyBentleyGeom.RotMatrix, skewFactor: MSPyBentleyGeom.RotMatrix = 0, primiaryAxis: int, secondaryAxis: int) -> bool
        
        Factor as{rotation*skewFactor} where the rotation favors indicated
        primary and secondary axes.
        
        Parameter ``[out]``:
        rotation the (orthogonal, right handed) rotation.
        
        Parameter ``[out]``:
        skewFactor the scale and skew parts.
        
        Parameter ``[in]``:
        primaryAxis selects column whose direction is preserved.
        
        Parameter ``[in]``:
        secondaryAxis selects columns that defines plane (with
        primaryAxis)
        
        Returns:
        true if primary and secondary are independent.
        """
        ...
    
    def RotationFromOriginXY(*args, **kwargs):
        """
        RotationFromOriginXY(origin: MSPyBentleyGeom.DPoint3d, xPoint: MSPyBentleyGeom.DPoint3d, yPoint: MSPyBentleyGeom.DPoint3d) -> MSPyBentleyGeom.RotMatrix
        
        Set this instance matrix to be an orthogonal (rotation)
        matrix with column 0 in the direction from the origin to the x point,
        column 1 in the plane of the 3 points, directed so the Y point on the
        positive side, and column 2 as their cross product.
        
        Parameter ``[in]``:
        origin The reference point
        
        Parameter ``[in]``:
        xPoint The x axis target point
        
        Parameter ``[in]``:
        yPoint The 3rd point defining xy plane.
        """
        ...
    
    def Scale(*args, **kwargs):
        """
        Scale(self: MSPyBentleyGeom.RotMatrix, leftMatrix: MSPyBentleyGeom.RotMatrix, xs: float, ys: float, zs: float, rightMatrix: MSPyBentleyGeom.RotMatrix) -> None
        
        Returns a matrix formed from a scaling matrix which is
        multiplied on the left and/or right with other matrices. That is, form
        LeftMatrix * ScaleMatrix * RightMatrix where the ScaleMatrix is
        constructed from the given scale factors.
        
        Parameter ``[in]``:
        leftMatrix The matrix on left of product
        
        Parameter ``[in]``:
        xs The x scale factor
        
        Parameter ``[in]``:
        ys The y scale factor
        
        Parameter ``[in]``:
        zs The z scale factor
        
        Parameter ``[in]``:
        rightMatrix The matrix on right of product
        """
        ...
    
    def ScaleColumns(*args, **kwargs):
        """
        ScaleColumns(*args, **kwargs)
        Overloaded function.
        
        1. ScaleColumns(self: MSPyBentleyGeom.RotMatrix, inMatrix: MSPyBentleyGeom.RotMatrix, xScale: float, yScale: float, zScale: float) -> None
        
        Applies scale factors to corresponding columns of the
        input matrix, and places the result in this instance matrix.
        
        Parameter ``[in]``:
        in The initial matrix
        
        Parameter ``[in]``:
        xs The scale factor for column 0
        
        Parameter ``[in]``:
        ys The scale factor for column 1
        
        Parameter ``[in]``:
        zs The scale factor for column 2
        
        2. ScaleColumns(self: MSPyBentleyGeom.RotMatrix, xScale: float, yScale: float, zScale: float) -> None
        
        Applies scale factors to corresponding columns of the
        input matrix, and places the result in this instance matrix.
        
        Parameter ``[in]``:
        in The initial matrix
        
        Parameter ``[in]``:
        xs The scale factor for column 0
        
        Parameter ``[in]``:
        ys The scale factor for column 1
        
        Parameter ``[in]``:
        zs The scale factor for column 2
        """
        ...
    
    def ScaleRows(*args, **kwargs):
        """
        ScaleRows(self: MSPyBentleyGeom.RotMatrix, inMatrix: MSPyBentleyGeom.RotMatrix, xScale: float, yScale: float, zScale: float) -> None
        
        Applies scale factors to corresponding rows of the input
        matrix, and places the result in this instance matrix.
        
        Parameter ``[in]``:
        inMatrix The initial matrix
        
        Parameter ``[in]``:
        xScale The scale factor for row 0
        
        Parameter ``[in]``:
        yScale The scale factor for row 1
        
        Parameter ``[in]``:
        zScale The scale factor for row 2
        """
        ...
    
    def SetColumn(*args, **kwargs):
        """
        SetColumn(self: MSPyBentleyGeom.RotMatrix, vector: MSPyBentleyGeom.DVec3d, col: int) -> None
        
        Set the components in a column.
        
        Parameter ``[in]``:
        vector new values
        
        Parameter ``[in]``:
        col The index of column to change. Column indices are 0, 1, 2.
        """
        ...
    
    def SetRow(*args, **kwargs):
        """
        SetRow(self: MSPyBentleyGeom.RotMatrix, vector: MSPyBentleyGeom.DVec3d, row: int) -> None
        
        Set the components in a row.
        
        Parameter ``[in]``:
        vector new values
        
        Parameter ``[in]``:
        row The index of row to change. Row indices are 0, 1, 2.
        """
        ...
    
    def ShuffleColumnsOf(*args, **kwargs):
        """
        ShuffleColumnsOf(self: MSPyBentleyGeom.RotMatrix, inMatrix: MSPyBentleyGeom.RotMatrix, i0: int, i1: int, i2: int) -> None
        
        Moves columns 0, 1, 2 of the input matrix into columns
        i0, i1, i2 of the instance.
        
        Parameter ``[in]``:
        inMatrix The input matrix
        
        Parameter ``[in]``:
        i0 The column to receive input column 0
        
        Parameter ``[in]``:
        i1 The column to receive input column 1
        
        Parameter ``[in]``:
        i2 The column to receive input column 2
        """
        ...
    
    def Solve(*args, **kwargs):
        """
        Solve(self: MSPyBentleyGeom.RotMatrix, result: MSPyBentleyGeom.DPoint3d, point: MSPyBentleyGeom.DPoint3d) -> bool
        
        Return the product of a matrix inverse and a point.
        
        Parameter ``[out]``:
        result the unknown point
        
        Parameter ``[in]``:
        point The The known point
        
        Returns:
        false if this instance is singular.
        """
        ...
    
    def SolveArray(*args, **kwargs):
        """
        SolveArray(self: MSPyBentleyGeom.RotMatrix, xyzOut: MSPyBentleyGeom.DPoint3dArray, xyzIn: MSPyBentleyGeom.DPoint3dArray) -> bool
        
        Solve M*xyzOut[i] = xyzIn[i] for array of points.
        (Equivalent to multiplying by the matrix inverse)
        """
        ...
    
    def SolveTranspose(*args, **kwargs):
        """
        SolveTranspose(self: MSPyBentleyGeom.RotMatrix, result: MSPyBentleyGeom.DPoint3d, point: MSPyBentleyGeom.DPoint3d) -> bool
        
        Return the product of a matrix inverse transpose and a
        point.
        
        Parameter ``[out]``:
        result result of the multiplication
        
        Parameter ``[in]``:
        point The known point multipled by the matrix inverse.
        
        Returns:
        false if this instance is singular.
        """
        ...
    
    def SquareAndNormalizeColumns(*args, **kwargs):
        """
        SquareAndNormalizeColumns(*args, **kwargs)
        Overloaded function.
        
        1. SquareAndNormalizeColumns(self: MSPyBentleyGeom.RotMatrix, inMatrix: MSPyBentleyGeom.RotMatrix, primaryAxis: int, secondaryAxis: int) -> bool
        
        Adjust the direction and length of columns of the input
        matrix to produce an instance matrix which has perpendicular, unit
        length columns. The column whose index is primaryAxis (i.e. 0,1,2 for
        x,y,z axis of coordinate frame) is normalized to unit length in its
        current direction. The column whose index is secondaryAxis is unit
        length and perpendicular to the primaryAxis column, and lies in the
        same plane as that defined by the original primary and secondary
        columns. To preserve X axis and XY plane, call with axis id's 0 and 1.
        To preserve Z axis and ZX plane, call with axis id's 2 and 0. inMatrix
        and pMatrix may be the same address.
        
        Parameter ``[in]``:
        inMatrix The input matrix
        
        Parameter ``[in]``:
        primaryAxis The axis id (0, 1, 2) which is to be normalized but
        left in its current direction
        
        Parameter ``[in]``:
        secondaryAxis The axis id (0, 1, 2) which is to be kept within the
        plane of the primary and secondary axis.
        
        Returns:
        false if primaryAxis and secondaryAxis are the same, or either
        axis has zero length
        
        2. SquareAndNormalizeColumns(self: MSPyBentleyGeom.RotMatrix, inMatrix: MSPyBentleyGeom.RotMatrix, primaryAxis: int, secondaryAxis: int, preferredOrientation: int) -> bool
        
        Adjust the direction and length of columns of the input
        matrix to produce an instance matrix which has perpendicular, unit
        length columns. The column whose index is primaryAxis (i.e. 0,1,2 for
        x,y,z axis of coordinate frame) is normalized to unit length in its
        current direction. The column whose index is secondaryAxis is unit
        length and perpendicular to the primaryAxis column, and lies in the
        same plane as that defined by the original primary and secondary
        columns. To preserve X axis and XY plane, call with axis id's 0 and 1.
        To preserve Z axis and ZX plane, call with axis id's 2 and 0. inMatrix
        and pMatrix may be the same address.
        
        Parameter ``[in]``:
        inMatrix The input matrix
        
        Parameter ``[in]``:
        primaryAxis The axis id (0, 1, 2) which is to be normalized but
        left in its current direction
        
        Parameter ``[in]``:
        secondaryAxis The axis id (0, 1, 2) which is to be kept within the
        plane of the primary and secondary axis.
        
        Returns:
        false if primaryAxis and secondaryAxis are the same, or either
        axis has zero length
        """
        ...
    
    def SquareAndNormalizeColumnsAnyOrder(*args, **kwargs):
        """
        SquareAndNormalizeColumnsAnyOrder(*args, **kwargs)
        Overloaded function.
        
        1. SquareAndNormalizeColumnsAnyOrder(self: MSPyBentleyGeom.RotMatrix, inMatrix: MSPyBentleyGeom.RotMatrix, preferredOrientation: int) -> bool
        
        Returns an orthogonal matrix that preserves aligns with
        the columns of inMatrix. This is done by trying various combinations
        of primary and secondary axes until one succeeds in
        squareAndNormalizeColumns.
        
        Parameter ``[in]``:
        inMatrix The input matrix
        
        Parameter ``[in]``:
        preferredOrientation
        
        * 1 for right handed system
        
        
        * -1 for left handed system
        
        
        * 0 to match orientation of input (but default to right handed if input is singular)
        
        
        2. SquareAndNormalizeColumnsAnyOrder(self: MSPyBentleyGeom.RotMatrix, inMatrix: MSPyBentleyGeom.RotMatrix) -> bool
        
        Returns an orthogonal matrix that preserves aligns with
        the columns of inMatrix. This is done by trying various combinations
        of primary and secondary axes until one succeeds in
        squareAndNormalizeColumns.
        
        Parameter ``[in]``:
        inMatrix The input matrix
        
        Parameter ``[in]``:
        preferredOrientation
        
        * 1 for right handed system
        
        
        * -1 for left handed system
        
        
        * 0 to match orientation of input (but default to right handed if input is singular)
        """
        ...
    
    def Subtract(*args, **kwargs):
        """
        Subtract(self: MSPyBentleyGeom.RotMatrix, delta: MSPyBentleyGeom.RotMatrix) -> None
        
        Subtract a matrix (componentwise, in place).
        
        Parameter ``[in]``:
        delta The matrix to subtract
        """
        ...
    
    def SumDiagonalSquares(*args, **kwargs):
        """
        SumDiagonalSquares(self: MSPyBentleyGeom.RotMatrix) -> float
        
        Computes the sum of the squares of the diagonal entries
        of this instance matrix.
        
        Returns:
        Sum of squares of diagonal entries
        """
        ...
    
    def SumOf(*args, **kwargs):
        """
        SumOf(self: MSPyBentleyGeom.RotMatrix, matrix0: MSPyBentleyGeom.RotMatrix, matrix1: MSPyBentleyGeom.RotMatrix, scale1: float, matrix2: MSPyBentleyGeom.RotMatrix, scale2: float) -> None
        
        Returns{Matrix0 + Matrix1*s1+Matrix2*s2}, i.e. the sum
        of matrix M0, matrix M1 multiplied by scale s1, and matrix M2
        multiplied by scale s2. Any combination of the matrix pointers may
        have identical addresses.
        
        Parameter ``[in]``:
        matrix0 The matrix0 of formula
        
        Parameter ``[in]``:
        matrix1 The matrix1 of formula
        
        Parameter ``[in]``:
        scale1 The scale factor to apply to Matrix1
        
        Parameter ``[in]``:
        matrix2 The matrix2 of formula
        
        Parameter ``[in]``:
        scale2 The scale factor to apply to Matrix2
        """
        ...
    
    def SumOffDiagonalSquares(*args, **kwargs):
        """
        SumOffDiagonalSquares(self: MSPyBentleyGeom.RotMatrix) -> float
        
        Computes the sum of the squares of the off-diagonal
        entries of this instance matrix.
        
        Returns:
        sum of square of off-diagonal entries of the matrix.
        """
        ...
    
    def SumSquares(*args, **kwargs):
        """
        SumSquares(self: MSPyBentleyGeom.RotMatrix) -> float
        
        Return the sum of squares of coefficients in a matrix.
        
        Returns:
        Sum of squares of all entries in matrix
        """
        ...
    
    def Transpose(*args, **kwargs):
        """
        Transpose(self: MSPyBentleyGeom.RotMatrix) -> None
        
        Transposes a matrix in place.
        """
        ...
    
    def TransposeOf(*args, **kwargs):
        """
        TransposeOf(self: MSPyBentleyGeom.RotMatrix, matrix: MSPyBentleyGeom.RotMatrix) -> None
        
        Initializes this instance as the transpose of a matrix.
        
        Parameter ``[in]``:
        matrix The input matrix
        """
        ...
    
    def UpperTriangleAbsRange(*args, **kwargs):
        """
        UpperTriangleAbsRange(self: MSPyBentleyGeom.RotMatrix) -> MSPyBentleyGeom.DRange1d
        
        return the range of absolute values strictly above the
        diagonal.
        """
        ...
    
    def UpperTriangleMaxAbs(*args, **kwargs):
        """
        UpperTriangleMaxAbs(self: MSPyBentleyGeom.RotMatrix) -> float
        
        return the largest absolute value in the upper triangle.
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.RotMatrix) -> None:
        ...
    
    @property
    def form3d(arg0: MSPyBentleyGeom.RotMatrix) -> numpy.typing.NDArray:
        ...
    @form3d.setter
    def form3d(arg0: MSPyBentleyGeom.RotMatrix, arg1: numpy.typing.NDArray) -> None:
        ...
    
class RotMatrixArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.RotMatrixArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.RotMatrixArray, arg0: MSPyBentleyGeom.RotMatrixArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.RotMatrixArray, arg0: Iterable) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.RotMatrixArray, x: MSPyBentleyGeom.RotMatrix) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.RotMatrixArray) -> None
        
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.RotMatrixArray, L: MSPyBentleyGeom.RotMatrixArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.RotMatrixArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.RotMatrixArray, i: int, x: MSPyBentleyGeom.RotMatrix) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.RotMatrixArray) -> MSPyBentleyGeom.RotMatrix
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.RotMatrixArray, i: int) -> MSPyBentleyGeom.RotMatrix
        
        Remove and return the item at index ``i``
        """
        ...
    
SILHBND_BOTH: int

SILHBND_NONE: int

SILHBND_U: int

SILHBND_V: int

class SolidLocationDetail:
    """
    None
    """

    @property
    def A(arg0: MSPyBentleyGeom.SolidLocationDetail) -> float:
        ...
    @A.setter
    def A(arg0: MSPyBentleyGeom.SolidLocationDetail, arg1: float) -> None:
        ...
    
    @property
    def FaceIndices(arg0: MSPyBentleyGeom.SolidLocationDetail) -> MSPyBentleyGeom.SolidLocationDetail.FaceIndices:
        ...
    
    def GetA(*args, **kwargs):
        """
        GetA(self: MSPyBentleyGeom.SolidLocationDetail) -> float
        
        query the a parameter
        """
        ...
    
    def GetFaceIndices(*args, **kwargs):
        """
        GetFaceIndices(self: MSPyBentleyGeom.SolidLocationDetail) -> MSPyBentleyGeom.SolidLocationDetail.FaceIndices
        
        return a structure with all selector indices.
        """
        ...
    
    def GetParentId(*args, **kwargs):
        """
        GetParentId(self: MSPyBentleyGeom.SolidLocationDetail) -> int
        
        Return the parent id.
        """
        ...
    
    def GetPickParameter(*args, **kwargs):
        """
        GetPickParameter(self: MSPyBentleyGeom.SolidLocationDetail) -> float
        
        Return the parameter along the pick ray.
        """
        ...
    
    def GetPrimarySelector(*args, **kwargs):
        """
        GetPrimarySelector(self: MSPyBentleyGeom.SolidLocationDetail) -> int
        
        Return the primary selector.
        """
        ...
    
    def GetSecondarySelector(*args, **kwargs):
        """
        GetSecondarySelector(self: MSPyBentleyGeom.SolidLocationDetail) -> int
        
        Return the secondary selector
        """
        ...
    
    def GetU(*args, **kwargs):
        """
        GetU(self: MSPyBentleyGeom.SolidLocationDetail) -> float
        
        query the u parameter
        """
        ...
    
    def GetUDirection(*args, **kwargs):
        """
        GetUDirection(self: MSPyBentleyGeom.SolidLocationDetail) -> Bentley.DVec3d
        
        Return u direction vector.
        """
        ...
    
    def GetUV(*args, **kwargs):
        """
        GetUV(self: MSPyBentleyGeom.SolidLocationDetail) -> Bentley.DPoint2d
        
        Return u,v parameter information
        """
        ...
    
    def GetV(*args, **kwargs):
        """
        GetV(self: MSPyBentleyGeom.SolidLocationDetail) -> float
        
        query the v parameter
        """
        ...
    
    def GetVDirection(*args, **kwargs):
        """
        GetVDirection(self: MSPyBentleyGeom.SolidLocationDetail) -> Bentley.DVec3d
        
        Return v direction vector.
        """
        ...
    
    def GetXYZ(*args, **kwargs):
        """
        GetXYZ(self: MSPyBentleyGeom.SolidLocationDetail) -> Bentley.DPoint3d
        
        Return the pick coordinates
        """
        ...
    
    def Init(*args, **kwargs):
        """
        Init(self: MSPyBentleyGeom.SolidLocationDetail) -> None
        
        Initialize to zeroed state.
        """
        ...
    
    def IsCap0(*args, **kwargs):
        """
        IsCap0(selector0: int, selector1: int) -> bool
        
        Ask if a selector pair is the start cap.
        """
        ...
    
    def IsCap1(*args, **kwargs):
        """
        IsCap1(selector0: int, selector1: int) -> bool
        
        Ask if a selector pair is the end cap.
        """
        ...
    
    def IsCapSelect(*args, **kwargs):
        """
        IsCapSelect(self: MSPyBentleyGeom.SolidLocationDetail) -> tuple
        """
        ...
    
    def MapPickParameterFractionToRange(*args, **kwargs):
        """
        MapPickParameterFractionToRange(self: MSPyBentleyGeom.SolidLocationDetail, range: Bentley.DRange1d) -> bool
        
        Treat current pick parameter as fractions in new interval. return
        false (and leave the pick parameter unchanged) if the range is
        undefined.
        """
        ...
    
    @property
    def ParentId(arg0: MSPyBentleyGeom.SolidLocationDetail) -> int:
        ...
    @ParentId.setter
    def ParentId(arg0: MSPyBentleyGeom.SolidLocationDetail, arg1: int) -> None:
        ...
    
    @property
    def PickParameter(arg0: MSPyBentleyGeom.SolidLocationDetail) -> float:
        ...
    @PickParameter.setter
    def PickParameter(arg0: MSPyBentleyGeom.SolidLocationDetail, arg1: float) -> None:
        ...
    
    PrimaryIdCap: int
    
    @property
    def PrimarySelector(arg0: MSPyBentleyGeom.SolidLocationDetail) -> int:
        ...
    
    @property
    def SecondarySelector(arg0: MSPyBentleyGeom.SolidLocationDetail) -> int:
        ...
    
    def SetA(*args, **kwargs):
        """
        SetA(self: MSPyBentleyGeom.SolidLocationDetail, a: float) -> None
        
        Set a.
        """
        ...
    
    def SetCapSelector(*args, **kwargs):
        """
        SetCapSelector(self: MSPyBentleyGeom.SolidLocationDetail, id: int) -> None
        
        Set selectors for cap id (typically 0 or 1)
        """
        ...
    
    def SetFaceIndices(*args, **kwargs):
        """
        SetFaceIndices(*args, **kwargs)
        Overloaded function.
        
        1. SetFaceIndices(self: MSPyBentleyGeom.SolidLocationDetail, id0: int, id1: int, id2: int) -> None
        
        Set all face selectors
        
        2. SetFaceIndices(self: MSPyBentleyGeom.SolidLocationDetail, indices: MSPyBentleyGeom.SolidLocationDetail.FaceIndices) -> None
        
        Set all face selectors
        """
        ...
    
    def SetFaceIndices01(*args, **kwargs):
        """
        SetFaceIndices01(self: MSPyBentleyGeom.SolidLocationDetail, id0: int, id1: int) -> None
        
        Set all face selectors
        """
        ...
    
    def SetParentId(*args, **kwargs):
        """
        SetParentId(self: MSPyBentleyGeom.SolidLocationDetail, id: int) -> None
        
        Set the parent id.
        """
        ...
    
    def SetPickParameter(*args, **kwargs):
        """
        SetPickParameter(self: MSPyBentleyGeom.SolidLocationDetail, f: float) -> None
        
        set the pick fraction.
        """
        ...
    
    def SetU(*args, **kwargs):
        """
        SetU(self: MSPyBentleyGeom.SolidLocationDetail, u: float) -> None
        
        Set u
        """
        ...
    
    def SetUDirection(*args, **kwargs):
        """
        SetUDirection(self: MSPyBentleyGeom.SolidLocationDetail, dXdv: Bentley.DVec3d) -> None
        
        Set the u direction vector
        """
        ...
    
    def SetUV(*args, **kwargs):
        """
        SetUV(*args, **kwargs)
        Overloaded function.
        
        1. SetUV(self: MSPyBentleyGeom.SolidLocationDetail, uv: Bentley.DPoint2d) -> None
        
        Set the u,v, and direction vectors.
        
        2. SetUV(self: MSPyBentleyGeom.SolidLocationDetail, u: float, v: float, uDirection: Bentley.DVec3d, vDirection: Bentley.DVec3d) -> None
        
        Set the u,v, and direction vectors.
        """
        ...
    
    def SetV(*args, **kwargs):
        """
        SetV(self: MSPyBentleyGeom.SolidLocationDetail, v: float) -> None
        
        Set v.
        """
        ...
    
    def SetVDirection(*args, **kwargs):
        """
        SetVDirection(self: MSPyBentleyGeom.SolidLocationDetail, dXdv: Bentley.DVec3d) -> None
        
        Set the v direction vector
        """
        ...
    
    def SetXYZ(*args, **kwargs):
        """
        SetXYZ(self: MSPyBentleyGeom.SolidLocationDetail, arg0: Bentley.DPoint3d) -> None
        
        Set the point coordinates.
        """
        ...
    
    def TransformInPlace(*args, **kwargs):
        """
        TransformInPlace(self: MSPyBentleyGeom.SolidLocationDetail, transform: Bentley.Transform) -> None
        
        TransformInPlace points and vectors by the transform.
        """
        ...
    
    @property
    def U(arg0: MSPyBentleyGeom.SolidLocationDetail) -> float:
        ...
    @U.setter
    def U(arg0: MSPyBentleyGeom.SolidLocationDetail, arg1: float) -> None:
        ...
    
    @property
    def UDirection(arg0: MSPyBentleyGeom.SolidLocationDetail) -> Bentley.DVec3d:
        ...
    @UDirection.setter
    def UDirection(arg0: MSPyBentleyGeom.SolidLocationDetail, arg1: Bentley.DVec3d) -> None:
        ...
    
    @property
    def UV(arg0: MSPyBentleyGeom.SolidLocationDetail) -> Bentley.DPoint2d:
        ...
    @UV.setter
    def UV(arg0: MSPyBentleyGeom.SolidLocationDetail, arg1: Bentley.DPoint2d) -> None:
        ...
    
    def UpdateIfSmallerA(*args, **kwargs):
        """
        UpdateIfSmallerA(self: MSPyBentleyGeom.SolidLocationDetail, source: MSPyBentleyGeom.SolidLocationDetail) -> bool
        """
        ...
    
    @property
    def V(arg0: MSPyBentleyGeom.SolidLocationDetail) -> float:
        ...
    @V.setter
    def V(arg0: MSPyBentleyGeom.SolidLocationDetail, arg1: float) -> None:
        ...
    
    @property
    def VDirection(arg0: MSPyBentleyGeom.SolidLocationDetail) -> Bentley.DVec3d:
        ...
    @VDirection.setter
    def VDirection(arg0: MSPyBentleyGeom.SolidLocationDetail, arg1: Bentley.DVec3d) -> None:
        ...
    
    @property
    def XYZ(arg0: MSPyBentleyGeom.SolidLocationDetail) -> Bentley.DPoint3d:
        ...
    @XYZ.setter
    def XYZ(arg0: MSPyBentleyGeom.SolidLocationDetail, arg1: Bentley.DPoint3d) -> None:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.SolidLocationDetail) -> None
        
        2. __init__(self: MSPyBentleyGeom.SolidLocationDetail, parentId: int, s: float) -> None
        
        3. __init__(self: MSPyBentleyGeom.SolidLocationDetail, parentId: int, s: float, xyz: Bentley.DPoint3d) -> None
        
        4. __init__(self: MSPyBentleyGeom.SolidLocationDetail, parentId: int, s: float, xyz: Bentley.DPoint3d, u: float, v: float, uVector: Bentley.DVec3d, vVector: Bentley.DVec3d) -> None
        """
        ...
    
class SolidLocationDetailArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.SolidLocationDetailArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.SolidLocationDetailArray, arg0: MSPyBentleyGeom.SolidLocationDetailArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.SolidLocationDetailArray, arg0: Iterable) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.SolidLocationDetailArray, x: MSPyBentleyGeom.SolidLocationDetail) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.SolidLocationDetailArray) -> None
        
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.SolidLocationDetailArray, L: MSPyBentleyGeom.SolidLocationDetailArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.SolidLocationDetailArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.SolidLocationDetailArray, i: int, x: MSPyBentleyGeom.SolidLocationDetail) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.SolidLocationDetailArray) -> MSPyBentleyGeom.SolidLocationDetail
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.SolidLocationDetailArray, i: int) -> MSPyBentleyGeom.SolidLocationDetail
        
        Remove and return the item at index ``i``
        """
        ...
    
class SolidPrimitiveType:
    """
    Members:
    
    eSolidPrimitiveType_None
    
    eSolidPrimitiveType_DgnTorusPipe
    
    eSolidPrimitiveType_DgnCone
    
    eSolidPrimitiveType_DgnBox
    
    eSolidPrimitiveType_DgnSphere
    
    eSolidPrimitiveType_DgnExtrusion
    
    eSolidPrimitiveType_DgnRotationalSweep
    
    eSolidPrimitiveType_DgnRuledSweep
    """

    def __init__(self: MSPyBentleyGeom.SolidPrimitiveType, value: int) -> None:
        ...
    
    eSolidPrimitiveType_DgnBox: SolidPrimitiveType
    
    eSolidPrimitiveType_DgnCone: SolidPrimitiveType
    
    eSolidPrimitiveType_DgnExtrusion: SolidPrimitiveType
    
    eSolidPrimitiveType_DgnRotationalSweep: SolidPrimitiveType
    
    eSolidPrimitiveType_DgnRuledSweep: SolidPrimitiveType
    
    eSolidPrimitiveType_DgnSphere: SolidPrimitiveType
    
    eSolidPrimitiveType_DgnTorusPipe: SolidPrimitiveType
    
    eSolidPrimitiveType_None: SolidPrimitiveType
    
    @property
    def name(self: handle) -> str:
        ...
    
    @property
    def value(arg0: MSPyBentleyGeom.SolidPrimitiveType) -> int:
        ...
    
TANGENT_CONTINUITY: int

TRUNCATE_BOTH: int

TRUNCATE_NONE: int

TRUNCATE_SINGLE: int

class TaggedLocalRange:
    """
    None
    """

    def DistanceOutside(*args, **kwargs):
        """
        DistanceOutside(self: MSPyBentleyGeom.LocalRange, spacePoint: Bentley.DPoint3d) -> float
        """
        ...
    
    def InitFromPrincipalAxesOfPoints(*args, **kwargs):
        """
        InitFromPrincipalAxesOfPoints(*args, **kwargs)
        Overloaded function.
        
        1. InitFromPrincipalAxesOfPoints(self: MSPyBentleyGeom.LocalRange, xyz: Bentley.Bstdcxx.bvector<Bentley.DPoint3d,Bentley.BentleyAllocator<Bentley.DPoint3d> >) -> bool
        
        2. InitFromPrincipalAxesOfPoints(self: MSPyBentleyGeom.LocalRange, xyzw: Bentley.Bstdcxx.bvector<Bentley.DPoint4d,Bentley.BentleyAllocator<Bentley.DPoint4d> >) -> bool
        """
        ...
    
    def InitNullRange(*args, **kwargs):
        """
        InitNullRange(self: MSPyBentleyGeom.LocalRange) -> None
        
        Initialize with identity transforms and an empty range. Initialize
        with identity transforms and an empty range.
        """
        ...
    
    def SetDistanceOutside(*args, **kwargs):
        """
        SetDistanceOutside(self: MSPyBentleyGeom.TaggedLocalRange, spacePoint: Bentley.DPoint3d) -> None
        """
        ...
    
    def SortByA(*args, **kwargs):
        """
        SortByA(data: Bentley.Bstdcxx.bvector<Bentley.TaggedLocalRange,Bentley.BentleyAllocator<Bentley.TaggedLocalRange> >) -> None
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.TaggedLocalRange, indexA: int, indexB: int, a: float = 0.0) -> None:
        ...
    
    @property
    def a(self: MSPyBentleyGeom.TaggedLocalRange) -> float:
        ...
    @a.setter
    def a(self: MSPyBentleyGeom.TaggedLocalRange, arg0: float) -> None:
        ...
    
    @property
    def indexA(self: MSPyBentleyGeom.TaggedLocalRange) -> int:
        ...
    @indexA.setter
    def indexA(self: MSPyBentleyGeom.TaggedLocalRange, arg0: int) -> None:
        ...
    
    @property
    def indexB(self: MSPyBentleyGeom.TaggedLocalRange) -> int:
        ...
    @indexB.setter
    def indexB(self: MSPyBentleyGeom.TaggedLocalRange, arg0: int) -> None:
        ...
    
    @property
    def localRange(self: MSPyBentleyGeom.LocalRange) -> Bentley.DRange3d:
        ...
    @localRange.setter
    def localRange(self: MSPyBentleyGeom.LocalRange, arg0: Bentley.DRange3d) -> None:
        ...
    
    @property
    def localToWorld(self: MSPyBentleyGeom.LocalRange) -> Bentley.Transform:
        ...
    @localToWorld.setter
    def localToWorld(self: MSPyBentleyGeom.LocalRange, arg0: Bentley.Transform) -> None:
        ...
    
    @property
    def worldRange(self: MSPyBentleyGeom.LocalRange) -> Bentley.DRange3d:
        ...
    @worldRange.setter
    def worldRange(self: MSPyBentleyGeom.LocalRange, arg0: Bentley.DRange3d) -> None:
        ...
    
    @property
    def worldToLocal(self: MSPyBentleyGeom.LocalRange) -> Bentley.Transform:
        ...
    @worldToLocal.setter
    def worldToLocal(self: MSPyBentleyGeom.LocalRange, arg0: Bentley.Transform) -> None:
        ...
    
class Transform:
    """
    None
    """

    def ColumnXMagnitude(*args, **kwargs):
        """
        ColumnXMagnitude(self: MSPyBentleyGeom.Transform) -> float
        
        Return magnitude of X column. This is commonly considered as the scale
        factor of the transform.
        """
        ...
    
    def Copy(*args, **kwargs):
        """
        Copy(self: MSPyBentleyGeom.Transform, source: MSPyBentleyGeom.Transform) -> None
        
        Returns a copy of a transformation.
        
        Parameter ``[in]``:
        source The source transform
        """
        ...
    
    def CorrectCoordinateFrameXYRange(*args, **kwargs):
        """
        CorrectCoordinateFrameXYRange(localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform, localRange: MSPyBentleyGeom.DRange3d, frameType: MSPyBentleyGeom.LocalCoordinateSelect, appliedTransformOldLocalToNewLocal: MSPyBentleyGeom.Transform = None) -> None
        
        Input transforms placed " within " caller's geoemtry so that the
        geometry range satisfies origin and scaling requirements indicatd by
        frame type. Expected usage is that a local coordinate frame is placed
        on some geometry and the range of the geometry is them computed within
        that local system. The coordinate frame then needs some combination of
        (a) move origin to lower left of the range, (b) rescale axes so that
        one or both of x,y directions scale to 01.
        
        Parameter ``[in,out]``:
        localToWorld local to world transformation to modify.
        
        Parameter ``[in,out]``:
        worldToLocal world to lcoal transformation to modify.
        
        Parameter ``[in,out]``:
        localRange range of subject data.
        
        Parameter ``[in]``:
        frameType identifies target scaling and origin.
        
        Parameter ``[out]``:
        appliedTransformOldLocalToNewLocal (optional) the transfrom
        applied to modify initial local geometry to final local geometry
        """
        ...
    
    def Determinant(*args, **kwargs):
        """
        Determinant(self: MSPyBentleyGeom.Transform) -> float
        
        Return the determinant of the matrix part.
        """
        ...
    
    def From(*args, **kwargs):
        """
        From(*args, **kwargs)
        Overloaded function.
        
        1. From(matrix: Bentley.RotMatrix) -> MSPyBentleyGeom.Transform
        
        Returns a transformation with the given matrix part and a
        zero translation part.
        
        Parameter ``[in]``:
        matrix The matrix part
        
        2. From(matrix: Bentley.RotMatrix, translation: MSPyBentleyGeom.DPoint3d) -> MSPyBentleyGeom.Transform
        
        Returns a transformation with the given matrix part and a
        zero translation part.
        
        Parameter ``[in]``:
        matrix The matrix part
        
        3. From(translation: MSPyBentleyGeom.DPoint3d) -> MSPyBentleyGeom.Transform
        
        Returns a transformation with the given matrix part and a
        zero translation part.
        
        Parameter ``[in]``:
        matrix The matrix part
        
        4. From(x: float, y: float, z: float) -> MSPyBentleyGeom.Transform
        
        Returns a transformation with the given matrix part and a
        zero translation part.
        
        Parameter ``[in]``:
        matrix The matrix part
        """
        ...
    
    def From2Points(*args, **kwargs):
        """
        From2Points(origin: MSPyBentleyGeom.DPoint2d, xPoint: MSPyBentleyGeom.DPoint2d, axisId: int, normalize: bool) -> MSPyBentleyGeom.Transform
        
        Returns a transformation in the xy-plane with origin
        origin, axis axisId towards xPoint, and the other axis perpendicular.
        If normalize is false, both axes have length equal to the distance
        between origin and xPoint.
        
        Parameter ``[in]``:
        origin
        
        Parameter ``[in]``:
        xPoint The target point of axis axisId of coordinate system
        
        Parameter ``[in]``:
        axisId The axis (x=0, y=1) that points from origin to xPoint
        
        Parameter ``[in]``:
        normalize true to have coordinate system normalized
        """
        ...
    
    def From4Points(*args, **kwargs):
        """
        From4Points(origin: MSPyBentleyGeom.DPoint3d, xPoint: MSPyBentleyGeom.DPoint3d, yPoint: MSPyBentleyGeom.DPoint3d, zPoint: MSPyBentleyGeom.DPoint3d) -> MSPyBentleyGeom.Transform
        
        Returns a transformation with origin at origin, x-axis
        from origin to xPoint, y-axis from origin to yPoint, and z-axis from
        origin to zPoint. All axes are unnormalized. There is no effort to
        detect zero length axes or degenerate points that define only a line
        or plane but not a full coordinate system. The axes may be skewed.
        
        Parameter ``[in]``:
        origin The origin of transformed coordinates
        
        Parameter ``[in]``:
        xPoint The 100 point of transformed coordinates
        
        Parameter ``[in]``:
        yPoint The 010 point of transformed coordinates
        
        Parameter ``[in]``:
        zPoint The 001 point of transformed coordinates
        """
        ...
    
    def FromAxisAndRotationAngle(*args, **kwargs):
        """
        FromAxisAndRotationAngle(*args, **kwargs)
        Overloaded function.
        
        1. FromAxisAndRotationAngle(axis: MSPyBentleyGeom.DRay3d, radians: float, derivativeTransform: MSPyBentleyGeom.Transform) -> MSPyBentleyGeom.Transform
        
        Returns a transformation of rotation about a specified
        ray, and also its derivative with respect to the angle.
        
        Parameter ``[in]``:
        axis axis of rotation
        
        Parameter ``[in]``:
        radians The rotation angle
        
        Parameter ``derivativeTransform``:
        transform mapping rotated point (anywhere) to direction vector at
        its destination.
        
        2. FromAxisAndRotationAngle(axis: MSPyBentleyGeom.DRay3d, radians: float) -> MSPyBentleyGeom.Transform
        
        Returns a transformation of rotation about a specified
        ray, and also its derivative with respect to the angle.
        
        Parameter ``[in]``:
        axis axis of rotation
        
        Parameter ``[in]``:
        radians The rotation angle
        
        Parameter ``derivativeTransform``:
        transform mapping rotated point (anywhere) to direction vector at
        its destination.
        """
        ...
    
    def FromFixedPointAndScaleFactors(*args, **kwargs):
        """
        FromFixedPointAndScaleFactors(origin: MSPyBentleyGeom.DPoint3d, xScale: float, yScale: float, zScale: float) -> MSPyBentleyGeom.Transform
        
        Returns a transformation with x,y,z scales around a fixed
        point.
        
        Parameter ``[in]``:
        origin The fixed point.
        
        Parameter ``[in]``:
        xScale x direction scale factor.
        
        Parameter ``[in]``:
        yScale y direction scale factor.
        
        Parameter ``[in]``:
        zScale z direction scale factor.
        """
        ...
    
    def FromLineAndRotationAngle(*args, **kwargs):
        """
        FromLineAndRotationAngle(point0: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d, radians: float) -> MSPyBentleyGeom.Transform
        
        Returns a transformation of rotation about a specified
        line.
        
        Parameter ``[in]``:
        point0 The start point of the line
        
        Parameter ``[in]``:
        point1 The end point of the line
        
        Parameter ``[in]``:
        radians The rotation angle
        """
        ...
    
    def FromMatrixAndFixedPoint(*args, **kwargs):
        """
        FromMatrixAndFixedPoint(matrix: Bentley.RotMatrix, origin: MSPyBentleyGeom.DPoint3d) -> MSPyBentleyGeom.Transform
        
        Returns a transformation with given matrix part, and
        translation part computed from the matrix and a given fixed point.
        This translation part is generally different from the fixed point
        itself. The resulting transformation will leave the fixed point
        unchanged and apply whatever effects are contained in the matrix as if
        the fixed point is the origin.
        
        Parameter ``[in]``:
        matrix The matrix part
        
        Parameter ``[in]``:
        origin The point that is to remain fixed when multiplied by the
        transformation.
        """
        ...
    
    def FromOriginAndBearingXY(*args, **kwargs):
        """
        FromOriginAndBearingXY(origin: MSPyBentleyGeom.DPoint3d, bearingRadians: float) -> MSPyBentleyGeom.Transform
        
        Returns a transformation with ul> li>translation xyz are
        the origin li>xAxis in direction of bearing radians (parallel to xy
        plane) li>yAxis perpenedicular to xAxis and also parallel to the xy
        plane. li>zAxis is global (0,0,1) ul>
        """
        ...
    
    def FromOriginAndVectors(*args, **kwargs):
        """
        FromOriginAndVectors(origin: MSPyBentleyGeom.DPoint3d, xVector: MSPyBentleyGeom.DVec3d, yVector: MSPyBentleyGeom.DVec3d, zVector: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.Transform
        
        Returns a transformation with origin at origin, x-axis
        xVector, y-axis yVector, and z-axis zVector. All axes are
        unnormalized. There is no effort to detect zero length axes or
        degenerate points that define only a line or plane but not a full
        coordinate system. The axes may be skewed.
        
        Parameter ``[in]``:
        origin The origin of transformed coordinates
        
        Parameter ``[in]``:
        xVector The 100 point of transformed coordinates
        
        Parameter ``[in]``:
        yVector The 010 point of transformed coordinates
        
        Parameter ``[in]``:
        zVector The 001 point of transformed coordinates
        """
        ...
    
    def FromOriginAndXVector(*args, **kwargs):
        """
        FromOriginAndXVector(origin: MSPyBentleyGeom.DPoint2d, xVector: MSPyBentleyGeom.DVec2d) -> MSPyBentleyGeom.Transform
        
        Returns a transform with given origin and xVector. The yVector is a
        CCW perpendicular to the xVector (with the same length) The zVecotor
        is a unitZ.
        """
        ...
    
    def FromPlaneNormalToLine(*args, **kwargs):
        """
        FromPlaneNormalToLine(origin: MSPyBentleyGeom.DPoint3d, xPoint: MSPyBentleyGeom.DPoint3d, axisId: int, normalize: bool) -> MSPyBentleyGeom.Transform
        
        Returns a (possibly skewed) transformation with origin
        origin, the axis axisId towards xPoint, and other axes perpendicular.
        If normalize is false, all axes have length equal to the distance
        between the two origin and xPoint. The axes may be skewed.
        
        Parameter ``[in]``:
        origin The origin of coordinate system
        
        Parameter ``[in]``:
        xPoint The target point of axis axisId of coordinate system
        
        Parameter ``[in]``:
        axisId The axis that points from origin to xPoint
        
        Parameter ``[in]``:
        normalize true to have coordinate system normalized
        """
        ...
    
    def FromPlaneOf3Points(*args, **kwargs):
        """
        FromPlaneOf3Points(origin: MSPyBentleyGeom.DPoint3d, xPoint: MSPyBentleyGeom.DPoint3d, yPoint: MSPyBentleyGeom.DPoint3d) -> MSPyBentleyGeom.Transform
        
        Returns a transformation with origin at origin, x-axis
        from origin to xPoint, y-axis from origin to yPoint, and z-axis equal
        to the cross product of x and y axes. All axes are unnormalized. There
        is no effort to detect zero length axes or degenerate points that
        define only a line or plane but not a full coordinate system.
        
        Parameter ``[in]``:
        origin The origin of coordinate system
        
        Parameter ``[in]``:
        xPoint The 100 point of coordinate system
        
        Parameter ``[in]``:
        yPoint The 010 point of coordinate system
        """
        ...
    
    def FromPlaneOf3PointsZeroZ(*args, **kwargs):
        """
        FromPlaneOf3PointsZeroZ(origin: MSPyBentleyGeom.DPoint3d, xPoint: MSPyBentleyGeom.DPoint3d, yPoint: MSPyBentleyGeom.DPoint3d) -> MSPyBentleyGeom.Transform
        
        Returns a transformation with origin at origin, x-axis
        from origin to xPoint, y-axis from origin to yPoint, and z-axis all
        zeros. All axes are unnormalized. There is no effort to detect zero
        length axes or degenerate points that define only a line or plane but
        not a full plane.
        
        Parameter ``[in]``:
        origin The origin of coordinate system
        
        Parameter ``[in]``:
        xPoint The 100 point of coordinate system
        
        Parameter ``[in]``:
        yPoint The 010 point of coordinate system
        """
        ...
    
    def FromPrincipleAxisRotations(*args, **kwargs):
        """
        FromPrincipleAxisRotations(inTransform: MSPyBentleyGeom.Transform, xrot: float, yrot: float, zrot: float) -> MSPyBentleyGeom.Transform
        
        Sets this instance to the transformation obtained by premultiplying
        inTransform by 3 matrix rotations about principle axes, given by the
        angles xrot, yrot and zrot. inTransform may be the same as this
        instance. Symbolically, given transform M and rotation matrices X,Y,Z,
        the resulting transform is X*Y*Z*M
        
        Parameter ``[in]``:
        inTransform The base transformation
        
        Parameter ``[in]``:
        xrot The x axis rotation, in radians
        
        Parameter ``[in]``:
        yrot The y axis rotation, in radians
        
        Parameter ``[in]``:
        zrot The z axis rotation, in radians
        """
        ...
    
    def FromProduct(*args, **kwargs):
        """
        FromProduct(*args, **kwargs)
        Overloaded function.
        
        1. FromProduct(transformA: MSPyBentleyGeom.Transform, transformB: MSPyBentleyGeom.Transform) -> MSPyBentleyGeom.Transform
        
        Returns the product of two transforms.
        
        2. FromProduct(transformA: MSPyBentleyGeom.Transform, transformB: MSPyBentleyGeom.Transform, transformC: MSPyBentleyGeom.Transform) -> MSPyBentleyGeom.Transform
        
        Returns the product of two transforms.
        
        3. FromProduct(matrixA: Bentley.RotMatrix, transformB: MSPyBentleyGeom.Transform) -> MSPyBentleyGeom.Transform
        
        Returns the product of two transforms.
        
        4. FromProduct(transformA: MSPyBentleyGeom.Transform, matrixB: Bentley.RotMatrix) -> MSPyBentleyGeom.Transform
        
        Returns the product of two transforms.
        """
        ...
    
    def FromRowValues(*args, **kwargs):
        """
        FromRowValues(x00: float, x01: float, x02: float, tx: float, x10: float, x11: float, x12: float, ty: float, x20: float, x21: float, x22: float, tz: float) -> MSPyBentleyGeom.Transform
        
        Returns a transformation copying the double values
        directly into the rows of this instance.
        
        Parameter ``[in]``:
        x00 The (0,0) entry of the matrix (row, column)
        
        Parameter ``[in]``:
        x01 The (0,1) entry
        
        Parameter ``[in]``:
        x02 The (0,2) entry
        
        Parameter ``[in]``:
        tx The x-coordinate of the translation part
        
        Parameter ``[in]``:
        x10 The (1,0) entry
        
        Parameter ``[in]``:
        x11 The (1,1) entry
        
        Parameter ``[in]``:
        x12 The (1,2) entry
        
        Parameter ``[in]``:
        ty The y-coordinate of the translation part
        
        Parameter ``[in]``:
        x20 The (2,0) entry
        
        Parameter ``[in]``:
        x21 The (2,1) entry
        
        Parameter ``[in]``:
        x22 The (2,2) entry
        
        Parameter ``[in]``:
        tz The z-coordinate of the translation part
        """
        ...
    
    def Get4Points(*args, **kwargs):
        """
        Get4Points(self: MSPyBentleyGeom.Transform, point0: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d, point3: MSPyBentleyGeom.DPoint3d) -> None
        
        Sets point0 to the origin (translation part), and sets point1, point2
        point3 to the x, y and z points (translations of columns of matrix
        part by origin) from this instance.
        
        Parameter ``[out]``:
        point0 origin of transform coordinates
        
        Parameter ``[out]``:
        point1 100 point of transform coordinates
        
        Parameter ``[out]``:
        point2 010 point of transform coordinates
        
        Parameter ``[out]``:
        point3 001 point of transform coordinates
        """
        ...
    
    def GetAnyFixedPoint(*args, **kwargs):
        """
        GetAnyFixedPoint(self: MSPyBentleyGeom.Transform, fixedPoint: MSPyBentleyGeom.DPoint3d) -> bool
        
        Compute any single point that remains unchanged by action
        of a transform. Note that a pure translation has no fixed points,
        while any other transformation does.
        
        Parameter ``[out]``:
        fixedPoint Point that is not changed by the transformation.
        
        Returns:
        true if the transformation has a fixed point.
        """
        ...
    
    def GetFixedLine(*args, **kwargs):
        """
        GetFixedLine(self: MSPyBentleyGeom.Transform, fixedPoint: MSPyBentleyGeom.DPoint3d, directionVector: MSPyBentleyGeom.DVec3d) -> bool
        
        Compute the line (if any) of points that are not affected
        by this transformation. Returns false if the fixed point set for the
        transform is empty, a single point, a plane, or all points.
        
        Parameter ``[out]``:
        fixedPoint A point on the line.
        
        Parameter ``[out]``:
        directionVector vector along the line.
        
        Returns:
        true if the transformation has a fixed point.
        """
        ...
    
    def GetFixedPlane(*args, **kwargs):
        """
        GetFixedPlane(*args, **kwargs)
        Overloaded function.
        
        1. GetFixedPlane(self: MSPyBentleyGeom.Transform, fixedPoint: MSPyBentleyGeom.DPoint3d, planeVectorX: MSPyBentleyGeom.DVec3d, planeVectorY: MSPyBentleyGeom.DVec3d) -> bool
        
        Compute the plane (if any) of points that are not
        affected by this transformation. Returns false if the fixed point set
        for the transform is empty, a single point, a line, or all points.
        
        Parameter ``[out]``:
        fixedPoint A point on the line.
        
        Parameter ``[out]``:
        planeVectorX a unit vector in the plane.
        
        Parameter ``[out]``:
        planeVectorY another unit vector in the plane, perpendicular to
        pDirectionVectorX.
        
        Returns:
        true if the transformation has a fixed point.
        
        2. GetFixedPlane(self: MSPyBentleyGeom.Transform, residualTransform: MSPyBentleyGeom.Transform, mirrorTransform: MSPyBentleyGeom.Transform, planePoint: MSPyBentleyGeom.DPoint3d, planeNormal: MSPyBentleyGeom.DVec3d) -> bool
        
        Compute the plane (if any) of points that are not
        affected by this transformation. Returns false if the fixed point set
        for the transform is empty, a single point, a line, or all points.
        
        Parameter ``[out]``:
        fixedPoint A point on the line.
        
        Parameter ``[out]``:
        planeVectorX a unit vector in the plane.
        
        Parameter ``[out]``:
        planeVectorY another unit vector in the plane, perpendicular to
        pDirectionVectorX.
        
        Returns:
        true if the transformation has a fixed point.
        """
        ...
    
    def GetFromMatrixByRowAndColumn(*args, **kwargs):
        """
        GetFromMatrixByRowAndColumn(self: MSPyBentleyGeom.Transform, row: int, col: int) -> float
        
        Returns a value from a specified row and column of the
        matrix part of the transformation.
        
        Parameter ``[in]``:
        row The index of row to read. Row indices are 0, 1, 2.
        
        Parameter ``[in]``:
        col The index of column to read. Column indices are 0, 1, 2.
        """
        ...
    
    def GetMatrixColumn(*args, **kwargs):
        """
        GetMatrixColumn(self: MSPyBentleyGeom.Transform, column: MSPyBentleyGeom.DVec3d, index: int) -> None
        
        Returns a column from the matrix part of the
        transformation.
        
        Parameter ``[out]``:
        column column of matrix part.
        
        Parameter ``[in]``:
        index column index
        """
        ...
    
    def GetMatrixRow(*args, **kwargs):
        """
        GetMatrixRow(self: MSPyBentleyGeom.Transform, row: MSPyBentleyGeom.DVec3d, index: int) -> None
        
        Returns a row from the matrix part of the transformation.
        
        Parameter ``[out]``:
        row row of matrix part.
        
        Parameter ``[in]``:
        index column index
        """
        ...
    
    def GetOriginAndVectors(*args, **kwargs):
        """
        GetOriginAndVectors(*args, **kwargs)
        Overloaded function.
        
        1. GetOriginAndVectors(self: MSPyBentleyGeom.Transform, origin: MSPyBentleyGeom.DPoint3d, vector0: MSPyBentleyGeom.DVec3d, vector1: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d) -> None
        
        Sets origin to the translation part, and sets vector0, vector1 vector2
        to the columns of this instance.
        
        Parameter ``[out]``:
        origin origin of transform coordinates
        
        Parameter ``[out]``:
        vector0 100 vector of transform coordinates
        
        Parameter ``[out]``:
        vector1 010 vector of transform coordinates
        
        Parameter ``[out]``:
        vector2 001 vector of transform coordinates
        
        2. GetOriginAndVectors(self: MSPyBentleyGeom.Transform, origin: MSPyBentleyGeom.DPoint2d, vector0: MSPyBentleyGeom.DVec2d, vector1: MSPyBentleyGeom.DVec2d) -> None
        
        Sets origin to the translation part, and sets vector0, vector1 vector2
        to the columns of this instance.
        
        Parameter ``[out]``:
        origin origin of transform coordinates
        
        Parameter ``[out]``:
        vector0 100 vector of transform coordinates
        
        Parameter ``[out]``:
        vector1 010 vector of transform coordinates
        
        Parameter ``[out]``:
        vector2 001 vector of transform coordinates
        """
        ...
    
    def GetPointComponent(*args, **kwargs):
        """
        GetPointComponent(self: MSPyBentleyGeom.Transform, row: int) -> float
        
        Returns a value from a specified component of the point
        (translation) part of the transformation.
        
        Parameter ``[in]``:
        row The index of point component to read. Indices are 0, 1, 2 for
        x, y, z
        """
        ...
    
    def GetTranslation(*args, **kwargs):
        """
        GetTranslation(*args, **kwargs)
        Overloaded function.
        
        1. GetTranslation(self: MSPyBentleyGeom.Transform, point: MSPyBentleyGeom.DPoint3d) -> None
        
        Returns the translation (point) part of a transformation.
        
        Parameter ``[out]``:
        point vector part of transformation
        
        2. GetTranslation(self: MSPyBentleyGeom.Transform, point: MSPyBentleyGeom.DPoint2d) -> None
        
        Returns the translation (point) part of a transformation.
        
        Parameter ``[out]``:
        point vector part of transformation
        """
        ...
    
    def InitForwardAndInverseFromAxesAndOrigin(*args, **kwargs):
        """
        InitForwardAndInverseFromAxesAndOrigin(localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform, axes: Bentley.RotMatrix, origin: MSPyBentleyGeom.DPoint3d) -> bool
        
        Construct transforms between local and world for given origin and axis
        directions.
        
        Parameter ``[out]``:
        localToWorld transform from local system to world.
        
        Parameter ``[out]``:
        worldToLocal transform from world to local system.
        
        Parameter ``[in]``:
        axes coordinate directions of local system (relative to world)
        
        Parameter ``[in]``:
        origin origin of local system (in world)
        
        Returns:
        true if axes were independent
        """
        ...
    
    def InitFrom(*args, **kwargs):
        """
        InitFrom(*args, **kwargs)
        Overloaded function.
        
        1. InitFrom(self: MSPyBentleyGeom.Transform, matrix: Bentley.RotMatrix) -> None
        
        Returns a transformation with the given matrix part and a
        zero translation part.
        
        Parameter ``[in]``:
        matrix The matrix part
        
        2. InitFrom(self: MSPyBentleyGeom.Transform, matrix: Bentley.RotMatrix, translation: MSPyBentleyGeom.DPoint3d) -> None
        
        Returns a transformation with the given matrix part and a
        zero translation part.
        
        Parameter ``[in]``:
        matrix The matrix part
        
        3. InitFrom(self: MSPyBentleyGeom.Transform, translation: MSPyBentleyGeom.DPoint3d) -> None
        
        Returns a transformation with the given matrix part and a
        zero translation part.
        
        Parameter ``[in]``:
        matrix The matrix part
        
        4. InitFrom(self: MSPyBentleyGeom.Transform, arg0: MSPyBentleyGeom.DVec3d) -> None
        
        5. InitFrom(self: MSPyBentleyGeom.Transform, x: float, y: float, z: float) -> None
        
        Returns a transformation with the given matrix part and a
        zero translation part.
        
        Parameter ``[in]``:
        matrix The matrix part
        
        6. InitFrom(self: MSPyBentleyGeom.Transform, x00: float, x01: float, x02: float, tx: float, x10: float, x11: float, x12: float, ty: float, x20: float, x21: float, x22: float, tz: float) -> None
        
        Returns a transformation with the given matrix part and a
        zero translation part.
        
        Parameter ``[in]``:
        matrix The matrix part
        
        7. InitFrom(self: MSPyBentleyGeom.Transform, hMap: MSPyBentleyGeom.DMap4d, inverse: int) -> bool
        
        Returns a transformation with the given matrix part and a
        zero translation part.
        
        Parameter ``[in]``:
        matrix The matrix part
        
        8. InitFrom(self: MSPyBentleyGeom.Transform, matrix: MSPyBentleyGeom.DMatrix4d) -> bool
        
        Returns a transformation with the given matrix part and a
        zero translation part.
        
        Parameter ``[in]``:
        matrix The matrix part
        """
        ...
    
    def InitFrom2Points(*args, **kwargs):
        """
        InitFrom2Points(self: MSPyBentleyGeom.Transform, origin: MSPyBentleyGeom.DPoint2d, xPoint: MSPyBentleyGeom.DPoint2d, axisId: int, normalize: bool) -> None
        
        Returns a transformation in the xy-plane with origin
        origin, axis axisId towards xPoint, and the other axis perpendicular.
        If normalize is false, both axes have length equal to the distance
        between origin and xPoint. //! //!
        
        Parameter ``[in]``:
        origin The origin of coordinate system
        
        Parameter ``[in]``:
        xPoint The target point of axis axisId of coordinate system
        
        Parameter ``[in]``:
        axisId The axis (x=0, y=1) that points from origin to xPoint
        
        Parameter ``[in]``:
        normalize true to have coordinate system normalized
        """
        ...
    
    def InitFrom3Points(*args, **kwargs):
        """
        InitFrom3Points(self: MSPyBentleyGeom.Transform, origin: MSPyBentleyGeom.DPoint2d, xPoint: MSPyBentleyGeom.DPoint2d, yPoint: MSPyBentleyGeom.DPoint2d) -> None
        
        Sets this instance to a transformation in the xy-plane with origin at
        origin, x-axis from origin to xPoint and y-axis from origin to yPoint.
        All axes are unnormalized. There is no effort to detect zero length
        axes or degenerate points that define a line but not a full coordinate
        system. The axes may be skewed.
        
        Parameter ``[in]``:
        origin The origin of transformed coordinates
        
        Parameter ``[in]``:
        xPoint The 10 point of transformed coordinates
        
        Parameter ``[in]``:
        yPoint The 01 point of transformed coordinates
        """
        ...
    
    def InitFrom4Points(*args, **kwargs):
        """
        InitFrom4Points(self: MSPyBentleyGeom.Transform, origin: MSPyBentleyGeom.DPoint3d, xPoint: MSPyBentleyGeom.DPoint3d, yPoint: MSPyBentleyGeom.DPoint3d, zPoint: MSPyBentleyGeom.DPoint3d) -> None
        
        Returns a transformation with origin at origin, x-axis
        from origin to xPoint, y-axis from origin to yPoint, and z-axis from
        origin to zPoint. All axes are unnormalized. There is no effort to
        detect zero length axes or degenerate points that define only a line
        or plane but not a full coordinate system. The axes may be skewed.
        
        Parameter ``[in]``:
        origin The origin of transformed coordinates
        
        Parameter ``[in]``:
        xPoint The 100 point of transformed coordinates
        
        Parameter ``[in]``:
        yPoint The 010 point of transformed coordinates
        
        Parameter ``[in]``:
        zPoint The 001 point of transformed coordinates
        """
        ...
    
    def InitFromLineAndRotationAngle(*args, **kwargs):
        """
        InitFromLineAndRotationAngle(self: MSPyBentleyGeom.Transform, point0: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d, radians: float) -> None
        
        Returns a transformation of rotation about a specified
        line.
        
        Parameter ``[in]``:
        point0 The start point of the line
        
        Parameter ``[in]``:
        point1 The end point of the line
        
        Parameter ``[in]``:
        radians The rotation angle
        """
        ...
    
    def InitFromMirrorPlane(*args, **kwargs):
        """
        InitFromMirrorPlane(self: MSPyBentleyGeom.Transform, origin: MSPyBentleyGeom.DPoint3d, normal: MSPyBentleyGeom.DVec3d) -> bool
        
        Initialize a transform that mirrors about a plane.
        
        Parameter ``[in]``:
        origin any point on the mirror plane.
        
        Parameter ``[in]``:
        normal vector perpendicular to mirror plane
        """
        ...
    
    def InitFromOriginAndLengths(*args, **kwargs):
        """
        InitFromOriginAndLengths(self: MSPyBentleyGeom.Transform, origin: MSPyBentleyGeom.DPoint2d, xAxisLength: float, yAxisLength: float) -> None
        
        Returns a transformation in the xy-plane with origin
        origin and x,y-axes of given lengths. The z-coordinate of the origin
        is zero and the z-axis is unscaled.
        
        Parameter ``[in]``:
        origin origin of coordinate system
        
        Parameter ``[in]``:
        xAxisLength The length of x-axis
        
        Parameter ``[in]``:
        yAxisLength The length of y-axis
        """
        ...
    
    def InitFromOriginAndVectors(*args, **kwargs):
        """
        InitFromOriginAndVectors(*args, **kwargs)
        Overloaded function.
        
        1. InitFromOriginAndVectors(self: MSPyBentleyGeom.Transform, origin: MSPyBentleyGeom.DPoint3d, xVector: MSPyBentleyGeom.DVec3d, yVector: MSPyBentleyGeom.DVec3d, zVector: MSPyBentleyGeom.DVec3d) -> None
        
        Returns a transformation with origin at origin, x-axis
        xVector, y-axis yVector, and z-axis zVector. All axes are
        unnormalized. There is no effort to detect zero length axes or
        degenerate points that define only a line or plane but not a full
        coordinate system. The axes may be skewed.
        
        Parameter ``[in]``:
        origin The origin of transformed coordinates
        
        Parameter ``[in]``:
        xVector The 100 vector of transformed coordinates
        
        Parameter ``[in]``:
        yVector The 010 vector of transformed coordinates
        
        Parameter ``[in]``:
        zVector The 001 vector of transformed coordinates
        
        2. InitFromOriginAndVectors(self: MSPyBentleyGeom.Transform, origin: MSPyBentleyGeom.DPoint2d, xVector: MSPyBentleyGeom.DVec2d, yVector: MSPyBentleyGeom.DVec2d) -> None
        
        Returns a transformation with origin at origin, x-axis
        xVector, y-axis yVector, and z-axis zVector. All axes are
        unnormalized. There is no effort to detect zero length axes or
        degenerate points that define only a line or plane but not a full
        coordinate system. The axes may be skewed.
        
        Parameter ``[in]``:
        origin The origin of transformed coordinates
        
        Parameter ``[in]``:
        xVector The 100 vector of transformed coordinates
        
        Parameter ``[in]``:
        yVector The 010 vector of transformed coordinates
        
        Parameter ``[in]``:
        zVector The 001 vector of transformed coordinates
        """
        ...
    
    def InitFromOriginAngleAndLengths(*args, **kwargs):
        """
        InitFromOriginAngleAndLengths(self: MSPyBentleyGeom.Transform, origin: MSPyBentleyGeom.DPoint2d, xAxisAngleRadians: float, xAxisLength: float, yAxisLength: float) -> None
        
        Returns a transformation in the xy-plane with origin
        origin and x,y-axes of the given lengths rotated counter-clockwise
        from standard position by the given angle. The z-coordinate of the
        origin is zero and the z-axis is unscaled.
        
        Parameter ``[in]``:
        origin origin of coordinate system
        
        Parameter ``[in]``:
        xAxisAngleRadians The ccw angle separating x-axis from its
        standard position
        
        Parameter ``[in]``:
        xAxisLength The length of x-axis
        
        Parameter ``[in]``:
        yAxisLength The length of y-axis
        """
        ...
    
    def InitFromOriginXVectorYVectorSquareAndNormalize(*args, **kwargs):
        """
        InitFromOriginXVectorYVectorSquareAndNormalize(self: MSPyBentleyGeom.Transform, origin: MSPyBentleyGeom.DPoint3d, xVector: MSPyBentleyGeom.DVec3d, yVector: MSPyBentleyGeom.DVec3d) -> bool
        
        Returns a transformation with origin, x axis direction,
        and xy plane All axes are normalized and perpendicular.
        
        Parameter ``[in]``:
        origin The origin of transformed coordinates
        
        Parameter ``[in]``:
        xVector direction for x axis
        
        Parameter ``[in]``:
        yVector " In plane " direction for y axis. <returns>true if
        SquareAndOrthogonalizeColumns succeeds</returns>
        """
        ...
    
    def InitFromPlaneNormalToLine(*args, **kwargs):
        """
        InitFromPlaneNormalToLine(self: MSPyBentleyGeom.Transform, origin: MSPyBentleyGeom.DPoint3d, xPoint: MSPyBentleyGeom.DPoint3d, axisId: int, normalize: bool) -> None
        
        Returns a (possibly skewed) transformation with origin
        origin, the axis axisId towards xPoint, and other axes perpendicular.
        If normalize is false, all axes have length equal to the distance
        between the two origin and xPoint. The axes may be skewed.
        
        Parameter ``[in]``:
        origin The origin of coordinate system
        
        Parameter ``[in]``:
        xPoint The target point of axis axisId of coordinate system
        
        Parameter ``[in]``:
        axisId The axis that points from origin to xPoint
        
        Parameter ``[in]``:
        normalize true to have coordinate system normalized
        """
        ...
    
    def InitFromPlaneOf3Points(*args, **kwargs):
        """
        InitFromPlaneOf3Points(self: MSPyBentleyGeom.Transform, origin: MSPyBentleyGeom.DPoint3d, xPoint: MSPyBentleyGeom.DPoint3d, yPoint: MSPyBentleyGeom.DPoint3d) -> None
        
        Returns a transformation with origin at origin, x-axis
        from origin to xPoint, y-axis from origin to yPoint, and z-axis equal
        to the cross product of x and y axes. All axes are unnormalized. There
        is no effort to detect zero length axes or degenerate points that
        define only a line or plane but not a full coordinate system.
        
        Parameter ``[in]``:
        origin The origin of coordinate system
        
        Parameter ``[in]``:
        xPoint The 100 point of coordinate system
        
        Parameter ``[in]``:
        yPoint The 010 point of coordinate system
        """
        ...
    
    def InitFromPrincipleAxisRotations(*args, **kwargs):
        """
        InitFromPrincipleAxisRotations(self: MSPyBentleyGeom.Transform, inTransform: MSPyBentleyGeom.Transform, xRot: float, yRot: float, zRot: float) -> None
        
        Sets this instance to the transformation obtained by premultiplying
        inTransform by 3 matrix rotations about principle axes, given by the
        angles xrot, yrot and zrot. inTransform may be the same as this
        instance. Symbolically, given transform [M t] and rotation matrices
        X,Y,Z, the resulting transform is [X*Y*Z*M X*Y*Z*t]
        
        Parameter ``[in]``:
        inTransform The base transformation
        
        Parameter ``[in]``:
        xrot The x axis rotation, in radians
        
        Parameter ``[in]``:
        yrot The y axis rotation, in radians
        
        Parameter ``[in]``:
        zrot The z axis rotation, in radians
        """
        ...
    
    def InitFromProjectionToPlane(*args, **kwargs):
        """
        InitFromProjectionToPlane(self: MSPyBentleyGeom.Transform, origin: MSPyBentleyGeom.DPoint3d, normal: MSPyBentleyGeom.DVec3d) -> bool
        
        Initialize a transform that projects to a plane.
        
        Parameter ``[in]``:
        origin any point on the target plane.
        
        Parameter ``[in]``:
        normal vector perpendicular to target plane
        """
        ...
    
    def InitFromScalePerpendicularToPlane(*args, **kwargs):
        """
        InitFromScalePerpendicularToPlane(self: MSPyBentleyGeom.Transform, origin: MSPyBentleyGeom.DPoint3d, normal: MSPyBentleyGeom.DVec3d, scale: float) -> bool
        
        Initialize a transform that scales around a plane
        
        Parameter ``[in]``:
        origin any point on the target plane
        
        Parameter ``[in]``:
        normal vector perpendicular to target plane.
        
        Parameter ``[in]``:
        scale scale factor. (e.g. 0.0 to project onto the plane, -1 to
        mirror)
        """
        ...
    
    def InitIdentity(*args, **kwargs):
        """
        InitIdentity(self: MSPyBentleyGeom.Transform) -> None
        
        returns an identity transformation, i.e. zero translation
        part and identity matrix part.
        """
        ...
    
    def InitNormalizedFrameFromOriginXPointYPoint(*args, **kwargs):
        """
        InitNormalizedFrameFromOriginXPointYPoint(self: MSPyBentleyGeom.Transform, origin: MSPyBentleyGeom.DPoint3d, xPoint: MSPyBentleyGeom.DPoint3d, yPoint: MSPyBentleyGeom.DPoint3d) -> bool
        
        Attempt to set up a coordinate frame origin at origin,
        x-axis from origin to xPoint, y-axis in plane with yPoint, All axes
        are normalized. Return false with identity at origin if unable to do
        cross products.
        
        Parameter ``[in]``:
        origin The origin of coordinate system
        
        Parameter ``[in]``:
        xPoint The 100 point of coordinate system
        
        Parameter ``[in]``:
        yPoint The 010 point of coordinate system
        """
        ...
    
    def InitProduct(*args, **kwargs):
        """
        InitProduct(*args, **kwargs)
        Overloaded function.
        
        1. InitProduct(self: MSPyBentleyGeom.Transform, transform1: MSPyBentleyGeom.Transform, transform2: MSPyBentleyGeom.Transform) -> None
        
        Returns the product of two transformations. Symbolically,
        given transforms [R t] and [S u], return the product transform [R t][S
        u] = [R*S t+R*u].
        
        Parameter ``[in]``:
        transform1 The first factor
        
        Parameter ``[in]``:
        transform2 The second factor
        
        2. InitProduct(self: MSPyBentleyGeom.Transform, matrix: Bentley.RotMatrix, transform: MSPyBentleyGeom.Transform) -> None
        
        Returns the product of two transformations. Symbolically,
        given transforms [R t] and [S u], return the product transform [R t][S
        u] = [R*S t+R*u].
        
        Parameter ``[in]``:
        transform1 The first factor
        
        Parameter ``[in]``:
        transform2 The second factor
        
        3. InitProduct(self: MSPyBentleyGeom.Transform, transform: MSPyBentleyGeom.Transform, matrix: Bentley.RotMatrix) -> None
        
        Returns the product of two transformations. Symbolically,
        given transforms [R t] and [S u], return the product transform [R t][S
        u] = [R*S t+R*u].
        
        Parameter ``[in]``:
        transform1 The first factor
        
        Parameter ``[in]``:
        transform2 The second factor
        """
        ...
    
    def InitUniformScaleApproximation(*args, **kwargs):
        """
        InitUniformScaleApproximation(self: MSPyBentleyGeom.Transform, transform: MSPyBentleyGeom.Transform, primaryAxis: int, secondaryAxis: int) -> bool
        
        Construct a transform which preserves both a primary
        column directon and a secondary column plane. Scale all columns to
        length of primary axis.
        
        Parameter ``[in]``:
        transform original matrix.
        
        Parameter ``[in]``:
        primaryAxis axis to be retained.
        
        Parameter ``[in]``:
        secondaryAxis axis defining plane to be maintained.
        """
        ...
    
    def InverseOf(*args, **kwargs):
        """
        InverseOf(self: MSPyBentleyGeom.Transform, in: MSPyBentleyGeom.Transform) -> bool
        
        Sets this instance to the inverse transform of in. in may be the same
        as this instance. This is a modestly expensive floating point
        computation (33 multiplies, 14 adds). Symbolically, given transform [R
        t] return transform [Q Q*(-t)] where Q is the inverse of matrix R.
        
        Parameter ``[in]``:
        in The input transformation
        
        Remark:
        This is deprecated. Preferred call is{resutl =
        in.ValidatedInverse ();}
        
        Returns:
        true if transform is invertible
        """
        ...
    
    def InvertRigidBodyTransformation(*args, **kwargs):
        """
        InvertRigidBodyTransformation(self: MSPyBentleyGeom.Transform, in: MSPyBentleyGeom.Transform) -> None
        
        Sets this instance to a matrix which is the inverse of in IN THE
        SPECIAL CASE WHERE in HAS ONLY PURE ROTATION OR MIRRORING IN ITS
        ROTATIONAL PART. These special conditions allow the 'inversion' to be
        done by only a transposition and one matrix-times-point
        multiplication, rather than the full effort of inverting a general
        transformation. It is the caller's responsibility to be sure that
        these special conditions hold. This usually occurs when the caller has
        just constructed the transform by a sequence of translations and
        rotations. If the caller has received the matrix from nonverified
        external sources and therefore does not know if the special conditions
        apply, the <CODE>inverseOf</CODE> method should be used instead. in
        may be the same as this instance. The specific computations in this
        special-case inversion are (1) the output transform's translation is
        the input transform's matrix times the negative of the input
        transform's translation, and (2) the output transform's matrix part is
        the tranpose of the input transform's matrix part. Symbolically, given
        transform [R t] return transform [R^ (R^)*(-t)] where ^ indicates
        transposition.
        
        Parameter ``[in]``:
        in The input transformation (TransformCR)
        """
        ...
    
    def IsEqual(*args, **kwargs):
        """
        IsEqual(*args, **kwargs)
        Overloaded function.
        
        1. IsEqual(self: MSPyBentleyGeom.Transform, transform2: MSPyBentleyGeom.Transform) -> bool
        
        Returns true if two transforms have exact (bitwise)
        equality.
        
        Parameter ``[in]``:
        transform2 The second transform
        
        Returns:
        true if the transforms are identical
        
        2. IsEqual(self: MSPyBentleyGeom.Transform, transform2: MSPyBentleyGeom.Transform, matrixTolerance: float, pointTolerance: float) -> bool
        
        Returns true if two transforms have exact (bitwise)
        equality.
        
        Parameter ``[in]``:
        transform2 The second transform
        
        Returns:
        true if the transforms are identical
        """
        ...
    
    def IsIdentity(*args, **kwargs):
        """
        IsIdentity(self: MSPyBentleyGeom.Transform) -> bool
        
        Returns true if the transform is the identity transform.
        
        Returns:
        true if the transformation is within tolerance of the identity.
        """
        ...
    
    def IsMirrorAboutPlane(*args, **kwargs):
        """
        IsMirrorAboutPlane(self: MSPyBentleyGeom.Transform, planePoint: MSPyBentleyGeom.DPoint3d, unitNormal: MSPyBentleyGeom.DVec3d) -> bool
        
        Returns true if the transform is a mirror with respect to
        a plane.
        
        Parameter ``[out]``:
        planePoint Some point on the plane.
        
        Parameter ``[out]``:
        unitNormal unit vector perpendicular to the plane.
        
        Returns:
        true if the transformation is a mirror.
        """
        ...
    
    def IsNearRigidScale(*args, **kwargs):
        """
        IsNearRigidScale(self: MSPyBentleyGeom.Transform, dest: MSPyBentleyGeom.Transform, primaryAxis: int = 0, tolerance: float = 1e-06) -> bool
        
        Clean up a transform that is close to a pure rotate and scale. If
        source is NOT near to a rigid scale, return false and copy to the
        dest. If near an identity return identity. If nearly perpendicular
        with scales other than 1, clean preserving the length and direction of
        the primary axis. This is intended to be used with a crude (e.g.
        1.0e-6) reltol to identify old DGN file matrices that are " dirty " by
        modern standards but were meant to be identity, rotation, or scaled
        rotations in the UOR era.
        
        Parameter ``[in]``:
        dest result
        
        Parameter ``[in]``:
        primaryAxis axis whose orientation and direction is preserved.
        
        Parameter ``[in]``:
        tolerance relative tolerance for recognizing near-perpendicular
        conditions.
        """
        ...
    
    def IsPlanar(*args, **kwargs):
        """
        IsPlanar(self: MSPyBentleyGeom.Transform, normal: MSPyBentleyGeom.DVec3d) -> bool
        
        Returns true if transformation effects are entirely
        within the plane with given normal.
        
        Parameter ``[in]``:
        normal The plane normal
        
        Returns:
        true if the transform has no effects perpendicular to planes with
        the given normal.
        """
        ...
    
    def IsRigid(*args, **kwargs):
        """
        IsRigid(self: MSPyBentleyGeom.Transform) -> bool
        
        Returns true if the matrix part of a transform is a rigid
        body rotation, i.e. its transpose is its inverse and it has a positive
        determinant.
        
        Returns:
        true if the transformation is rigid (no scale or shear in the
        matrix part)
        """
        ...
    
    def IsRigidScale(*args, **kwargs):
        """
        IsRigidScale(self: MSPyBentleyGeom.Transform) -> tuple
        
        Returns true if the matrix part of a transform is a rigid
        body rotation, i.e. its transpose is its inverse and it has a positive
        determinant.
        
        Parameter ``[out]``:
        scale scale factor.
        
        Returns:
        true if the transformation is rigid (no scale or shear in the
        matrix part)
        """
        ...
    
    def IsRotateAroundLine(*args, **kwargs):
        """
        IsRotateAroundLine(self: MSPyBentleyGeom.Transform, fixedPoint: MSPyBentleyGeom.DPoint3d, directionVector: MSPyBentleyGeom.DVec3d) -> tuple
        
        Returns true if the transform is a non-zero rotation
        around a line.
        
        Parameter ``[out]``:
        fixedPoint a point on the line.
        
        Parameter ``[out]``:
        directionVector vector in the line direction.
        
        Parameter ``[out]``:
        radians rotation angle in radians.
        
        Returns:
        true if the transformation is a non-zero rotation.
        """
        ...
    
    def IsTranslate(*args, **kwargs):
        """
        IsTranslate(self: MSPyBentleyGeom.Transform, translation: MSPyBentleyGeom.DPoint3d) -> bool
        
        Returns true if the transform is a simple translation.
        
        Parameter ``[out]``:
        translation the translation vector. Zero of not a translation
        transform.
        
        Returns:
        true if the transformation is a pure translation.
        """
        ...
    
    def IsTranslateScaleRotateAroundZ(*args, **kwargs):
        """
        IsTranslateScaleRotateAroundZ(self: MSPyBentleyGeom.Transform, origin: MSPyBentleyGeom.DPoint3d, rigidAxes: Bentley.RotMatrix) -> tuple
        
        Return true if the transform a combination of only 2 thing:(1) move
        origin, (2) rotate around Z
        
        Parameter ``[out]``:
        origin origin of frame.
        
        Parameter ``[out]``:
        rigidAxes unit-length axes.
        
        Parameter ``[out]``:
        scale scale factor on the original axes.
        
        Parameter ``[out]``:
        radians positive rotation around Z
        """
        ...
    
    def IsUniformScale(*args, **kwargs):
        """
        IsUniformScale(self: MSPyBentleyGeom.Transform, fixedPoint: MSPyBentleyGeom.DPoint3d) -> tuple
        
        Returns true if the transform is a uniform scale with
        scale factor other than 1.0.
        
        Parameter ``[out]``:
        fixedPoint (If function result is true) the (one) point which
        remains in place in the transformation.
        
        Parameter ``[out]``:
        scale The scale factor. If the transform is not a scale, this is
        returned as 1.0.
        
        Returns:
        true if the transformation is a uniform scale.
        """
        ...
    
    def IsUniformScaleAndRotateAroundLine(*args, **kwargs):
        """
        IsUniformScaleAndRotateAroundLine(self: MSPyBentleyGeom.Transform, fixedPoint: MSPyBentleyGeom.DPoint3d, directionVector: MSPyBentleyGeom.DVec3d) -> tuple
        
        Returns true if the transform is a uniform scale combined
        with a rotation. One, but not both, of the two steps may be null (unit
        scale or no rotation)
        
        Parameter ``[out]``:
        fixedPoint fixed point of scaling. This is also a point on the
        line.
        
        Parameter ``[out]``:
        directionVector vector in the direction of the rotation.
        
        Parameter ``[out]``:
        radians rotation angle
        
        Parameter ``[out]``:
        scale scale factor.
        
        Returns:
        true if the transformation has at least one of the scale, rotate
        effects.
        """
        ...
    
    def Matrix(*args, **kwargs):
        """
        Matrix(self: MSPyBentleyGeom.Transform) -> Bentley.RotMatrix
        
        Return the matrix part
        """
        ...
    
    def MatrixColumnMagnitude(*args, **kwargs):
        """
        MatrixColumnMagnitude(self: MSPyBentleyGeom.Transform, i: int) -> float
        
        return the magnitude of a column of the matrix.
        
        Parameter ``[in]``:
        i column index. Adjusted cyclically if outside 012
        """
        ...
    
    def MaxDiff(*args, **kwargs):
        """
        MaxDiff(self: MSPyBentleyGeom.Transform, otherTransform: MSPyBentleyGeom.Transform) -> float
        
        Returns the largest absolute value difference between
        corresponding coefficients
        
        Parameter ``[in]``:
        otherTransform
        
        Returns:
        largest absolute difference between the two transforms
        """
        ...
    
    def Multiply(*args, **kwargs):
        """
        Multiply(*args, **kwargs)
        Overloaded function.
        
        1. Multiply(self: MSPyBentleyGeom.Transform, point: MSPyBentleyGeom.DPoint3d) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        Parameter ``[in,out]``:
        point point to be updated
        
        2. Multiply(self: MSPyBentleyGeom.Transform, result: MSPyBentleyGeom.DPoint3d, point: MSPyBentleyGeom.DPoint3d) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        Parameter ``[in,out]``:
        point point to be updated
        
        3. Multiply(self: MSPyBentleyGeom.Transform, point: MSPyBentleyGeom.DPoint3d, x: float, y: float, z: float) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        Parameter ``[in,out]``:
        point point to be updated
        
        4. Multiply(self: MSPyBentleyGeom.Transform, points: MSPyBentleyGeom.DPoint3dArray) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        Parameter ``[in,out]``:
        point point to be updated
        
        5. Multiply(self: MSPyBentleyGeom.Transform, outPoints: MSPyBentleyGeom.DPoint3dArray, inPoints: MSPyBentleyGeom.DPoint3dArray) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        Parameter ``[in,out]``:
        point point to be updated
        
        6. Multiply(self: MSPyBentleyGeom.Transform, result: MSPyBentleyGeom.DPoint2d, point: MSPyBentleyGeom.DPoint2d) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        Parameter ``[in,out]``:
        point point to be updated
        
        7. Multiply(self: MSPyBentleyGeom.Transform, outPoints: MSPyBentleyGeom.DPoint2dArray, inPoints: MSPyBentleyGeom.DPoint2dArray) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        Parameter ``[in,out]``:
        point point to be updated
        
        8. Multiply(self: MSPyBentleyGeom.Transform, result: MSPyBentleyGeom.DPoint3d, point: MSPyBentleyGeom.DPoint2d) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        Parameter ``[in,out]``:
        point point to be updated
        
        9. Multiply(self: MSPyBentleyGeom.Transform, outPoints: MSPyBentleyGeom.DPoint3dArray, inPoints: MSPyBentleyGeom.DPoint2dArray) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        Parameter ``[in,out]``:
        point point to be updated
        
        10. Multiply(self: MSPyBentleyGeom.Transform, result: MSPyBentleyGeom.DPoint2d, point: MSPyBentleyGeom.DPoint3d) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        Parameter ``[in,out]``:
        point point to be updated
        
        11. Multiply(self: MSPyBentleyGeom.Transform, outPoints: MSPyBentleyGeom.DPoint2dArray, inPoints: MSPyBentleyGeom.DPoint2dArray) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        Parameter ``[in,out]``:
        point point to be updated
        
        12. Multiply(self: MSPyBentleyGeom.Transform, result: MSPyBentleyGeom.DPoint4d, point: MSPyBentleyGeom.DPoint4d) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        Parameter ``[in,out]``:
        point point to be updated
        
        13. Multiply(self: MSPyBentleyGeom.Transform, outPoints: MSPyBentleyGeom.DPoint4dArray, inPoints: MSPyBentleyGeom.DPoint4dArray) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        Parameter ``[in,out]``:
        point point to be updated
        
        14. Multiply(self: MSPyBentleyGeom.Transform, outRange: MSPyBentleyGeom.DRange3d, inRange: MSPyBentleyGeom.DRange3d) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        Parameter ``[in,out]``:
        point point to be updated
        
        15. Multiply(self: MSPyBentleyGeom.Transform, inoutEllipse: MSPyBentleyGeom.DEllipse3d) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        Parameter ``[in,out]``:
        point point to be updated
        
        16. Multiply(self: MSPyBentleyGeom.Transform, outEllipse: MSPyBentleyGeom.DEllipse3d, inEllipse: MSPyBentleyGeom.DEllipse3d) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        Parameter ``[in,out]``:
        point point to be updated
        
        17. Multiply(self: MSPyBentleyGeom.Transform, inoutPlane: MSPyBentleyGeom.DPlane3d) -> bool
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        Parameter ``[in,out]``:
        point point to be updated
        
        18. Multiply(self: MSPyBentleyGeom.Transform, outPlane: MSPyBentleyGeom.DPlane3d, inPlane: MSPyBentleyGeom.DPlane3d) -> bool
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        Parameter ``[in,out]``:
        point point to be updated
        
        19. Multiply(self: MSPyBentleyGeom.Transform, inoutSegment: MSPyBentleyGeom.DSegment3d) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        Parameter ``[in,out]``:
        point point to be updated
        
        20. Multiply(self: MSPyBentleyGeom.Transform, outSegment: MSPyBentleyGeom.DSegment3d, inSegment: MSPyBentleyGeom.DSegment3d) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        Parameter ``[in,out]``:
        point point to be updated
        
        21. Multiply(self: MSPyBentleyGeom.Transform, inoutRay: MSPyBentleyGeom.DRay3d) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        Parameter ``[in,out]``:
        point point to be updated
        
        22. Multiply(self: MSPyBentleyGeom.Transform, outRay: MSPyBentleyGeom.DRay3d, inRay: MSPyBentleyGeom.DRay3d) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        Parameter ``[in,out]``:
        point point to be updated
        
        23. Multiply(self: MSPyBentleyGeom.Transform, xyzwOut: MSPyBentleyGeom.DPoint4dArray, xyzwIn: MSPyBentleyGeom.DPoint4dArray) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        Parameter ``[in,out]``:
        point point to be updated
        
        24. Multiply(self: MSPyBentleyGeom.Transform, xyzOut: MSPyBentleyGeom.DPoint3dArray, xyzIn: MSPyBentleyGeom.DPoint3dArray) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        Parameter ``[in,out]``:
        point point to be updated
        
        25. Multiply(self: MSPyBentleyGeom.Transform, xyOut: MSPyBentleyGeom.DPoint2dArray, xyIn: MSPyBentleyGeom.DPoint2dArray) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        Parameter ``[in,out]``:
        point point to be updated
        
        26. Multiply(self: MSPyBentleyGeom.Transform, xyzOut: MSPyBentleyGeom.DPoint3dArray, xyIn: MSPyBentleyGeom.DPoint2dArray) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        Parameter ``[in,out]``:
        point point to be updated
        
        27. Multiply(self: MSPyBentleyGeom.Transform, xyOut: MSPyBentleyGeom.DPoint2dArray, xyzIn: MSPyBentleyGeom.DPoint3dArray) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        Parameter ``[in,out]``:
        point point to be updated
        """
        ...
    
    def MultiplyMatrixOnly(*args, **kwargs):
        """
        MultiplyMatrixOnly(*args, **kwargs)
        Overloaded function.
        
        1. MultiplyMatrixOnly(self: MSPyBentleyGeom.Transform, point: MSPyBentleyGeom.DPoint3d, x: float, y: float, z: float) -> None
        
        Multiplies the matrix part of this instance times the column vector
        constructed from components x,y,z. Symbolically, given transform [R t]
        and column vector p, the returned point is R*p.
        
        Parameter ``[out]``:
        point result of matrix * point operation
        
        Parameter ``[in]``:
        x The x component of the point
        
        Parameter ``[in]``:
        y The y component of the point
        
        Parameter ``[in]``:
        z The z component of the point
        
        2. MultiplyMatrixOnly(self: MSPyBentleyGeom.Transform, outPoint: MSPyBentleyGeom.DPoint3d, inPoint: MSPyBentleyGeom.DPoint3d) -> None
        
        Multiplies the matrix part of this instance times the column vector
        constructed from components x,y,z. Symbolically, given transform [R t]
        and column vector p, the returned point is R*p.
        
        Parameter ``[out]``:
        point result of matrix * point operation
        
        Parameter ``[in]``:
        x The x component of the point
        
        Parameter ``[in]``:
        y The y component of the point
        
        Parameter ``[in]``:
        z The z component of the point
        
        3. MultiplyMatrixOnly(self: MSPyBentleyGeom.Transform, point: MSPyBentleyGeom.DPoint3d) -> None
        
        Multiplies the matrix part of this instance times the column vector
        constructed from components x,y,z. Symbolically, given transform [R t]
        and column vector p, the returned point is R*p.
        
        Parameter ``[out]``:
        point result of matrix * point operation
        
        Parameter ``[in]``:
        x The x component of the point
        
        Parameter ``[in]``:
        y The y component of the point
        
        Parameter ``[in]``:
        z The z component of the point
        """
        ...
    
    def MultiplyTransformTranslation(*args, **kwargs):
        """
        MultiplyTransformTranslation(self: MSPyBentleyGeom.Transform, transform: MSPyBentleyGeom.Transform, translation: MSPyBentleyGeom.DVec3d, scaleFactor: float) -> None
        
        Multiply by a translation " from the left ":result = transformIn *
        (Identity, scaled translationIn)
        
        Parameter ``[in]``:
        transformIn full transform for right factor.
        
        Parameter ``[in]``:
        translationIn translation vector for right term
        
        Parameter ``[in]``:
        scaleFactor scale factor for translation
        """
        ...
    
    def MultiplyTranslationTransform(*args, **kwargs):
        """
        MultiplyTranslationTransform(self: MSPyBentleyGeom.Transform, translation: MSPyBentleyGeom.DVec3d, scaleFactor: float, transform: MSPyBentleyGeom.Transform) -> None
        
        Multiply by a translation " from the left ":result = (Identity, scaled
        translationIn) * transformIn
        
        Parameter ``[in]``:
        translationIn translation vector for left term
        
        Parameter ``[in]``:
        scaleFactor factor for translation
        
        Parameter ``[in]``:
        transformIn full transform for right factor.
        """
        ...
    
    def MultiplyTranspose(*args, **kwargs):
        """
        MultiplyTranspose(*args, **kwargs)
        Overloaded function.
        
        1. MultiplyTranspose(self: MSPyBentleyGeom.Transform, outPoints: MSPyBentleyGeom.DPoint3dArray, inPoints: MSPyBentleyGeom.DPoint3dArray) -> None
        
        Multiplies this instance times each column vector in inPoint, using
        the transpose of the matrix part of this instance in the
        multiplications, and places the resulting points in outPoint.
        Symbolically, given transform [R t], each returned point has the
        equivalent form p*R + t, where p is a row vector. inPoint and outPoint
        may be the same.
        
        Parameter ``[out]``:
        outPoint transformed points
        
        Parameter ``[in]``:
        inPoint The input points
        
        Parameter ``[in]``:
        numPoint The number of points
        
        2. MultiplyTranspose(self: MSPyBentleyGeom.Transform, points: MSPyBentleyGeom.DPoint3dArray) -> None
        
        Multiplies this instance times each column vector in inPoint, using
        the transpose of the matrix part of this instance in the
        multiplications, and places the resulting points in outPoint.
        Symbolically, given transform [R t], each returned point has the
        equivalent form p*R + t, where p is a row vector. inPoint and outPoint
        may be the same.
        
        Parameter ``[out]``:
        outPoint transformed points
        
        Parameter ``[in]``:
        inPoint The input points
        
        Parameter ``[in]``:
        numPoint The number of points
        """
        ...
    
    def MultiplyTransposeMatrixOnly(*args, **kwargs):
        """
        MultiplyTransposeMatrixOnly(*args, **kwargs)
        Overloaded function.
        
        1. MultiplyTransposeMatrixOnly(self: MSPyBentleyGeom.Transform, point: MSPyBentleyGeom.DPoint3d, x: float, y: float, z: float) -> None
        
        Multiplies the row vector constructed from components x,y,z times the
        matrix part of this instance. Symbolically, given transform [R t] and
        row vector p, the returned point is p*R.
        
        Parameter ``[out]``:
        point result of point * matrix operation
        
        Parameter ``[in]``:
        x The x component of the point
        
        Parameter ``[in]``:
        y The y component of the point
        
        Parameter ``[in]``:
        z The z component of the point
        
        2. MultiplyTransposeMatrixOnly(self: MSPyBentleyGeom.Transform, outPoint: MSPyBentleyGeom.DPoint3d, inPoint: MSPyBentleyGeom.DPoint3d) -> None
        
        Multiplies the row vector constructed from components x,y,z times the
        matrix part of this instance. Symbolically, given transform [R t] and
        row vector p, the returned point is p*R.
        
        Parameter ``[out]``:
        point result of point * matrix operation
        
        Parameter ``[in]``:
        x The x component of the point
        
        Parameter ``[in]``:
        y The y component of the point
        
        Parameter ``[in]``:
        z The z component of the point
        
        3. MultiplyTransposeMatrixOnly(self: MSPyBentleyGeom.Transform, point: MSPyBentleyGeom.DPoint3d) -> None
        
        Multiplies the row vector constructed from components x,y,z times the
        matrix part of this instance. Symbolically, given transform [R t] and
        row vector p, the returned point is p*R.
        
        Parameter ``[out]``:
        point result of point * matrix operation
        
        Parameter ``[in]``:
        x The x component of the point
        
        Parameter ``[in]``:
        y The y component of the point
        
        Parameter ``[in]``:
        z The z component of the point
        """
        ...
    
    def MultiplyWeighted(*args, **kwargs):
        """
        MultiplyWeighted(*args, **kwargs)
        Overloaded function.
        
        1. MultiplyWeighted(self: MSPyBentleyGeom.Transform, point: MSPyBentleyGeom.DPoint3d, weight: float) -> None
        
        Multiplies a " weighted point " in place. That is, the point is input
        and output as (wx,wy,wz,w) where x,y,z are the cartesian image
        coordinates.
        
        Parameter ``[in,out]``:
        point point to be updated
        
        Parameter ``[in]``:
        weight The weight
        
        2. MultiplyWeighted(self: MSPyBentleyGeom.Transform, weightedXYZOut: MSPyBentleyGeom.DPoint3dArray, weightedXYZIn: MSPyBentleyGeom.DPoint3dArray, weights: MSPyBentley.DoubleArray) -> None
        
        Multiplies a " weighted point " in place. That is, the point is input
        and output as (wx,wy,wz,w) where x,y,z are the cartesian image
        coordinates.
        
        Parameter ``[in,out]``:
        point point to be updated
        
        Parameter ``[in]``:
        weight The weight
        """
        ...
    
    def OffsetPointByColumn(*args, **kwargs):
        """
        OffsetPointByColumn(self: MSPyBentleyGeom.Transform, out: MSPyBentleyGeom.DPoint3d, in: MSPyBentleyGeom.DPoint3d, i: int) -> None
        
        Adds column i of the matrix part of this instance to point in and
        places the result in out.
        
        Parameter ``[out]``:
        out sum of in and column i
        
        Parameter ``[in]``:
        in The base point for sum
        
        Parameter ``[in]``:
        i The column index of matrix
        """
        ...
    
    def Origin(*args, **kwargs):
        """
        Origin(self: MSPyBentleyGeom.Transform) -> MSPyBentleyGeom.DPoint3d
        
        Return the origin (aka translation) part as a DPoint3d.
        """
        ...
    
    def ScaleCompleteRows(*args, **kwargs):
        """
        ScaleCompleteRows(self: MSPyBentleyGeom.Transform, transform: MSPyBentleyGeom.Transform, xscale: float, yscale: float, zscale: float) -> None
        
        Scale the complete rows by respective factors. (See also
        scaleMatrixColumns, scaleMatrixRows, which only act on the matrix
        part)
        
        Parameter ``[in]``:
        transform The input transform.
        
        Parameter ``[in]``:
        xscale The x column scale factor
        
        Parameter ``[in]``:
        yscale The y column scale factor
        
        Parameter ``[in]``:
        zscale The z column scale factor
        """
        ...
    
    def ScaleDoubleArrayByXColumnMagnitude(*args, **kwargs):
        """
        ScaleDoubleArrayByXColumnMagnitude(self: MSPyBentleyGeom.Transform, data: float, n: int) -> None
        
        scale all values in an array of doubles by the magnitude of a
        specified column of the matrix.
        
        Parameter ``[in]``:
        data array of doubles.
        
        Parameter ``[in]``:
        n number of values.
        """
        ...
    
    def ScaleMatrixColumns(*args, **kwargs):
        """
        ScaleMatrixColumns(*args, **kwargs)
        Overloaded function.
        
        1. ScaleMatrixColumns(self: MSPyBentleyGeom.Transform, InTransform: MSPyBentleyGeom.Transform, xScale: float, yScale: float, zScale: float) -> None
        
        Scale the columns of the matrix part by respective factors.
        Translation part is unaffected. (See also scaleMatrixRows,
        scaleTransformRows)
        
        Parameter ``[in]``:
        transform The input transform.
        
        Parameter ``[in]``:
        xscale The x column scale factor
        
        Parameter ``[in]``:
        yscale The y column scale factor
        
        Parameter ``[in]``:
        zscale The z column scale factor
        
        2. ScaleMatrixColumns(self: MSPyBentleyGeom.Transform, xscale: float, yscale: float, zscale: float) -> None
        
        Scale the columns of the matrix part by respective factors.
        Translation part is unaffected. (See also scaleMatrixRows,
        scaleTransformRows)
        
        Parameter ``[in]``:
        transform The input transform.
        
        Parameter ``[in]``:
        xscale The x column scale factor
        
        Parameter ``[in]``:
        yscale The y column scale factor
        
        Parameter ``[in]``:
        zscale The z column scale factor
        """
        ...
    
    def ScaleMatrixRows(*args, **kwargs):
        """
        ScaleMatrixRows(self: MSPyBentleyGeom.Transform, transform: MSPyBentleyGeom.Transform, xscale: float, yscale: float, zscale: float) -> None
        
        Scale the rows of the matrix part by respective factors. Translation
        part is unaffected. (See also scaleMatrixColumns, scaleTransformRows)
        
        Parameter ``[in]``:
        transform The input transform.
        
        Parameter ``[in]``:
        xscale The x column scale factor
        
        Parameter ``[in]``:
        yscale The y column scale factor
        
        Parameter ``[in]``:
        zscale The z column scale factor
        """
        ...
    
    def SetFixedPoint(*args, **kwargs):
        """
        SetFixedPoint(*args, **kwargs)
        Overloaded function.
        
        1. SetFixedPoint(self: MSPyBentleyGeom.Transform, point: MSPyBentleyGeom.DPoint2d) -> None
        
        Sets the translation part of this instance so that it leaves point
        point unchanged, i.e. so that this instance may be interpreted as
        applying its matrix part as a rotation or scaling about point.
        Symbolically, given transform [R t] and column vector p, the returned
        transform is [R p-R*p]. (The prior translation part is destroyed, and
        does not affect the result in any way.)
        
        Parameter ``[in]``:
        point The point that is to remain fixed when multiplied by the
        modified transformation
        
        2. SetFixedPoint(self: MSPyBentleyGeom.Transform, point: MSPyBentleyGeom.DPoint3d) -> None
        
        Sets the translation part of this instance so that it leaves point
        point unchanged, i.e. so that this instance may be interpreted as
        applying its matrix part as a rotation or scaling about point.
        Symbolically, given transform [R t] and column vector p, the returned
        transform is [R p-R*p]. (The prior translation part is destroyed, and
        does not affect the result in any way.)
        
        Parameter ``[in]``:
        point The point that is to remain fixed when multiplied by the
        modified transformation
        """
        ...
    
    def SetMatrix(*args, **kwargs):
        """
        SetMatrix(self: MSPyBentleyGeom.Transform, matrix: Bentley.RotMatrix) -> None
        
        Overwrites the matrix part of a preexisting
        transformation. The translation part is unchanged.
        
        Parameter ``[in]``:
        matrix The matrix to insert
        """
        ...
    
    def SetMatrixColumn(*args, **kwargs):
        """
        SetMatrixColumn(self: MSPyBentleyGeom.Transform, column: MSPyBentleyGeom.DVec3d, index: int) -> None
        
        Set a column of the matrix part.
        
        Parameter ``[out]``:
        column column data
        
        Parameter ``[in]``:
        index column index
        """
        ...
    
    def SetMatrixRow(*args, **kwargs):
        """
        SetMatrixRow(self: MSPyBentleyGeom.Transform, row: MSPyBentleyGeom.DVec3d, index: int) -> None
        
        Set a column of the matrix part.
        
        Parameter ``[out]``:
        row row data
        
        Parameter ``[in]``:
        index column index
        """
        ...
    
    def SetTranslation(*args, **kwargs):
        """
        SetTranslation(*args, **kwargs)
        Overloaded function.
        
        1. SetTranslation(self: MSPyBentleyGeom.Transform, point: MSPyBentleyGeom.DPoint3d) -> None
        
        Sets the translation part of this instance to point. The prior
        translation part is overwritten, and the matrix part is unchanged.
        Symbolically, if point is u then this instance [R t] becomes the
        transformation [R u].
        
        Parameter ``[in]``:
        point The vector to insert
        
        2. SetTranslation(self: MSPyBentleyGeom.Transform, point: MSPyBentleyGeom.DPoint2d) -> None
        
        Sets the translation part of this instance to point. The prior
        translation part is overwritten, and the matrix part is unchanged.
        Symbolically, if point is u then this instance [R t] becomes the
        transformation [R u].
        
        Parameter ``[in]``:
        point The vector to insert
        """
        ...
    
    def Solve(*args, **kwargs):
        """
        Solve(self: MSPyBentleyGeom.Transform, outPoint: MSPyBentleyGeom.DPoint3d, inPoint: MSPyBentleyGeom.DPoint3d) -> bool
        
        Solves the linear system Tx=b, where T is this instance, b is the
        input point and x is the output point. No simplifying assumptions are
        made regarding the matrix part of T. Symbolically, if T = [M t], then
        x = Q (b - t), where Q is the inverse of M (i.e., the system is
        equivalent to Mx = b - t). inPoint and outPoint may have identical
        addresses.
        
        Parameter ``[out]``:
        outPoint solution to system
        
        Parameter ``[in]``:
        inPoint The constant point of the system
        
        Returns:
        false if the matrix part of this instance is singular.
        """
        ...
    
    def SolveArray(*args, **kwargs):
        """
        SolveArray(self: MSPyBentleyGeom.Transform, xyzOut: MSPyBentleyGeom.DPoint3dArray, xyzIn: MSPyBentleyGeom.DPoint3dArray) -> bool
        
        Solves the linear systems TX=B, where T is this instance, B is the
        matrix of numPoints input points and X is the matrix of numPoints
        output points. No simplifying assumptions are made regarding the
        matrix part of T. Symbolically, if T = [M t], then for each
        input/output point i, X[i] = Q (B[i] - t), where Q is the inverse of M
        (i.e., the i_th system is equivalent to MX[i] = B[i] - t). inPoint and
        outPoint may have identical addresses.
        
        Parameter ``[out]``:
        outPoint column points of solution matrix to system
        
        Parameter ``[in]``:
        inPoint The column points of constant matrix of system
        
        Parameter ``[in]``:
        numPoints The number of input/output points
        
        Returns:
        false if the matrix part of this instance is singular.
        """
        ...
    
    def TransformImplicitPlane(*args, **kwargs):
        """
        TransformImplicitPlane(self: MSPyBentleyGeom.Transform, a: float, b: float, c: float, d: float) -> tuple
        
        Transform the a,b,c,d components for an implicit plane. The plane
        equation format is ax+by+cz=d.
        
        Parameter ``[out]``:
        aOut x coefficient in transformed plane equation
        
        Parameter ``[out]``:
        bOut y coefficient in transformed plane equation
        
        Parameter ``[out]``:
        cOut z coefficient in transformed plane equation
        
        Parameter ``[out]``:
        dOut constant coefficient for equation.
        
        Parameter ``[in]``:
        a The x coefficient in plane equation
        
        Parameter ``[in]``:
        b The y coefficient in plane equation
        
        Parameter ``[in]``:
        c The z coefficient in plane equation
        
        Parameter ``[in]``:
        d The constant on right hand side of plane equation
        """
        ...
    
    def TranslateInLocalCoordinates(*args, **kwargs):
        """
        TranslateInLocalCoordinates(self: MSPyBentleyGeom.Transform, in: MSPyBentleyGeom.Transform, x: float, y: float, z: float) -> None
        
        Sets this instance to a transformation that has the same matrix part
        as transform in and a translation part that is the SUM of the
        translation part of in plus the product of the matrix part of in times
        the given point. If the translation part of in is interpreted as the
        origin of a coordinate system (whose axis directions and sizes are
        given by the columns of the matrix part), this instance becomes a
        coordinate frame with the same axis directions and sizes, but with the
        origin shifted to point x,y,z of the in system. That is, x,y,z are the
        local coordinates of the new origin, and the translation part of this
        instance becomes the global coordinates of the new origin. in may be
        identical to this instance. Symbolically, if in is the transform [R t]
        and the local origin coordinates x,y,z are in column vector p, the
        result is the transformation [R t+R*p].
        
        Parameter ``[in]``:
        in The input transformation
        
        Parameter ``[in]``:
        x The x-coordinate of the local origin
        
        Parameter ``[in]``:
        y The y-coordinate of the local origin
        
        Parameter ``[in]``:
        z The z-coordinate of the local origin
        """
        ...
    
    def Translation(*args, **kwargs):
        """
        Translation(self: MSPyBentleyGeom.Transform) -> MSPyBentleyGeom.DVec3d
        
        Return the translation (aka origin) part as a DVec3d.
        """
        ...
    
    def TryRangeMapping(*args, **kwargs):
        """
        TryRangeMapping(sourceRange: MSPyBentleyGeom.DRange2d, destRange: MSPyBentleyGeom.DRange2d, transform: MSPyBentleyGeom.Transform) -> bool
        
        Returns a transformation that maps corners of the source
        range to corners of the destination range.
        
        Returns:
        false if either range is null or any direction of the sourceRange
        has zero length.
        """
        ...
    
    def ValidatedInverse(*args, **kwargs):
        """
        ValidatedInverse(self: MSPyBentleyGeom.Transform) -> MSPyBentleyGeom.ValidatedTransform
        
        Return the inverse of the instance transform. This is a modestly
        expensive floating point computation (33 multiplies, 14 adds).
        Symbolically, given transform [R t] return transform [Q Q*(-t)] where
        Q is the inverse of matrix R.
        
        Returns:
        """
        ...
    
    def ZeroTranslation(*args, **kwargs):
        """
        ZeroTranslation(self: MSPyBentleyGeom.Transform) -> None
        
        Sets the translation part of this instance to zero. The prior
        translation part is overwritten, and the matrix part is unchanged.
        Symbolically, this instance [R t] becomes the transformation [R 0].
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.Transform) -> None:
        ...
    
class TransformArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.TransformArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.TransformArray, arg0: MSPyBentleyGeom.TransformArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.TransformArray, arg0: Iterable) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.TransformArray, x: MSPyBentleyGeom.Transform) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.TransformArray) -> None
        
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.TransformArray, L: MSPyBentleyGeom.TransformArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.TransformArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.TransformArray, i: int, x: MSPyBentleyGeom.Transform) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.TransformArray) -> MSPyBentleyGeom.Transform
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.TransformArray, i: int) -> MSPyBentleyGeom.Transform
        
        Remove and return the item at index ``i``
        """
        ...
    
U0_EDGE: int

U1_EDGE: int

V0_EDGE: int

V1_EDGE: int

class ValidatedClipPlane:
    """
    None
    """

    def IsValid(*args, **kwargs):
        """
        IsValid(*args, **kwargs)
        Overloaded function.
        
        1. IsValid(self: MSPyBentleyGeom.ValidatedClipPlane) -> bool
        
        2. IsValid(self: MSPyBentleyGeom.ValidatedClipPlane, value: MSPyBentleyGeom.ClipPlane) -> bool
        """
        ...
    
    def SetIsValid(*args, **kwargs):
        """
        SetIsValid(self: MSPyBentleyGeom.ValidatedClipPlane, value: bool) -> None
        """
        ...
    
    def Value(*args, **kwargs):
        """
        Value(self: MSPyBentleyGeom.ValidatedClipPlane) -> MSPyBentleyGeom.ClipPlane
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ValidatedClipPlane) -> None
        
        2. __init__(self: MSPyBentleyGeom.ValidatedClipPlane, value: MSPyBentleyGeom.ClipPlane) -> None
        
        3. __init__(self: MSPyBentleyGeom.ValidatedClipPlane, value: MSPyBentleyGeom.ClipPlane, isValid: bool) -> None
        """
        ...
    
class ValidatedCurveLocationDetail:
    """
    None
    """

    def IsValid(*args, **kwargs):
        """
        IsValid(*args, **kwargs)
        Overloaded function.
        
        1. IsValid(self: MSPyBentleyGeom.ValidatedCurveLocationDetail) -> bool
        
        2. IsValid(self: MSPyBentleyGeom.ValidatedCurveLocationDetail, value: MSPyBentleyGeom.CurveLocationDetail) -> bool
        """
        ...
    
    def SetIsValid(*args, **kwargs):
        """
        SetIsValid(self: MSPyBentleyGeom.ValidatedCurveLocationDetail, value: bool) -> None
        """
        ...
    
    def Value(*args, **kwargs):
        """
        Value(self: MSPyBentleyGeom.ValidatedCurveLocationDetail) -> MSPyBentleyGeom.CurveLocationDetail
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ValidatedCurveLocationDetail) -> None
        
        2. __init__(self: MSPyBentleyGeom.ValidatedCurveLocationDetail, value: MSPyBentleyGeom.CurveLocationDetail) -> None
        
        3. __init__(self: MSPyBentleyGeom.ValidatedCurveLocationDetail, value: MSPyBentleyGeom.CurveLocationDetail, isValid: bool) -> None
        """
        ...
    
class ValidatedDEllipse3d:
    """
    None
    """

    def IsValid(*args, **kwargs):
        """
        IsValid(*args, **kwargs)
        Overloaded function.
        
        1. IsValid(self: MSPyBentleyGeom.ValidatedDEllipse3d) -> bool
        
        2. IsValid(self: MSPyBentleyGeom.ValidatedDEllipse3d, value: MSPyBentleyGeom.DEllipse3d) -> bool
        """
        ...
    
    def SetIsValid(*args, **kwargs):
        """
        SetIsValid(self: MSPyBentleyGeom.ValidatedDEllipse3d, value: bool) -> None
        """
        ...
    
    def Value(*args, **kwargs):
        """
        Value(self: MSPyBentleyGeom.ValidatedDEllipse3d) -> MSPyBentleyGeom.DEllipse3d
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ValidatedDEllipse3d) -> None
        
        2. __init__(self: MSPyBentleyGeom.ValidatedDEllipse3d, value: MSPyBentleyGeom.DEllipse3d) -> None
        
        3. __init__(self: MSPyBentleyGeom.ValidatedDEllipse3d, value: MSPyBentleyGeom.DEllipse3d, isValid: bool) -> None
        """
        ...
    
class ValidatedDPlane3d:
    """
    None
    """

    def IsValid(*args, **kwargs):
        """
        IsValid(*args, **kwargs)
        Overloaded function.
        
        1. IsValid(self: MSPyBentleyGeom.ValidatedDPlane3d) -> bool
        
        2. IsValid(self: MSPyBentleyGeom.ValidatedDPlane3d, value: MSPyBentleyGeom.DPlane3d) -> bool
        """
        ...
    
    def SetIsValid(*args, **kwargs):
        """
        SetIsValid(self: MSPyBentleyGeom.ValidatedDPlane3d, value: bool) -> None
        """
        ...
    
    def Value(*args, **kwargs):
        """
        Value(self: MSPyBentleyGeom.ValidatedDPlane3d) -> MSPyBentleyGeom.DPlane3d
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ValidatedDPlane3d) -> None
        
        2. __init__(self: MSPyBentleyGeom.ValidatedDPlane3d, value: MSPyBentleyGeom.DPlane3d) -> None
        
        3. __init__(self: MSPyBentleyGeom.ValidatedDPlane3d, value: MSPyBentleyGeom.DPlane3d, isValid: bool) -> None
        """
        ...
    
class ValidatedDPlane3dByVectors:
    """
    None
    """

    def IsValid(*args, **kwargs):
        """
        IsValid(*args, **kwargs)
        Overloaded function.
        
        1. IsValid(self: MSPyBentleyGeom.ValidatedDPlane3dByVectors) -> bool
        
        2. IsValid(self: MSPyBentleyGeom.ValidatedDPlane3dByVectors, value: MSPyBentleyGeom.DPlane3dByVectors) -> bool
        """
        ...
    
    def SetIsValid(*args, **kwargs):
        """
        SetIsValid(self: MSPyBentleyGeom.ValidatedDPlane3dByVectors, value: bool) -> None
        """
        ...
    
    def Value(*args, **kwargs):
        """
        Value(self: MSPyBentleyGeom.ValidatedDPlane3dByVectors) -> MSPyBentleyGeom.DPlane3dByVectors
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ValidatedDPlane3dByVectors) -> None
        
        2. __init__(self: MSPyBentleyGeom.ValidatedDPlane3dByVectors, value: MSPyBentleyGeom.DPlane3dByVectors) -> None
        
        3. __init__(self: MSPyBentleyGeom.ValidatedDPlane3dByVectors, value: MSPyBentleyGeom.DPlane3dByVectors, isValid: bool) -> None
        """
        ...
    
class ValidatedDPoint2d:
    """
    None
    """

    def IsValid(*args, **kwargs):
        """
        IsValid(*args, **kwargs)
        Overloaded function.
        
        1. IsValid(self: MSPyBentleyGeom.ValidatedDPoint2d) -> bool
        
        2. IsValid(self: MSPyBentleyGeom.ValidatedDPoint2d, value: MSPyBentleyGeom.DPoint2d) -> bool
        """
        ...
    
    def SetIsValid(*args, **kwargs):
        """
        SetIsValid(self: MSPyBentleyGeom.ValidatedDPoint2d, value: bool) -> None
        """
        ...
    
    def Value(*args, **kwargs):
        """
        Value(self: MSPyBentleyGeom.ValidatedDPoint2d) -> MSPyBentleyGeom.DPoint2d
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ValidatedDPoint2d) -> None
        
        2. __init__(self: MSPyBentleyGeom.ValidatedDPoint2d, value: MSPyBentleyGeom.DPoint2d) -> None
        
        3. __init__(self: MSPyBentleyGeom.ValidatedDPoint2d, value: MSPyBentleyGeom.DPoint2d, isValid: bool) -> None
        """
        ...
    
class ValidatedDPoint3d:
    """
    None
    """

    def IsValid(*args, **kwargs):
        """
        IsValid(*args, **kwargs)
        Overloaded function.
        
        1. IsValid(self: MSPyBentleyGeom.ValidatedDPoint3d) -> bool
        
        2. IsValid(self: MSPyBentleyGeom.ValidatedDPoint3d, value: MSPyBentleyGeom.DPoint3d) -> bool
        """
        ...
    
    def SetIsValid(*args, **kwargs):
        """
        SetIsValid(self: MSPyBentleyGeom.ValidatedDPoint3d, value: bool) -> None
        """
        ...
    
    def Value(*args, **kwargs):
        """
        Value(self: MSPyBentleyGeom.ValidatedDPoint3d) -> MSPyBentleyGeom.DPoint3d
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ValidatedDPoint3d) -> None
        
        2. __init__(self: MSPyBentleyGeom.ValidatedDPoint3d, value: MSPyBentleyGeom.DPoint3d) -> None
        
        3. __init__(self: MSPyBentleyGeom.ValidatedDPoint3d, value: MSPyBentleyGeom.DPoint3d, isValid: bool) -> None
        """
        ...
    
class ValidatedDPoint4d:
    """
    None
    """

    def IsValid(*args, **kwargs):
        """
        IsValid(*args, **kwargs)
        Overloaded function.
        
        1. IsValid(self: MSPyBentleyGeom.ValidatedDPoint4d) -> bool
        
        2. IsValid(self: MSPyBentleyGeom.ValidatedDPoint4d, value: MSPyBentleyGeom.DPoint4d) -> bool
        """
        ...
    
    def SetIsValid(*args, **kwargs):
        """
        SetIsValid(self: MSPyBentleyGeom.ValidatedDPoint4d, value: bool) -> None
        """
        ...
    
    def Value(*args, **kwargs):
        """
        Value(self: MSPyBentleyGeom.ValidatedDPoint4d) -> MSPyBentleyGeom.DPoint4d
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ValidatedDPoint4d) -> None
        
        2. __init__(self: MSPyBentleyGeom.ValidatedDPoint4d, value: MSPyBentleyGeom.DPoint4d) -> None
        
        3. __init__(self: MSPyBentleyGeom.ValidatedDPoint4d, value: MSPyBentleyGeom.DPoint4d, isValid: bool) -> None
        """
        ...
    
class ValidatedDRange3d:
    """
    None
    """

    def IsValid(*args, **kwargs):
        """
        IsValid(*args, **kwargs)
        Overloaded function.
        
        1. IsValid(self: MSPyBentleyGeom.ValidatedDRange3d) -> bool
        
        2. IsValid(self: MSPyBentleyGeom.ValidatedDRange3d, value: MSPyBentleyGeom.DRange3d) -> bool
        """
        ...
    
    def SetIsValid(*args, **kwargs):
        """
        SetIsValid(self: MSPyBentleyGeom.ValidatedDRange3d, value: bool) -> None
        """
        ...
    
    def Value(*args, **kwargs):
        """
        Value(self: MSPyBentleyGeom.ValidatedDRange3d) -> MSPyBentleyGeom.DRange3d
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ValidatedDRange3d) -> None
        
        2. __init__(self: MSPyBentleyGeom.ValidatedDRange3d, value: MSPyBentleyGeom.DRange3d) -> None
        
        3. __init__(self: MSPyBentleyGeom.ValidatedDRange3d, value: MSPyBentleyGeom.DRange3d, isValid: bool) -> None
        """
        ...
    
class ValidatedDRay3d:
    """
    None
    """

    def IsValid(*args, **kwargs):
        """
        IsValid(*args, **kwargs)
        Overloaded function.
        
        1. IsValid(self: MSPyBentleyGeom.ValidatedDRay3d) -> bool
        
        2. IsValid(self: MSPyBentleyGeom.ValidatedDRay3d, value: MSPyBentleyGeom.DRay3d) -> bool
        """
        ...
    
    def SetIsValid(*args, **kwargs):
        """
        SetIsValid(self: MSPyBentleyGeom.ValidatedDRay3d, value: bool) -> None
        """
        ...
    
    def Value(*args, **kwargs):
        """
        Value(self: MSPyBentleyGeom.ValidatedDRay3d) -> MSPyBentleyGeom.DRay3d
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ValidatedDRay3d) -> None
        
        2. __init__(self: MSPyBentleyGeom.ValidatedDRay3d, value: MSPyBentleyGeom.DRay3d) -> None
        
        3. __init__(self: MSPyBentleyGeom.ValidatedDRay3d, value: MSPyBentleyGeom.DRay3d, isValid: bool) -> None
        """
        ...
    
class ValidatedDSegment3d:
    """
    None
    """

    def IsValid(*args, **kwargs):
        """
        IsValid(*args, **kwargs)
        Overloaded function.
        
        1. IsValid(self: MSPyBentleyGeom.ValidatedDSegment3d) -> bool
        
        2. IsValid(self: MSPyBentleyGeom.ValidatedDSegment3d, value: MSPyBentleyGeom.DSegment3d) -> bool
        """
        ...
    
    def SetIsValid(*args, **kwargs):
        """
        SetIsValid(self: MSPyBentleyGeom.ValidatedDSegment3d, value: bool) -> None
        """
        ...
    
    def Value(*args, **kwargs):
        """
        Value(self: MSPyBentleyGeom.ValidatedDSegment3d) -> MSPyBentleyGeom.DSegment3d
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ValidatedDSegment3d) -> None
        
        2. __init__(self: MSPyBentleyGeom.ValidatedDSegment3d, value: MSPyBentleyGeom.DSegment3d) -> None
        
        3. __init__(self: MSPyBentleyGeom.ValidatedDSegment3d, value: MSPyBentleyGeom.DSegment3d, isValid: bool) -> None
        """
        ...
    
class ValidatedDVec2d:
    """
    None
    """

    def IsValid(*args, **kwargs):
        """
        IsValid(*args, **kwargs)
        Overloaded function.
        
        1. IsValid(self: MSPyBentleyGeom.ValidatedDVec2d) -> bool
        
        2. IsValid(self: MSPyBentleyGeom.ValidatedDVec2d, value: MSPyBentleyGeom.DVec2d) -> bool
        """
        ...
    
    def SetIsValid(*args, **kwargs):
        """
        SetIsValid(self: MSPyBentleyGeom.ValidatedDVec2d, value: bool) -> None
        """
        ...
    
    def Value(*args, **kwargs):
        """
        Value(self: MSPyBentleyGeom.ValidatedDVec2d) -> MSPyBentleyGeom.DVec2d
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ValidatedDVec2d) -> None
        
        2. __init__(self: MSPyBentleyGeom.ValidatedDVec2d, value: MSPyBentleyGeom.DVec2d) -> None
        
        3. __init__(self: MSPyBentleyGeom.ValidatedDVec2d, value: MSPyBentleyGeom.DVec2d, isValid: bool) -> None
        """
        ...
    
class ValidatedDVec3d:
    """
    None
    """

    def IsValid(*args, **kwargs):
        """
        IsValid(*args, **kwargs)
        Overloaded function.
        
        1. IsValid(self: MSPyBentleyGeom.ValidatedDVec3d) -> bool
        
        2. IsValid(self: MSPyBentleyGeom.ValidatedDVec3d, value: MSPyBentleyGeom.DVec3d) -> bool
        """
        ...
    
    def SetIsValid(*args, **kwargs):
        """
        SetIsValid(self: MSPyBentleyGeom.ValidatedDVec3d, value: bool) -> None
        """
        ...
    
    def Value(*args, **kwargs):
        """
        Value(self: MSPyBentleyGeom.ValidatedDVec3d) -> MSPyBentleyGeom.DVec3d
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ValidatedDVec3d) -> None
        
        2. __init__(self: MSPyBentleyGeom.ValidatedDVec3d, value: MSPyBentleyGeom.DVec3d) -> None
        
        3. __init__(self: MSPyBentleyGeom.ValidatedDVec3d, value: MSPyBentleyGeom.DVec3d, isValid: bool) -> None
        """
        ...
    
class ValidatedDouble:
    """
    None
    """

    def IsValid(*args, **kwargs):
        """
        IsValid(*args, **kwargs)
        Overloaded function.
        
        1. IsValid(self: MSPyBentleyGeom.ValidatedDouble) -> bool
        
        2. IsValid(self: MSPyBentleyGeom.ValidatedDouble, value: float) -> bool
        """
        ...
    
    def SetIsValid(*args, **kwargs):
        """
        SetIsValid(self: MSPyBentleyGeom.ValidatedDouble, value: bool) -> None
        """
        ...
    
    def Value(*args, **kwargs):
        """
        Value(self: MSPyBentleyGeom.ValidatedDouble) -> float
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ValidatedDouble) -> None
        
        2. __init__(self: MSPyBentleyGeom.ValidatedDouble, value: float) -> None
        
        3. __init__(self: MSPyBentleyGeom.ValidatedDouble, value: float, isValid: bool) -> None
        """
        ...
    
class ValidatedLocalRange:
    """
    None
    """

    def IsValid(*args, **kwargs):
        """
        IsValid(*args, **kwargs)
        Overloaded function.
        
        1. IsValid(self: MSPyBentleyGeom.ValidatedLocalRange) -> bool
        
        2. IsValid(self: MSPyBentleyGeom.ValidatedLocalRange, value: MSPyBentleyGeom.LocalRange) -> bool
        """
        ...
    
    def SetIsValid(*args, **kwargs):
        """
        SetIsValid(self: MSPyBentleyGeom.ValidatedLocalRange, value: bool) -> None
        """
        ...
    
    def Value(*args, **kwargs):
        """
        Value(self: MSPyBentleyGeom.ValidatedLocalRange) -> MSPyBentleyGeom.LocalRange
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ValidatedLocalRange) -> None
        
        2. __init__(self: MSPyBentleyGeom.ValidatedLocalRange, value: MSPyBentleyGeom.LocalRange) -> None
        
        3. __init__(self: MSPyBentleyGeom.ValidatedLocalRange, value: MSPyBentleyGeom.LocalRange, isValid: bool) -> None
        """
        ...
    
class ValidatedRotMatrix:
    """
    None
    """

    def IsValid(*args, **kwargs):
        """
        IsValid(*args, **kwargs)
        Overloaded function.
        
        1. IsValid(self: MSPyBentleyGeom.ValidatedRotMatrix) -> bool
        
        2. IsValid(self: MSPyBentleyGeom.ValidatedRotMatrix, value: MSPyBentleyGeom.RotMatrix) -> bool
        """
        ...
    
    def SetIsValid(*args, **kwargs):
        """
        SetIsValid(self: MSPyBentleyGeom.ValidatedRotMatrix, value: bool) -> None
        """
        ...
    
    def Value(*args, **kwargs):
        """
        Value(self: MSPyBentleyGeom.ValidatedRotMatrix) -> MSPyBentleyGeom.RotMatrix
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ValidatedRotMatrix) -> None
        
        2. __init__(self: MSPyBentleyGeom.ValidatedRotMatrix, value: MSPyBentleyGeom.RotMatrix) -> None
        
        3. __init__(self: MSPyBentleyGeom.ValidatedRotMatrix, value: MSPyBentleyGeom.RotMatrix, isValid: bool) -> None
        """
        ...
    
class ValidatedSize:
    """
    None
    """

    def IsValid(*args, **kwargs):
        """
        IsValid(*args, **kwargs)
        Overloaded function.
        
        1. IsValid(self: MSPyBentleyGeom.ValidatedSize) -> bool
        
        2. IsValid(self: MSPyBentleyGeom.ValidatedSize, value: int) -> bool
        """
        ...
    
    def SetIsValid(*args, **kwargs):
        """
        SetIsValid(self: MSPyBentleyGeom.ValidatedSize, value: bool) -> None
        """
        ...
    
    def Value(*args, **kwargs):
        """
        Value(self: MSPyBentleyGeom.ValidatedSize) -> int
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ValidatedSize) -> None
        
        2. __init__(self: MSPyBentleyGeom.ValidatedSize, value: int) -> None
        
        3. __init__(self: MSPyBentleyGeom.ValidatedSize, value: int, isValid: bool) -> None
        """
        ...
    
class ValidatedTransform:
    """
    None
    """

    def IsValid(*args, **kwargs):
        """
        IsValid(*args, **kwargs)
        Overloaded function.
        
        1. IsValid(self: MSPyBentleyGeom.ValidatedTransform) -> bool
        
        2. IsValid(self: MSPyBentleyGeom.ValidatedTransform, value: MSPyBentleyGeom.Transform) -> bool
        """
        ...
    
    def SetIsValid(*args, **kwargs):
        """
        SetIsValid(self: MSPyBentleyGeom.ValidatedTransform, value: bool) -> None
        """
        ...
    
    def Value(*args, **kwargs):
        """
        Value(self: MSPyBentleyGeom.ValidatedTransform) -> MSPyBentleyGeom.Transform
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ValidatedTransform) -> None
        
        2. __init__(self: MSPyBentleyGeom.ValidatedTransform, value: MSPyBentleyGeom.Transform) -> None
        
        3. __init__(self: MSPyBentleyGeom.ValidatedTransform, value: MSPyBentleyGeom.Transform, isValid: bool) -> None
        """
        ...
    
class VertexId:
    """
    None
    """

    def GetFaces(*args, **kwargs):
        """
        GetFaces(self: MSPyBentleyGeom.VertexId) -> tuple
        """
        ...
    
    def SetFaces(*args, **kwargs):
        """
        SetFaces(self: MSPyBentleyGeom.VertexId, f1: MSPyBentleyGeom.FaceId, f2: MSPyBentleyGeom.FaceId, f3: MSPyBentleyGeom.FaceId) -> None
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.VertexId) -> None:
        ...
    
class VertexIdArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.VertexIdArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.VertexIdArray, arg0: MSPyBentleyGeom.VertexIdArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.VertexIdArray, arg0: Iterable) -> None
        """
        ...
    
    def append(*args, **kwargs):
        """
        append(self: MSPyBentleyGeom.VertexIdArray, x: MSPyBentleyGeom.VertexId) -> None
        
        Add an item to the end of the list
        """
        ...
    
    def clear(*args, **kwargs):
        """
        clear(self: MSPyBentleyGeom.VertexIdArray) -> None
        
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        extend(*args, **kwargs)
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.VertexIdArray, L: MSPyBentleyGeom.VertexIdArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.VertexIdArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(*args, **kwargs):
        """
        insert(self: MSPyBentleyGeom.VertexIdArray, i: int, x: MSPyBentleyGeom.VertexId) -> None
        
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        pop(*args, **kwargs)
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.VertexIdArray) -> MSPyBentleyGeom.VertexId
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.VertexIdArray, i: int) -> MSPyBentleyGeom.VertexId
        
        Remove and return the item at index ``i``
        """
        ...
    
class YawPitchRollAngles:
    """
    None
    """

    def FromDegrees(*args, **kwargs):
        """
        FromDegrees(yawDegrees: float, pitchDegrees: float, rollDegrees: float) -> MSPyBentleyGeom.YawPitchRollAngles
        
        constructor from all angles in degrees
        """
        ...
    
    def FromRadians(*args, **kwargs):
        """
        FromRadians(yawRadians: float, pitchRadians: float, rollRadians: float) -> MSPyBentleyGeom.YawPitchRollAngles
        
        constructor from all angles in radians
        """
        ...
    
    def GetPitch(*args, **kwargs):
        """
        GetPitch(self: MSPyBentleyGeom.YawPitchRollAngles) -> MSPyBentleyGeom.AngleInDegrees
        """
        ...
    
    def GetRoll(*args, **kwargs):
        """
        GetRoll(self: MSPyBentleyGeom.YawPitchRollAngles) -> MSPyBentleyGeom.AngleInDegrees
        """
        ...
    
    def GetYaw(*args, **kwargs):
        """
        GetYaw(self: MSPyBentleyGeom.YawPitchRollAngles) -> MSPyBentleyGeom.AngleInDegrees
        """
        ...
    
    def IsIdentity(*args, **kwargs):
        """
        IsIdentity(self: MSPyBentleyGeom.YawPitchRollAngles) -> bool
        
        test for near-zero angles.
        """
        ...
    
    def MaxAbsDegrees(*args, **kwargs):
        """
        MaxAbsDegrees(self: MSPyBentleyGeom.YawPitchRollAngles) -> float
        
        return the maximum absolute radians among the angles.
        """
        ...
    
    def MaxAbsRadians(*args, **kwargs):
        """
        MaxAbsRadians(self: MSPyBentleyGeom.YawPitchRollAngles) -> float
        
        return the maximum absolute radians among the angles.
        """
        ...
    
    def MaxDiffDegrees(*args, **kwargs):
        """
        MaxDiffDegrees(self: MSPyBentleyGeom.YawPitchRollAngles, other: MSPyBentleyGeom.YawPitchRollAngles) -> float
        
        return the maximum absolute difference among radians among the angles.
        """
        ...
    
    def MaxDiffRadians(*args, **kwargs):
        """
        MaxDiffRadians(self: MSPyBentleyGeom.YawPitchRollAngles, other: MSPyBentleyGeom.YawPitchRollAngles) -> float
        
        return the maximum absolute difference among radians among the angles.
        """
        ...
    
    @property
    def Pitch(arg0: MSPyBentleyGeom.YawPitchRollAngles) -> MSPyBentleyGeom.AngleInDegrees:
        ...
    
    @property
    def Roll(arg0: MSPyBentleyGeom.YawPitchRollAngles) -> MSPyBentleyGeom.AngleInDegrees:
        ...
    
    def ToRotMatrix(*args, **kwargs):
        """
        ToRotMatrix(self: MSPyBentleyGeom.YawPitchRollAngles) -> Bentley.RotMatrix
        
        Convert the angles to a RotMatrix
        """
        ...
    
    def ToTransform(*args, **kwargs):
        """
        ToTransform(self: MSPyBentleyGeom.YawPitchRollAngles, origin: Bentley.DPoint3d) -> Bentley.Transform
        
        Convert the angles and an origin to a Transform.
        """
        ...
    
    def TryFromRotMatrix(*args, **kwargs):
        """
        TryFromRotMatrix(angles: MSPyBentleyGeom.YawPitchRollAngles, matrix: Bentley.RotMatrix) -> bool
        
        Try to extract angles from a RotMatrix
        """
        ...
    
    @property
    def Yaw(arg0: MSPyBentleyGeom.YawPitchRollAngles) -> MSPyBentleyGeom.AngleInDegrees:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.YawPitchRollAngles) -> None
        
        2. __init__(self: MSPyBentleyGeom.YawPitchRollAngles, yaw: MSPyBentleyGeom.AngleInDegrees, pitch: MSPyBentleyGeom.AngleInDegrees, roll: MSPyBentleyGeom.AngleInDegrees) -> None
        
        3. __init__(self: MSPyBentleyGeom.YawPitchRollAngles, yaw: MSPyBentleyGeom.Angle, pitch: MSPyBentleyGeom.Angle, roll: MSPyBentleyGeom.Angle) -> None
        """
        ...
    
eAreaSelect_CCWNegativeWindingNumber: AreaSelect

eAreaSelect_CCWNonzeroWindingNumber: AreaSelect

eAreaSelect_CCWPositiveWindingNumber: AreaSelect

eAreaSelect_Parity: AreaSelect

eBoolSelect_FromStructure: BoolSelect

eBoolSelect_Parity: BoolSelect

eBoolSelect_Summed_Negative: BoolSelect

eBoolSelect_Summed_NonZero: BoolSelect

eBoolSelect_Summed_Parity: BoolSelect

eBoolSelect_Summed_Positive: BoolSelect

eBoolSelect_Union: BoolSelect

eCURVE_CURVE_BLEND_BisectorParabola: BlendType

eCURVE_CURVE_BLEND_VerticalAxisParabola: BlendType

eCURVE_PARAMETER_MAPPING_BezierFraction: CurveParameterMapping

eCURVE_PARAMETER_MAPPING_CurveFraction: CurveParameterMapping

eCURVE_PARAMETER_MAPPING_CurveKnot: CurveParameterMapping

eClipPlaneContainment_Ambiguous: ClipPlaneContainment

eClipPlaneContainment_StronglyInside: ClipPlaneContainment

eClipPlaneContainment_StronglyOutside: ClipPlaneContainment

eFACET_PARAM_01BothAxes: FacetParamMode

eFACET_PARAM_01LargerAxis: FacetParamMode

eFACET_PARAM_Distance: FacetParamMode

eLOCAL_COORDINATE_SCALE_01RangeBothAxes: LocalCoordinateSelect

eLOCAL_COORDINATE_SCALE_01RangeLargerAxis: LocalCoordinateSelect

eLOCAL_COORDINATE_SCALE_UnitAxesAtLowerLeft: LocalCoordinateSelect

eLOCAL_COORDINATE_SCALE_UnitAxesAtStart: LocalCoordinateSelect

eREPROJECT_BadArgument: ReprojectStatus

eREPROJECT_CSMAPERR_DatumConverterNotSet: ReprojectStatus

eREPROJECT_CSMAPERR_Error: ReprojectStatus

eREPROJECT_CSMAPERR_OutOfMathematicalDomain: ReprojectStatus

eREPROJECT_CSMAPERR_OutOfUsefulRange: ReprojectStatus

eREPROJECT_CSMAPERR_VerticalDatumConversionError: ReprojectStatus

eREPROJECT_DataError: ReprojectStatus

eREPROJECT_DontValidateRange: ReprojectStatus

eREPROJECT_GeoCoordNotInitialized: ReprojectStatus

eREPROJECT_InvalidCoordSys: ReprojectStatus

eREPROJECT_NoChange: ReprojectStatus

eREPROJECT_StrokeError: ReprojectStatus

eREPROJECT_Success: ReprojectStatus

eSolidPrimitiveType_DgnBox: SolidPrimitiveType

eSolidPrimitiveType_DgnCone: SolidPrimitiveType

eSolidPrimitiveType_DgnExtrusion: SolidPrimitiveType

eSolidPrimitiveType_DgnRotationalSweep: SolidPrimitiveType

eSolidPrimitiveType_DgnRuledSweep: SolidPrimitiveType

eSolidPrimitiveType_DgnSphere: SolidPrimitiveType

eSolidPrimitiveType_DgnTorusPipe: SolidPrimitiveType

eSolidPrimitiveType_None: SolidPrimitiveType

class interpolationParam:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    
    @property
    def isChordLenKnots(self: MSPyBentleyGeom.interpolationParam) -> int:
        ...
    @isChordLenKnots.setter
    def isChordLenKnots(self: MSPyBentleyGeom.interpolationParam, arg0: int) -> None:
        ...
    
    @property
    def isChordLenTangents(self: MSPyBentleyGeom.interpolationParam) -> int:
        ...
    @isChordLenTangents.setter
    def isChordLenTangents(self: MSPyBentleyGeom.interpolationParam, arg0: int) -> None:
        ...
    
    @property
    def isColinearTangents(self: MSPyBentleyGeom.interpolationParam) -> int:
        ...
    @isColinearTangents.setter
    def isColinearTangents(self: MSPyBentleyGeom.interpolationParam, arg0: int) -> None:
        ...
    
    @property
    def isNaturalTangents(self: MSPyBentleyGeom.interpolationParam) -> int:
        ...
    @isNaturalTangents.setter
    def isNaturalTangents(self: MSPyBentleyGeom.interpolationParam, arg0: int) -> None:
        ...
    
    @property
    def isPeriodic(self: MSPyBentleyGeom.interpolationParam) -> int:
        ...
    @isPeriodic.setter
    def isPeriodic(self: MSPyBentleyGeom.interpolationParam, arg0: int) -> None:
        ...
    
    @property
    def numKnots(self: MSPyBentleyGeom.interpolationParam) -> int:
        ...
    @numKnots.setter
    def numKnots(self: MSPyBentleyGeom.interpolationParam, arg0: int) -> None:
        ...
    
    @property
    def numPoints(self: MSPyBentleyGeom.interpolationParam) -> int:
        ...
    @numPoints.setter
    def numPoints(self: MSPyBentleyGeom.interpolationParam, arg0: int) -> None:
        ...
    
    @property
    def order(self: MSPyBentleyGeom.interpolationParam) -> int:
        ...
    @order.setter
    def order(self: MSPyBentleyGeom.interpolationParam, arg0: int) -> None:
        ...
    
mgds_fc_condition: float

mgds_fc_epsilon: float

mgds_fc_iang_to_rad: float

mgds_fc_miang_to_rad: float

mgds_fc_nearZero: float

mgds_fc_rad_to_iang: float

msGeomConst_2pi: float

msGeomConst_degreesPerRadian: float

msGeomConst_pi: float

msGeomConst_piOver12: float

msGeomConst_piOver2: float

msGeomConst_piOver4: float

msGeomConst_radiansPerDegree: float

