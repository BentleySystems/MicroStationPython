from typing import Any, Optional, overload, Type, Sequence, Iterable, Union, Callable
from enum import Enum
import MSPyBentleyGeom

ANY_EDGE: int

class Angle:
    """
    None
    """

    @staticmethod
    def Acos(arg: float) -> float:
        """
        Return acos of arg, but cap arg at +- 1
        """
        ...
    
    @staticmethod
    def AdjustToSweep(theta: float, thetaStart: float, sweep: float) -> float:
        """
        Shift{theta} so it is within one period of{thetaStart} in the
        direction of{sweep}. Return angle in radians
        """
        ...
    
    @staticmethod
    def ApplyGivensWeights(a: float, b: float, cos: float, sin: float) -> tuple:
        """
        :param (output):
        aOut{(a,b) DOT (cos,sin)}
        
        :param (output):
        bOut{(cross,sin) DOT (a,b)}
        
        :param (input):
        a x coordiante
        
        :param (input):
        b y coordinate
        
        :param (input):
        cos cosine term of Givens rotation.
        
        :param (input):
        sin sine term of Givens rotation.
        """
        ...
    
    @staticmethod
    def Asin(arg: float) -> float:
        """
        Return asin of arg, but cap arg at +- 1
        """
        ...
    
    @staticmethod
    def Atan2(numerator: float, denominator: float) -> float:
        """
        Return the arctan of numerator/denominator, in full -PI to PI range.
        0,0 returns 0.
        """
        ...
    
    @staticmethod
    def CircleFractionToRadians(fraction: float) -> float:
        """
        Convert radians to degrees
        """
        ...
    
    @staticmethod
    def ConstructGivensWeights(a: float, b: float) -> tuple:
        """
        Construct cosine and sine of vector to (a,b). (Just normalize a and
        b.)
        
        :param (output):
        cosine
        
        :param (output):
        sine
        
        :param (input):
        a
        
        :param (input):
        b
        """
        ...
    
    def Cos(self: MSPyBentleyGeom.Angle) -> float:
        """
        return the cosine of the angle.
        """
        ...
    
    @staticmethod
    def Cyclic2dAxis(i: int) -> int:
        """
        :returns:
        i adjusted to [0,1] with wraparound.
        """
        ...
    
    @staticmethod
    def Cyclic3dAxes(i: int) -> tuple:
        """
        :param (output):
        i0 i adjusted to [0,1,2] with wraparound
        
        :param (output):
        i1 i+1 adjusted to [0,1,2] with wraparound
        
        :param (output):
        i2 i+2 adjusted to [0,1,2] with wraparound
        
        :param (input):
        i initial axis
        """
        ...
    
    @staticmethod
    def Cyclic3dAxis(i: int) -> int:
        """
        :returns:
        i adjusted to [0,1,2] with wraparound.
        """
        ...
    
    def Degrees(self: MSPyBentleyGeom.Angle) -> float:
        """
        Return the angle in degrees
        """
        ...
    
    @staticmethod
    def DegreesToRadians(degrees: float) -> float:
        """
        Convert degrees to radians
        """
        ...
    
    @staticmethod
    def EvaluateTrigCombination(constCoff: float, cosCoff: float, sinCoff: float, theta: float) -> float:
        """
        Evaluate{f(theta) = constCoff + cosCoff * cos(theta) + sinCoff *
        sin(theta)}
        
        :param (input):
        constCoff constant coefficient
        
        :param (input):
        cosCoff cosine coefficient
        
        :param (input):
        sinCoff sine coefficient
        
        :param (input):
        theta evaluation angle
        """
        ...
    
    @staticmethod
    def ForwardComplement(radians: float) -> float:
        """
        Angle which sweeps in the same direction to return to sum of 2pi
        Examples
        
        * ForwardComplement of{pi/2}{3pi/2}
        
        * ForwardComplement of{-pi/2}{-3pi/2}
        """
        ...
    
    @staticmethod
    def FromAtan2(sine: float, cosine: float) -> MSPyBentleyGeom.Angle:
        """
        Strongly typed " constructor " (static method)
        """
        ...
    
    @staticmethod
    def FromDegrees(degrees: float) -> MSPyBentleyGeom.Angle:
        """
        Strongly typed " constructor " (static method)
        """
        ...
    
    @staticmethod
    def FromFullCircle() -> MSPyBentleyGeom.Angle:
        """
        Strongly typed " constructor " (static method) for full circle angle
        """
        ...
    
    @staticmethod
    def FromRadians(radians: float) -> MSPyBentleyGeom.Angle:
        """
        Strongly typed " constructor " (static method)
        """
        ...
    
    @staticmethod
    def HalfAngleFuctions(rCos2A: float, rSin2A: float) -> tuple:
        """
        Given trig functions (cosine and sine) of some (double) angle 2A, find
        trig functions for the angle A.
        """
        ...
    
    @staticmethod
    def InExactSweep(theta: float, thetaStart: float, sweep: float) -> bool:
        """
        Test if angle is in sweep with no tolerance or period shift
        """
        ...
    
    @staticmethod
    def InSweepAllowPeriodShift(theta: float, thetaStart: float, sweep: float) -> bool:
        """
        Test if theta or any shift by multiple of 2pi is in sweep.
        """
        ...
    
    @staticmethod
    def IsFullCircle(radians: float) -> bool:
        """
        Return true if{fabs(radians)} is within{Angle:SmallAngle} of 2PI.
        """
        ...
    
    @staticmethod
    def IsNearZero(radians: float) -> bool:
        """
        Test if{radians} is{SmallAngle} or smaller.
        """
        ...
    
    @staticmethod
    def IsNearZeroAllowPeriodShift(*args, **kwargs):
        """
        Overloaded function.
        
        1. IsNearZeroAllowPeriodShift(radians: float) -> bool
        
        Test if{radians} is{SmallAngle} or smaller.
        
        2. IsNearZeroAllowPeriodShift(radians: float, radiansTol: float) -> bool
        
        Test if{radians} is{SmallAngle} or smaller.
        """
        ...
    
    @staticmethod
    def MediumAngle() -> float:
        """
        Medium angle used in toleranced angle comparisons.
        """
        ...
    
    @staticmethod
    def NearlyEqual(radiansA: float, radiansB: float) -> bool:
        """
        Test if two angles are within{SmallAngle} (NOT allowing 2pi shift!!)
        """
        ...
    
    @staticmethod
    def NearlyEqualAllowPeriodShift(radiansA: float, radiansB: float) -> bool:
        """
        Test if two angles are within{SmallAngle}, allowing 2pi shift.
        """
        ...
    
    @staticmethod
    def NormalizeToSweep(*args, **kwargs):
        """
        Overloaded function.
        
        1. NormalizeToSweep(theta: float, thetaStart: float, sweep: float) -> float
        
        Shift{theta} so it is within one period of{thetaStart} in the
        direction of{sweep}. Return FRACTIONAL position.
        
        2. NormalizeToSweep(theta: float, thetaStart: float, sweep: float, extend0: bool, extend1: bool) -> float
        
        Shift{theta} so it is within one period of{thetaStart} in the
        direction of{sweep}. Return FRACTIONAL position.
        """
        ...
    
    @staticmethod
    def PeriodShift(theta: float, periods: float) -> float:
        """
        Add a multiple of 2PI to theta...
        """
        ...
    
    @staticmethod
    def Pi() -> float:
        """
        constant{PI}
        """
        ...
    
    @staticmethod
    def PiOver2() -> float:
        """
        consant{PI/2}
        """
        ...
    
    def Radians(self: MSPyBentleyGeom.Angle) -> float:
        """
        Return the angle in radians
        """
        ...
    
    @staticmethod
    def RadiansToDegrees(radians: float) -> float:
        """
        Convert radians to degrees
        """
        ...
    
    @staticmethod
    def ReverseComplement(radians: float) -> float:
        """
        Angle which sweeps in the other direction to the same end angle
        (modulo 2pi) as the given sweep.
        """
        ...
    
    @staticmethod
    def Rotate90UntilSmallAngle(x0: float, y0: float) -> tuple:
        """
        Find a vector that differs from (x0,y0) by a multiple of 90 degrees,
        x1 is positive, and y1 is as small as possible in absolute value, i.e.
        points to the right.
        """
        ...
    
    def Sin(self: MSPyBentleyGeom.Angle) -> float:
        """
        return the sine of the angle.
        """
        ...
    
    @staticmethod
    def SmallAngle() -> float:
        """
        Small angle used in toleranced angle comparisons.
        """
        ...
    
    @staticmethod
    def TinyAngle() -> float:
        """
        About 10 times unit roundoff . . .
        """
        ...
    
    @staticmethod
    def TrigCombinationRange(constCoff: float, cosCoff: float, sinCoff: float) -> tuple:
        """
        Find the min and max values of{f(theta) = constCoff + cosCoff *
        cos(theta) + sinCoff * sin(theta)} in [-pi,pi]
        
        :param (input):
        constCoff constant coefficient
        
        :param (input):
        cosCoff cosine coefficient
        
        :param (input):
        sinCoff sine coefficient
        
        :param (input):
        thetaMin angle where min occurs
        
        :param (input):
        fMin minimum value
        
        :param (input):
        thetaMax angle where max occurs
        
        :param (input):
        fMax maximum value
        """
        ...
    
    @staticmethod
    def TrigCombinationRangeInSweep(constCoff: float, cosCoff: float, sinCoff: float, thetaA: float, sweep: float) -> Tuple[float, float, float, float]:
        """
        Find the min and max values of{f(theta) = constCoff + cosCoff *
        cos(theta) + sinCoff * sin(theta)} in [thetaA, thetaB].
        
        :param (input):
        constCoff constant coefficient
        
        :param (input):
        cosCoff cosine coefficient
        
        :param (input):
        sinCoff sine coefficient
        
        :param (input):
        thetaA angle range limit
        
        :param (input):
        sweep sweep angle
        
        :param (input):
        thetaMin angle where min occurs
        
        :param (input):
        fMin minimum value
        
        :param (input):
        thetaMax angle where max occurs
        
        :param (input):
        fMax maximum value
        """
        ...
    
    @staticmethod
    def TrigIntegrals(theta0: float, theta1: float, integrals: RotMatrix) -> None:
        """
        Return integrals of [cc cs c; cs ss s; c s 1] from theta0 to theta1
        
        :param (input):
        theta0 beginning of integration interval
        
        :param (input):
        theta1 end of integration interval
        
        :param (output):
        integrals symmetric matrix of integrals.
        """
        ...
    
    @staticmethod
    def TwoPi() -> float:
        """
        constant{2*PI}
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.Angle) -> None
        
        2. __init__(self: MSPyBentleyGeom.Angle, arg0: MSPyBentleyGeom.Angle) -> None
        """
        ...
    
class AngleInDegrees:
    """
    None
    """

    def AlmostEqual(self: MSPyBentleyGeom.AngleInDegrees, other: MSPyBentleyGeom.AngleInDegrees) -> bool:
        """
        approximate equality test
        """
        ...
    
    def Cos(self: MSPyBentleyGeom.AngleInDegrees) -> float:
        """
        Return the cosine of the angle
        """
        ...
    
    def Degrees(self: MSPyBentleyGeom.AngleInDegrees) -> float:
        """
        Return the angle in degrees as simple double
        """
        ...
    
    @staticmethod
    def FromAtan2(y: float, x: float) -> MSPyBentleyGeom.AngleInDegrees:
        """
        Construct from xy vector components (with y first as usual for atan2)
        """
        ...
    
    @staticmethod
    def FromDegrees(degrees: float) -> MSPyBentleyGeom.AngleInDegrees:
        """
        Construct angle in degrees from input in degrees.
        """
        ...
    
    @staticmethod
    def FromRadians(radians: float) -> MSPyBentleyGeom.AngleInDegrees:
        """
        Construct angle in degrees from input in radians
        """
        ...
    
    def Radians(self: MSPyBentleyGeom.AngleInDegrees) -> float:
        """
        Return the angle in radians as a simple double.
        """
        ...
    
    def Sin(self: MSPyBentleyGeom.AngleInDegrees) -> float:
        """
        Return the sine of the angle
        """
        ...
    
    @staticmethod
    def SmallAngleInDegrees() -> MSPyBentleyGeom.AngleInDegrees:
        """
        The degrees form of the system small angle (for radians,
        Angle.SmallAngle ())
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.AngleInDegrees) -> None
        
        2. __init__(self: MSPyBentleyGeom.AngleInDegrees, arg0: MSPyBentleyGeom.AngleInDegrees) -> None
        
        3. __init__(self: MSPyBentleyGeom.AngleInDegrees, arg0: MSPyBentleyGeom.Angle) -> None
        """
        ...
    
class AnnounceDoubleDPoint2d:
    """
    None
    """

    def Announce(self: MSPyBentleyGeom.AnnounceDoubleDPoint2d, fraction: float, xy: DVec2d) -> None:
        ...
    
    def __init__(*args, **kwargs):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    
class AreaSelect:
    """
    Members:
    
    eAreaSelect_Parity
    
    eAreaSelect_CCWPositiveWindingNumber
    
    eAreaSelect_CCWNonzeroWindingNumber
    
    eAreaSelect_CCWNegativeWindingNumber
    """

    def __init__(self: MSPyBentleyGeom.AreaSelect, value: int) -> None:
        ...
    
    eAreaSelect_CCWNegativeWindingNumber: AreaSelect
    
    eAreaSelect_CCWNonzeroWindingNumber: AreaSelect
    
    eAreaSelect_CCWPositiveWindingNumber: AreaSelect
    
    eAreaSelect_Parity: AreaSelect
    
    @property
    def name(self: handle) -> str:
        ...
    
    @property
    def value(arg0: MSPyBentleyGeom.AreaSelect) -> int:
        ...
    
class BCurveSegment:
    """
    None
    """

    def AddExtrema(self: MSPyBentleyGeom.BCurveSegment, params: MSPyBentleyGeom.DoubleArray, range: DRange3d = None, mapToKnots: bool = False, firstDimension: int = 0, lastDimension: int = 2, includeStartEnd: bool = True) -> None:
        """
        Find minmax params (in some or all dimensions)
        
        :param [in,out]:
        params receiver vector.
        
        :param (output):
        range (optional) range observed at (a) points in the params and
        (b) endpoints.
        
        :param (input):
        mapToKnots if true convert bezier params to knots.
        
        :param (input):
        firstDimension first dimension (0,1,2) to examine.
        
        :param (input):
        lastDimension last dimension (0,1,2) to examine.
        
        :param (input):
        includeStartEnd true to force params 0 and 1 into the results.
        """
        ...
    
    def AddStrokes(self: MSPyBentleyGeom.BCurveSegment, points: List[DPoint3d], derivatives: List[DVec3d], params: MSPyBentleyGeom.DoubleArray, options: IFacetOptions, fractionA: float = 0.0, fractionB: float = 1.0, useWorkPoles: bool = False, curve: MSBsplineCurve = None) -> None:
        """
        Add strokes to point and param arrays.
        
        :param [in,out]:
        points receives points.
        
        :param [in,out]:
        params receives parameters.
        
        :param [in,out]:
        derivatives receives derivatives
        
        :param (input):
        options stroke controls
        
        :param (input):
        fractionA start fraction
        
        :param (input):
        fractionB end fraction
        
        :param (input):
        useWorkPoles true to stroke from work poles, false for primaries.
        
        :param (input):
        curve curve pointer (for use in parameter mapping, if indicated by
        facet options)
        """
        ...
    
    def BuildWorkPoles(self: MSPyBentleyGeom.BCurveSegment, transform: Transform) -> None:
        """
        Transform primary poles into work poles.
        """
        ...
    
    def CopyFrom(*args, **kwargs):
        """
        Overloaded function.
        
        1. CopyFrom(self: MSPyBentleyGeom.BCurveSegment, source: MSPyBentleyGeom.BCurveSegment, matrix: DMatrix4d = None) -> None
        
        Copy from{source} and apply a 4d (perspective) matrix.
        
        2. CopyFrom(self: MSPyBentleyGeom.BCurveSegment, source: MSPyBentleyGeom.BCurveSegment, matrix: RotMatrix) -> None
        
        Copy from{source} and apply a 4d (perspective) matrix.
        
        3. CopyFrom(self: MSPyBentleyGeom.BCurveSegment, source: MSPyBentleyGeom.BCurveSegment, matrix: Transform) -> None
        
        Copy from{source} and apply a 4d (perspective) matrix.
        """
        ...
    
    def FractionToKnot(self: MSPyBentleyGeom.BCurveSegment, f: float) -> float:
        """
        Return the knot value at a fractional parameter
        """
        ...
    
    def FractionToPoint(*args, **kwargs):
        """
        Overloaded function.
        
        1. FractionToPoint(self: MSPyBentleyGeom.BCurveSegment, xyz: DPoint3d, f: float) -> None
        
        Evalute the point at given fraction
        
        2. FractionToPoint(self: MSPyBentleyGeom.BCurveSegment, f: float) -> DPoint3d
        
        Evalute the point at given fraction
        
        3. FractionToPoint(self: MSPyBentleyGeom.BCurveSegment, xyz: DPoint3d, tangent: DVec3d, f: float, applyKnotScale: bool = True) -> None
        
        Evalute the point at given fraction
        """
        ...
    
    def GetKnotP(*args, **kwargs):
        """
        Overloaded function.
        
        1. GetKnotP(self: MSPyBentleyGeom.BCurveSegment, index: int) -> float
        
        Get a pointer to an indexed knot.
        
        2. GetKnotP(self: MSPyBentleyGeom.BCurveSegment) -> float
        
        Get a pointer to an indexed knot.
        """
        ...
    
    def GetNumKnots(self: MSPyBentleyGeom.BCurveSegment) -> int:
        """
        Return knot count
        """
        ...
    
    def GetOrder(self: MSPyBentleyGeom.BCurveSegment) -> int:
        """
        Return pole count.
        """
        ...
    
    def GetPoleP(*args, **kwargs):
        """
        Overloaded function.
        
        1. GetPoleP(self: MSPyBentleyGeom.BCurveSegment, index: int) -> DPoint4d
        
        Return (interior) pointer to indexed pole.
        
        2. GetPoleP(self: MSPyBentleyGeom.BCurveSegment) -> DPoint4d
        
        Return (interior) pointer to indexed pole.
        """
        ...
    
    def GetWorkPoleP(self: MSPyBentleyGeom.BCurveSegment, index: int) -> DPoint4d:
        """
        Return a work pole by index.
        """
        ...
    
    def Index(self: MSPyBentleyGeom.BCurveSegment) -> int:
        """
        Index (from start) in parent bspline
        """
        ...
    
    def IsNullU(self: MSPyBentleyGeom.BCurveSegment) -> bool:
        """
        return true if the bezier (just extracted from bspline) has zero-
        length knot interval.
        """
        ...
    
    def IsRational(self: MSPyBentleyGeom.BCurveSegment, useWorkPoles: bool = False) -> bool:
        """
        Query if the bezier has weighted control points. Optionally inspect
        the work poles rather than the primaries.
        """
        ...
    
    def KnotRange(self: MSPyBentleyGeom.BCurveSegment) -> DRange1d:
        """
        Return uMin,uMax packaged as DRange1d....
        """
        ...
    
    def Length(*args, **kwargs):
        """
        Overloaded function.
        
        1. Length(self: MSPyBentleyGeom.BCurveSegment, fraction0: float, fraction1: float) -> float
        
        Compute length between fractions
        
        2. Length(self: MSPyBentleyGeom.BCurveSegment, worldToLocal: RotMatrix, fraction0: float, fraction1: float) -> float
        
        Compute length between fractions
        """
        ...
    
    def Multiply(self: MSPyBentleyGeom.BCurveSegment, transform: Transform) -> None:
        """
        Transform primary poles
        """
        ...
    
    @property
    def NumKnots(arg0: MSPyBentleyGeom.BCurveSegment) -> int:
        ...
    
    @property
    def Order(arg0: MSPyBentleyGeom.BCurveSegment) -> int:
        ...
    
    def PolygonLength(self: MSPyBentleyGeom.BCurveSegment) -> float:
        """
        Compute polygon length
        """
        ...
    
    @staticmethod
    def RefineCloseApproach(curveA: MSPyBentleyGeom.BCurveSegment, fractionAin: float, curveB: MSPyBentleyGeom.BCurveSegment, fractionBin: float, useWorkPoles: bool, xyOnly: bool) -> tuple:
        """
        Run newton iteration to move frctions to closest approach points.
        return true if iteration succeeeded.
        
        :param (input):
        curveA first curve
        
        :param (input):
        fractionAin initial fraction on curveA
        
        :param (input):
        curveB second curve
        
        :param (input):
        fractionBin initial fraction on curveB
        
        :param (input):
        useWorkPoles true to iterate with the work poles, false for
        primaries
        
        :param (input):
        xyOnly true to iterate on xy parts, false for xyz
        
        :param (output):
        fractionAOut fraction on curveA
        
        :param (output):
        xyzAOut point on curveA
        
        :param (output):
        fractionBOut fraction on curveB
        
        :param (output):
        xyzBOut point on curveB
        """
        ...
    
    def SaturateKnots(self: MSPyBentleyGeom.BCurveSegment) -> None:
        """
        On input, knots are arbitrary sorted sequence, with{order-1} leading
        knots. On output, knots are collapsed to bezier.
        """
        ...
    
    def SetUMax(self: MSPyBentleyGeom.BCurveSegment, u: float) -> None:
        """
        Set upper knot in parent bspline
        """
        ...
    
    def SetUMin(self: MSPyBentleyGeom.BCurveSegment, u: float) -> None:
        """
        Set lower knot in parent bspline
        """
        ...
    
    def SubdivideToIntersection(self: MSPyBentleyGeom.BCurveSegment, interval: DRange1d) -> bool:
        """
        Find the intersection of the segment UMin, UMax and the given
        interval. If empty, return false. If not empty,
        """
        ...
    
    def TryGetPoleXYZ(self: MSPyBentleyGeom.BCurveSegment, index: int, xyz: DPoint3d) -> bool:
        """
        derference a pole, and drop to xyz.
        """
        ...
    
    def UMax(self: MSPyBentleyGeom.BCurveSegment) -> float:
        """
        Upper knot in parent bspline
        """
        ...
    
    def UMin(self: MSPyBentleyGeom.BCurveSegment) -> float:
        """
        Lower knot in parent bspline
        """
        ...
    
    def WireCentroid(self: MSPyBentleyGeom.BCurveSegment, centroid: DPoint3d, fraction0: float, fraction1: float) -> float:
        """
        Compute length and centroid of curve as wire.
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.BCurveSegment) -> None:
        ...
    
BSCURVE_CIRCLE: int

BSCURVE_CIRCULAR_ARC: int

BSCURVE_ELLIPSE: int

BSCURVE_ELLIPTICAL_ARC: int

BSCURVE_GENERAL: int

BSCURVE_HYPERBOLIC_ARC: int

BSCURVE_LINE: int

BSCURVE_PARABOLIC_ARC: int

class BSIIncrementalVectorIntegrand:
    """
    None
    """

    def AnnounceIntermediateIntegral(self: MSPyBentleyGeom.BSIIncrementalVectorIntegrand, t: float, pIntegrals: MSPyBentleyGeom.DoubleArray) -> bool:
        ...
    
    def EvaluateVectorIntegrand(self: MSPyBentleyGeom.BSIVectorIntegrand, t: float, pF: MSPyBentleyGeom.DoubleArray) -> None:
        ...
    
    def VectorIntegrandCount(self: MSPyBentleyGeom.BSIVectorIntegrand) -> int:
        ...
    
    def __init__(self: MSPyBentleyGeom.BSIIncrementalVectorIntegrand) -> None:
        ...
    
class BSIQuadraturePoints:
    """
    None
    """

    def AccumulateWeightedSums(self: MSPyBentleyGeom.BSIQuadraturePoints, function: MSPyBentleyGeom.BSIVectorIntegrand, t0: float, t1: float, pSums: MSPyBentleyGeom.DoubleArray, numInterval: int) -> None:
        """
        @description Evaluate and accumulate function values over an interval.
        
        :param (input):
        function function object that can be called as often as needed.
        
        :param (input):
        t0 start of interval.
        
        :param (input):
        t1 end of interval.
        
        :param [in,out]:
        pSums accumulating sums.
        
        :param (input):
        numInterval number of intervals to use within t0..t1.
        """
        ...
    
    @property
    def ConvergencePower(arg0: MSPyBentleyGeom.BSIQuadraturePoints) -> float:
        ...
    
    def GetConvergencePower(self: MSPyBentleyGeom.BSIQuadraturePoints) -> float:
        """
        @description Return the exponent for the convergence rate of the rule.
        """
        ...
    
    def GetEval(self: MSPyBentleyGeom.BSIQuadraturePoints, i: int, a0: float, a1: float) -> tuple:
        """
        @description Get the coordinate a weight of the i'th quadrature point,
        mapped to interval a0..a1
        
        :param (input):
        i index of evaluation point.
        
        :param (input):
        a0 start of mapped interval.
        
        :param (input):
        a1 end of mapped interval.
        
        :param (output):
        a evaluation coordinate.
        
        :param (output):
        w weight. Both the local quadrature weight and the interval length
        are incorporated in the returned weight.
        
        :returns:
        false if index is out of range.
        """
        ...
    
    def GetNumEval(self: MSPyBentleyGeom.BSIQuadraturePoints) -> int:
        """
        @description Return the number of points in the quadrature rule.
        """
        ...
    
    @staticmethod
    def GetXYEval(xRule: MSPyBentleyGeom.BSIQuadraturePoints, ix: int, x0: float, x1: float, yRule: MSPyBentleyGeom.BSIQuadraturePoints, iy: int, y0: float, y1: float) -> tuple:
        """
        Get the coordinates and weight of quarature point (i,j) in a 2D
        rectangular domain with specified quadrature for each direction.
        
        :param (input):
        xRule x direction quadrature rule
        
        :param (input):
        ix point index in x rule.
        
        :param (input):
        x0 started of x mapped interval
        
        :param (input):
        x1 end of x mapped interval
        
        :param (input):
        yRule y direction quadrature rule.
        
        :param (input):
        iy point index in y rule.
        
        :param (input):
        y0 start of y mapped interval
        
        :param (input):
        y1 end of y mapped interval
        
        :param (output):
        x x coordinate to evaluate.
        
        :param (output):
        y y coordinate to evaluate.
        
        :param (output):
        w weight for sums
        """
        ...
    
    def InitGauss(self: MSPyBentleyGeom.BSIQuadraturePoints, numEval: int) -> int:
        """
        @description Setup for a " Gaussian " quadrature.
        
        :param (input):
        numEval requested number of points.
        
        :returns:
        Number of points actually to be used. max is 5
        """
        ...
    
    def InitGaussKronrod(self: MSPyBentleyGeom.BSIQuadraturePoints, numEval: int, gaussPartner: MSPyBentleyGeom.BSIQuadraturePoints) -> int:
        """
        @description Setup for a " Kronrod " part of Gauss-Kronrad quadrature.
        The simple Gauss x values appear (in order) at the odd positions of
        the Kronrod rule.
        
        :param numEval:
        (input) requested number of points. ONLY 7 IS SUPPORTED
        
        :param gaussPartner:
        (input) corresponding simple Gauss rule.
        
        :returns:
        Number of points actually to be used.
        """
        ...
    
    def InitGaussLobatto(self: MSPyBentleyGeom.BSIQuadraturePoints, numEval: int) -> int:
        """
        @description Setup for " Gauss - Lobatto " quadrature. This uses endpoints
        plus gauss-like interior points.
        
        :param (input):
        numEval requested number of points.
        
        Remark:
        s numEval may be 3, 4, and 5.
        
        Remark:
        s numEval == 3 is the same as " Simpson "
        """
        ...
    
    def InitUniform(self: MSPyBentleyGeom.BSIQuadraturePoints, numEval: int) -> int:
        """
        @description Setup for a " Newton - Cotes " regularly spaced quadrature.
        
        Remark:
        Gaussian quadrature points are usually more effective. numEval ==
        1 is " rectangle rule " numEval == 2 is " trapezoid rule " numEval ==
        3 is " Simpson s rule "
        
        :param (input):
        numEval requested number of points.
        
        :returns:
        Number of points actually to be used. max is 4
        """
        ...
    
    def IntegrateWithRombergExtrapolation(self: MSPyBentleyGeom.BSIQuadraturePoints, function: MSPyBentleyGeom.BSIIncrementalVectorIntegrand, t0: float, t1: float, numInterval: int) -> tuple:
        """
        @description Integrate over an interval.
        
        * In each interval, form gauss sums with one and then two
        subintervals.
        
        * Apply 1 step Romberg (Richardson) extrapolation.
        
        * Accept the extrapolation as that interval's contribution.
        
        * Accumulate the max extrapolation as error bound.
        
        * The ongoing integration at the end of each interval,
        
        * exit if the announcement function returns false
        
        * The caller is can capture sums as announced
        
        :param (input):
        function function object that can be called as often as needed.
        
        :param (input):
        t0 start of interval.
        
        :param (input):
        t1 end of interval.
        
        :param (input):
        numInterval number of intervals to use within t0..t1.
        
        :param (output):
        totalErrorBound
        
        :returns:
        false if function.AnnounceIntermediateIntergral () returned false.
        Bentley Systems +---------------+---------------+---------------+-
        --------------+------
        """
        ...
    
    @property
    def NumEval(arg0: MSPyBentleyGeom.BSIQuadraturePoints) -> int:
        ...
    
    def __init__(self: MSPyBentleyGeom.BSIQuadraturePoints) -> None:
        ...
    
class BSITriangleQuadraturePoints:
    """
    None
    """

    def AccumulateWeightedSums(self: MSPyBentleyGeom.BSITriangleQuadraturePoints, arg0: MSPyBentleyGeom.BSIVectorIntegrandXY, arg1: MSPyBentleyGeom.DoubleArray) -> None:
        ...
    
    def AccumulateWeightedSumsMapped(self: MSPyBentleyGeom.BSITriangleQuadraturePoints, arg0: MSPyBentleyGeom.BSIVectorIntegrandXY, arg1: MSPyBentleyGeom.DoubleArray, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float) -> None:
        ...
    
    def GetEval(self: MSPyBentleyGeom.BSITriangleQuadraturePoints, i: int) -> tuple:
        """
        @description Get the coordinates and weight of the i'th quadrature
        point
        
        :param (input):
        i index of evaluation point.
        
        :param (output):
        u evaluation coordinate.
        
        :param (output):
        v evaluation coordinate.
        
        :param (output):
        w weight.
        
        :returns:
        false if index is out of range.
        """
        ...
    
    def GetNumEval(self: MSPyBentleyGeom.BSITriangleQuadraturePoints) -> int:
        """
        @description Return the number of points in the quadrature rule.
        """
        ...
    
    def InitStrang(self: MSPyBentleyGeom.BSITriangleQuadraturePoints, selector: int) -> int:
        """
        @description Setup for a " Strang " rule as defined in http://people.sc.
        fsu.edu/~jburkardt/datasets/quadrature_rules_tri/quadrature_rules_tri.
        html
        
        :param (input):
        selector rule selector.
        
        Remark:
        s; Selectors are:(1 --- centroid; exact degree 1) (2 --- 3
        midsides; exact degree 2) (3 --- centroid and one towards each
        vertex; exact degree 3) (4 --- 6 points, vertices and midsides of
        an inset triangle; exact degree 3) (5 --- 6 points, 2 inset from
        each edge; exact degree 4) (6 --- 7 points, centroid and 2 insets
        from each edge -- insets equally weighted; exact degree 4) (7 ---
        7 points, centroid, one towards each vertex, one towards each
        edge; exact degree 5) (8 --- 9 points; exact degree 6) (9 --- 12
        points; exact degree 6) (10 --- 13 points -- negative weight at
        centroid; exact degree 7)
        """
        ...
    
    @property
    def NumEval(arg0: MSPyBentleyGeom.BSITriangleQuadraturePoints) -> int:
        ...
    
    def __init__(self: MSPyBentleyGeom.BSITriangleQuadraturePoints) -> None:
        ...
    
class BSIVectorIntegrand:
    """
    None
    """

    def EvaluateVectorIntegrand(self: MSPyBentleyGeom.BSIVectorIntegrand, t: float, pF: MSPyBentleyGeom.DoubleArray) -> None:
        ...
    
    def VectorIntegrandCount(self: MSPyBentleyGeom.BSIVectorIntegrand) -> int:
        ...
    
    def __init__(self: MSPyBentleyGeom.BSIVectorIntegrand) -> None:
        ...
    
class BSIVectorIntegrandXY:
    """
    None
    """

    def EvaluateVectorIntegrand(self: MSPyBentleyGeom.BSIVectorIntegrandXY, x: float, y: float, pF: MSPyBentleyGeom.DoubleArray) -> None:
        ...
    
    def VectorIntegrandCount(self: MSPyBentleyGeom.BSIVectorIntegrandXY) -> int:
        ...
    
    def __init__(self: MSPyBentleyGeom.BSIVectorIntegrandXY) -> None:
        ...
    
BSSURF_CONE: int

BSSURF_GENERAL: int

BSSURF_PLANE: int

BSSURF_REVOLUTION: int

BSSURF_RIGHT_CYLINDER: int

BSSURF_RULED_SURFACE: int

BSSURF_SPHERE: int

BSSURF_TAB_CYLINDER: int

BSSURF_TORUS: int

BSSURF_U: int

BSSURF_V: int

class BeExtendedData:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.BeExtendedData) -> None
        
        2. __init__(self: MSPyBentleyGeom.BeExtendedData, arg0: MSPyBentleyGeom.BeExtendedData) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.BeExtendedData, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.BeExtendedData, x: MSPyBentleyGeom.BeExtendedDataEntry) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.BeExtendedData) -> None:
        """
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.BeExtendedData, L: MSPyBentleyGeom.BeExtendedData) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.BeExtendedData, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.BeExtendedData, i: int, x: MSPyBentleyGeom.BeExtendedDataEntry) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.BeExtendedData) -> MSPyBentleyGeom.BeExtendedDataEntry
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.BeExtendedData, i: int) -> MSPyBentleyGeom.BeExtendedDataEntry
        
        Remove and return the item at index ``i``
        """
        ...
    
class BeExtendedDataEntry:
    """
    None
    """

    @property
    def Key(self: MSPyBentleyGeom.BeExtendedDataEntry) -> MSPyBentley.Utf8String:
        ...
    @Key.setter
    def Key(self: MSPyBentleyGeom.BeExtendedDataEntry, arg0: MSPyBentley.Utf8String) -> None:
        ...
    
    @property
    def Type(self: MSPyBentleyGeom.BeExtendedDataEntry) -> MSPyBentley.Utf8String:
        ...
    @Type.setter
    def Type(self: MSPyBentleyGeom.BeExtendedDataEntry, arg0: MSPyBentley.Utf8String) -> None:
        ...
    
    @property
    def Value(self: MSPyBentleyGeom.BeExtendedDataEntry) -> MSPyBentley.Utf8String:
        ...
    @Value.setter
    def Value(self: MSPyBentleyGeom.BeExtendedDataEntry, arg0: MSPyBentley.Utf8String) -> None:
        ...
    
    def __init__(self: MSPyBentleyGeom.BeExtendedDataEntry) -> None:
        ...
    
class BeExtendedDataGeometryMap:
    """
    None
    """

    def __init__(self: MSPyBentleyGeom.BeExtendedDataGeometryMap) -> None:
        ...
    
    def items(self: MSPyBentleyGeom.BeExtendedDataGeometryMap) -> MSPyBentleyGeom.ItemsView[BeExtendedDataGeometryMap]:
        ...
    
    def keys(self: MSPyBentleyGeom.BeExtendedDataGeometryMap) -> MSPyBentleyGeom.KeysView[BeExtendedDataGeometryMap]:
        ...
    
    def values(self: MSPyBentleyGeom.BeExtendedDataGeometryMap) -> MSPyBentleyGeom.ValuesView[BeExtendedDataGeometryMap]:
        ...
    
class BeXmlCGStreamReader:
    """
    None
    """

    @staticmethod
    def TryParse(*args, **kwargs):
        """
        Overloaded function.
        
        1. TryParse(beXmlCGString: str, geometry: MSPyBentleyGeom.IGeometryPtrArray, extendedData: MSPyBentleyGeom.BeExtendedDataGeometryMap, maxDepth: int = 2147483647) -> bool
        
        2. TryParse(buffer: MSPyBentleyGeom.UInt8Array, geometry: MSPyBentleyGeom.IGeometryPtrArray, extendedData: MSPyBentleyGeom.BeExtendedDataGeometryMap, maxDepth: int = 2147483647) -> bool
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    
class BeXmlCGWriter:
    """
    None
    """

    @staticmethod
    def Write(data: MSPyBentleyGeom.IGeometry, extendedData: MSPyBentleyGeom.BeExtendedDataGeometryMap = 0, preferCGSweeps: bool = False) -> MSPyBentley.Utf8String:
        ...
    
    @staticmethod
    def WriteBytes(byte: MSPyBentleyGeom.UInt8Array, data: MSPyBentleyGeom.IGeometry, extendedData: MSPyBentleyGeom.BeExtendedDataGeometryMap = 0, preferCGSweeps: bool = False) -> None:
        ...
    
    def __init__(*args, **kwargs):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    
class BlendDetail:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    
    @property
    def detailA(self: MSPyBentleyGeom.BlendDetail) -> MSPyBentleyGeom.CurveLocationDetail:
        ...
    @detailA.setter
    def detailA(self: MSPyBentleyGeom.BlendDetail, arg0: MSPyBentleyGeom.CurveLocationDetail) -> None:
        ...
    
    @property
    def detailB(self: MSPyBentleyGeom.BlendDetail) -> MSPyBentleyGeom.CurveLocationDetail:
        ...
    @detailB.setter
    def detailB(self: MSPyBentleyGeom.BlendDetail, arg0: MSPyBentleyGeom.CurveLocationDetail) -> None:
        ...
    
    @property
    def geometry(self: MSPyBentleyGeom.BlendDetail) -> ICurvePrimitive:
        ...
    @geometry.setter
    def geometry(self: MSPyBentleyGeom.BlendDetail, arg0: ICurvePrimitive) -> None:
        ...
    
class BlendDetailArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.BlendDetailArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.BlendDetailArray, arg0: MSPyBentleyGeom.BlendDetailArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.BlendDetailArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.BlendDetailArray, x: MSPyBentleyGeom.BlendDetail) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.BlendDetailArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.BlendDetailArray, L: MSPyBentleyGeom.BlendDetailArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.BlendDetailArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.BlendDetailArray, i: int, x: MSPyBentleyGeom.BlendDetail) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.BlendDetailArray) -> MSPyBentleyGeom.BlendDetail
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.BlendDetailArray, i: int) -> MSPyBentleyGeom.BlendDetail
        
        Remove and return the item at index ``i``
        """
        ...
    
class BlendType:
    """
    Members:
    
    eCURVE_CURVE_BLEND_BisectorParabola
    
    eCURVE_CURVE_BLEND_VerticalAxisParabola
    """

    def __init__(self: MSPyBentleyGeom.BlendType, value: int) -> None:
        ...
    
    eCURVE_CURVE_BLEND_BisectorParabola: BlendType
    
    eCURVE_CURVE_BLEND_VerticalAxisParabola: BlendType
    
    @property
    def name(self: handle) -> str:
        ...
    
    @property
    def value(arg0: MSPyBentleyGeom.BlendType) -> int:
        ...
    
class BlockedVectorCurveTopologyId:
    """
    None
    """

    @property
    def Active(arg0: MSPyBentleyGeom.BlockedVectorCurveTopologyId) -> bool:
        ...
    @Active.setter
    def Active(arg0: MSPyBentleyGeom.BlockedVectorCurveTopologyId, arg1: bool) -> None:
        ...
    
    def Append(*args, **kwargs):
        """
        Overloaded function.
        
        1. Append(self: MSPyBentleyGeom.BlockedVectorCurveTopologyId, pBuffer: MSPyBentleyGeom.CurveTopologyId, count: int) -> int
        
        2. Append(self: MSPyBentleyGeom.BlockedVectorCurveTopologyId, source: MSPyBentleyGeom.BlockedVectorCurveTopologyId) -> int
        
        3. Append(self: MSPyBentleyGeom.BlockedVectorCurveTopologyId, source: MSPyBentleyGeom.CurveTopologyId) -> int
        """
        ...
    
    def AppendAndReturnIndex(self: MSPyBentleyGeom.BlockedVectorCurveTopologyId, source: MSPyBentleyGeom.CurveTopologyId) -> int:
        ...
    
    def ClearAndAppend(self: MSPyBentleyGeom.BlockedVectorCurveTopologyId, source: MSPyBentleyGeom.CurveTopologyIdArray) -> None:
        ...
    
    def ClearAndAppendBlock(*args, **kwargs):
        """
        Overloaded function.
        
        1. ClearAndAppendBlock(self: MSPyBentleyGeom.BlockedVectorCurveTopologyId, source: MSPyBentleyGeom.BlockedVectorCurveTopologyId, i0: int, numWrap: int, n: int) -> int
        
        2. ClearAndAppendBlock(self: MSPyBentleyGeom.BlockedVectorCurveTopologyId, source: MSPyBentleyGeom.CurveTopologyId, sourceSize: int, i0: int, numWrap: int, n: int) -> int
        """
        ...
    
    def CopyData(self: MSPyBentleyGeom.BlockedVectorCurveTopologyId, fromIndex: int, toIndex: int) -> None:
        ...
    
    def CopyVectorFrom(self: MSPyBentleyGeom.BlockedVectorCurveTopologyId, source: MSPyBentleyGeom.CurveTopologyIdArray) -> None:
        ...
    
    def GetCP(self: MSPyBentleyGeom.BlockedVectorCurveTopologyId) -> MSPyBentleyGeom.CurveTopologyId:
        ...
    
    def GetPtr(self: MSPyBentleyGeom.BlockedVectorCurveTopologyId) -> MSPyBentleyGeom.CurveTopologyId:
        ...
    
    @property
    def IndexFamily(arg0: MSPyBentleyGeom.BlockedVectorCurveTopologyId) -> int:
        ...
    
    @property
    def IndexedBy(arg0: MSPyBentleyGeom.BlockedVectorCurveTopologyId) -> int:
        ...
    
    def NumCompleteRows(self: MSPyBentleyGeom.BlockedVectorCurveTopologyId) -> int:
        ...
    
    @property
    def NumPerStruct(arg0: MSPyBentleyGeom.BlockedVectorCurveTopologyId) -> int:
        ...
    
    def ReverseInRange(self: MSPyBentleyGeom.BlockedVectorCurveTopologyId, iFirst: int, iLast: int) -> None:
        ...
    
    def SetTags(self: MSPyBentleyGeom.BlockedVectorCurveTopologyId, numPeStruct: int, structsPerRow: int, tag: int, IndexFamily: int, IndexedBy: int, active: bool) -> None:
        ...
    
    @property
    def StructsPerRow(arg0: MSPyBentleyGeom.BlockedVectorCurveTopologyId) -> int:
        ...
    @StructsPerRow.setter
    def StructsPerRow(arg0: MSPyBentleyGeom.BlockedVectorCurveTopologyId, arg1: int) -> None:
        ...
    
    @property
    def Tag(arg0: MSPyBentleyGeom.BlockedVectorCurveTopologyId) -> int:
        ...
    
    def Trim(self: MSPyBentleyGeom.BlockedVectorCurveTopologyId, index0: int, count: int) -> None:
        ...
    
    def TryGet(self: MSPyBentleyGeom.BlockedVectorCurveTopologyId, index: int, defaultValue: MSPyBentleyGeom.CurveTopologyId) -> Tuple[bool, MSPyBentleyGeom.CurveTopologyId]:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.BlockedVectorCurveTopologyId) -> None
        
        2. __init__(self: MSPyBentleyGeom.BlockedVectorCurveTopologyId, numPerStruct: int, structsPerRow: int = 0, tag: int = 0, indexFamily: int = 0, indexBy: int = 0, active: bool = False) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.CurveTopologyIdArray, x: MSPyBentleyGeom.CurveTopologyId) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.CurveTopologyIdArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def count(self: MSPyBentleyGeom.CurveTopologyIdArray, x: MSPyBentleyGeom.CurveTopologyId) -> int:
        """
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.CurveTopologyIdArray, L: MSPyBentleyGeom.CurveTopologyIdArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.CurveTopologyIdArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.CurveTopologyIdArray, i: int, x: MSPyBentleyGeom.CurveTopologyId) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.CurveTopologyIdArray) -> MSPyBentleyGeom.CurveTopologyId
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.CurveTopologyIdArray, i: int) -> MSPyBentleyGeom.CurveTopologyId
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(self: MSPyBentleyGeom.CurveTopologyIdArray, x: MSPyBentleyGeom.CurveTopologyId) -> None:
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class BlockedVectorDPoint2d:
    """
    None
    """

    @property
    def Active(arg0: MSPyBentleyGeom.BlockedVectorDPoint2d) -> bool:
        ...
    @Active.setter
    def Active(arg0: MSPyBentleyGeom.BlockedVectorDPoint2d, arg1: bool) -> None:
        ...
    
    def Append(*args, **kwargs):
        """
        Overloaded function.
        
        1. Append(self: MSPyBentleyGeom.BlockedVectorDPoint2d, pBuffer: MSPyBentleyGeom.DPoint2d, count: int) -> int
        
        2. Append(self: MSPyBentleyGeom.BlockedVectorDPoint2d, source: MSPyBentleyGeom.BlockedVectorDPoint2d) -> int
        
        3. Append(self: MSPyBentleyGeom.BlockedVectorDPoint2d, source: MSPyBentleyGeom.DPoint2d) -> int
        """
        ...
    
    def AppendAndReturnIndex(self: MSPyBentleyGeom.BlockedVectorDPoint2d, source: MSPyBentleyGeom.DPoint2d) -> int:
        ...
    
    def ClearAndAppend(self: MSPyBentleyGeom.BlockedVectorDPoint2d, source: MSPyBentleyGeom.DPoint2dArray) -> None:
        ...
    
    def ClearAndAppendBlock(*args, **kwargs):
        """
        Overloaded function.
        
        1. ClearAndAppendBlock(self: MSPyBentleyGeom.BlockedVectorDPoint2d, source: MSPyBentleyGeom.BlockedVectorDPoint2d, i0: int, numWrap: int, n: int) -> int
        
        2. ClearAndAppendBlock(self: MSPyBentleyGeom.BlockedVectorDPoint2d, source: MSPyBentleyGeom.DPoint2d, sourceSize: int, i0: int, numWrap: int, n: int) -> int
        """
        ...
    
    def CopyData(self: MSPyBentleyGeom.BlockedVectorDPoint2d, fromIndex: int, toIndex: int) -> None:
        ...
    
    def CopyVectorFrom(self: MSPyBentleyGeom.BlockedVectorDPoint2d, source: MSPyBentleyGeom.DPoint2dArray) -> None:
        ...
    
    def GetCP(self: MSPyBentleyGeom.BlockedVectorDPoint2d) -> MSPyBentleyGeom.DPoint2d:
        ...
    
    def GetPtr(self: MSPyBentleyGeom.BlockedVectorDPoint2d) -> MSPyBentleyGeom.DPoint2d:
        ...
    
    @property
    def IndexFamily(arg0: MSPyBentleyGeom.BlockedVectorDPoint2d) -> int:
        ...
    
    @property
    def IndexedBy(arg0: MSPyBentleyGeom.BlockedVectorDPoint2d) -> int:
        ...
    
    def NumCompleteRows(self: MSPyBentleyGeom.BlockedVectorDPoint2d) -> int:
        ...
    
    @property
    def NumPerStruct(arg0: MSPyBentleyGeom.BlockedVectorDPoint2d) -> int:
        ...
    
    def ReverseInRange(self: MSPyBentleyGeom.BlockedVectorDPoint2d, iFirst: int, iLast: int) -> None:
        ...
    
    def SetTags(self: MSPyBentleyGeom.BlockedVectorDPoint2d, numPeStruct: int, structsPerRow: int, tag: int, IndexFamily: int, IndexedBy: int, active: bool) -> None:
        ...
    
    @property
    def StructsPerRow(arg0: MSPyBentleyGeom.BlockedVectorDPoint2d) -> int:
        ...
    @StructsPerRow.setter
    def StructsPerRow(arg0: MSPyBentleyGeom.BlockedVectorDPoint2d, arg1: int) -> None:
        ...
    
    @property
    def Tag(arg0: MSPyBentleyGeom.BlockedVectorDPoint2d) -> int:
        ...
    
    def Trim(self: MSPyBentleyGeom.BlockedVectorDPoint2d, index0: int, count: int) -> None:
        ...
    
    def TryGet(self: MSPyBentleyGeom.BlockedVectorDPoint2d, index: int, defaultValue: MSPyBentleyGeom.DPoint2d) -> Tuple[bool, MSPyBentleyGeom.DPoint2d]:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.BlockedVectorDPoint2d) -> None
        
        2. __init__(self: MSPyBentleyGeom.BlockedVectorDPoint2d, numPerStruct: int, structsPerRow: int = 0, tag: int = 0, indexFamily: int = 0, indexBy: int = 0, active: bool = False) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.DPoint2dArray, x: MSPyBentleyGeom.DPoint2d) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.DPoint2dArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def count(self: MSPyBentleyGeom.DPoint2dArray, x: MSPyBentleyGeom.DPoint2d) -> int:
        """
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.DPoint2dArray, L: MSPyBentleyGeom.DPoint2dArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.DPoint2dArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.DPoint2dArray, i: int, x: MSPyBentleyGeom.DPoint2d) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.DPoint2dArray) -> MSPyBentleyGeom.DPoint2d
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.DPoint2dArray, i: int) -> MSPyBentleyGeom.DPoint2d
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(self: MSPyBentleyGeom.DPoint2dArray, x: MSPyBentleyGeom.DPoint2d) -> None:
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class BlockedVectorDPoint3d:
    """
    None
    """

    @property
    def Active(arg0: MSPyBentleyGeom.BlockedVectorDPoint3d) -> bool:
        ...
    @Active.setter
    def Active(arg0: MSPyBentleyGeom.BlockedVectorDPoint3d, arg1: bool) -> None:
        ...
    
    def Append(*args, **kwargs):
        """
        Overloaded function.
        
        1. Append(self: MSPyBentleyGeom.BlockedVectorDPoint3d, pBuffer: MSPyBentleyGeom.DPoint3d, count: int) -> int
        
        2. Append(self: MSPyBentleyGeom.BlockedVectorDPoint3d, source: MSPyBentleyGeom.BlockedVectorDPoint3d) -> int
        
        3. Append(self: MSPyBentleyGeom.BlockedVectorDPoint3d, source: MSPyBentleyGeom.DPoint3d) -> int
        """
        ...
    
    def AppendAndReturnIndex(self: MSPyBentleyGeom.BlockedVectorDPoint3d, source: MSPyBentleyGeom.DPoint3d) -> int:
        ...
    
    def ClearAndAppend(self: MSPyBentleyGeom.BlockedVectorDPoint3d, source: MSPyBentleyGeom.DPoint3dArray) -> None:
        ...
    
    def ClearAndAppendBlock(*args, **kwargs):
        """
        Overloaded function.
        
        1. ClearAndAppendBlock(self: MSPyBentleyGeom.BlockedVectorDPoint3d, source: MSPyBentleyGeom.BlockedVectorDPoint3d, i0: int, numWrap: int, n: int) -> int
        
        2. ClearAndAppendBlock(self: MSPyBentleyGeom.BlockedVectorDPoint3d, source: MSPyBentleyGeom.DPoint3d, sourceSize: int, i0: int, numWrap: int, n: int) -> int
        """
        ...
    
    def CopyData(self: MSPyBentleyGeom.BlockedVectorDPoint3d, fromIndex: int, toIndex: int) -> None:
        ...
    
    def CopyVectorFrom(self: MSPyBentleyGeom.BlockedVectorDPoint3d, source: MSPyBentleyGeom.DPoint3dArray) -> None:
        ...
    
    def GetCP(self: MSPyBentleyGeom.BlockedVectorDPoint3d) -> MSPyBentleyGeom.DPoint3d:
        ...
    
    def GetPtr(self: MSPyBentleyGeom.BlockedVectorDPoint3d) -> MSPyBentleyGeom.DPoint3d:
        ...
    
    @property
    def IndexFamily(arg0: MSPyBentleyGeom.BlockedVectorDPoint3d) -> int:
        ...
    
    @property
    def IndexedBy(arg0: MSPyBentleyGeom.BlockedVectorDPoint3d) -> int:
        ...
    
    def NumCompleteRows(self: MSPyBentleyGeom.BlockedVectorDPoint3d) -> int:
        ...
    
    @property
    def NumPerStruct(arg0: MSPyBentleyGeom.BlockedVectorDPoint3d) -> int:
        ...
    
    def ReverseInRange(self: MSPyBentleyGeom.BlockedVectorDPoint3d, iFirst: int, iLast: int) -> None:
        ...
    
    def SetTags(self: MSPyBentleyGeom.BlockedVectorDPoint3d, numPeStruct: int, structsPerRow: int, tag: int, IndexFamily: int, IndexedBy: int, active: bool) -> None:
        ...
    
    @property
    def StructsPerRow(arg0: MSPyBentleyGeom.BlockedVectorDPoint3d) -> int:
        ...
    @StructsPerRow.setter
    def StructsPerRow(arg0: MSPyBentleyGeom.BlockedVectorDPoint3d, arg1: int) -> None:
        ...
    
    @property
    def Tag(arg0: MSPyBentleyGeom.BlockedVectorDPoint3d) -> int:
        ...
    
    def Trim(self: MSPyBentleyGeom.BlockedVectorDPoint3d, index0: int, count: int) -> None:
        ...
    
    def TryGet(self: MSPyBentleyGeom.BlockedVectorDPoint3d, index: int, defaultValue: MSPyBentleyGeom.DPoint3d) -> Tuple[bool, MSPyBentleyGeom.DPoint3d]:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.BlockedVectorDPoint3d) -> None
        
        2. __init__(self: MSPyBentleyGeom.BlockedVectorDPoint3d, numPerStruct: int, structsPerRow: int = 0, tag: int = 0, indexFamily: int = 0, indexBy: int = 0, active: bool = False) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.DPoint3dArray, x: MSPyBentleyGeom.DPoint3d) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.DPoint3dArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def count(self: MSPyBentleyGeom.DPoint3dArray, x: MSPyBentleyGeom.DPoint3d) -> int:
        """
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.DPoint3dArray, L: MSPyBentleyGeom.DPoint3dArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.DPoint3dArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.DPoint3dArray, i: int, x: MSPyBentleyGeom.DPoint3d) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.DPoint3dArray) -> MSPyBentleyGeom.DPoint3d
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.DPoint3dArray, i: int) -> MSPyBentleyGeom.DPoint3d
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(self: MSPyBentleyGeom.DPoint3dArray, x: MSPyBentleyGeom.DPoint3d) -> None:
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class BlockedVectorDVec3d:
    """
    None
    """

    @property
    def Active(arg0: MSPyBentleyGeom.BlockedVectorDVec3d) -> bool:
        ...
    @Active.setter
    def Active(arg0: MSPyBentleyGeom.BlockedVectorDVec3d, arg1: bool) -> None:
        ...
    
    def Append(*args, **kwargs):
        """
        Overloaded function.
        
        1. Append(self: MSPyBentleyGeom.BlockedVectorDVec3d, pBuffer: MSPyBentleyGeom.DVec3d, count: int) -> int
        
        2. Append(self: MSPyBentleyGeom.BlockedVectorDVec3d, source: MSPyBentleyGeom.BlockedVectorDVec3d) -> int
        
        3. Append(self: MSPyBentleyGeom.BlockedVectorDVec3d, source: MSPyBentleyGeom.DVec3d) -> int
        """
        ...
    
    def AppendAndReturnIndex(self: MSPyBentleyGeom.BlockedVectorDVec3d, source: MSPyBentleyGeom.DVec3d) -> int:
        ...
    
    def ClearAndAppend(self: MSPyBentleyGeom.BlockedVectorDVec3d, source: MSPyBentleyGeom.DVec3dArray) -> None:
        ...
    
    def ClearAndAppendBlock(*args, **kwargs):
        """
        Overloaded function.
        
        1. ClearAndAppendBlock(self: MSPyBentleyGeom.BlockedVectorDVec3d, source: MSPyBentleyGeom.BlockedVectorDVec3d, i0: int, numWrap: int, n: int) -> int
        
        2. ClearAndAppendBlock(self: MSPyBentleyGeom.BlockedVectorDVec3d, source: MSPyBentleyGeom.DVec3d, sourceSize: int, i0: int, numWrap: int, n: int) -> int
        """
        ...
    
    def CopyData(self: MSPyBentleyGeom.BlockedVectorDVec3d, fromIndex: int, toIndex: int) -> None:
        ...
    
    def CopyVectorFrom(self: MSPyBentleyGeom.BlockedVectorDVec3d, source: MSPyBentleyGeom.DVec3dArray) -> None:
        ...
    
    def GetCP(self: MSPyBentleyGeom.BlockedVectorDVec3d) -> MSPyBentleyGeom.DVec3d:
        ...
    
    def GetPtr(self: MSPyBentleyGeom.BlockedVectorDVec3d) -> MSPyBentleyGeom.DVec3d:
        ...
    
    @property
    def IndexFamily(arg0: MSPyBentleyGeom.BlockedVectorDVec3d) -> int:
        ...
    
    @property
    def IndexedBy(arg0: MSPyBentleyGeom.BlockedVectorDVec3d) -> int:
        ...
    
    def NumCompleteRows(self: MSPyBentleyGeom.BlockedVectorDVec3d) -> int:
        ...
    
    @property
    def NumPerStruct(arg0: MSPyBentleyGeom.BlockedVectorDVec3d) -> int:
        ...
    
    def ReverseInRange(self: MSPyBentleyGeom.BlockedVectorDVec3d, iFirst: int, iLast: int) -> None:
        ...
    
    def SetTags(self: MSPyBentleyGeom.BlockedVectorDVec3d, numPeStruct: int, structsPerRow: int, tag: int, IndexFamily: int, IndexedBy: int, active: bool) -> None:
        ...
    
    @property
    def StructsPerRow(arg0: MSPyBentleyGeom.BlockedVectorDVec3d) -> int:
        ...
    @StructsPerRow.setter
    def StructsPerRow(arg0: MSPyBentleyGeom.BlockedVectorDVec3d, arg1: int) -> None:
        ...
    
    @property
    def Tag(arg0: MSPyBentleyGeom.BlockedVectorDVec3d) -> int:
        ...
    
    def Trim(self: MSPyBentleyGeom.BlockedVectorDVec3d, index0: int, count: int) -> None:
        ...
    
    def TryGet(self: MSPyBentleyGeom.BlockedVectorDVec3d, index: int, defaultValue: MSPyBentleyGeom.DVec3d) -> Tuple[bool, MSPyBentleyGeom.DVec3d]:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.BlockedVectorDVec3d) -> None
        
        2. __init__(self: MSPyBentleyGeom.BlockedVectorDVec3d, numPerStruct: int, structsPerRow: int = 0, tag: int = 0, indexFamily: int = 0, indexBy: int = 0, active: bool = False) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.DVec3dArray, x: MSPyBentleyGeom.DVec3d) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.DVec3dArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def count(self: MSPyBentleyGeom.DVec3dArray, x: MSPyBentleyGeom.DVec3d) -> int:
        """
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.DVec3dArray, L: MSPyBentleyGeom.DVec3dArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.DVec3dArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.DVec3dArray, i: int, x: MSPyBentleyGeom.DVec3d) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.DVec3dArray) -> MSPyBentleyGeom.DVec3d
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.DVec3dArray, i: int) -> MSPyBentleyGeom.DVec3d
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(self: MSPyBentleyGeom.DVec3dArray, x: MSPyBentleyGeom.DVec3d) -> None:
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class BlockedVectorFacetFaceData:
    """
    None
    """

    @property
    def Active(arg0: MSPyBentleyGeom.BlockedVectorFacetFaceData) -> bool:
        ...
    @Active.setter
    def Active(arg0: MSPyBentleyGeom.BlockedVectorFacetFaceData, arg1: bool) -> None:
        ...
    
    def Append(*args, **kwargs):
        """
        Overloaded function.
        
        1. Append(self: MSPyBentleyGeom.BlockedVectorFacetFaceData, pBuffer: MSPyBentleyGeom.FacetFaceData, count: int) -> int
        
        2. Append(self: MSPyBentleyGeom.BlockedVectorFacetFaceData, source: MSPyBentleyGeom.BlockedVectorFacetFaceData) -> int
        
        3. Append(self: MSPyBentleyGeom.BlockedVectorFacetFaceData, source: MSPyBentleyGeom.FacetFaceData) -> int
        """
        ...
    
    def AppendAndReturnIndex(self: MSPyBentleyGeom.BlockedVectorFacetFaceData, source: MSPyBentleyGeom.FacetFaceData) -> int:
        ...
    
    def ClearAndAppend(self: MSPyBentleyGeom.BlockedVectorFacetFaceData, source: MSPyBentleyGeom.FacetFaceDataArray) -> None:
        ...
    
    def ClearAndAppendBlock(*args, **kwargs):
        """
        Overloaded function.
        
        1. ClearAndAppendBlock(self: MSPyBentleyGeom.BlockedVectorFacetFaceData, source: MSPyBentleyGeom.BlockedVectorFacetFaceData, i0: int, numWrap: int, n: int) -> int
        
        2. ClearAndAppendBlock(self: MSPyBentleyGeom.BlockedVectorFacetFaceData, source: MSPyBentleyGeom.FacetFaceData, sourceSize: int, i0: int, numWrap: int, n: int) -> int
        """
        ...
    
    def CopyData(self: MSPyBentleyGeom.BlockedVectorFacetFaceData, fromIndex: int, toIndex: int) -> None:
        ...
    
    def CopyVectorFrom(self: MSPyBentleyGeom.BlockedVectorFacetFaceData, source: MSPyBentleyGeom.FacetFaceDataArray) -> None:
        ...
    
    def GetCP(self: MSPyBentleyGeom.BlockedVectorFacetFaceData) -> MSPyBentleyGeom.FacetFaceData:
        ...
    
    def GetPtr(self: MSPyBentleyGeom.BlockedVectorFacetFaceData) -> MSPyBentleyGeom.FacetFaceData:
        ...
    
    @property
    def IndexFamily(arg0: MSPyBentleyGeom.BlockedVectorFacetFaceData) -> int:
        ...
    
    @property
    def IndexedBy(arg0: MSPyBentleyGeom.BlockedVectorFacetFaceData) -> int:
        ...
    
    def NumCompleteRows(self: MSPyBentleyGeom.BlockedVectorFacetFaceData) -> int:
        ...
    
    @property
    def NumPerStruct(arg0: MSPyBentleyGeom.BlockedVectorFacetFaceData) -> int:
        ...
    
    def ReverseInRange(self: MSPyBentleyGeom.BlockedVectorFacetFaceData, iFirst: int, iLast: int) -> None:
        ...
    
    def SetTags(self: MSPyBentleyGeom.BlockedVectorFacetFaceData, numPeStruct: int, structsPerRow: int, tag: int, IndexFamily: int, IndexedBy: int, active: bool) -> None:
        ...
    
    @property
    def StructsPerRow(arg0: MSPyBentleyGeom.BlockedVectorFacetFaceData) -> int:
        ...
    @StructsPerRow.setter
    def StructsPerRow(arg0: MSPyBentleyGeom.BlockedVectorFacetFaceData, arg1: int) -> None:
        ...
    
    @property
    def Tag(arg0: MSPyBentleyGeom.BlockedVectorFacetFaceData) -> int:
        ...
    
    def Trim(self: MSPyBentleyGeom.BlockedVectorFacetFaceData, index0: int, count: int) -> None:
        ...
    
    def TryGet(self: MSPyBentleyGeom.BlockedVectorFacetFaceData, index: int, defaultValue: MSPyBentleyGeom.FacetFaceData) -> Tuple[bool, MSPyBentleyGeom.FacetFaceData]:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.BlockedVectorFacetFaceData) -> None
        
        2. __init__(self: MSPyBentleyGeom.BlockedVectorFacetFaceData, numPerStruct: int, structsPerRow: int = 0, tag: int = 0, indexFamily: int = 0, indexBy: int = 0, active: bool = False) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.FacetFaceDataArray, x: MSPyBentleyGeom.FacetFaceData) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.FacetFaceDataArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.FacetFaceDataArray, L: MSPyBentleyGeom.FacetFaceDataArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.FacetFaceDataArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.FacetFaceDataArray, i: int, x: MSPyBentleyGeom.FacetFaceData) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.FacetFaceDataArray) -> MSPyBentleyGeom.FacetFaceData
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.FacetFaceDataArray, i: int) -> MSPyBentleyGeom.FacetFaceData
        
        Remove and return the item at index ``i``
        """
        ...
    
class BlockedVectorFloatRgb:
    """
    None
    """

    @property
    def Active(arg0: MSPyBentleyGeom.BlockedVectorFloatRgb) -> bool:
        ...
    @Active.setter
    def Active(arg0: MSPyBentleyGeom.BlockedVectorFloatRgb, arg1: bool) -> None:
        ...
    
    def Append(*args, **kwargs):
        """
        Overloaded function.
        
        1. Append(self: MSPyBentleyGeom.BlockedVectorFloatRgb, pBuffer: MSPyBentleyGeom.FloatRgb, count: int) -> int
        
        2. Append(self: MSPyBentleyGeom.BlockedVectorFloatRgb, source: MSPyBentleyGeom.BlockedVectorFloatRgb) -> int
        
        3. Append(self: MSPyBentleyGeom.BlockedVectorFloatRgb, source: MSPyBentleyGeom.FloatRgb) -> int
        """
        ...
    
    def AppendAndReturnIndex(self: MSPyBentleyGeom.BlockedVectorFloatRgb, source: MSPyBentleyGeom.FloatRgb) -> int:
        ...
    
    def ClearAndAppend(self: MSPyBentleyGeom.BlockedVectorFloatRgb, source: MSPyBentleyGeom.FloatRgbArray) -> None:
        ...
    
    def ClearAndAppendBlock(*args, **kwargs):
        """
        Overloaded function.
        
        1. ClearAndAppendBlock(self: MSPyBentleyGeom.BlockedVectorFloatRgb, source: MSPyBentleyGeom.BlockedVectorFloatRgb, i0: int, numWrap: int, n: int) -> int
        
        2. ClearAndAppendBlock(self: MSPyBentleyGeom.BlockedVectorFloatRgb, source: MSPyBentleyGeom.FloatRgb, sourceSize: int, i0: int, numWrap: int, n: int) -> int
        """
        ...
    
    def CopyData(self: MSPyBentleyGeom.BlockedVectorFloatRgb, fromIndex: int, toIndex: int) -> None:
        ...
    
    def CopyVectorFrom(self: MSPyBentleyGeom.BlockedVectorFloatRgb, source: MSPyBentleyGeom.FloatRgbArray) -> None:
        ...
    
    def GetCP(self: MSPyBentleyGeom.BlockedVectorFloatRgb) -> MSPyBentleyGeom.FloatRgb:
        ...
    
    def GetPtr(self: MSPyBentleyGeom.BlockedVectorFloatRgb) -> MSPyBentleyGeom.FloatRgb:
        ...
    
    @property
    def IndexFamily(arg0: MSPyBentleyGeom.BlockedVectorFloatRgb) -> int:
        ...
    
    @property
    def IndexedBy(arg0: MSPyBentleyGeom.BlockedVectorFloatRgb) -> int:
        ...
    
    def NumCompleteRows(self: MSPyBentleyGeom.BlockedVectorFloatRgb) -> int:
        ...
    
    @property
    def NumPerStruct(arg0: MSPyBentleyGeom.BlockedVectorFloatRgb) -> int:
        ...
    
    def ReverseInRange(self: MSPyBentleyGeom.BlockedVectorFloatRgb, iFirst: int, iLast: int) -> None:
        ...
    
    def SetTags(self: MSPyBentleyGeom.BlockedVectorFloatRgb, numPeStruct: int, structsPerRow: int, tag: int, IndexFamily: int, IndexedBy: int, active: bool) -> None:
        ...
    
    @property
    def StructsPerRow(arg0: MSPyBentleyGeom.BlockedVectorFloatRgb) -> int:
        ...
    @StructsPerRow.setter
    def StructsPerRow(arg0: MSPyBentleyGeom.BlockedVectorFloatRgb, arg1: int) -> None:
        ...
    
    @property
    def Tag(arg0: MSPyBentleyGeom.BlockedVectorFloatRgb) -> int:
        ...
    
    def Trim(self: MSPyBentleyGeom.BlockedVectorFloatRgb, index0: int, count: int) -> None:
        ...
    
    def TryGet(self: MSPyBentleyGeom.BlockedVectorFloatRgb, index: int, defaultValue: MSPyBentleyGeom.FloatRgb) -> Tuple[bool, MSPyBentleyGeom.FloatRgb]:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.BlockedVectorFloatRgb) -> None
        
        2. __init__(self: MSPyBentleyGeom.BlockedVectorFloatRgb, numPerStruct: int, structsPerRow: int = 0, tag: int = 0, indexFamily: int = 0, indexBy: int = 0, active: bool = False) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.FloatRgbArray, x: MSPyBentleyGeom.FloatRgb) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.FloatRgbArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.FloatRgbArray, L: MSPyBentleyGeom.FloatRgbArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.FloatRgbArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.FloatRgbArray, i: int, x: MSPyBentleyGeom.FloatRgb) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.FloatRgbArray) -> MSPyBentleyGeom.FloatRgb
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.FloatRgbArray, i: int) -> MSPyBentleyGeom.FloatRgb
        
        Remove and return the item at index ``i``
        """
        ...
    
class BlockedVectorInt:
    """
    None
    """

    def Abs(self: MSPyBentleyGeom.BlockedVectorInt) -> None:
        """
        Set each entry to its absolute value
        """
        ...
    
    def AbsInRange(self: MSPyBentleyGeom.BlockedVectorInt, iFirst: int, iLast: int) -> None:
        """
        for each k in the inclusive range kFirst<=k<=kLast, set the entry to
        its absolute value.
        """
        ...
    
    @property
    def Active(arg0: MSPyBentleyGeom.BlockedVectorIntT) -> bool:
        ...
    @Active.setter
    def Active(arg0: MSPyBentleyGeom.BlockedVectorIntT, arg1: bool) -> None:
        ...
    
    def AddAndTerminate(self: MSPyBentleyGeom.BlockedVectorInt, pValues: int, numValues: int) -> bool:
        """
        Add one row with terminator or pad.
        """
        ...
    
    def AddSequentialBlock(self: MSPyBentleyGeom.BlockedVectorInt, firstValue: int, numValue: int, numWrap: int, numTrailingZero: int = 0, clearFirst: bool = False) -> None:
        """
        Add one row with wraparound, optional terminator. NO ACTION if the
        array is not active !!!!
        """
        ...
    
    def AddSteppedBlock(self: MSPyBentleyGeom.BlockedVectorInt, fierstValue: int, valueStep: int, numValue: int, numWrap: int, numTrailingZero: int = 0, clearFirst: bool = False) -> None:
        """
        Add one row with wraparound, optional terminator. NO ACTION if the
        array is not active !!!!
        """
        ...
    
    def AddTerminatedGridBlocks(self: MSPyBentleyGeom.BlockedVectorInt, numRow: int, numPerRow: int, rowStep: int, colStep: int, triangulated: bool, clearFirst: bool, firstValue: int, terminator: int) -> None:
        """
        Create indices for a rectangular grid.
        """
        ...
    
    def AddTerminatedSequentialBlocks(self: MSPyBentleyGeom.BlockedVectorInt, numRow: int, numPerRow: int, clearFirst: bool = False, firstValue: int = 1, terminator: int = 0) -> None:
        """
        Add numRow blocks of numPerRow sequential values with terminator after
        each row.
        """
        ...
    
    def AllNegativeInRange(self: MSPyBentleyGeom.BlockedVectorInt, iFirst: int, iLast: int) -> bool:
        """
        return true if all entries in the inclusive range kFirst<=k<=kLast are
        negative.
        """
        ...
    
    def Append(*args, **kwargs):
        """
        Overloaded function.
        
        1. Append(self: MSPyBentleyGeom.BlockedVectorIntT, pBuffer: int, count: int) -> int
        
        2. Append(self: MSPyBentleyGeom.BlockedVectorIntT, source: MSPyBentleyGeom.BlockedVectorIntT) -> int
        
        3. Append(self: MSPyBentleyGeom.BlockedVectorIntT, source: int) -> int
        """
        ...
    
    def AppendAndReturnIndex(self: MSPyBentleyGeom.BlockedVectorIntT, source: int) -> int:
        ...
    
    def AppendShifted(self: MSPyBentleyGeom.BlockedVectorInt, source: MSPyBentleyGeom.BlockedVectorInt, shift: int) -> None:
        ...
    
    def ClearAndAppend(self: MSPyBentleyGeom.BlockedVectorIntT, source: MSPyBentleyGeom.Int32Array) -> None:
        ...
    
    def ClearAndAppendBlock(*args, **kwargs):
        """
        Overloaded function.
        
        1. ClearAndAppendBlock(self: MSPyBentleyGeom.BlockedVectorIntT, source: MSPyBentleyGeom.BlockedVectorIntT, i0: int, numWrap: int, n: int) -> int
        
        2. ClearAndAppendBlock(self: MSPyBentleyGeom.BlockedVectorIntT, source: int, sourceSize: int, i0: int, numWrap: int, n: int) -> int
        """
        ...
    
    def ConvertBlockedToZeroTerminated(self: MSPyBentleyGeom.BlockedVectorInt) -> None:
        """
        If the current array has blocked structsPerRow, expand to variable
        length 0-terminated form. (ASSUMES all zeros in blocked form are
        placeholders.)
        """
        ...
    
    def CopyData(self: MSPyBentleyGeom.BlockedVectorIntT, fromIndex: int, toIndex: int) -> None:
        ...
    
    def CopyVectorFrom(self: MSPyBentleyGeom.BlockedVectorIntT, source: MSPyBentleyGeom.Int32Array) -> None:
        ...
    
    def CountZeros(self: MSPyBentleyGeom.BlockedVectorInt) -> int:
        """
        Count zeros in the vector.
        """
        ...
    
    def DelimitFace(self: MSPyBentleyGeom.BlockedVectorInt, numPerFace: int, iFirst: int) -> tuple:
        """
        From given start position, find final (inclusive) position and
        position for next start search. Initialize iFirst to zero before first
        call. Return false if no more faces.
        """
        ...
    
    def GetCP(self: MSPyBentleyGeom.BlockedVectorIntT) -> int:
        ...
    
    def GetPtr(self: MSPyBentleyGeom.BlockedVectorIntT) -> int:
        ...
    
    class IndexAction:
        """
        Members:
        
        eNone
        
        eForcePositive
        
        eForceNegative
        
        eNegate
        """
    
        def __init__(self: MSPyBentleyGeom.BlockedVectorInt.IndexAction, value: int) -> None:
            ...
        
        eForceNegative: IndexAction
        
        eForcePositive: IndexAction
        
        eNegate: IndexAction
        
        eNone: IndexAction
        
        @property
        def name(self: handle) -> str:
            ...
        
        @property
        def value(arg0: MSPyBentleyGeom.BlockedVectorInt.IndexAction) -> int:
            ...
        
    @property
    def IndexFamily(arg0: MSPyBentleyGeom.BlockedVectorIntT) -> int:
        ...
    
    @property
    def IndexedBy(arg0: MSPyBentleyGeom.BlockedVectorIntT) -> int:
        ...
    
    def MinMax(self: MSPyBentleyGeom.BlockedVectorInt) -> tuple:
        """
        Return min and max values in entire vector.
        
        :param (output):
        minValue smallest value, INT_MAX if empty array.
        
        :param (output):
        maxValue largest value, INT_MIN if empty array.
        """
        ...
    
    def NegateInRange(self: MSPyBentleyGeom.BlockedVectorInt, iFirst: int, iLast: int) -> None:
        ...
    
    def NegativeAbsInRange(self: MSPyBentleyGeom.BlockedVectorInt, iFirst: int, iLast: int) -> None:
        """
        for each k in the inclusive range kFirst<=k<=kLast, set the entry to
        the negative of its absolute value.
        """
        ...
    
    def NumCompleteRows(self: MSPyBentleyGeom.BlockedVectorIntT) -> int:
        ...
    
    @property
    def NumPerStruct(arg0: MSPyBentleyGeom.BlockedVectorIntT) -> int:
        ...
    
    def ReverseInRange(self: MSPyBentleyGeom.BlockedVectorIntT, iFirst: int, iLast: int) -> None:
        ...
    
    def SetTags(self: MSPyBentleyGeom.BlockedVectorIntT, numPeStruct: int, structsPerRow: int, tag: int, IndexFamily: int, IndexedBy: int, active: bool) -> None:
        ...
    
    def ShiftSignsFromCyclicPredecessorsInRange(self: MSPyBentleyGeom.BlockedVectorInt, kFirst: int, kLast: int) -> None:
        """
        for each k in the inclusive range kFirst<=k<=kLast, set the sign to
        the prior value from its
        """
        ...
    
    @property
    def StructsPerRow(arg0: MSPyBentleyGeom.BlockedVectorIntT) -> int:
        ...
    @StructsPerRow.setter
    def StructsPerRow(arg0: MSPyBentleyGeom.BlockedVectorIntT, arg1: int) -> None:
        ...
    
    @property
    def Tag(arg0: MSPyBentleyGeom.BlockedVectorIntT) -> int:
        ...
    
    def Trim(self: MSPyBentleyGeom.BlockedVectorIntT, index0: int, count: int) -> None:
        ...
    
    def TryGet(self: MSPyBentleyGeom.BlockedVectorIntT, index: int, defaultValue: int) -> Tuple[bool, int]:
        ...
    
    def __init__(self: MSPyBentleyGeom.BlockedVectorInt) -> None:
        ...
    
    def append(self: MSPyBentleyGeom.Int32Array, x: int) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.Int32Array) -> None:
        """
        Clear the contents
        """
        ...
    
    def count(self: MSPyBentleyGeom.Int32Array, x: int) -> int:
        """
        Return the number of times ``x`` appears in the list
        """
        ...
    
    eForceNegative: IndexAction
    
    eForcePositive: IndexAction
    
    eNegate: IndexAction
    
    eNone: IndexAction
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.Int32Array, L: MSPyBentleyGeom.Int32Array) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.Int32Array, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.Int32Array, i: int, x: int) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.Int32Array) -> int
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.Int32Array, i: int) -> int
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(self: MSPyBentleyGeom.Int32Array, x: int) -> None:
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class BlockedVectorIntT:
    """
    None
    """

    @property
    def Active(arg0: MSPyBentleyGeom.BlockedVectorIntT) -> bool:
        ...
    @Active.setter
    def Active(arg0: MSPyBentleyGeom.BlockedVectorIntT, arg1: bool) -> None:
        ...
    
    def Append(*args, **kwargs):
        """
        Overloaded function.
        
        1. Append(self: MSPyBentleyGeom.BlockedVectorIntT, pBuffer: int, count: int) -> int
        
        2. Append(self: MSPyBentleyGeom.BlockedVectorIntT, source: MSPyBentleyGeom.BlockedVectorIntT) -> int
        
        3. Append(self: MSPyBentleyGeom.BlockedVectorIntT, source: int) -> int
        """
        ...
    
    def AppendAndReturnIndex(self: MSPyBentleyGeom.BlockedVectorIntT, source: int) -> int:
        ...
    
    def ClearAndAppend(self: MSPyBentleyGeom.BlockedVectorIntT, source: MSPyBentleyGeom.Int32Array) -> None:
        ...
    
    def ClearAndAppendBlock(*args, **kwargs):
        """
        Overloaded function.
        
        1. ClearAndAppendBlock(self: MSPyBentleyGeom.BlockedVectorIntT, source: MSPyBentleyGeom.BlockedVectorIntT, i0: int, numWrap: int, n: int) -> int
        
        2. ClearAndAppendBlock(self: MSPyBentleyGeom.BlockedVectorIntT, source: int, sourceSize: int, i0: int, numWrap: int, n: int) -> int
        """
        ...
    
    def CopyData(self: MSPyBentleyGeom.BlockedVectorIntT, fromIndex: int, toIndex: int) -> None:
        ...
    
    def CopyVectorFrom(self: MSPyBentleyGeom.BlockedVectorIntT, source: MSPyBentleyGeom.Int32Array) -> None:
        ...
    
    def GetCP(self: MSPyBentleyGeom.BlockedVectorIntT) -> int:
        ...
    
    def GetPtr(self: MSPyBentleyGeom.BlockedVectorIntT) -> int:
        ...
    
    @property
    def IndexFamily(arg0: MSPyBentleyGeom.BlockedVectorIntT) -> int:
        ...
    
    @property
    def IndexedBy(arg0: MSPyBentleyGeom.BlockedVectorIntT) -> int:
        ...
    
    def NumCompleteRows(self: MSPyBentleyGeom.BlockedVectorIntT) -> int:
        ...
    
    @property
    def NumPerStruct(arg0: MSPyBentleyGeom.BlockedVectorIntT) -> int:
        ...
    
    def ReverseInRange(self: MSPyBentleyGeom.BlockedVectorIntT, iFirst: int, iLast: int) -> None:
        ...
    
    def SetTags(self: MSPyBentleyGeom.BlockedVectorIntT, numPeStruct: int, structsPerRow: int, tag: int, IndexFamily: int, IndexedBy: int, active: bool) -> None:
        ...
    
    @property
    def StructsPerRow(arg0: MSPyBentleyGeom.BlockedVectorIntT) -> int:
        ...
    @StructsPerRow.setter
    def StructsPerRow(arg0: MSPyBentleyGeom.BlockedVectorIntT, arg1: int) -> None:
        ...
    
    @property
    def Tag(arg0: MSPyBentleyGeom.BlockedVectorIntT) -> int:
        ...
    
    def Trim(self: MSPyBentleyGeom.BlockedVectorIntT, index0: int, count: int) -> None:
        ...
    
    def TryGet(self: MSPyBentleyGeom.BlockedVectorIntT, index: int, defaultValue: int) -> Tuple[bool, int]:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.BlockedVectorIntT) -> None
        
        2. __init__(self: MSPyBentleyGeom.BlockedVectorIntT, numPerStruct: int, structsPerRow: int = 0, tag: int = 0, indexFamily: int = 0, indexBy: int = 0, active: bool = False) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.Int32Array, x: int) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.Int32Array) -> None:
        """
        Clear the contents
        """
        ...
    
    def count(self: MSPyBentleyGeom.Int32Array, x: int) -> int:
        """
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.Int32Array, L: MSPyBentleyGeom.Int32Array) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.Int32Array, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.Int32Array, i: int, x: int) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.Int32Array) -> int
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.Int32Array, i: int) -> int
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(self: MSPyBentleyGeom.Int32Array, x: int) -> None:
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class BlockedVectorPolyfaceEdgeChain:
    """
    None
    """

    @property
    def Active(arg0: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain) -> bool:
        ...
    @Active.setter
    def Active(arg0: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain, arg1: bool) -> None:
        ...
    
    def Append(*args, **kwargs):
        """
        Overloaded function.
        
        1. Append(self: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain, pBuffer: MSPyBentleyGeom.PolyfaceEdgeChain, count: int) -> int
        
        2. Append(self: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain, source: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain) -> int
        
        3. Append(self: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain, source: MSPyBentleyGeom.PolyfaceEdgeChain) -> int
        """
        ...
    
    def AppendAndReturnIndex(self: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain, source: MSPyBentleyGeom.PolyfaceEdgeChain) -> int:
        ...
    
    def ClearAndAppend(self: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain, source: MSPyBentleyGeom.PolyfaceEdgeChainArray) -> None:
        ...
    
    def ClearAndAppendBlock(*args, **kwargs):
        """
        Overloaded function.
        
        1. ClearAndAppendBlock(self: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain, source: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain, i0: int, numWrap: int, n: int) -> int
        
        2. ClearAndAppendBlock(self: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain, source: MSPyBentleyGeom.PolyfaceEdgeChain, sourceSize: int, i0: int, numWrap: int, n: int) -> int
        """
        ...
    
    def CopyData(self: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain, fromIndex: int, toIndex: int) -> None:
        ...
    
    def CopyVectorFrom(self: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain, source: MSPyBentleyGeom.PolyfaceEdgeChainArray) -> None:
        ...
    
    def GetCP(self: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain) -> MSPyBentleyGeom.PolyfaceEdgeChain:
        ...
    
    def GetPtr(self: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain) -> MSPyBentleyGeom.PolyfaceEdgeChain:
        ...
    
    @property
    def IndexFamily(arg0: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain) -> int:
        ...
    
    @property
    def IndexedBy(arg0: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain) -> int:
        ...
    
    def NumCompleteRows(self: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain) -> int:
        ...
    
    @property
    def NumPerStruct(arg0: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain) -> int:
        ...
    
    def ReverseInRange(self: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain, iFirst: int, iLast: int) -> None:
        ...
    
    def SetTags(self: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain, numPeStruct: int, structsPerRow: int, tag: int, IndexFamily: int, IndexedBy: int, active: bool) -> None:
        ...
    
    @property
    def StructsPerRow(arg0: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain) -> int:
        ...
    @StructsPerRow.setter
    def StructsPerRow(arg0: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain, arg1: int) -> None:
        ...
    
    @property
    def Tag(arg0: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain) -> int:
        ...
    
    def Trim(self: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain, index0: int, count: int) -> None:
        ...
    
    def TryGet(self: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain, index: int, defaultValue: MSPyBentleyGeom.PolyfaceEdgeChain) -> Tuple[bool, MSPyBentleyGeom.PolyfaceEdgeChain]:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain) -> None
        
        2. __init__(self: MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain, numPerStruct: int, structsPerRow: int = 0, tag: int = 0, indexFamily: int = 0, indexBy: int = 0, active: bool = False) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.PolyfaceEdgeChainArray, x: MSPyBentleyGeom.PolyfaceEdgeChain) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.PolyfaceEdgeChainArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.PolyfaceEdgeChainArray, L: MSPyBentleyGeom.PolyfaceEdgeChainArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.PolyfaceEdgeChainArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.PolyfaceEdgeChainArray, i: int, x: MSPyBentleyGeom.PolyfaceEdgeChain) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.PolyfaceEdgeChainArray) -> MSPyBentleyGeom.PolyfaceEdgeChain
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.PolyfaceEdgeChainArray, i: int) -> MSPyBentleyGeom.PolyfaceEdgeChain
        
        Remove and return the item at index ``i``
        """
        ...
    
class BlockedVectorRgbFactor:
    """
    None
    """

    @property
    def Active(arg0: MSPyBentleyGeom.BlockedVectorRgbFactor) -> bool:
        ...
    @Active.setter
    def Active(arg0: MSPyBentleyGeom.BlockedVectorRgbFactor, arg1: bool) -> None:
        ...
    
    def Append(*args, **kwargs):
        """
        Overloaded function.
        
        1. Append(self: MSPyBentleyGeom.BlockedVectorRgbFactor, pBuffer: MSPyBentleyGeom.RgbFactor, count: int) -> int
        
        2. Append(self: MSPyBentleyGeom.BlockedVectorRgbFactor, source: MSPyBentleyGeom.BlockedVectorRgbFactor) -> int
        
        3. Append(self: MSPyBentleyGeom.BlockedVectorRgbFactor, source: MSPyBentleyGeom.RgbFactor) -> int
        """
        ...
    
    def AppendAndReturnIndex(self: MSPyBentleyGeom.BlockedVectorRgbFactor, source: MSPyBentleyGeom.RgbFactor) -> int:
        ...
    
    def ClearAndAppend(self: MSPyBentleyGeom.BlockedVectorRgbFactor, source: MSPyBentleyGeom.RgbFactorArray) -> None:
        ...
    
    def ClearAndAppendBlock(*args, **kwargs):
        """
        Overloaded function.
        
        1. ClearAndAppendBlock(self: MSPyBentleyGeom.BlockedVectorRgbFactor, source: MSPyBentleyGeom.BlockedVectorRgbFactor, i0: int, numWrap: int, n: int) -> int
        
        2. ClearAndAppendBlock(self: MSPyBentleyGeom.BlockedVectorRgbFactor, source: MSPyBentleyGeom.RgbFactor, sourceSize: int, i0: int, numWrap: int, n: int) -> int
        """
        ...
    
    def CopyData(self: MSPyBentleyGeom.BlockedVectorRgbFactor, fromIndex: int, toIndex: int) -> None:
        ...
    
    def CopyVectorFrom(self: MSPyBentleyGeom.BlockedVectorRgbFactor, source: MSPyBentleyGeom.RgbFactorArray) -> None:
        ...
    
    def GetCP(self: MSPyBentleyGeom.BlockedVectorRgbFactor) -> MSPyBentleyGeom.RgbFactor:
        ...
    
    def GetPtr(self: MSPyBentleyGeom.BlockedVectorRgbFactor) -> MSPyBentleyGeom.RgbFactor:
        ...
    
    @property
    def IndexFamily(arg0: MSPyBentleyGeom.BlockedVectorRgbFactor) -> int:
        ...
    
    @property
    def IndexedBy(arg0: MSPyBentleyGeom.BlockedVectorRgbFactor) -> int:
        ...
    
    def NumCompleteRows(self: MSPyBentleyGeom.BlockedVectorRgbFactor) -> int:
        ...
    
    @property
    def NumPerStruct(arg0: MSPyBentleyGeom.BlockedVectorRgbFactor) -> int:
        ...
    
    def ReverseInRange(self: MSPyBentleyGeom.BlockedVectorRgbFactor, iFirst: int, iLast: int) -> None:
        ...
    
    def SetTags(self: MSPyBentleyGeom.BlockedVectorRgbFactor, numPeStruct: int, structsPerRow: int, tag: int, IndexFamily: int, IndexedBy: int, active: bool) -> None:
        ...
    
    @property
    def StructsPerRow(arg0: MSPyBentleyGeom.BlockedVectorRgbFactor) -> int:
        ...
    @StructsPerRow.setter
    def StructsPerRow(arg0: MSPyBentleyGeom.BlockedVectorRgbFactor, arg1: int) -> None:
        ...
    
    @property
    def Tag(arg0: MSPyBentleyGeom.BlockedVectorRgbFactor) -> int:
        ...
    
    def Trim(self: MSPyBentleyGeom.BlockedVectorRgbFactor, index0: int, count: int) -> None:
        ...
    
    def TryGet(self: MSPyBentleyGeom.BlockedVectorRgbFactor, index: int, defaultValue: MSPyBentleyGeom.RgbFactor) -> Tuple[bool, MSPyBentleyGeom.RgbFactor]:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.BlockedVectorRgbFactor) -> None
        
        2. __init__(self: MSPyBentleyGeom.BlockedVectorRgbFactor, numPerStruct: int, structsPerRow: int = 0, tag: int = 0, indexFamily: int = 0, indexBy: int = 0, active: bool = False) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.RgbFactorArray, x: MSPyBentleyGeom.RgbFactor) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.RgbFactorArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.RgbFactorArray, L: MSPyBentleyGeom.RgbFactorArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.RgbFactorArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.RgbFactorArray, i: int, x: MSPyBentleyGeom.RgbFactor) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.RgbFactorArray) -> MSPyBentleyGeom.RgbFactor
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.RgbFactorArray, i: int) -> MSPyBentleyGeom.RgbFactor
        
        Remove and return the item at index ``i``
        """
        ...
    
class BlockedVectorUInt32:
    """
    None
    """

    @property
    def Active(arg0: MSPyBentleyGeom.BlockedVectorUInt32) -> bool:
        ...
    @Active.setter
    def Active(arg0: MSPyBentleyGeom.BlockedVectorUInt32, arg1: bool) -> None:
        ...
    
    def Append(*args, **kwargs):
        """
        Overloaded function.
        
        1. Append(self: MSPyBentleyGeom.BlockedVectorUInt32, pBuffer: int, count: int) -> int
        
        2. Append(self: MSPyBentleyGeom.BlockedVectorUInt32, source: MSPyBentleyGeom.BlockedVectorUInt32) -> int
        
        3. Append(self: MSPyBentleyGeom.BlockedVectorUInt32, source: int) -> int
        """
        ...
    
    def AppendAndReturnIndex(self: MSPyBentleyGeom.BlockedVectorUInt32, source: int) -> int:
        ...
    
    def ClearAndAppend(self: MSPyBentleyGeom.BlockedVectorUInt32, source: MSPyBentleyGeom.UInt32Array) -> None:
        ...
    
    def ClearAndAppendBlock(*args, **kwargs):
        """
        Overloaded function.
        
        1. ClearAndAppendBlock(self: MSPyBentleyGeom.BlockedVectorUInt32, source: MSPyBentleyGeom.BlockedVectorUInt32, i0: int, numWrap: int, n: int) -> int
        
        2. ClearAndAppendBlock(self: MSPyBentleyGeom.BlockedVectorUInt32, source: int, sourceSize: int, i0: int, numWrap: int, n: int) -> int
        """
        ...
    
    def CopyData(self: MSPyBentleyGeom.BlockedVectorUInt32, fromIndex: int, toIndex: int) -> None:
        ...
    
    def CopyVectorFrom(self: MSPyBentleyGeom.BlockedVectorUInt32, source: MSPyBentleyGeom.UInt32Array) -> None:
        ...
    
    def GetCP(self: MSPyBentleyGeom.BlockedVectorUInt32) -> int:
        ...
    
    def GetPtr(self: MSPyBentleyGeom.BlockedVectorUInt32) -> int:
        ...
    
    @property
    def IndexFamily(arg0: MSPyBentleyGeom.BlockedVectorUInt32) -> int:
        ...
    
    @property
    def IndexedBy(arg0: MSPyBentleyGeom.BlockedVectorUInt32) -> int:
        ...
    
    def NumCompleteRows(self: MSPyBentleyGeom.BlockedVectorUInt32) -> int:
        ...
    
    @property
    def NumPerStruct(arg0: MSPyBentleyGeom.BlockedVectorUInt32) -> int:
        ...
    
    def ReverseInRange(self: MSPyBentleyGeom.BlockedVectorUInt32, iFirst: int, iLast: int) -> None:
        ...
    
    def SetTags(self: MSPyBentleyGeom.BlockedVectorUInt32, numPeStruct: int, structsPerRow: int, tag: int, IndexFamily: int, IndexedBy: int, active: bool) -> None:
        ...
    
    @property
    def StructsPerRow(arg0: MSPyBentleyGeom.BlockedVectorUInt32) -> int:
        ...
    @StructsPerRow.setter
    def StructsPerRow(arg0: MSPyBentleyGeom.BlockedVectorUInt32, arg1: int) -> None:
        ...
    
    @property
    def Tag(arg0: MSPyBentleyGeom.BlockedVectorUInt32) -> int:
        ...
    
    def Trim(self: MSPyBentleyGeom.BlockedVectorUInt32, index0: int, count: int) -> None:
        ...
    
    def TryGet(self: MSPyBentleyGeom.BlockedVectorUInt32, index: int, defaultValue: int) -> Tuple[bool, int]:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.BlockedVectorUInt32) -> None
        
        2. __init__(self: MSPyBentleyGeom.BlockedVectorUInt32, numPerStruct: int, structsPerRow: int = 0, tag: int = 0, indexFamily: int = 0, indexBy: int = 0, active: bool = False) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.UInt32Array, x: int) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.UInt32Array) -> None:
        """
        Clear the contents
        """
        ...
    
    def count(self: MSPyBentleyGeom.UInt32Array, x: int) -> int:
        """
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.UInt32Array, L: MSPyBentleyGeom.UInt32Array) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.UInt32Array, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.UInt32Array, i: int, x: int) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.UInt32Array) -> int
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.UInt32Array, i: int) -> int
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(self: MSPyBentleyGeom.UInt32Array, x: int) -> None:
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class BoolArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.BoolArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.BoolArray, arg0: MSPyBentleyGeom.BoolArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.BoolArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.BoolArray, x: bool) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.BoolArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def count(self: MSPyBentleyGeom.BoolArray, x: bool) -> int:
        """
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.BoolArray, L: MSPyBentleyGeom.BoolArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.BoolArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.BoolArray, i: int, x: bool) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.BoolArray) -> bool
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.BoolArray, i: int) -> bool
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(self: MSPyBentleyGeom.BoolArray, x: bool) -> None:
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class BoolSelect:
    """
    Members:
    
    eBoolSelect_Parity
    
    eBoolSelect_Union
    
    eBoolSelect_Summed_Parity
    
    eBoolSelect_Summed_Positive
    
    eBoolSelect_Summed_NonZero
    
    eBoolSelect_Summed_Negative
    
    eBoolSelect_FromStructure
    """

    def __init__(self: MSPyBentleyGeom.BoolSelect, value: int) -> None:
        ...
    
    eBoolSelect_FromStructure: BoolSelect
    
    eBoolSelect_Parity: BoolSelect
    
    eBoolSelect_Summed_Negative: BoolSelect
    
    eBoolSelect_Summed_NonZero: BoolSelect
    
    eBoolSelect_Summed_Parity: BoolSelect
    
    eBoolSelect_Summed_Positive: BoolSelect
    
    eBoolSelect_Union: BoolSelect
    
    @property
    def name(self: handle) -> str:
        ...
    
    @property
    def value(arg0: MSPyBentleyGeom.BoolSelect) -> int:
        ...
    
class BsplineDisplay:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    
    @property
    def curveDisplay(self: MSPyBentleyGeom.BsplineDisplay) -> int:
        ...
    @curveDisplay.setter
    def curveDisplay(self: MSPyBentleyGeom.BsplineDisplay, arg0: int) -> None:
        ...
    
    @property
    def polygonDisplay(self: MSPyBentleyGeom.BsplineDisplay) -> int:
        ...
    @polygonDisplay.setter
    def polygonDisplay(self: MSPyBentleyGeom.BsplineDisplay, arg0: int) -> None:
        ...
    
    @property
    def rulesByLength(self: MSPyBentleyGeom.BsplineDisplay) -> int:
        ...
    @rulesByLength.setter
    def rulesByLength(self: MSPyBentleyGeom.BsplineDisplay, arg0: int) -> None:
        ...
    
class BsplineParam:
    """
    None
    """

    @staticmethod
    def NumberAllocatedKnots(numPoles: int, order: int, closed: int) -> int:
        """
        Return the number of knots in the allocated knot array. Note that this
        number may be different from the value of the numKnots field of this
        structure because the numKnots field traditionally indicated only the
        number of interior knots.
        """
        ...
    
    @staticmethod
    def NumberInteriorKnots(numPoles: int, order: int, closed: int) -> int:
        """
        Return the number of interior knots, as recorded (for legacy reasons)
        in the params structures
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    
    @property
    def closed(self: MSPyBentleyGeom.BsplineParam) -> int:
        ...
    @closed.setter
    def closed(self: MSPyBentleyGeom.BsplineParam, arg0: int) -> None:
        ...
    
    @property
    def numKnots(self: MSPyBentleyGeom.BsplineParam) -> int:
        ...
    @numKnots.setter
    def numKnots(self: MSPyBentleyGeom.BsplineParam, arg0: int) -> None:
        ...
    
    @property
    def numPoles(self: MSPyBentleyGeom.BsplineParam) -> int:
        ...
    @numPoles.setter
    def numPoles(self: MSPyBentleyGeom.BsplineParam, arg0: int) -> None:
        ...
    
    @property
    def numRules(self: MSPyBentleyGeom.BsplineParam) -> int:
        ...
    @numRules.setter
    def numRules(self: MSPyBentleyGeom.BsplineParam, arg0: int) -> None:
        ...
    
    @property
    def order(self: MSPyBentleyGeom.BsplineParam) -> int:
        ...
    @order.setter
    def order(self: MSPyBentleyGeom.BsplineParam, arg0: int) -> None:
        ...
    
CURVATURE_CONTINUITY: int

class ClipPlane:
    """
    None
    """

    def BoundedSegmentHasSimpleIntersection(self: MSPyBentleyGeom.ClipPlane, pointA: DPoint3d, pointB: DPoint3d) -> tuple:
        """
        Return true if the through{pointA} and{pointB} crosses the plane at
        a fractional coordinate between 0 and 1. Note that if both points are
        ON the plane the return value is false -- the " on " case is not a
        simple intersection.
        """
        ...
    
    @staticmethod
    def ClipPlaneToRange(range: DRange3d, plane: DPlane3d, clippedPoints: List[DPoint3d], largeRectangle: List[DPoint3d] = None) -> None:
        """
        Return the (possibly empty) polygon of intersection between a DRange3d
        and an (unbounded) plane.
        """
        ...
    
    def ConvexPolygonClipInPlace(*args, **kwargs):
        """
        Overloaded function.
        
        1. ConvexPolygonClipInPlace(self: MSPyBentleyGeom.ClipPlane, xyz: List[DPoint3d], work: List[DPoint3d], onPlaneHandling: int) -> None
        
        Clip a convex polygon. caller supplies work and altitude arrays as
        works space. result is written inplace to xyz.
        
        * onPlaneHandling=0 means no special handling for all-oin.
        
        * onPlaneHandling=1 means treat all-on as (input)
        
        * onPlaneHandling= -1 means treat all-on as (output)
        
        2. ConvexPolygonClipInPlace(self: MSPyBentleyGeom.ClipPlane, xyz: List[DPoint3d], work: List[DPoint3d]) -> None
        
        Clip a convex polygon. caller supplies work and altitude arrays as
        works space. result is written inplace to xyz.
        
        * onPlaneHandling=0 means no special handling for all-oin.
        
        * onPlaneHandling=1 means treat all-on as (input)
        
        * onPlaneHandling= -1 means treat all-on as (output)
        
        3. ConvexPolygonClipInPlace(self: MSPyBentleyGeom.ClipPlane, xyz: list, work: list, onPlaneHandling: int) -> None
        
        Clip a convex polygon. caller supplies work and altitude arrays as
        works space. result is written inplace to xyz.
        
        * onPlaneHandling=0 means no special handling for all-oin.
        
        * onPlaneHandling=1 means treat all-on as (input)
        
        * onPlaneHandling= -1 means treat all-on as (output)
        
        4. ConvexPolygonClipInPlace(self: MSPyBentleyGeom.ClipPlane, xyz: list, work: list) -> None
        
        Clip a convex polygon. caller supplies work and altitude arrays as
        works space. result is written inplace to xyz.
        
        * onPlaneHandling=0 means no special handling for all-oin.
        
        * onPlaneHandling=1 means treat all-on as (input)
        
        * onPlaneHandling= -1 means treat all-on as (output)
        """
        ...
    
    def ConvexPolygonSplitInsideOutside(self: MSPyBentleyGeom.ClipPlane, xyz: List[DPoint3d], xyzIn: List[DPoint3d], xyzOut: List[DPoint3d], altitudeRange: DRange1d) -> None:
        """
        (input) original polygon (output) inside part (output) outside part (output) min
        and max altitude values.
        """
        ...
    
    @property
    def DPlane4d(arg0: MSPyBentleyGeom.ClipPlane) -> DPoint4d:
        ...
    @DPlane4d.setter
    def DPlane4d(arg0: MSPyBentleyGeom.ClipPlane, arg1: DPoint4d) -> None:
        ...
    
    def DotProduct(*args, **kwargs):
        """
        Overloaded function.
        
        1. DotProduct(self: MSPyBentleyGeom.ClipPlane, normal: DVec3d) -> float
        
        Evaluate Dot Product with plane normal.
        
        2. DotProduct(self: MSPyBentleyGeom.ClipPlane, point: DPoint3d) -> float
        
        Evaluate Dot Product with plane normal.
        """
        ...
    
    def EvaluatePoint(self: MSPyBentleyGeom.ClipPlane, point: DPoint3d) -> float:
        """
        Evaluate the plane equation at{point}.
        """
        ...
    
    @staticmethod
    def FindPointOnBothPlanes(data: List[DPoint3d], plane0: MSPyBentleyGeom.ClipPlane, plane1: MSPyBentleyGeom.ClipPlane, tolerance: float) -> MSPyBentleyGeom.ValidatedSize:
        """
        Search an array of points for the first index at which the point is on
        both of two planes.
        """
        ...
    
    @property
    def Flags(arg0: MSPyBentleyGeom.ClipPlane) -> int:
        ...
    @Flags.setter
    def Flags(arg0: MSPyBentleyGeom.ClipPlane, arg1: int) -> None:
        ...
    
    @staticmethod
    def FromEdgeAndUpVector(point0: DPoint3d, point1: DPoint3d, upVector: DVec3d, tiltAngle: MSPyBentleyGeom.Angle) -> MSPyBentleyGeom.ValidatedClipPlane:
        """
        ul> li>For non-tilted case, (tiltAngle = 0), the inward normal vector
        is upVector cross edge vector. li>If tilt is nonzero, that plane is
        rotated around the (forward) edge vector. ul
        """
        ...
    
    @staticmethod
    def FromPointsAndDistanceAlongPlaneNormal(points: List[DPoint3d], upVector: DVec3d, distance: float, pointInside: bool) -> MSPyBentleyGeom.ValidatedClipPlane:
        """
        Create a clip plane perpendicular to upVvector, positioned a distance
        forward or backward of given points. ul> li
        """
        ...
    
    def GetDPlane3d(self: MSPyBentleyGeom.ClipPlane) -> DPlane3d:
        """
        Return the plane as origin and normal.
        """
        ...
    
    def GetDPlane4d(self: MSPyBentleyGeom.ClipPlane) -> DPoint4d:
        """
        Return the plane for use as h = [ax,ay,az,aw] DOT [x,y,z,1]
        """
        ...
    
    def GetDistance(self: MSPyBentleyGeom.ClipPlane) -> float:
        """
        Return the plane distance.
        """
        ...
    
    @staticmethod
    def GetEvaluationCount(clear: bool = False) -> int:
        ...
    
    def GetFlags(self: MSPyBentleyGeom.ClipPlane) -> int:
        """
        Get flags.
        """
        ...
    
    def GetInvisible(self: MSPyBentleyGeom.ClipPlane) -> bool:
        ...
    
    def GetIsInterior(self: MSPyBentleyGeom.ClipPlane) -> bool:
        """
        Return the interior flag.
        """
        ...
    
    def GetLocalToWorldTransform(*args, **kwargs):
        """
        Overloaded function.
        
        1. GetLocalToWorldTransform(self: MSPyBentleyGeom.ClipPlane, zPointsOut: bool = False) -> Transform
        
        Return the plane as a transform with origin on plane, z vector
        perpendicular.
        
        2. GetLocalToWorldTransform(self: MSPyBentleyGeom.ClipPlane, localToWorld: Transform, worldToLocal: Transform, zPointsOut: bool = False) -> bool
        
        Return the plane as a transform with origin on plane, z vector
        perpendicular.
        """
        ...
    
    def GetNormal(self: MSPyBentleyGeom.ClipPlane) -> DVec3d:
        """
        Return the plane normal.
        """
        ...
    
    @property
    def IsInvisible(arg0: MSPyBentleyGeom.ClipPlane) -> bool:
        ...
    @IsInvisible.setter
    def IsInvisible(arg0: MSPyBentleyGeom.ClipPlane, arg1: bool) -> None:
        ...
    
    def IsPointOn(self: MSPyBentleyGeom.ClipPlane, point: DPoint3d, tolerance: float) -> bool:
        """
        Return if the point is on plane within tolerance
        """
        ...
    
    def IsPointOnOrInside(*args, **kwargs):
        """
        Overloaded function.
        
        1. IsPointOnOrInside(self: MSPyBentleyGeom.ClipPlane, point: DPoint3d) -> bool
        
        Return if the point is on or inside plane.
        
        2. IsPointOnOrInside(self: MSPyBentleyGeom.ClipPlane, point: DPoint3d, tolerance: float) -> bool
        
        Return if the point is on or inside plane.
        """
        ...
    
    def IsVisible(self: MSPyBentleyGeom.ClipPlane) -> bool:
        """
        Return whether cut for this flag should be displayed (!invisible &&
        !isInterior);
        """
        ...
    
    def MultiplyPlaneTimesMatrix(self: MSPyBentleyGeom.ClipPlane, matrix: DMatrix4d) -> None:
        """
        multiply plane coefficients times a DMatrix4d (such as the worldToNPC
        matrix) multiply [ax,ay,az,aw] * matrix
        """
        ...
    
    def Negate(self: MSPyBentleyGeom.ClipPlane) -> None:
        """
        Flip the normal direction.
        """
        ...
    
    def OffsetDistance(self: MSPyBentleyGeom.ClipPlane, distance: float) -> None:
        """
        Apply offset to plane.
        """
        ...
    
    def PolygonCrossings(self: MSPyBentleyGeom.ClipPlane, xyz: List[DPoint3d], crossings: List[DPoint3d]) -> None:
        """
        Return crossings of all edges of a polygon (including final closure)
        This uses simple zero tests -- does not try to filter double data at
        vertex-on-plane case
        """
        ...
    
    def SetDPlane4d(self: MSPyBentleyGeom.ClipPlane, plane: DPoint4d) -> None:
        ...
    
    def SetFlags(*args, **kwargs):
        """
        Overloaded function.
        
        1. SetFlags(self: MSPyBentleyGeom.ClipPlane, flags: int) -> None
        
        Set flags.
        
        2. SetFlags(self: MSPyBentleyGeom.ClipPlane, invisible: bool, interior: bool) -> None
        
        Set flags.
        """
        ...
    
    def SetInvisible(self: MSPyBentleyGeom.ClipPlane, invisible: bool) -> None:
        """
        Get invisible.
        """
        ...
    
    def SimpleIntersectionFractions(self: MSPyBentleyGeom.ClipPlane, arc: DEllipse3d, bounded: bool) -> tuple:
        ...
    
    def TransformInPlace(self: MSPyBentleyGeom.ClipPlane, transform: Transform) -> None:
        """
        Transform plane.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ClipPlane) -> None
        
        2. __init__(self: MSPyBentleyGeom.ClipPlane, normal: DVec3d, distance: float, invisible: bool = False, interior: bool = False) -> None
        
        3. __init__(self: MSPyBentleyGeom.ClipPlane, normal: DVec3d, point: DPoint3d, invisible: bool = False, interior: bool = False) -> None
        
        4. __init__(self: MSPyBentleyGeom.ClipPlane, plane: DPlane3d, invisible: bool = False, interior: bool = False) -> None
        """
        ...
    
class ClipPlaneArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ClipPlaneArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.ClipPlaneArray, arg0: MSPyBentleyGeom.ClipPlaneArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.ClipPlaneArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.ClipPlaneArray, x: MSPyBentleyGeom.ClipPlane) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.ClipPlaneArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.ClipPlaneArray, L: MSPyBentleyGeom.ClipPlaneArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.ClipPlaneArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.ClipPlaneArray, i: int, x: MSPyBentleyGeom.ClipPlane) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.ClipPlaneArray) -> MSPyBentleyGeom.ClipPlane
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.ClipPlaneArray, i: int) -> MSPyBentleyGeom.ClipPlane
        
        Remove and return the item at index ``i``
        """
        ...
    
class ClipPlaneContainment:
    """
    Members:
    
    eClipPlaneContainment_StronglyInside
    
    eClipPlaneContainment_Ambiguous
    
    eClipPlaneContainment_StronglyOutside
    """

    def __init__(self: MSPyBentleyGeom.ClipPlaneContainment, value: int) -> None:
        ...
    
    eClipPlaneContainment_Ambiguous: ClipPlaneContainment
    
    eClipPlaneContainment_StronglyInside: ClipPlaneContainment
    
    eClipPlaneContainment_StronglyOutside: ClipPlaneContainment
    
    @property
    def name(self: handle) -> str:
        ...
    
    @property
    def value(arg0: MSPyBentleyGeom.ClipPlaneContainment) -> int:
        ...
    
class ClipPlaneSet:
    """
    None
    """

    def AppendCrossings(*args, **kwargs):
        """
        Overloaded function.
        
        1. AppendCrossings(self: MSPyBentleyGeom.ClipPlaneSet, curves: CurveVector, crossings: List[CurveLocationDetailPair]) -> None
        
        Compute crossings of this ClipPlaneSet with curve primitives within a
        CurveVector.
        
        :param (input):
        curves candidate curves
        
        :param (output):
        crossings detailed crossing data.
        
        2. AppendCrossings(self: MSPyBentleyGeom.ClipPlaneSet, curve: ICurvePrimitive, crossings: List[CurveLocationDetailPair]) -> None
        
        Compute crossings of this ClipPlaneSet with curve primitives within a
        CurveVector.
        
        :param (input):
        curves candidate curves
        
        :param (output):
        crossings detailed crossing data.
        """
        ...
    
    def AppendIntervals(*args, **kwargs):
        """
        Overloaded function.
        
        1. AppendIntervals(self: MSPyBentleyGeom.ClipPlaneSet, segment: DSegment3d, intervals: List[DSegment1d]) -> None
        
        Enumerate the " in " intervals .. the array is NOT cleared
        
        2. AppendIntervals(self: MSPyBentleyGeom.ClipPlaneSet, arc: DEllipse3d, intervals: List[DSegment1d]) -> None
        
        Enumerate the " in " intervals .. the array is NOT cleared
        
        3. AppendIntervals(self: MSPyBentleyGeom.ClipPlaneSet, curve: MSBsplineCurve, intervals: List[DSegment1d]) -> None
        
        Enumerate the " in " intervals .. the array is NOT cleared
        """
        ...
    
    @staticmethod
    def ClassifyCurvePrimitiveInSetDifference(curve: ICurvePrimitive, clipSet: MSPyBentleyGeom.ClipPlaneSet, maskSet: MSPyBentleyGeom.ClipPlaneSet) -> MSPyBentleyGeom.ClipPlaneContainment:
        """
        Determine if a CurveVector is completely in, completely out, or mixed
        with respect to a postive ClipPlaneSet and a mask (hole) ClipPlaneSet.
        
        :param curve:
        (input) curve to test
        
        :param clipSet:
        (input) the positive clip set
        
        :param maskSet:
        (input) the negative (holes) clip set
        """
        ...
    
    @staticmethod
    def ClassifyCurveVectorInSetDifference(curves: CurveVector, clipSet: MSPyBentleyGeom.ClipPlaneSet, maskSet: MSPyBentleyGeom.ClipPlaneSet, considerRegions: bool) -> MSPyBentleyGeom.ClipPlaneContainment:
        """
        Determine if a CurveVector is completely in, completely out, or mixed
        with respect to a postive ClipPlaneSet and a mask (hole) ClipPlaneSet.
        
        :param curves:
        (input) curves or region to clip.
        
        :param clipSet:
        (input) the positive clip set
        
        :param maskSet:
        (input) the negative (holes) clip set
        
        :param considerRegions:
        (input) if true, treat Outer, Inner, Parity, and Union regions as
        areas. If false, only consider boundaries.
        """
        ...
    
    def ClassifyPointContainment(self: MSPyBentleyGeom.ClipPlaneSet, points: List[DPoint3d], onIsOutsize: bool = False) -> MSPyBentleyGeom.ClipPlaneContainment:
        """
        @description return a summary classification
        
        * ClipPlaneContainment_StronglyInside All points are inside the plane
        set
        
        * ClipPlaneContainment_Ambiguous
        
        * ClipPlaneContainment_StronglyOut Strongly out. All points are out,
        and are all on one side of one of planes, so edges joining pairs of
        points will always be out also.
        """
        ...
    
    @staticmethod
    def ClassifyPolyfaceInSetDifference(polyface: PolyfaceQuery, clipSet: MSPyBentleyGeom.ClipPlaneSet, maskSet: MSPyBentleyGeom.ClipPlaneSet) -> MSPyBentleyGeom.ClipPlaneContainment:
        """
        Determine if a Polyface is completely in, completely out, or mixed
        with respect to a postive ClipPlaneSet and a mask (hole) ClipPlaneSet.
        
        :param polyface:
        (input) polyface to test
        
        :param clipSet:
        (input) the positive clip set
        
        :param maskSet:
        (input) the negative (holes) clip set
        """
        ...
    
    @staticmethod
    def ClipAndMaskPlanarRegion(outsideClip: MSPyBentleyGeom.ClipPlaneSet, holeClip: MSPyBentleyGeom.ClipPlaneSet, planarRegion: CurveVector) -> CurveVector:
        """
        Clip a planar region to the (optional) outsideClip. Subtract the
        (optional) holeClip.
        
        :param outsideClip:
        (input) optional outer clip
        
        :param holeClip:
        (input) optional hole clip
        
        :param planarRegion:
        A CurveVector of type Loop or ParityRegion.
        """
        ...
    
    def ClipPlanarRegion(self: MSPyBentleyGeom.ClipPlaneSet, planarRegion: CurveVector, localToWorld: Transform, worldToLocal: Transform) -> CurveVector:
        """
        Clip a planar region to this ClipPlaneset
        
        :param planarRegion:
        (input) A CurveVector of type Loop or ParityRegion.
        
        :param localToWorld:
        (output) transform from the plane of the planarRegion to world
        
        :param worldToLocal:
        (output) transform from world to the plane of the planarRegion
        """
        ...
    
    @staticmethod
    def ClipPlaneSetIntersectPolyface(polyface: PolyfaceQuery, clipSet: MSPyBentleyGeom.ClipPlaneSet, constructNewFacetsOnClipSetPlanes: bool) -> tuple:
        """
        Clip a polyface to a a postive ClipPlaneSet. This produces cut faces
        where the clipSet is inside the polyface. If the polyface is not
        closed, cut faces may be produced where sections are closed loops.
        
        :param polyface:
        (input) polyface to test
        
        :param clipSet:
        (input) the positive clip set
        
        :param constructNewFacetsOnClipSetPlanes:
        (input) true to construct new faces where clip planes are inside the
        facet.
        
        :param inside:
        (output) (optional) " inside " parts
        
        :param outside:
        (output) (optional) " outside " parts
        
        :param distanceTolerance:
        (optional) if nonzero, this is the distance tolerance for various
        internal steps. It is recommended that callers with metric data
        pass DoubleOps.SmallMetricDistance ().
        """
        ...
    
    @staticmethod
    def ClipToSetDifference(polyface: PolyfaceQuery, clipSet: MSPyBentleyGeom.ClipPlaneSet, maskSet: MSPyBentleyGeom.ClipPlaneSet) -> tuple:
        """
        Clip a polyface to a a postive ClipPlaneSet and a mask (hole)
        ClipPlaneSet.
        
        :param polyface:
        (input) polyface to test
        
        :param clipSet:
        (input) the positive clip set
        
        :param maskSet:
        (input) the negative (holes) clip set
        
        :param inside:
        (output) (optional) " inside " parts
        
        :param outside:
        (output) (optional) " outside " parts
        """
        ...
    
    @staticmethod
    def FromSweptPolygon(*args, **kwargs):
        """
        Overloaded function.
        
        1. FromSweptPolygon(points: List[DPoint3d], direction: DVec3d = None) -> MSPyBentleyGeom.ClipPlaneSet
        
        Create a (chain of) convex clippers for an (unbounded) polygon sweep
        in given direction. polygon may have disconnects. default sweep
        direction is Z
        
        2. FromSweptPolygon(points: list, direction: DVec3d = None) -> MSPyBentleyGeom.ClipPlaneSet
        
        Create a (chain of) convex clippers for an (unbounded) polygon sweep
        in given direction. polygon may have disconnects. default sweep
        direction is Z
        """
        ...
    
    def GetRange(self: MSPyBentleyGeom.ClipPlaneSet, range: DRange3d, transform: Transform) -> bool:
        """
        Get range of this ClipPlaneSet.
        """
        ...
    
    def GetRayIntersection(self: MSPyBentleyGeom.ClipPlaneSet, point: DPoint3d, direction: DVec3d) -> tuple:
        """
        Get nearest intersect distance along ray.
        """
        ...
    
    def IsAnyPointInOrOn(*args, **kwargs):
        """
        Overloaded function.
        
        1. IsAnyPointInOrOn(self: MSPyBentleyGeom.ClipPlaneSet, segment: DSegment3d) -> bool
        
        Clip a bounded line segment
        
        2. IsAnyPointInOrOn(self: MSPyBentleyGeom.ClipPlaneSet, arc: DEllipse3d) -> bool
        
        Clip a bounded line segment
        
        3. IsAnyPointInOrOn(self: MSPyBentleyGeom.ClipPlaneSet, curve: MSBsplineCurve) -> bool
        
        Clip a bounded line segment
        """
        ...
    
    def IsPointInside(self: MSPyBentleyGeom.ClipPlaneSet, point: DPoint3d) -> bool:
        """
        Test if point is inside.
        """
        ...
    
    def IsPointOnOrInside(self: MSPyBentleyGeom.ClipPlaneSet, point: DPoint3d, tolerance: float) -> bool:
        """
        Test if point is inside to supplied tolerance.
        """
        ...
    
    def IsSphereInside(self: MSPyBentleyGeom.ClipPlaneSet, point: DPoint3d, radius: float) -> bool:
        """
        Test if point is inside to supplied tolerance.
        """
        ...
    
    def MultiplyPlanesTimesMatrix(self: MSPyBentleyGeom.ClipPlaneSet, matrix: DMatrix4d) -> None:
        """
        multiply plane coefficients times a DMatrix4d (such as the worldToNPC
        matrix) multiply [ax,ay,az,aw] * matrix
        """
        ...
    
    @staticmethod
    def SweptPolygonClipPolyface(polyface: PolyfaceQuery, polygon: List[DPoint3d], sweepDirection: DVec3d, constructNewFacetsOnClipSetPlanes: bool) -> tuple:
        """
        Clip a polyface to a swept polygon. This produces side faces where the
        sweep makes a closed cut. If the polyface is not closed, cut faces may
        be produced where sections are closed loops.
        
        :param polyface:
        (input) polyface to test
        
        :param polygon:
        (input) polygon points.
        
        :param sweepDirection:
        (input) sweep direction for the polygon.
        
        :param constructNewFacetsOnClipSetPlanes:
        (input) true to construct new faces where clip planes are inside the
        facet.
        
        :param inside:
        (output) (optional) " inside " parts
        
        :param outside:
        (output) (optional) " outside " parts
        """
        ...
    
    def TestRayIntersect(self: MSPyBentleyGeom.ClipPlaneSet, point: DPoint3d, direction: DVec3d) -> bool:
        """
        Test for intersection with ray.
        """
        ...
    
    def TransformInPlace(self: MSPyBentleyGeom.ClipPlaneSet, transform: Transform) -> None:
        """
        Transform each plane set.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ClipPlaneSet) -> None
        
        2. __init__(self: MSPyBentleyGeom.ClipPlaneSet, planes: MSPyBentleyGeom.ClipPlaneArray) -> None
        
        3. __init__(self: MSPyBentleyGeom.ClipPlaneSet, convexSet: MSPyBentleyGeom.ConvexClipPlaneSet) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.ConvexClipPlaneSetArray, x: MSPyBentleyGeom.ConvexClipPlaneSet) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.ConvexClipPlaneSetArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.ConvexClipPlaneSetArray, L: MSPyBentleyGeom.ConvexClipPlaneSetArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.ConvexClipPlaneSetArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.ConvexClipPlaneSetArray, i: int, x: MSPyBentleyGeom.ConvexClipPlaneSet) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.ConvexClipPlaneSetArray) -> MSPyBentleyGeom.ConvexClipPlaneSet
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.ConvexClipPlaneSetArray, i: int) -> MSPyBentleyGeom.ConvexClipPlaneSet
        
        Remove and return the item at index ``i``
        """
        ...
    
class CompoundDrawState:
    """
    None
    """

    @property
    def ConditionalBlockIndices(arg0: MSPyBentleyGeom.CompoundDrawState) -> MSPyBentleyGeom.UInt64Array:
        ...
    
    @property
    def DebugString(arg0: MSPyBentleyGeom.CompoundDrawState) -> MSPyBentley.WString:
        ...
    
    @property
    def DrawGeomMethodIndex(arg0: MSPyBentleyGeom.CompoundDrawState) -> int:
        ...
    @DrawGeomMethodIndex.setter
    def DrawGeomMethodIndex(arg0: MSPyBentleyGeom.CompoundDrawState, arg1: int) -> None:
        ...
    
    def GetConditionalBlockIndices(self: MSPyBentleyGeom.CompoundDrawState) -> MSPyBentleyGeom.UInt64Array:
        """
        return (reference to) the stored block indices.
        """
        ...
    
    def GetDebugString(self: MSPyBentleyGeom.CompoundDrawState) -> MSPyBentley.WString:
        """
        Return debug representation.
        """
        ...
    
    def GetDrawGeomMethodIndex(self: MSPyBentleyGeom.CompoundDrawState) -> int:
        ...
    
    def Load(self: MSPyBentleyGeom.CompoundDrawState, data: MSPyBentleyGeom.UInt16Array) -> None:
        """
        Copy data from the caller's memory into this CompoundDrawState.
        """
        ...
    
    def SetDrawGeomMethodIndex(self: MSPyBentleyGeom.CompoundDrawState, index: int) -> None:
        """
        set the drawGeom index.
        """
        ...
    
    def Store(self: MSPyBentleyGeom.CompoundDrawState, arg0: MSPyBentleyGeom.UInt16Array) -> None:
        """
        copy all data into the caller's bvector.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.CompoundDrawState) -> None
        
        2. __init__(self: MSPyBentleyGeom.CompoundDrawState, drawIndex: int, conditionBlockIndices: MSPyBentleyGeom.UInt64Array) -> None
        
        3. __init__(self: MSPyBentleyGeom.CompoundDrawState, rhs: MSPyBentleyGeom.CompoundDrawState) -> None
        """
        ...
    
class ConvexClipPlaneSet:
    """
    None
    """

    def Add(self: MSPyBentleyGeom.ConvexClipPlaneSet, plane: MSPyBentleyGeom.ValidatedClipPlane) -> bool:
        """
        Add the plane if it is valid.
        """
        ...
    
    def AddSweptPolyline(self: MSPyBentleyGeom.ConvexClipPlaneSet, points: List[DPoint3d], upVector: DVec3d, tiltAngle: MSPyBentleyGeom.Angle) -> None:
        """
        Add space " to the left of a polyline ", with left determined by edges
        and an upvector. ul> li>If teh polyline is closed, an orientation test
        is done and the point order is reveresed if needed to be sure the
        planes are oriented to enclose the space. li>For each edge of the
        polyline, the primary plane has its primary outward normal as edge
        vector cross up vector. li>The normal is then rotated by the tilt
        angle towards the up vector. li>to close around a polygon, repeat the
        first point at end. li>When closed, this correspondes to a CCW polygon
        with the upVector pointing at the eye, and the volume expands behind
        the polygon li> ul
        """
        ...
    
    def AppendCrossings(*args, **kwargs):
        """
        Overloaded function.
        
        1. AppendCrossings(self: MSPyBentleyGeom.ConvexClipPlaneSet, curves: CurveVector, crossings: List[CurveLocationDetailPair]) -> None
        
        Compute crossings of this set's planes with curve primitives within a
        CurveVector.
        
        :param (input):
        curves candidate curves
        
        :param (output):
        crossings detailed crossing data.
        
        2. AppendCrossings(self: MSPyBentleyGeom.ConvexClipPlaneSet, curve: ICurvePrimitive, crossings: List[CurveLocationDetailPair]) -> None
        
        Compute crossings of this set's planes with curve primitives within a
        CurveVector.
        
        :param (input):
        curves candidate curves
        
        :param (output):
        crossings detailed crossing data.
        """
        ...
    
    def AppendIntervals(*args, **kwargs):
        """
        Overloaded function.
        
        1. AppendIntervals(self: MSPyBentleyGeom.ConvexClipPlaneSet, arc: DEllipse3d, intervals: List[DSegment1d], planeSign: float = 1.0) -> bool
        
        Enumerate the " in " intervals .. the array is NOT cleared If the
        intervals array is nullptr, returns true immediately when any interior
        interval is found.
        
        2. AppendIntervals(self: MSPyBentleyGeom.ConvexClipPlaneSet, curve: MSBsplineCurve, intervals: List[DSegment1d]) -> bool
        
        Enumerate the " in " intervals .. the array is NOT cleared If the
        intervals array is nullptr, returns true immediately when any interior
        interval is found.
        """
        ...
    
    def ClassifyPointContainment(self: MSPyBentleyGeom.ConvexClipPlaneSet, points: List[DPoint3d], onIsOutsize: bool = False) -> MSPyBentleyGeom.ClipPlaneContainment:
        """
        @description return a summary classification
        
        * ClipPlaneContainment_StronglyInside All points are inside the plane
        set
        
        * ClipPlaneContainment_Ambiguous
        
        * ClipPlaneContainment_StronglyOut Strongly out. All points are out,
        and are all on one side of one of planes, so edges joining pairs of
        points will always be out also.
        """
        ...
    
    def ClipBoundedSegment(self: MSPyBentleyGeom.ConvexClipPlaneSet, pointA: DPoint3d, pointB: DPoint3d, planeSign: float = 1.0) -> tuple:
        """
        Clip a (bounded) line segment to this set of planes.
        """
        ...
    
    def ClipPointsOnOrInside(self: MSPyBentleyGeom.ConvexClipPlaneSet, points: List[DPoint3d], inOrOn: List[DPoint3d], out: List[DPoint3d]) -> None:
        """
        Clip points.
        """
        ...
    
    def ClipUnBoundedSegment(self: MSPyBentleyGeom.ConvexClipPlaneSet, pointA: DPoint3d, pointB: DPoint3d, planeSign: float = 1.0) -> tuple:
        """
        Clip an unbounded line to this set of planes.
        """
        ...
    
    def ConvexPolygonClip(*args, **kwargs):
        """
        Overloaded function.
        
        1. ConvexPolygonClip(self: MSPyBentleyGeom.ConvexClipPlaneSet, input: List[DPoint3d], output: List[DPoint3d], work: List[DPoint3d]) -> None
        
        Return the (polygon) of intersection
        
        2. ConvexPolygonClip(self: MSPyBentleyGeom.ConvexClipPlaneSet, input: List[DPoint3d], output: List[DPoint3d], work: List[DPoint3d], onPlaneHandling: int) -> None
        
        Return the (polygon) of intersection
        
        3. ConvexPolygonClip(self: MSPyBentleyGeom.ConvexClipPlaneSet, input: list, output: list, work: list) -> None
        
        Return the (polygon) of intersection
        
        4. ConvexPolygonClip(self: MSPyBentleyGeom.ConvexClipPlaneSet, input: list, output: list, work: list, onPlaneHandling: int) -> None
        
        Return the (polygon) of intersection
        """
        ...
    
    @staticmethod
    def FromXYPolyLine(points: List[DPoint3d], hiddenEdge: MSPyBentleyGeom.BoolArray, leftIsInside: bool) -> MSPyBentleyGeom.ConvexClipPlaneSet:
        """
        Create clip plane set for regiosn to one side of a polyline. If
        hiddenEdge is an empty array, all clips are marked as regular
        clippers. The hiddenEdge array must contain a boolean (usual false)
        for each point of the points array. If (true), clip output from that
        intersections with that edge may be made invisible by some later
        methods.
        """
        ...
    
    def GetRange(self: MSPyBentleyGeom.ConvexClipPlaneSet, range: DRange3d, transform: Transform) -> bool:
        """
        Get range of this ConvexClipPlaneSet.
        """
        ...
    
    def IsPointInside(self: MSPyBentleyGeom.ConvexClipPlaneSet, point: DPoint3d) -> bool:
        """
        Test if point is inside all planes.
        """
        ...
    
    def IsPointOnOrInside(self: MSPyBentleyGeom.ConvexClipPlaneSet, point: DPoint3d, tolerance: float) -> bool:
        """
        Test if point is inside all planes to supplied tolerance.
        """
        ...
    
    def IsSphereInside(self: MSPyBentleyGeom.ConvexClipPlaneSet, point: DPoint3d, tolerance: float) -> bool:
        """
        Test if sphere is inside all planes.
        """
        ...
    
    def MultiplyPlanesTimesMatrix(self: MSPyBentleyGeom.ConvexClipPlaneSet, matrix: DMatrix4d) -> None:
        """
        multiply plane coefficients times a DMatrix4d (such as the worldToNPC
        matrix) multiply [ax,ay,az,aw] * matrix
        """
        ...
    
    def ReloadSweptConvexPolygon(self: MSPyBentleyGeom.ConvexClipPlaneSet, points: List[DPoint3d], sweepDirection: DVec3d, sideSelect: int) -> int:
        """
        reinitialize to clip to a swept polygon. ul> li> 1 -- success, and the
        sweep vector and polygon area normal have positive dot product li> -1
        -- success, and the sweep vector and polygon area normal have negative
        dot product ul> 0 -- failure - polygon normal is perpendicular to
        sweep.
        """
        ...
    
    def TransformInPlace(self: MSPyBentleyGeom.ConvexClipPlaneSet, transform: Transform) -> None:
        """
        Transform plane set.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ConvexClipPlaneSet) -> None
        
        2. __init__(self: MSPyBentleyGeom.ConvexClipPlaneSet, n: int) -> None
        
        3. __init__(self: MSPyBentleyGeom.ConvexClipPlaneSet, planes: MSPyBentleyGeom.ClipPlaneArray) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.ClipPlaneArray, x: MSPyBentleyGeom.ClipPlane) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.ClipPlaneArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.ClipPlaneArray, L: MSPyBentleyGeom.ClipPlaneArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.ClipPlaneArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.ClipPlaneArray, i: int, x: MSPyBentleyGeom.ClipPlane) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.ClipPlaneArray) -> MSPyBentleyGeom.ClipPlane
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.ClipPlaneArray, i: int) -> MSPyBentleyGeom.ClipPlane
        
        Remove and return the item at index ``i``
        """
        ...
    
class ConvexClipPlaneSetArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ConvexClipPlaneSetArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.ConvexClipPlaneSetArray, arg0: MSPyBentleyGeom.ConvexClipPlaneSetArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.ConvexClipPlaneSetArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.ConvexClipPlaneSetArray, x: MSPyBentleyGeom.ConvexClipPlaneSet) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.ConvexClipPlaneSetArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.ConvexClipPlaneSetArray, L: MSPyBentleyGeom.ConvexClipPlaneSetArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.ConvexClipPlaneSetArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.ConvexClipPlaneSetArray, i: int, x: MSPyBentleyGeom.ConvexClipPlaneSet) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.ConvexClipPlaneSetArray) -> MSPyBentleyGeom.ConvexClipPlaneSet
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.ConvexClipPlaneSetArray, i: int) -> MSPyBentleyGeom.ConvexClipPlaneSet
        
        Remove and return the item at index ``i``
        """
        ...
    
class CurveAndSolidLocationDetail:
    """
    None
    """

    def __init__(self: MSPyBentleyGeom.CurveAndSolidLocationDetail, curveDetail: MSPyBentleyGeom.CurveLocationDetail, solidDetail: MSPyBentleyGeom.SolidLocationDetail) -> None:
        ...
    
    @property
    def curveDetail(self: MSPyBentleyGeom.CurveAndSolidLocationDetail) -> MSPyBentleyGeom.CurveLocationDetail:
        ...
    @curveDetail.setter
    def curveDetail(self: MSPyBentleyGeom.CurveAndSolidLocationDetail, arg0: MSPyBentleyGeom.CurveLocationDetail) -> None:
        ...
    
    @property
    def solidDetail(self: MSPyBentleyGeom.CurveAndSolidLocationDetail) -> MSPyBentleyGeom.SolidLocationDetail:
        ...
    @solidDetail.setter
    def solidDetail(self: MSPyBentleyGeom.CurveAndSolidLocationDetail, arg0: MSPyBentleyGeom.SolidLocationDetail) -> None:
        ...
    
class CurveAndSolidLocationDetailArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.CurveAndSolidLocationDetailArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.CurveAndSolidLocationDetailArray, arg0: MSPyBentleyGeom.CurveAndSolidLocationDetailArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.CurveAndSolidLocationDetailArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.CurveAndSolidLocationDetailArray, x: MSPyBentleyGeom.CurveAndSolidLocationDetail) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.CurveAndSolidLocationDetailArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.CurveAndSolidLocationDetailArray, L: MSPyBentleyGeom.CurveAndSolidLocationDetailArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.CurveAndSolidLocationDetailArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.CurveAndSolidLocationDetailArray, i: int, x: MSPyBentleyGeom.CurveAndSolidLocationDetail) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.CurveAndSolidLocationDetailArray) -> MSPyBentleyGeom.CurveAndSolidLocationDetail
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.CurveAndSolidLocationDetailArray, i: int) -> MSPyBentleyGeom.CurveAndSolidLocationDetail
        
        Remove and return the item at index ``i``
        """
        ...
    
class CurveCurve:
    """
    None
    """

    @staticmethod
    def CloseApproach(pointsOnA: MSPyBentleyGeom.CurveVector, pointsOnB: MSPyBentleyGeom.CurveVector, curveA: MSPyBentleyGeom.ICurvePrimitive, curveB: MSPyBentleyGeom.ICurvePrimitive, maxDist: float = 1.7976931348623157e+308) -> None:
        ...
    
    @staticmethod
    def ClosestApproach(*args, **kwargs):
        """
        Overloaded function.
        
        1. ClosestApproach(pointOnA: MSPyBentleyGeom.CurveLocationDetail, pointOnB: MSPyBentleyGeom.CurveLocationDetail, curveA: MSPyBentleyGeom.ICurvePrimitive, curveB: MSPyBentleyGeom.ICurvePrimitive) -> bool
        
        2. ClosestApproach(pointOnA: MSPyBentleyGeom.CurveLocationDetail, pointOnB: MSPyBentleyGeom.CurveLocationDetail, chainA: MSPyBentleyGeom.CurveVector, chainB: MSPyBentleyGeom.CurveVector) -> bool
        """
        ...
    
    @staticmethod
    def ClosestApproachNewton(arg0: MSPyBentleyGeom.ICurvePrimitive, arg1: MSPyBentleyGeom.ICurvePrimitive) -> tuple:
        ...
    
    @staticmethod
    def CollectBlends(*args, **kwargs):
        """
        Overloaded function.
        
        1. CollectBlends(curveA: MSPyBentleyGeom.ICurvePrimitive, curveB: MSPyBentleyGeom.ICurvePrimitive, blendType: MSPyBentleyGeom.BlendType, distanceA: float, distanceB: float, extend: bool, blendCurves: MSPyBentleyGeom.BlendDetailArray) -> None
        
        2. CollectBlends(chainA: MSPyBentleyGeom.CurveVector, chainB: MSPyBentleyGeom.CurveVector, blendType: MSPyBentleyGeom.BlendType, distanceA: float, distanceB: float, extend: bool, blendCurves: MSPyBentleyGeom.BlendDetailArray) -> None
        """
        ...
    
    @staticmethod
    def CollectFilletArcs(*args, **kwargs):
        """
        Overloaded function.
        
        1. CollectFilletArcs(curveA: MSPyBentleyGeom.ICurvePrimitive, curveB: MSPyBentleyGeom.ICurvePrimitive, radius: float, extend: bool, arcs: MSPyBentleyGeom.FilletDetailArray) -> None
        
        2. CollectFilletArcs(chainA: MSPyBentleyGeom.CurveVector, chainB: MSPyBentleyGeom.CurveVector, radius: float, extend: bool, arcs: MSPyBentleyGeom.FilletDetailArray) -> None
        """
        ...
    
    class FilletDetail:
        """
        None
        """
    
        def __init__(*args, **kwargs):
            """
            Initialize self.  See help(type(self)) for accurate signature.
            """
            ...
        
        @property
        def arc(self: MSPyBentleyGeom.CurveCurve.FilletDetail) -> DEllipse3d:
            ...
        @arc.setter
        def arc(self: MSPyBentleyGeom.CurveCurve.FilletDetail, arg0: DEllipse3d) -> None:
            ...
        
        @property
        def detailA(self: MSPyBentleyGeom.CurveCurve.FilletDetail) -> MSPyBentleyGeom.CurveLocationDetail:
            ...
        @detailA.setter
        def detailA(self: MSPyBentleyGeom.CurveCurve.FilletDetail, arg0: MSPyBentleyGeom.CurveLocationDetail) -> None:
            ...
        
        @property
        def detailB(self: MSPyBentleyGeom.CurveCurve.FilletDetail) -> MSPyBentleyGeom.CurveLocationDetail:
            ...
        @detailB.setter
        def detailB(self: MSPyBentleyGeom.CurveCurve.FilletDetail, arg0: MSPyBentleyGeom.CurveLocationDetail) -> None:
            ...
        
    @staticmethod
    def GetPartialCurveDetailPair(intersectionA: MSPyBentleyGeom.CurveVector, intersectionB: MSPyBentleyGeom.CurveVector, i: int, detailA: MSPyBentleyGeom.PartialCurveDetail, detailB: MSPyBentleyGeom.PartialCurveDetail) -> bool:
        """
        Convenience function for extracting PartialCurveDetail data from two
        arrays returned by CurveCurve.IntersectionsXY return false if index
        out of range or addresses something other than PartialCurveData.
        
        :param (input):
        intersectionA first source vector
        
        :param (input):
        intersectionB second source vector
        
        :param (input):
        i index to acccess in source vectors.
        
        :param (output):
        detailA data from intersectionA
        
        :param (output):
        detailB data from intersectionB
        """
        ...
    
    @staticmethod
    def IntersectRotatedCurveSpaceCurve(worldToLocal: Transform, rotatedCurve: MSPyBentleyGeom.CurveVector, spaceCurve: MSPyBentleyGeom.ICurvePrimitive, detailA: MSPyBentleyGeom.CurveLocationDetailArray, detailB: MSPyBentleyGeom.CurveLocationDetailArray) -> None:
        """
        Compute intersections of (a) a curve rotated around an axis and (b) a
        space curve.
        """
        ...
    
    @staticmethod
    def IntersectionsXY(*args, **kwargs):
        """
        Overloaded function.
        
        1. IntersectionsXY(intersectionA: MSPyBentleyGeom.CurveVector, intersectionB: MSPyBentleyGeom.CurveVector, curveA: MSPyBentleyGeom.CurveVector, curveB: MSPyBentleyGeom.CurveVector, pWorldToLocal: DMatrix4d) -> None
        
        2. IntersectionsXY(intersectionA: MSPyBentleyGeom.CurveVector, intersectionB: MSPyBentleyGeom.CurveVector, curveA: MSPyBentleyGeom.ICurvePrimitive, curveB: MSPyBentleyGeom.ICurvePrimitive, pWorldToLocal: DMatrix4d, extend: bool = False) -> None
        
        3. IntersectionsXY(intersectionA: MSPyBentleyGeom.CurveVector, intersectionB: MSPyBentleyGeom.CurveVector, curveA: MSPyBentleyGeom.ICurvePrimitive, curveB: MSPyBentleyGeom.CurveVector, pWorldToLocal: DMatrix4d) -> None
        
        4. IntersectionsXY(intersectionA: MSPyBentleyGeom.CurveVector, intersectionB: MSPyBentleyGeom.CurveVector, curveA: MSPyBentleyGeom.ICurvePrimitive, curveB: MSPyBentleyGeom.ICurvePrimitive, pWorldToLocal: DMatrix4d, extendA0: bool, extendA1: bool, extendB0: bool, extendB1: bool) -> None
        """
        ...
    
    @staticmethod
    def IsContained(intersectionA: MSPyBentleyGeom.CurveVector, intersectionB: MSPyBentleyGeom.CurveVector, i: int, j: int, considerSinglePoints: bool, considerIntervals: bool) -> bool:
        """
        Test if interval i is contained in interval j.
        """
        ...
    
    @staticmethod
    def IsSinglePointPair(*args, **kwargs):
        """
        Overloaded function.
        
        1. IsSinglePointPair(arg0: MSPyBentleyGeom.CurveVector, arg1: MSPyBentleyGeom.CurveVector, arg2: int) -> tuple
        
        2. IsSinglePointPair(intersectionA: MSPyBentleyGeom.CurveVector, intersectionB: MSPyBentleyGeom.CurveVector, i: int, detailA: MSPyBentleyGeom.CurveLocationDetail, detailB: MSPyBentleyGeom.CurveLocationDetail) -> bool
        """
        ...
    
    @staticmethod
    def TransverseRegionIntersectionSegments(regionA: MSPyBentleyGeom.CurveVector, regionB: MSPyBentleyGeom.CurveVector, segments: List[DSegment3d]) -> bool:
        """
        Determine the line of intersection of the planes of the two containing
        planes. In that line, find all segments as split by the two curve
        vectors. Return false if the curve vectors are not individually planar
        or are not closed
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    
class CurveGapOptions:
    """
    None
    """

    @property
    def EqualPointTolerance(arg0: MSPyBentleyGeom.CurveGapOptions) -> float:
        ...
    @EqualPointTolerance.setter
    def EqualPointTolerance(arg0: MSPyBentleyGeom.CurveGapOptions, arg1: float) -> None:
        ...
    
    def GetEqualPointTolerance(self: MSPyBentleyGeom.CurveGapOptions) -> float:
        """
        :returns:
        tolerance for gaps that do not have to be closed at all.
        """
        ...
    
    def GetMaxAdjustAlongCurve(self: MSPyBentleyGeom.CurveGapOptions) -> float:
        """
        :returns:
        max allowable motion along a curve.
        """
        ...
    
    def GetMaxDirectAdjustTolerance(self: MSPyBentleyGeom.CurveGapOptions) -> float:
        """
        :returns:
        max allowable motion of line and linestring endpoints.
        """
        ...
    
    def GetRemovePriorGapPrimitives(self: MSPyBentleyGeom.CurveGapOptions) -> bool:
        """
        :returns:
        flag to remove prior gap primitives
        """
        ...
    
    @property
    def MaxAdjustAlongCurve(arg0: MSPyBentleyGeom.CurveGapOptions) -> float:
        ...
    @MaxAdjustAlongCurve.setter
    def MaxAdjustAlongCurve(arg0: MSPyBentleyGeom.CurveGapOptions, arg1: float) -> None:
        ...
    
    @property
    def MaxDirectAdjustTolerance(arg0: MSPyBentleyGeom.CurveGapOptions) -> float:
        ...
    @MaxDirectAdjustTolerance.setter
    def MaxDirectAdjustTolerance(arg0: MSPyBentleyGeom.CurveGapOptions, arg1: float) -> None:
        ...
    
    @property
    def RemovePriorGapPrimitives(arg0: MSPyBentleyGeom.CurveGapOptions) -> bool:
        ...
    @RemovePriorGapPrimitives.setter
    def RemovePriorGapPrimitives(arg0: MSPyBentleyGeom.CurveGapOptions, arg1: bool) -> None:
        ...
    
    def SetEqualPointTolerance(self: MSPyBentleyGeom.CurveGapOptions, value: float) -> None:
        """
        Set gap size that does not need to be corrected.
        """
        ...
    
    def SetMaxAdjustAlongCurve(self: MSPyBentleyGeom.CurveGapOptions, value: float) -> None:
        """
        Set max motion along a curve.
        """
        ...
    
    def SetMaxDirectAdjustTolerance(self: MSPyBentleyGeom.CurveGapOptions, value: float) -> None:
        """
        Set max allowable motion of line and linestring endpoints.
        """
        ...
    
    def SetRemovePriorGapPrimitives(self: MSPyBentleyGeom.CurveGapOptions, value: bool) -> None:
        """
        Set flag to remove prior gap primitives
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.CurveGapOptions) -> None
        
        2. __init__(self: MSPyBentleyGeom.CurveGapOptions, equalPointTolerance: float, maxDirectAdjust: float, maxAdjustAlongCurve: float) -> None
        """
        ...
    
class CurveKeyPointCollector:
    """
    None
    """

    def EnableKeyPointType(self: MSPyBentleyGeom.CurveKeyPointCollector, selector: MSPyBentleyGeom.CurveKeyPointCollector.KeyPointType, value: bool) -> None:
        """
        Indicate keypoint preference
        """
        ...
    
    def EnableSingleKeyPointType(self: MSPyBentleyGeom.CurveKeyPointCollector, selector: MSPyBentleyGeom.CurveKeyPointCollector.KeyPointType) -> None:
        """
        Indicate keypoint preference, and suppress all others.
        """
        ...
    
    def GetWorldToLocal(self: MSPyBentleyGeom.CurveKeyPointCollector, worldToLocal: DMatrix4d) -> bool:
        """
        Query the worldTolocal matrix.
        """
        ...
    
    class KeyPointType:
        """
        Members:
        
        eEndPoint
        
        ePerpendicular
        
        eTangency
        
        eBreakPoint
        
        eNumTypes
        """
    
        def __init__(self: MSPyBentleyGeom.CurveKeyPointCollector.KeyPointType, value: int) -> None:
            ...
        
        eBreakPoint: KeyPointType
        
        eEndPoint: KeyPointType
        
        eNumTypes: KeyPointType
        
        ePerpendicular: KeyPointType
        
        eTangency: KeyPointType
        
        @property
        def name(self: handle) -> str:
            ...
        
        @property
        def value(arg0: MSPyBentleyGeom.CurveKeyPointCollector.KeyPointType) -> int:
            ...
        
    def NeedKeyPointType(self: MSPyBentleyGeom.CurveKeyPointCollector, selector: MSPyBentleyGeom.CurveKeyPointCollector.KeyPointType) -> bool:
        """
        Ask if a particular KeyPointType is requested.
        """
        ...
    
    def SetXYOnly(self: MSPyBentleyGeom.CurveKeyPointCollector, worldToLocal: DMatrix4d) -> None:
        """
        Request projection to XY plane.
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.CurveKeyPointCollector) -> None:
        ...
    
    eBreakPoint: KeyPointType
    
    eEndPoint: KeyPointType
    
    eNumTypes: KeyPointType
    
    ePerpendicular: KeyPointType
    
    eTangency: KeyPointType
    
class CurveKeyPoint_ClosestPointCollector:
    """
    None
    """

    def AnnouncePoint(self: MSPyBentleyGeom.CurveKeyPoint_ClosestPointCollector, worldDetail: MSPyBentleyGeom.CurveLocationDetail, selector: MSPyBentleyGeom.CurveKeyPointCollector.KeyPointType) -> None:
        """
        Announce a keypoint in world form. Derived class override captures as
        needed.
        """
        ...
    
    def EnableKeyPointType(self: MSPyBentleyGeom.CurveKeyPointCollector, selector: MSPyBentleyGeom.CurveKeyPointCollector.KeyPointType, value: bool) -> None:
        """
        Indicate keypoint preference
        """
        ...
    
    def EnableSingleKeyPointType(self: MSPyBentleyGeom.CurveKeyPointCollector, selector: MSPyBentleyGeom.CurveKeyPointCollector.KeyPointType) -> None:
        """
        Indicate keypoint preference, and suppress all others.
        """
        ...
    
    def GetResult(self: MSPyBentleyGeom.CurveKeyPoint_ClosestPointCollector) -> tuple:
        """
        Access the saved detail
        """
        ...
    
    def GetWorldToLocal(self: MSPyBentleyGeom.CurveKeyPointCollector, worldToLocal: DMatrix4d) -> bool:
        """
        Query the worldTolocal matrix.
        """
        ...
    
    class KeyPointType:
        """
        Members:
        
        eEndPoint
        
        ePerpendicular
        
        eTangency
        
        eBreakPoint
        
        eNumTypes
        """
    
        def __init__(self: MSPyBentleyGeom.CurveKeyPointCollector.KeyPointType, value: int) -> None:
            ...
        
        eBreakPoint: KeyPointType
        
        eEndPoint: KeyPointType
        
        eNumTypes: KeyPointType
        
        ePerpendicular: KeyPointType
        
        eTangency: KeyPointType
        
        @property
        def name(self: handle) -> str:
            ...
        
        @property
        def value(arg0: MSPyBentleyGeom.CurveKeyPointCollector.KeyPointType) -> int:
            ...
        
    def NeedKeyPointType(self: MSPyBentleyGeom.CurveKeyPointCollector, selector: MSPyBentleyGeom.CurveKeyPointCollector.KeyPointType) -> bool:
        """
        Ask if a particular KeyPointType is requested.
        """
        ...
    
    def SetXYOnly(self: MSPyBentleyGeom.CurveKeyPointCollector, worldToLocal: DMatrix4d) -> None:
        """
        Request projection to XY plane.
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.CurveKeyPoint_ClosestPointCollector, biasPoint: DPoint3d) -> None:
        ...
    
    eBreakPoint: KeyPointType
    
    eEndPoint: KeyPointType
    
    eNumTypes: KeyPointType
    
    ePerpendicular: KeyPointType
    
    eTangency: KeyPointType
    
class CurveLocationDetail:
    """
    None
    """

    def AlmostEqualPoint(self: MSPyBentleyGeom.CurveLocationDetail, other: MSPyBentleyGeom.CurveLocationDetail) -> bool:
        """
        test if point coordinates are AlmostEqual
        """
        ...
    
    def Distance(self: MSPyBentleyGeom.CurveLocationDetail, other: MSPyBentleyGeom.CurveLocationDetail) -> float:
        """
        Return distance between point fields of this and other.
        """
        ...
    
    def Interpolate(*args, **kwargs):
        """
        Overloaded function.
        
        1. Interpolate(self: MSPyBentleyGeom.CurveLocationDetail, param: MSPyBentleyGeom.DoubleArray) -> tuple
        
        Use the componentIndex and componentFraction to interpolate doubles.
        
        2. Interpolate(self: MSPyBentleyGeom.CurveLocationDetail, fraction: float, dataB: MSPyBentleyGeom.CurveLocationDetail) -> MSPyBentleyGeom.ValidatedCurveLocationDetail
        
        Use the componentIndex and componentFraction to interpolate doubles.
        """
        ...
    
    def PointAndUnitTangent(self: MSPyBentleyGeom.CurveLocationDetail) -> ValidatedValue<DRay3d:
        """
        Try to evalute the point and unit tangent at the detail's fraction
        """
        ...
    
    def SetComponentFractionFromFraction(self: MSPyBentleyGeom.CurveLocationDetail, globalFraction: float, numComponent: int) -> None:
        """
        Set the componentIndex, numComponent, componentFraction, and fraction.
        (Component fraction and index are computed from global fraction and
        indices) All other data (point, curve pointer, a) is left unchanged.
        """
        ...
    
    def SetDistance(self: MSPyBentleyGeom.CurveLocationDetail, value: float) -> None:
        """
        set distance field ({a})
        """
        ...
    
    def SetDistanceFrom(self: MSPyBentleyGeom.CurveLocationDetail, refPoint: DPoint3d) -> float:
        """
        set xyz distance from point.
        """
        ...
    
    def SetFractionFromComponentFraction(self: MSPyBentleyGeom.CurveLocationDetail, componentFraction: float, componentIndex: int, numComponent: int) -> None:
        """
        Set the componentIndex, numComponent, componentFraction, and fraction.
        (Global fraction is computed as (componentIndex + componentFraction)/
        numComponent. All other data (point, curve pointer, a) is left
        unchanged.
        """
        ...
    
    def SetMaxDistance(self: MSPyBentleyGeom.CurveLocationDetail) -> None:
        """
        set distance to very large value.
        """
        ...
    
    def SetSingleComponentData(self: MSPyBentleyGeom.CurveLocationDetail) -> None:
        """
        copy fraction to componentFraction and set component index and count
        for single component.
        """
        ...
    
    def SetSingleComponentFractionAndA(self: MSPyBentleyGeom.CurveLocationDetail, fraction: float, a: float) -> None:
        """
        Set fraction and a fields from parameters. Make the component fraction
        match. Set componentIndex and numComponentIndex to 0 and 1.
        """
        ...
    
    @staticmethod
    def SortByCurveAndFraction(detail: MSPyBentleyGeom.CurveLocationDetailArray) -> None:
        """
        Sort to gather CurveLocationDetail's with same curve, and then by
        fraction within those curves.
        """
        ...
    
    def TryComponentFractionToPoint(self: MSPyBentleyGeom.CurveLocationDetail, xyz: DPoint3d, dXdf: DVec3d) -> bool:
        """
        Try to evaluate the referenced curve at the detail's component
        fraction.
        """
        ...
    
    def TryFractionToPoint(self: MSPyBentleyGeom.CurveLocationDetail, xyz: DPoint3d, dXdf: DVec3d) -> bool:
        """
        Try to evaluate the referenced curve at the detail's fraction.
        """
        ...
    
    def UpdateIfCloser(self: MSPyBentleyGeom.CurveLocationDetail, otherDetail: MSPyBentleyGeom.CurveLocationDetail) -> bool:
        """
        conditional replace candidate, with minDistance update if needed.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.CurveLocationDetail) -> None
        
        2. __init__(self: MSPyBentleyGeom.CurveLocationDetail, curve: ICurvePrimitive, numComponent: int = 1) -> None
        
        3. __init__(self: MSPyBentleyGeom.CurveLocationDetail, curve: ICurvePrimitive, fraction: float, point: DPoint3d) -> None
        
        4. __init__(self: MSPyBentleyGeom.CurveLocationDetail, curve: ICurvePrimitive, fraction: float, point: DPoint3d, componentIndex: int, numComponent: int, componentFraction: float) -> None
        
        5. __init__(self: MSPyBentleyGeom.CurveLocationDetail, curve: ICurvePrimitive, fraction: float, point: DPoint3d, componentIndex: int, numComponent: int, componentFraction: float, a: float) -> None
        """
        ...
    
    @property
    def a(self: MSPyBentleyGeom.CurveLocationDetail) -> float:
        ...
    @a.setter
    def a(self: MSPyBentleyGeom.CurveLocationDetail, arg0: float) -> None:
        ...
    
    @property
    def componentFraction(self: MSPyBentleyGeom.CurveLocationDetail) -> float:
        ...
    @componentFraction.setter
    def componentFraction(self: MSPyBentleyGeom.CurveLocationDetail, arg0: float) -> None:
        ...
    
    @property
    def componentIndex(self: MSPyBentleyGeom.CurveLocationDetail) -> int:
        ...
    @componentIndex.setter
    def componentIndex(self: MSPyBentleyGeom.CurveLocationDetail, arg0: int) -> None:
        ...
    
    @property
    def curve(arg0: MSPyBentleyGeom.CurveLocationDetail) -> ICurvePrimitive:
        ...
    
    @property
    def fraction(self: MSPyBentleyGeom.CurveLocationDetail) -> float:
        ...
    @fraction.setter
    def fraction(self: MSPyBentleyGeom.CurveLocationDetail, arg0: float) -> None:
        ...
    
    @property
    def numComponent(self: MSPyBentleyGeom.CurveLocationDetail) -> int:
        ...
    @numComponent.setter
    def numComponent(self: MSPyBentleyGeom.CurveLocationDetail, arg0: int) -> None:
        ...
    
    @property
    def point(self: MSPyBentleyGeom.CurveLocationDetail) -> DPoint3d:
        ...
    @point.setter
    def point(self: MSPyBentleyGeom.CurveLocationDetail, arg0: DPoint3d) -> None:
        ...
    
class CurveLocationDetailArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.CurveLocationDetailArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.CurveLocationDetailArray, arg0: MSPyBentleyGeom.CurveLocationDetailArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.CurveLocationDetailArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.CurveLocationDetailArray, x: MSPyBentleyGeom.CurveLocationDetail) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.CurveLocationDetailArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.CurveLocationDetailArray, L: MSPyBentleyGeom.CurveLocationDetailArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.CurveLocationDetailArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.CurveLocationDetailArray, i: int, x: MSPyBentleyGeom.CurveLocationDetail) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.CurveLocationDetailArray) -> MSPyBentleyGeom.CurveLocationDetail
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.CurveLocationDetailArray, i: int) -> MSPyBentleyGeom.CurveLocationDetail
        
        Remove and return the item at index ``i``
        """
        ...
    
class CurveLocationDetailPair:
    """
    None
    """

    def GetDSegment3d(self: MSPyBentleyGeom.CurveLocationDetailPair) -> DSegment3d:
        """
        assemble points from detailA, detailB into a DSegment3d.
        """
        ...
    
    def SameCurveAndFraction(self: MSPyBentleyGeom.CurveLocationDetailPair) -> bool:
        """
        Return true if the two details are for (bitwise) identical curve and
        fraction.
        """
        ...
    
    def Set(*args, **kwargs):
        """
        Overloaded function.
        
        1. Set(self: MSPyBentleyGeom.CurveLocationDetailPair, fraction0: float, point0: DPoint3d, a0: float, fraction1: float, point1: DPoint3d, a1: float) -> None
        
        update fractions, points, and a
        
        2. Set(self: MSPyBentleyGeom.CurveLocationDetailPair, curveA: ICurvePrimitive, curveB: ICurvePrimitive) -> None
        
        update fractions, points, and a
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.CurveLocationDetailPair) -> None
        
        2. __init__(self: MSPyBentleyGeom.CurveLocationDetailPair, detailA: MSPyBentleyGeom.CurveLocationDetail, detailB: MSPyBentleyGeom.CurveLocationDetail) -> None
        
        3. __init__(self: MSPyBentleyGeom.CurveLocationDetailPair, detailA: MSPyBentleyGeom.CurveLocationDetail) -> None
        
        4. __init__(self: MSPyBentleyGeom.CurveLocationDetailPair, curve: ICurvePrimitive, fraction0: float, point0: DPoint3d) -> None
        
        5. __init__(self: MSPyBentleyGeom.CurveLocationDetailPair, curve: ICurvePrimitive, fraction0: float, point0: DPoint3d, componentIndex: int, numComponent: int, componentFraction: float) -> None
        
        6. __init__(self: MSPyBentleyGeom.CurveLocationDetailPair, curve0: ICurvePrimitive, a0: float, curve1: ICurvePrimitive, a1: float) -> None
        """
        ...
    
    @property
    def detailA(self: MSPyBentleyGeom.CurveLocationDetailPair) -> MSPyBentleyGeom.CurveLocationDetail:
        ...
    @detailA.setter
    def detailA(self: MSPyBentleyGeom.CurveLocationDetailPair, arg0: MSPyBentleyGeom.CurveLocationDetail) -> None:
        ...
    
    @property
    def detailB(self: MSPyBentleyGeom.CurveLocationDetailPair) -> MSPyBentleyGeom.CurveLocationDetail:
        ...
    @detailB.setter
    def detailB(self: MSPyBentleyGeom.CurveLocationDetailPair, arg0: MSPyBentleyGeom.CurveLocationDetail) -> None:
        ...
    
class CurveLocationDetailPairArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.CurveLocationDetailPairArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.CurveLocationDetailPairArray, arg0: MSPyBentleyGeom.CurveLocationDetailPairArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.CurveLocationDetailPairArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.CurveLocationDetailPairArray, x: MSPyBentleyGeom.CurveLocationDetailPair) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.CurveLocationDetailPairArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.CurveLocationDetailPairArray, L: MSPyBentleyGeom.CurveLocationDetailPairArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.CurveLocationDetailPairArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.CurveLocationDetailPairArray, i: int, x: MSPyBentleyGeom.CurveLocationDetailPair) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.CurveLocationDetailPairArray) -> MSPyBentleyGeom.CurveLocationDetailPair
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.CurveLocationDetailPairArray, i: int) -> MSPyBentleyGeom.CurveLocationDetailPair
        
        Remove and return the item at index ``i``
        """
        ...
    
class CurveOffsetOptions:
    """
    None
    """

    @property
    def ArcAngle(arg0: MSPyBentleyGeom.CurveOffsetOptions) -> float:
        ...
    @ArcAngle.setter
    def ArcAngle(arg0: MSPyBentleyGeom.CurveOffsetOptions, arg1: float) -> None:
        ...
    
    @property
    def BCurveMethod(arg0: MSPyBentleyGeom.CurveOffsetOptions) -> int:
        ...
    @BCurveMethod.setter
    def BCurveMethod(arg0: MSPyBentleyGeom.CurveOffsetOptions, arg1: int) -> None:
        ...
    
    @property
    def BCurvePointsPerKnot(arg0: MSPyBentleyGeom.CurveOffsetOptions) -> int:
        ...
    @BCurvePointsPerKnot.setter
    def BCurvePointsPerKnot(arg0: MSPyBentleyGeom.CurveOffsetOptions, arg1: int) -> None:
        ...
    
    @property
    def ChamferAngle(arg0: MSPyBentleyGeom.CurveOffsetOptions) -> float:
        ...
    @ChamferAngle.setter
    def ChamferAngle(arg0: MSPyBentleyGeom.CurveOffsetOptions, arg1: float) -> None:
        ...
    
    @property
    def ForceClosure(arg0: MSPyBentleyGeom.CurveOffsetOptions) -> bool:
        ...
    @ForceClosure.setter
    def ForceClosure(arg0: MSPyBentleyGeom.CurveOffsetOptions, arg1: bool) -> None:
        ...
    
    def GetArcAngle(self: MSPyBentleyGeom.CurveOffsetOptions) -> float:
        ...
    
    def GetBCurveMethod(self: MSPyBentleyGeom.CurveOffsetOptions) -> int:
        ...
    
    def GetBCurvePointsPerKnot(self: MSPyBentleyGeom.CurveOffsetOptions) -> int:
        ...
    
    def GetChamferAngle(self: MSPyBentleyGeom.CurveOffsetOptions) -> float:
        ...
    
    def GetForceClosure(self: MSPyBentleyGeom.CurveOffsetOptions) -> bool:
        ...
    
    def GetOffsetDistance(self: MSPyBentleyGeom.CurveOffsetOptions) -> float:
        ...
    
    def GetTolerance(self: MSPyBentleyGeom.CurveOffsetOptions) -> float:
        ...
    
    @property
    def OffsetDistance(arg0: MSPyBentleyGeom.CurveOffsetOptions) -> float:
        ...
    @OffsetDistance.setter
    def OffsetDistance(arg0: MSPyBentleyGeom.CurveOffsetOptions, arg1: float) -> None:
        ...
    
    def SetArcAngle(self: MSPyBentleyGeom.CurveOffsetOptions, valueRadians: float) -> None:
        ...
    
    def SetBCurveMethod(self: MSPyBentleyGeom.CurveOffsetOptions, n: int) -> None:
        ...
    
    def SetBCurvePointsPerKnot(self: MSPyBentleyGeom.CurveOffsetOptions, n: int) -> None:
        ...
    
    def SetChamferAngle(self: MSPyBentleyGeom.CurveOffsetOptions, value: float) -> None:
        ...
    
    def SetForceClosure(self: MSPyBentleyGeom.CurveOffsetOptions, value: bool) -> None:
        ...
    
    def SetOffsetDistance(self: MSPyBentleyGeom.CurveOffsetOptions, distance: float) -> None:
        ...
    
    def SetTolerance(self: MSPyBentleyGeom.CurveOffsetOptions, tol: float) -> None:
        ...
    
    @property
    def Tolerance(arg0: MSPyBentleyGeom.CurveOffsetOptions) -> float:
        ...
    @Tolerance.setter
    def Tolerance(arg0: MSPyBentleyGeom.CurveOffsetOptions, arg1: float) -> None:
        ...
    
    def __init__(self: MSPyBentleyGeom.CurveOffsetOptions, offsetDistance: float) -> None:
        ...
    
class CurveParameterMapping:
    """
    Members:
    
    eCURVE_PARAMETER_MAPPING_BezierFraction
    
    eCURVE_PARAMETER_MAPPING_CurveKnot
    
    eCURVE_PARAMETER_MAPPING_CurveFraction
    """

    def __init__(self: MSPyBentleyGeom.CurveParameterMapping, value: int) -> None:
        ...
    
    eCURVE_PARAMETER_MAPPING_BezierFraction: CurveParameterMapping
    
    eCURVE_PARAMETER_MAPPING_CurveFraction: CurveParameterMapping
    
    eCURVE_PARAMETER_MAPPING_CurveKnot: CurveParameterMapping
    
    @property
    def name(self: handle) -> str:
        ...
    
    @property
    def value(arg0: MSPyBentleyGeom.CurveParameterMapping) -> int:
        ...
    
class CurvePrimitiveId:
    """
    None
    """

    def Clone(self: MSPyBentleyGeom.CurvePrimitiveId) -> MSPyBentleyGeom.CurvePrimitiveId:
        """
        Return a copy.
        """
        ...
    
    @property
    def CurveTopologyId(arg0: MSPyBentleyGeom.CurvePrimitiveId) -> CurveTopologyId:
        ...
    
    @property
    def DebugString(arg0: MSPyBentleyGeom.CurvePrimitiveId) -> MSPyBentley.WString:
        ...
    
    def GetCompoundDrawState(self: MSPyBentleyGeom.CurvePrimitiveId) -> MSPyBentleyGeom.CompoundDrawState:
        """
        Query the compound draw state (refCounted)
        """
        ...
    
    def GetCurveTopologyId(self: MSPyBentleyGeom.CurvePrimitiveId) -> CurveTopologyId:
        """
        Return the topologyId object. This may fail (and return defaulted
        structure) for some types.
        """
        ...
    
    def GetDebugString(self: MSPyBentleyGeom.CurvePrimitiveId) -> MSPyBentley.WString:
        """
        Get debug string
        """
        ...
    
    def GetLineStringAssociationIds(self: MSPyBentleyGeom.CurvePrimitiveId, nTargetIds: int) -> tuple:
        """
        If this is a Type_PolyfaceCut with exactly nTargetIds id values, copy
        out the topology type and the ids.
        """
        ...
    
    def GetParasolidBodyId(self: MSPyBentleyGeom.CurvePrimitiveId, id: CurveTopologyId) -> BentleyStatus:
        """
        Copy data to target object if this is a parasolid body.
        """
        ...
    
    def GetRawIdString(self: MSPyBentleyGeom.CurvePrimitiveId) -> MSPyBentley.WString:
        """
        Get hex form of the ids
        """
        ...
    
    def GetSolidPrimitiveId(self: MSPyBentleyGeom.CurvePrimitiveId, id: CurveTopologyId) -> BentleyStatus:
        """
        Copy data to target object if this is a solid primitive.
        """
        ...
    
    def GetType(self: MSPyBentleyGeom.CurvePrimitiveId) -> MSPyBentleyGeom.CurvePrimitiveId.Type:
        """
        Get the type code.
        """
        ...
    
    @property
    def RawIdString(arg0: MSPyBentleyGeom.CurvePrimitiveId) -> MSPyBentley.WString:
        ...
    
    def SetCompoundDrawState(self: MSPyBentleyGeom.CurvePrimitiveId, arg0: MSPyBentleyGeom.CompoundDrawState) -> None:
        """
        Set the compound draw state.
        """
        ...
    
    def Store(self: MSPyBentleyGeom.CurvePrimitiveId, data: MSPyBentleyGeom.UInt8Array) -> None:
        """
        Copy the id data into bytes.
        """
        ...
    
    @property
    def Type(arg0: MSPyBentleyGeom.CurvePrimitiveId) -> MSPyBentleyGeom.CurvePrimitiveId.Type:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.CurvePrimitiveId, type: MSPyBentleyGeom.CurvePrimitiveId.Type, data: bytes, cds: MSPyBentleyGeom.CompoundDrawState) -> None
        
        2. __init__(self: MSPyBentleyGeom.CurvePrimitiveId, type: MSPyBentleyGeom.CurvePrimitiveId.Type, topologyId: CurveTopologyId, cds: MSPyBentleyGeom.CompoundDrawState) -> None
        
        3. __init__(self: MSPyBentleyGeom.CurvePrimitiveId, data: bytes) -> None
        
        4. __init__(self: MSPyBentleyGeom.CurvePrimitiveId, id: MSPyBentleyGeom.CurvePrimitiveId) -> None
        """
        ...
    
    eType_ACISCut: Type
    
    eType_CachedCut: Type
    
    eType_CachedEdge: Type
    
    eType_CachedUnderlay: Type
    
    eType_CurveVector: Type
    
    eType_CutGeometry: Type
    
    eType_Max: Type
    
    eType_OpenCascadeBody: Type
    
    eType_ParaSolidBody: Type
    
    eType_ParaSolidCut: Type
    
    eType_PolyfaceCut: Type
    
    eType_PolyfaceEdge: Type
    
    eType_SolidPrimitive: Type
    
    eType_UnspecifiedTopologyId: Type
    
    eType_UnusedWasFacetSet: Type
    
class CurveTopologyId:
    """
    None
    """

    @staticmethod
    def AddCurveVectorIds(curveVector: CurveVector, type: MSPyBentleyGeom.CurvePrimitiveId.Type, id: MSPyBentleyGeom.CurveTopologyId, cds: MSPyBentleyGeom.CompoundDrawState) -> BentleyStatus:
        ...
    
    def Clear(self: MSPyBentleyGeom.CurveTopologyId) -> None:
        """
        Clear the id array and set the type code to default unknown value.
        """
        ...
    
    @property
    def Count(arg0: MSPyBentleyGeom.CurveTopologyId) -> int:
        ...
    
    @property
    def DebugString(arg0: MSPyBentleyGeom.CurveTopologyId) -> MSPyBentley.WString:
        ...
    
    @staticmethod
    def FromBRepIsoline(faceId: faceId, isolineIndex: int) -> MSPyBentleyGeom.CurveTopologyId:
        """
        construct and return with FaceId and isolineIndex
        """
        ...
    
    @staticmethod
    def FromBRepPlanarFace(faceId: faceId) -> MSPyBentleyGeom.CurveTopologyId:
        """
        Construct and return for brep edge with one face.
        """
        ...
    
    @staticmethod
    def FromBRepSharedEdge(faceId0: faceId, faceId1: faceId) -> MSPyBentleyGeom.CurveTopologyId:
        """
        Construct an return for brep edge with two faces.
        """
        ...
    
    @staticmethod
    def FromBRepSheetEdge(edgeId: faceId) -> MSPyBentleyGeom.CurveTopologyId:
        """
        Construct and return for brep edge with one face.
        """
        ...
    
    @staticmethod
    def FromBRepSilhouette(edgeId: faceId) -> MSPyBentleyGeom.CurveTopologyId:
        """
        Construct and return for brep silhouette edge.
        """
        ...
    
    @staticmethod
    def FromCurveVector() -> MSPyBentleyGeom.CurveTopologyId:
        """
        construct and return for curve vector
        """
        ...
    
    @staticmethod
    def FromGeometryMap() -> MSPyBentleyGeom.CurveTopologyId:
        """
        construct and return for geometry map.
        """
        ...
    
    @staticmethod
    def FromMeshEdgeVertices(vertexIndex0: int, vertexIndex1: int) -> MSPyBentleyGeom.CurveTopologyId:
        """
        construct and return for mesh edge with 2 vertices
        """
        ...
    
    @staticmethod
    def FromMeshSharedEdge(faceIndex0: int, faceIndex1: int) -> MSPyBentleyGeom.CurveTopologyId:
        """
        construct and return for mesh edge with 2 faces
        """
        ...
    
    @staticmethod
    def FromParasolidGPArrayId(arg0: int, arg1: int) -> MSPyBentleyGeom.CurveTopologyId:
        """
        construct and return from Parasolid parasolid GPArray ID
        """
        ...
    
    @staticmethod
    def FromSweepLateral(lateralIndex: int) -> MSPyBentleyGeom.CurveTopologyId:
        """
        construct and return for indexed lateral within sweep.
        """
        ...
    
    @staticmethod
    def FromSweepProfile(profileIndex: int) -> MSPyBentleyGeom.CurveTopologyId:
        """
        construct and return for index of swept profile curve.
        """
        ...
    
    @staticmethod
    def FromSweepSilhouette(silhouetteIndex: int) -> MSPyBentleyGeom.CurveTopologyId:
        """
        construct and return for silhouette of sweep
        """
        ...
    
    @staticmethod
    def FromUnknownCurve(curveIndex: int) -> MSPyBentleyGeom.CurveTopologyId:
        """
        construct and return for unknown curve
        """
        ...
    
    @staticmethod
    def FromVisEdgesAnalytic(curveIndex: int) -> MSPyBentleyGeom.CurveTopologyId:
        ...
    
    @staticmethod
    def FromVisEdgesBoundedPlane(arg0: int) -> MSPyBentleyGeom.CurveTopologyId:
        """
        construct and return for indexed loop in visible edges
        """
        ...
    
    @staticmethod
    def FromVisEdgesIntersection() -> MSPyBentleyGeom.CurveTopologyId:
        """
        construct and return for intersection curve in visible edges
        """
        ...
    
    @staticmethod
    def FromWire() -> MSPyBentleyGeom.CurveTopologyId:
        """
        construct and return for wire edge
        """
        ...
    
    def GetBRepIsoline(self: MSPyBentleyGeom.CurveTopologyId, faceId: faceId) -> tuple:
        """
        Extract brep isoline.
        """
        ...
    
    def GetBRepPlanarFace(self: MSPyBentleyGeom.CurveTopologyId, faceId: faceId) -> BentleyStatus:
        ...
    
    def GetBRepSharedEdge(self: MSPyBentleyGeom.CurveTopologyId, faceId0: faceId, faceId1: faceId) -> BentleyStatus:
        """
        extract adjacent faces of brep edge
        """
        ...
    
    def GetBRepSheetEdge(self: MSPyBentleyGeom.CurveTopologyId, edgeId: faceId) -> BentleyStatus:
        """
        extract adjacent face of brep edge
        """
        ...
    
    def GetCount(self: MSPyBentleyGeom.CurveTopologyId) -> int:
        """
        Return the id data count (in UInt32's)
        """
        ...
    
    def GetDebugString(self: MSPyBentleyGeom.CurveTopologyId) -> MSPyBentley.WString:
        """
        Return debug string form
        """
        ...
    
    def GetId(self: MSPyBentleyGeom.CurveTopologyId, index: int) -> int:
        """
        Return id by index
        """
        ...
    
    def GetType(self: MSPyBentleyGeom.CurveTopologyId) -> MSPyBentleyGeom.CurveTopologyId.Type:
        """
        Return the type code
        """
        ...
    
    def Init(*args, **kwargs):
        """
        Overloaded function.
        
        1. Init(self: MSPyBentleyGeom.CurveTopologyId, type: MSPyBentleyGeom.CurveTopologyId.Type, ids: MSPyBentleyGeom.UInt32Array) -> None
        
        Initializer with type code and array of ids.
        
        2. Init(self: MSPyBentleyGeom.CurveTopologyId, ids: MSPyBentleyGeom.UInt32Array) -> None
        
        Initializer with type code and array of ids.
        """
        ...
    
    def IsEmpty(self: MSPyBentleyGeom.CurveTopologyId) -> bool:
        """
        Return true if there are no ids.
        """
        ...
    
    def Pack(self: MSPyBentleyGeom.CurveTopologyId, packed: MSPyBentleyGeom.UInt8Array) -> None:
        """
        Return a packed form of the ids.
        """
        ...
    
    @property
    def Type(arg0: MSPyBentleyGeom.CurveTopologyId) -> MSPyBentleyGeom.CurveTopologyId.Type:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.CurveTopologyId) -> None
        
        2. __init__(self: MSPyBentleyGeom.CurveTopologyId, type: MSPyBentleyGeom.CurveTopologyId.Type) -> None
        
        3. __init__(self: MSPyBentleyGeom.CurveTopologyId, type: MSPyBentleyGeom.CurveTopologyId.Type, id: int) -> None
        
        4. __init__(self: MSPyBentleyGeom.CurveTopologyId, type: MSPyBentleyGeom.CurveTopologyId.Type, id0: int, id1: int) -> None
        
        5. __init__(self: MSPyBentleyGeom.CurveTopologyId, type: MSPyBentleyGeom.CurveTopologyId.Type, id0: int, id1: int, id2: int) -> None
        
        6. __init__(self: MSPyBentleyGeom.CurveTopologyId, rhs: MSPyBentleyGeom.CurveTopologyId) -> None
        
        7. __init__(self: MSPyBentleyGeom.CurveTopologyId, curveId: MSPyBentleyGeom.CurveTopologyId, id: int) -> None
        
        8. __init__(self: MSPyBentleyGeom.CurveTopologyId, id: int, curveId: MSPyBentleyGeom.CurveTopologyId) -> None
        """
        ...
    
    eType_BRepIsoIsoline: Type
    
    eType_BRepPlanarFace: Type
    
    eType_BRepSharedEdge: Type
    
    eType_BRepSheetEdge: Type
    
    eType_BRepSilhouette: Type
    
    eType_CurveVector: Type
    
    eType_CutFill: Type
    
    eType_CutWires: Type
    
    eType_GeometryMap: Type
    
    eType_IndexedMeshEdge: Type
    
    eType_Max: Type
    
    eType_MeshEdgeVertices: Type
    
    eType_MeshSharedEdge: Type
    
    eType_MeshSheetEdge: Type
    
    eType_MeshUnknown: Type
    
    eType_PolyfaceCut: Type
    
    eType_PolyfaceEdge: Type
    
    eType_SweepLateral: Type
    
    eType_SweepProfile: Type
    
    eType_SweepSilhouette: Type
    
    eType_UnannnouncedSectionShape: Type
    
    eType_UnannouncedSectionWire: Type
    
    eType_Unknown: Type
    
    eType_VisEdgesAnalytic: Type
    
    eType_VisEdgesBoundedPlane: Type
    
    eType_VisEdgesIntersection: Type
    
    eType_Wire: Type
    
class CurveTopologyIdArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.CurveTopologyIdArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.CurveTopologyIdArray, arg0: MSPyBentleyGeom.CurveTopologyIdArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.CurveTopologyIdArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.CurveTopologyIdArray, x: MSPyBentleyGeom.CurveTopologyId) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.CurveTopologyIdArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def count(self: MSPyBentleyGeom.CurveTopologyIdArray, x: MSPyBentleyGeom.CurveTopologyId) -> int:
        """
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.CurveTopologyIdArray, L: MSPyBentleyGeom.CurveTopologyIdArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.CurveTopologyIdArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.CurveTopologyIdArray, i: int, x: MSPyBentleyGeom.CurveTopologyId) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.CurveTopologyIdArray) -> MSPyBentleyGeom.CurveTopologyId
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.CurveTopologyIdArray, i: int) -> MSPyBentleyGeom.CurveTopologyId
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(self: MSPyBentleyGeom.CurveTopologyIdArray, x: MSPyBentleyGeom.CurveTopologyId) -> None:
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class CurveVector:
    """
    None
    """

    def Add(*args, **kwargs):
        """
        Overloaded function.
        
        1. Add(self: MSPyBentleyGeom.CurveVector, child: MSPyBentleyGeom.ICurvePrimitive) -> None
        
        add single curve primitive
        
        2. Add(self: MSPyBentleyGeom.CurveVector, child: MSPyBentleyGeom.CurveVector) -> None
        
        add single curve primitive
        """
        ...
    
    def AddPrimitives(self: MSPyBentleyGeom.CurveVector, source: MSPyBentleyGeom.CurveVector) -> int:
        """
        recurse through source. append all leaf primitives to this. Return
        number added.
        """
        ...
    
    def AddSpacedPoints(*args, **kwargs):
        """
        Overloaded function.
        
        1. AddSpacedPoints(self: MSPyBentleyGeom.CurveVector, distances: MSPyBentleyGeom.DoubleArray, locations: MSPyBentleyGeom.CurveLocationDetailArray) -> bool
        
        2. AddSpacedPoints(self: MSPyBentleyGeom.CurveVector, distances: MSPyBentleyGeom.DoubleArray, locations: MSPyBentleyGeom.CurveLocationDetailArray) -> bool
        
        Compute points at (many) specified distances along the (many) curves
        in the CurveVector. Intervals between successive distances can " jump "
        from one curve to the next. If curves to not connect head to tail, the
        gap is NOT filled -- measurement just picks up after the gap.
        
        :param (input):
        distances vector of distances, all measured from the start of the
        first primitive.
        
        :param (output):
        locations vector of locations. (This is NOT cleared at start --
        points are just added.)
        """
        ...
    
    def AddStrokePoints(*args, **kwargs):
        """
        Overloaded function.
        
        1. AddStrokePoints(self: MSPyBentleyGeom.CurveVector, points: List[DPoint3d], options: IFacetOptions) -> None
        
        2. AddStrokePoints(self: MSPyBentleyGeom.CurveVector, points: List[DPoint3d], options: IFacetOptions) -> None
        
        Add stroke points form all children to output. Strokes from all
        children are concatenated into the same vector, separated only by
        DISCONNECT points. Use Stroke() to get structured strokes.
        
        :param [in,out]:
        points growing vector of strokes.
        
        :param (input):
        options options for stroke density. chordTolerance,
        angleTolerance, and maxEdgeLength will be used.
        """
        ...
    
    def AnnounceKeyPoints(*args, **kwargs):
        """
        Overloaded function.
        
        1. AnnounceKeyPoints(self: MSPyBentleyGeom.CurveVector, spacePoint: DPoint3d, collector: MSPyBentleyGeom.CurveKeyPointCollector, extend0: bool, extend1: bool) -> None
        
        2. AnnounceKeyPoints(self: MSPyBentleyGeom.CurveVector, spacePoint: DPoint3d, collector: MSPyBentleyGeom.CurveKeyPointCollector, extend0: bool, extend1: bool) -> None
        
        Search for various keypoints (as requested by the collector) During
        recursion, extension bits are changed to false for interior points of
        paths
        """
        ...
    
    def AppendClosedCurvePlaneIntersections(*args, **kwargs):
        """
        Overloaded function.
        
        1. AppendClosedCurvePlaneIntersections(self: MSPyBentleyGeom.CurveVector, plane: DPlane3d, intersections: MSPyBentleyGeom.CurveLocationDetailPairArray, tolerance: float = 0.0) -> bool
        
        2. AppendClosedCurvePlaneIntersections(self: MSPyBentleyGeom.CurveVector, plane: DPlane3d, intersections: MSPyBentleyGeom.CurveLocationDetailPairArray, tolerance: float = 0.0) -> bool
        
        Compute intersections of closed CurveVector with a plane and organize
        as start end pairs by parity rules. Intersections are reported as
        CurveLocationDetailPairs for start and end of segments.
        
        :param (input):
        plane
        
        :param (output):
        intersections intersection details
        
        :param (input):
        tolerance for on-plane decisions. If 0, a tolerance is computed
        based on the coordinates in the curve.
        """
        ...
    
    def AppendCurvePlaneIntersections(*args, **kwargs):
        """
        Overloaded function.
        
        1. AppendCurvePlaneIntersections(self: MSPyBentleyGeom.CurveVector, plane: DPlane3d, intersections: MSPyBentleyGeom.CurveLocationDetailPairArray, tolerance: float = 0.0) -> None
        
        2. AppendCurvePlaneIntersections(self: MSPyBentleyGeom.CurveVector, plane: DPlane3d, intersections: MSPyBentleyGeom.CurveLocationDetailPairArray, tolerance: float = 0.0) -> None
        
        Compute simple points of intersection of the curve with a plane.
        Single point intersection appears as a CurveLocationDetailPair with
        identical locations for both parts of the pair (SameCurveAndFraction)
        Curve-on-plane appears as CurveLocationDetailPair with curve,fraction
        data for start and end of on-plane sections.
        
        :param (input):
        plane
        
        :param (output):
        intersections intersection details
        
        :param (input):
        tolerance for on-plane decisions. If 0, a tolerance is computed
        based on the coordinates in the curve.
        """
        ...
    
    def AppendSplitCurvesByPlane(self: MSPyBentleyGeom.CurveVector, plane: DPlane3d, belowCollector: MSPyBentleyGeom.CurveVector, aboveCollector: MSPyBentleyGeom.CurveVector, onCollector: MSPyBentleyGeom.CurveVector) -> None:
        """
        Return curves (not regions) that are below, above, and on a plane
        """
        ...
    
    def AppendSplitCurvesByRegion(self: MSPyBentleyGeom.CurveVector, region: MSPyBentleyGeom.CurveVector, insideCollector: MSPyBentleyGeom.CurveVector, outsideCollector: MSPyBentleyGeom.CurveVector, onCollector: MSPyBentleyGeom.CurveVector) -> None:
        """
        Return curves (not regions) that are inside, outside, or on a region.
        """
        ...
    
    def AreStartEndAlmostEqual(self: MSPyBentleyGeom.CurveVector) -> bool:
        """
        Query:Does this have start and end points and are the points almost
        equal?
        """
        ...
    
    @staticmethod
    def AreaAnalysis(*args, **kwargs):
        """
        Overloaded function.
        
        1. AreaAnalysis(region: MSPyBentleyGeom.CurveVector, select1: MSPyBentleyGeom.AreaSelect, select2: MSPyBentleyGeom.BoolSelect, reverse: bool) -> MSPyBentleyGeom.CurveVector
        
        2. AreaAnalysis(region: MSPyBentleyGeom.CurveVector, select1: MSPyBentleyGeom.AreaSelect, select2: MSPyBentleyGeom.BoolSelect, reverse: bool) -> MSPyBentleyGeom.CurveVector
        
        Return a curve vector containing the " inside " areas by various
        conditions.
        
        :param (input):
        region Region that may have loops back over its area.
        
        :param (input):
        select1 Rule for classifying single area:one of
        AreaSelect_Parity, AreaSelect_CCWPositiveWindingNumber,
        AreaSelect_CCWNonzeroWindingNumber,
        AreaSelect_CCWNegativeWindingNumber
        
        :param (input):
        select2 Rule for combining leaf left results:One of
        BoolSelect_Parity, BoolSelect_Union, BoolSelect_Sum_Parity,
        BoolSelect_CCWPositiveWindingNumber,
        BoolSelect_CCWNonzeroWindingNumber,
        BoolSelect_CCWNegativeWindingNumber
        
        :param (input):
        reverse to return the opposite set of faces.
        """
        ...
    
    @staticmethod
    def AreaDifference(*args, **kwargs):
        """
        Overloaded function.
        
        1. AreaDifference(regionA: MSPyBentleyGeom.CurveVector, regionB: MSPyBentleyGeom.CurveVector, newToOld: List[CurvePrimitivePtrPair] = None) -> MSPyBentleyGeom.CurveVector
        
        2. AreaDifference(regionA: MSPyBentleyGeom.CurveVector, regionB: MSPyBentleyGeom.CurveVector, newToOld: List[CurvePrimitivePtrPair] = None) -> MSPyBentleyGeom.CurveVector
        
        Return a curve vector containing the difference of input areas.
        
        :param (input):
        regionA left operand
        
        :param (input):
        regionB right operand
        
        :param [in,out]:
        newToOld (optional) pointer to bvector to receive paring of new
        and old curves.
        """
        ...
    
    @staticmethod
    def AreaIntersection(*args, **kwargs):
        """
        Overloaded function.
        
        1. AreaIntersection(regionA: MSPyBentleyGeom.CurveVector, regionB: MSPyBentleyGeom.CurveVector, newToOld: List[CurvePrimitivePtrPair] = None) -> MSPyBentleyGeom.CurveVector
        
        2. AreaIntersection(regionA: MSPyBentleyGeom.CurveVector, regionB: MSPyBentleyGeom.CurveVector, newToOld: List[CurvePrimitivePtrPair] = None) -> MSPyBentleyGeom.CurveVector
        
        Return a curve vector containing the intersection of input areas.
        
        :param (input):
        regionA left operand
        
        :param (input):
        regionB right operand
        
        :param [in,out]:
        newToOld (optional) pointer to bvector to receive paring of new
        and old curves.
        """
        ...
    
    def AreaOffset(self: MSPyBentleyGeom.CurveVector, options: MSPyBentleyGeom.CurveOffsetOptions) -> MSPyBentleyGeom.CurveVector:
        """
        return a (deep) clone with all areas increased or decreased according
        to the offset distance.
        
        Remark:
        A positive offset is to the right of the curve (i.e. CCW outer
        loop offsets to a larger area)
        """
        ...
    
    @staticmethod
    def AreaParity(*args, **kwargs):
        """
        Overloaded function.
        
        1. AreaParity(regionA: MSPyBentleyGeom.CurveVector, regionB: MSPyBentleyGeom.CurveVector, newToOld: List[CurvePrimitivePtrPair] = None) -> MSPyBentleyGeom.CurveVector
        
        2. AreaParity(regionA: MSPyBentleyGeom.CurveVector, regionB: MSPyBentleyGeom.CurveVector, newToOld: List[CurvePrimitivePtrPair] = None) -> MSPyBentleyGeom.CurveVector
        
        Return a curve vector containing the parity of input areas.
        
        :param (input):
        regionA left operand
        
        :param (input):
        regionB right operand
        
        :param [in,out]:
        newToOld (optional) pointer to bvector to receive paring of new
        and old curves.
        """
        ...
    
    @staticmethod
    def AreaUnion(*args, **kwargs):
        """
        Overloaded function.
        
        1. AreaUnion(regionA: MSPyBentleyGeom.CurveVector, regionB: MSPyBentleyGeom.CurveVector, newToOld: List[CurvePrimitivePtrPair] = None) -> MSPyBentleyGeom.CurveVector
        
        2. AreaUnion(regionA: MSPyBentleyGeom.CurveVector, regionB: MSPyBentleyGeom.CurveVector, newToOld: List[CurvePrimitivePtrPair] = None) -> MSPyBentleyGeom.CurveVector
        
        Return a curve vector containing the union of input areas.
        
        :param (input):
        regionA left operand
        
        :param (input):
        regionB right operand
        
        :param [in,out]:
        newToOld (optional) pointer to bvector to receive paring of new
        and old curves.
        """
        ...
    
    def AssembleChains(*args, **kwargs):
        """
        Overloaded function.
        
        1. AssembleChains(self: MSPyBentleyGeom.CurveVector) -> MSPyBentleyGeom.CurveVector
        
        2. AssembleChains(self: MSPyBentleyGeom.CurveVector) -> MSPyBentleyGeom.CurveVector
        
        Join curve primitives head to tail. Return a top level
        BOUNDARY_TYPE_None containing the various BOUNDARY_TYPE_Open and
        BOUNDARY_TYPE_Outer
        """
        ...
    
    @property
    def BoundaryType(arg0: MSPyBentleyGeom.CurveVector) -> MSPyBentleyGeom.CurveVector.BoundaryType:
        ...
    
    def CentroidAreaXY(self: MSPyBentleyGeom.CurveVector) -> tuple:
        """
        Return the centroid and area of the curve vector as viewed in the xy
        plane. return false if the CurveVector is not one of the area types
        (union region, parity region, or closed loop)
        
        Remark:
        Union region moments are the simple sum of constituents (i.e
        overlap is not determined)
        
        Remark:
        Parity region moments are signed sum per area, assuming largest is
        outer and all others are inner (subtractive)
        
        :param (output):
        centroid curve centroid
        
        :param (output):
        area area of region.
        """
        ...
    
    def CentroidNormalArea(self: MSPyBentleyGeom.CurveVector) -> tuple:
        """
        Return the centroid, normal and area of the curve vector. return false
        if the CurveVector is not one of the area types (union region, parity
        region, or closed loop)
        
        Remark:
        Union region moments are the simple sum of constituents (i.e
        overlap is not determined)
        
        Remark:
        Parity region moments are signed sum per area, assuming largest is
        outer and all others are inner (subtractive)
        
        Remark:
        If curves are non-planar, the centroid and normal are
        approximations with no particular guarantees.
        
        :param (output):
        centroid curve centroid
        
        :param (output):
        normal curve normal
        
        :param (output):
        area area of region.
        """
        ...
    
    def Clone(self: MSPyBentleyGeom.CurveVector) -> MSPyBentleyGeom.CurveVector:
        """
        Return a " deep copy "
        """
        ...
    
    def CloneAsBsplines(*args, **kwargs):
        """
        Overloaded function.
        
        1. CloneAsBsplines(self: MSPyBentleyGeom.CurveVector) -> MSPyBentleyGeom.CurveVector
        
        2. CloneAsBsplines(self: MSPyBentleyGeom.CurveVector) -> MSPyBentleyGeom.CurveVector
        
        Return a " deep copy " with primitives replaced by bsplines The tree
        upper levels of the tree structure are retained -- i.e. the output
        contains corresponding tree structure ParityRegion, UnionRegion,
        OuterLoop, and InnerLoop ul> li>UnionRegion and ParityRegion vectors:
        Create a new CurveVector of the same type. Recursively create
        children. li>OuterLoop, InnerLoop, OpenPath:Create a new curve vector
        of the same type. li>Primitives:Each primitive is copied as a bspline
        curve primitive. ul
        """
        ...
    
    def CloneBetweenCyclicIndexedFractions(*args, **kwargs):
        """
        Overloaded function.
        
        1. CloneBetweenCyclicIndexedFractions(self: MSPyBentleyGeom.CurveVector, index0: int, fraction0: float, index1: int, fraction1: float) -> MSPyBentleyGeom.CurveVector
        
        2. CloneBetweenCyclicIndexedFractions(self: MSPyBentleyGeom.CurveVector, index0: int, fraction0: float, index1: int, fraction1: float) -> MSPyBentleyGeom.CurveVector
        
        Return a new vector containing curves from index0,fraction0 to
        index1,fraction1 with the (signed int!!) indices interpretted
        cyclically.
        """
        ...
    
    def CloneBetweenDirectedFractions(*args, **kwargs):
        """
        Overloaded function.
        
        1. CloneBetweenDirectedFractions(self: MSPyBentleyGeom.CurveVector, index0: int, fraction0: float, index1: int, fraction1: float, allowExtrapolation: bool, usePartialCurves: bool = False) -> MSPyBentleyGeom.CurveVector
        
        2. CloneBetweenDirectedFractions(self: MSPyBentleyGeom.CurveVector, location0: MSPyBentleyGeom.CurveLocationDetail, location1: MSPyBentleyGeom.CurveLocationDetail, allowExtrapolation: bool = False, usePartialCurves: bool = False) -> MSPyBentleyGeom.CurveVector
        """
        ...
    
    def CloneDereferenced(self: MSPyBentleyGeom.CurveVector, allowExtrapolation: bool = False, maximumDeref: bool = True) -> MSPyBentleyGeom.CurveVector:
        """
        Return a " deep copy " with PartialCurve primitives replaced by full
        curves.
        
        :param (input):
        maximumDeref true to recurse through all steps of PartialCurve
        chains
        
        :param (input):
        allowExtrapolation true to allow extension before/after endpoints.
        """
        ...
    
    def CloneInLocalCoordinates(self: MSPyBentleyGeom.CurveVector, rameType: LocalCoordinateSelect, localToWorld: Transform, worldToLocal: Transform, localRange: DRange3d) -> MSPyBentleyGeom.CurveVector:
        """
        Return curve copy and transforms for a local coordinate system related
        to the curves. The local x and y axes are parallel to the x and y axes
        of the Frenet frame at the curve start.
        
        :returns:
        curves transformed to local system.
        
        :param (output):
        localToWorld local to world transform
        
        :param (output):
        worldToLocal world to local transform
        
        :param (output):
        localRange curve vector range in the local frame.
        
        :param (input):
        frameType Selects how the geometry size is represented in the
        scale. ul> li>LOCAL_COORDINATE_SCALE_UnitAxesAtStart -- x,y,z
        columns in the transform are unit vectors. localRange values are
        true geometry sizes. origin is at start point of first primitive.
        li>LOCAL_COORDINATE_SCALE_UnitAxesAtLowerLeft -- x,y,z columns in
        the transform are unit vectors. localRange values are true
        geometry sizes. origin is at lower left of range.
        li>LOCAL_COORDINATE_SCALE_01RangeBothAxes -- x column is a vector
        spanning the x range from min to max. y column is a vector
        spanning the y range from min to max. localRange values are 0..1
        (inclusive) in both directions. origin is at lower left of range.
        li>LOCAL_COORDINATE_SCALE_01RangeLargerAxis -- x and y columns
        have the same length, large enough to span the larger direction.
        localRange values are 0..1 in the larger direction, 0..f in the
        smaller direction, where f is that direction's size as a fraction
        of the larger direction. origin is at lower left of range. ul
        """
        ...
    
    def CloneOffsetCurvesXY(self: MSPyBentleyGeom.CurveVector, options: MSPyBentleyGeom.CurveOffsetOptions) -> MSPyBentleyGeom.CurveVector:
        """
        return a (deep) clone with all curves offset by signed distance. This
        is a curve operation, and may result in self-intersecting offset
        curves.
        
        Remark:
        A positive offset is to the right of the curve (i.e. CCW outer
        loop offsets to a larger area)
        """
        ...
    
    def CloneReversed(*args, **kwargs):
        """
        Overloaded function.
        
        1. CloneReversed(self: MSPyBentleyGeom.CurveVector) -> MSPyBentleyGeom.CurveVector
        
        2. CloneReversed(self: MSPyBentleyGeom.CurveVector) -> MSPyBentleyGeom.CurveVector
        
        Return a new curve vector that has all components reversed.
        """
        ...
    
    def CloneWithBlends(self: MSPyBentleyGeom.CurveVector, blendType: MSPyBentleyGeom.BlendType, radiusA: float, radiusB: float) -> MSPyBentleyGeom.CurveVector:
        """
        return a (deep) clone with fillets inserted between successive curves.
        """
        ...
    
    def CloneWithExplodedLinestrings(self: MSPyBentleyGeom.CurveVector) -> MSPyBentleyGeom.CurveVector:
        """
        Return a curve vector that is a clone, but with all polylines split
        into individual line segments.
        """
        ...
    
    def CloneWithFillets(self: MSPyBentleyGeom.CurveVector, radius: float) -> MSPyBentleyGeom.CurveVector:
        """
        return a (deep) clone with fillets inserted between successive curves.
        """
        ...
    
    def CloneWithGapsClosed(self: MSPyBentleyGeom.CurveVector, options: MSPyBentleyGeom.CurveGapOptions) -> MSPyBentleyGeom.CurveVector:
        """
        return a (deep) clone with endpoint gaps closed. When gaps are found
        larger than gapTolerance, line segments are added. The options that
        will be used are:1) options.SetEqualPointTolerance(value):Gaps
        smaller than this are acceptable. This Suggested value:around 1e-7 in
        master units. 2) options.SetMaxDirectAdjustTolerance:gaps this small
        may be closed by directly moving endopints of lines or linestrings.
        SuggestedValue:10 to 1000 times the equal point tolerance 3)
        options.SetRemovePriorGapPrimitives(true):primitives marked as gaps
        are purged. (And the gaps are re-closed) Suggested value:true.
        (default is true) 4) options.SetMaxAdjustAlongPrimitive:points may
        move this far if the final point is on the extended element.
        """
        ...
    
    def CloneWithSplits(self: MSPyBentleyGeom.CurveVector, splitterCurves: MSPyBentleyGeom.CurveVector, primitivesOnly: bool = False) -> MSPyBentleyGeom.CurveVector:
        """
        Return a curve vector that is a clone, but with all primitives split
        at intersections with any splitter curve. Optionally omit tree
        structure and only copy primitives.
        """
        ...
    
    def ClosestCurveOrRegionPoint(*args, **kwargs):
        """
        Overloaded function.
        
        1. ClosestCurveOrRegionPoint(self: MSPyBentleyGeom.CurveVector, spacePoint: DPoint3d, curveOrRegionPoint: DPoint3d) -> MSPyBentleyGeom.CurveVector.InOutClassification
        
        2. ClosestCurveOrRegionPoint(self: MSPyBentleyGeom.CurveVector, spacePoint: DPoint3d, curveOrRegionPoint: DPoint3d) -> MSPyBentleyGeom.CurveVector.InOutClassification
        
        Search for closest point on curve. If CV is a region type, also look
        for projection onto interior of the region.
        
        :param (input):
        spacePoint fixed point of search
        
        :param (output):
        curveOrRegionPoint computed point on curve or region interior.
        
        :returns:
        INOUT_On if the point is a curve point. INOUT_In if the point is a
        projection to the region interior. INOUT_Unknown for empty curve
        vector.
        """
        ...
    
    def ClosestPointBounded(*args, **kwargs):
        """
        Overloaded function.
        
        1. ClosestPointBounded(self: MSPyBentleyGeom.CurveVector, spacePoint: DPoint3d, location: MSPyBentleyGeom.CurveLocationDetail) -> bool
        
        2. ClosestPointBounded(self: MSPyBentleyGeom.CurveVector, spacePoint: DPoint3d, location: MSPyBentleyGeom.CurveLocationDetail, extend0: bool, extend1: bool) -> bool
        
        3. ClosestPointBounded(self: MSPyBentleyGeom.CurveVector, spacePoint: DPoint3d, location: MSPyBentleyGeom.CurveLocationDetail) -> bool
        
        Search for the closest point on any contained curve.
        
        4. ClosestPointBounded(self: MSPyBentleyGeom.CurveVector, spacePoint: DPoint3d, location: MSPyBentleyGeom.CurveLocationDetail, extend0: bool, extend1: bool) -> bool
        
        Search for the closest point on any contained curve.
        """
        ...
    
    def ClosestPointBoundedXY(*args, **kwargs):
        """
        Overloaded function.
        
        1. ClosestPointBoundedXY(self: MSPyBentleyGeom.CurveVector, spacePoint: DPoint3d, worldToLocal: DMatrix4d, location: MSPyBentleyGeom.CurveLocationDetail) -> bool
        
        2. ClosestPointBoundedXY(self: MSPyBentleyGeom.CurveVector, spacePoint: DPoint3d, worldToLocal: DMatrix4d, location: MSPyBentleyGeom.CurveLocationDetail, extend0: bool, extend1: bool) -> bool
        
        3. ClosestPointBoundedXY(self: MSPyBentleyGeom.CurveVector, spacePoint: DPoint3d, worldToLocal: DMatrix4d, location: MSPyBentleyGeom.CurveLocationDetail) -> bool
        
        Search for the closest point on any contained curve, using only xy
        (viewed) coordinates.
        
        4. ClosestPointBoundedXY(self: MSPyBentleyGeom.CurveVector, spacePoint: DPoint3d, worldToLocal: DMatrix4d, location: MSPyBentleyGeom.CurveLocationDetail, extend0: bool, extend1: bool) -> bool
        
        Search for the closest point on any contained curve, using only xy
        (viewed) coordinates.
        """
        ...
    
    def CollectLinearGeometry(*args, **kwargs):
        """
        Overloaded function.
        
        1. CollectLinearGeometry(self: MSPyBentleyGeom.CurveVector, regionsPoints: List[Bstdcxx.bvector<Bstdcxx.bvector<DPoint3d],List[DPoint3d] >,List[Bstdcxx.bvector<DPoint3d],List[DPoint3d] > >) -> bool
        
        Add strokes from the instance curves.
        * The output retains structure as complex as "union of multi-loop parity regions".
        * For a BOUNDARY_TYPE_None, each child is added recursively.
        
        :regionsPoints [out]:
        collection of collections of loops; regionsPoints[i] is an array of loops, regionPoints[i][j] is a loop, regionPoints[i][j][k] is a point of a loop.
        
        :strokeOptions [input]:
        stroke options. If null all curved geometry is skipped.
        
        :returns:
        true if and only if no geometry was skipped and no unexpected was structure encountered.
        
        2. CollectLinearGeometry(self: MSPyBentleyGeom.CurveVector, regionsPoints: List[Bstdcxx.bvector<Bstdcxx.bvector<DPoint3d],List[DPoint3d] >,List[Bstdcxx.bvector<DPoint3d],List[DPoint3d] > >, strokeOptions: IFacetOptions) -> bool
        
        Add strokes from the instance curves.
        * The output retains structure as complex as "union of multi-loop parity regions".
        * For a BOUNDARY_TYPE_None, each child is added recursively.
        
        :regionsPoints [out]:
        collection of collections of loops; regionsPoints[i] is an array of loops, regionPoints[i][j] is a loop, regionPoints[i][j][k] is a point of a loop.
        
        :strokeOptions [input]:
        stroke options. If null all curved geometry is skipped.
        
        :returns:
        true if and only if no geometry was skipped and no unexpected was structure encountered.
        
        3. CollectLinearGeometry(self: MSPyBentleyGeom.CurveVector, regionsPoints: List[Bstdcxx.bvector<DPoint3d],List[DPoint3d] >, strokeOptions: IFacetOptions = None) -> bool
        
        Add strokes from the instance curves.
        * The output retains structure as complex as "union of multi-loop parity regions".
        * For a BOUNDARY_TYPE_None, each child is added recursively.
        
        :regionsPoints [out]:
        collection of collections of loops; regionsPoints[i] is an array of loops, regionPoints[i][j] is a loop, regionPoints[i][j][k] is a point of a loop.
        
        :strokeOptions [input]:
        stroke options. If null all curved geometry is skipped.
        
        :returns:
        true if and only if no geometry was skipped and no unexpected was structure encountered.
        """
        ...
    
    def ComputeSecondMomentAreaProducts(self: MSPyBentleyGeom.CurveVector, products: DMatrix4d) -> bool:
        """
        Return the area, centroid, orientation, and principal moments,
        treating this as a thin planar sheet.
        
        :param (output):
        products integrated [xx xy xz x; xy yy yz y; xz yz zz z; x y z 1]
        dA
        """
        ...
    
    def ComputeSecondMomentDifferentialAreaRotationProducts(self: MSPyBentleyGeom.CurveVector, rotationAxis: DRay3d, rotationToWorld: Transform, products: DMatrix4d) -> bool:
        """
        Return the moment products [xx,xy,xz,xw; etc] of the area as a
        differential rotational slice.
        
        :param (input):
        rotationAxis the origin and z axis of the rotation.
        
        :param (output):
        rotationToWorld transformation from rotation system (origin on
        rotation axis) to world. The products are base don local
        coordinates in the system.
        
        :param (output):
        products products in the rotation system.
        
        :returns:
        false if invalid area for rotational sweep.
        """
        ...
    
    def ComputeSecondMomentDifferentialWireRotationProducts(self: MSPyBentleyGeom.CurveVector, rotationAxis: DRay3d, rotationToWorld: Transform, products: DMatrix4d) -> bool:
        """
        Return the moment products [xx,xy,xz,xw; etc] of the wire as a
        differential rotational contribution
        
        :param (input):
        rotationAxis the origin and z axis of the rotation.
        
        :param (output):
        rotationToWorld transformation from rotation system (origin on
        rotation axis) to world. The products are base don local
        coordinates in the system.
        
        :param (output):
        products products in the rotation system.
        
        :returns:
        false if invalid area for rotational sweep.
        """
        ...
    
    def ComputeSecondMomentWireProducts(self: MSPyBentleyGeom.CurveVector, products: DMatrix4d) -> bool:
        """
        Return the area, centroid, orientation, and principal moments,
        treating this as a wire
        
        :param (output):
        products integrated [xx xy xz x; xy yy yz y; xz yz zz z; x y z 1]
        dA
        """
        ...
    
    def ConsolidateAdjacentPrimitives(*args, **kwargs):
        """
        Overloaded function.
        
        1. ConsolidateAdjacentPrimitives(self: MSPyBentleyGeom.CurveVector) -> None
        
        2. ConsolidateAdjacentPrimitives(self: MSPyBentleyGeom.CurveVector, doSimplifyLinestrings: bool) -> None
        
        3. ConsolidateAdjacentPrimitives(self: MSPyBentleyGeom.CurveVector) -> None
        
        Inplace update to consolidate contiguous parts. Adjacent lines and
        linestrings become a single linestring. Interior colinear points of
        linestrings are eliminated. Adjacent and compatible arcs become single
        arc.
        
        4. ConsolidateAdjacentPrimitives(self: MSPyBentleyGeom.CurveVector, doSimplifyLinestrings: bool) -> None
        
        Inplace update to consolidate contiguous parts. Adjacent lines and
        linestrings become a single linestring. Interior colinear points of
        linestrings are eliminated. Adjacent and compatible arcs become single
        arc.
        """
        ...
    
    def ContainsNonLinearPrimitive(*args, **kwargs):
        """
        Overloaded function.
        
        1. ContainsNonLinearPrimitive(self: MSPyBentleyGeom.CurveVector) -> bool
        
        2. ContainsNonLinearPrimitive(self: MSPyBentleyGeom.CurveVector) -> bool
        
        Return true if CurveVector has a component that is not a line or
        linestring.
        """
        ...
    
    def CountPrimitivesOfType(self: MSPyBentleyGeom.CurveVector, targetType: MSPyBentleyGeom.ICurvePrimitive.CurvePrimitiveType) -> int:
        """
        Count primitives of specified type.
        
        :param (input):
        targetType primitive type to count.
        """
        ...
    
    @staticmethod
    def CreateDisk(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateDisk(arc: DEllipse3d, boundaryType: MSPyBentleyGeom.CurveVector.BoundaryType = <BoundaryType.eBOUNDARY_TYPE_Outer: 2>, forceXYOrientation: bool = False) -> MSPyBentleyGeom.CurveVector
        
        2. CreateDisk(arc: DEllipse3d, boundaryType: MSPyBentleyGeom.CurveVector.BoundaryType = <BoundaryType.eBOUNDARY_TYPE_Outer: 2>, forceXYOrientation: bool = False) -> MSPyBentleyGeom.CurveVector
        
        Create a (deep) curve vector structure for a complete elliptic
        (circular) disk.
        
        :param (input):
        arc boundary ellipse
        
        :param (input):
        boundaryType is one of
        
        * BOUNDARY_TYPE_Outer:force to counterclockwise and positive area as
        seen looking at xy plane.
        
        * BOUNDARY_TYPE_Inner:force to clockwise and negative area as seen
        looking at xy plane.
        
        * BOUNDARY_TYPE_Open, BOUNDARY_TYPE_None:ellipse inserted with its
        own direction.
        
        * BOUNDARY_TYPE_UnionRegion, BOUNDARY_TYPE_ParityRegion create two-
        level structure with arc at second level with BOUNDARY_TYPE_Outer
        
        :param (input):
        forceXYOrientation if true, reverse arc sweep so it acts as
        requested inner/outer in xy view.
        """
        ...
    
    @staticmethod
    def CreateLinear(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateLinear(points: List[DPoint3d], boundaryType: MSPyBentleyGeom.CurveVector.BoundaryType = <BoundaryType.eBOUNDARY_TYPE_Open: 1>, forceXYOrientation: bool = False) -> MSPyBentleyGeom.CurveVector
        
        Create a linestring or polygon from xyz data.
        
        :param (input):
        points vertex coordinates points.
        
        :param (input):
        boundaryType is one of
        
        * BOUNDARY_TYPE_Outer, or BOUNDARY_TYPE_INNER:Duplication forced on
        first/last point. Orientation optionally enforced.
        
        * BOUNDARY_TYPE_Open, BOUNDARY_TYPE_None:points copied unchanged.
        
        * BOUNDARY_TYPE_UnionRegion, BOUNDARY_TYPE_ParityRegion create two-
        level structure with polygon at second level with BOUNDARY_TYPE_Outer.
        
        :param (input):
        forceXYOrientation true to force outer and inner loops to have
        correct (CCW/CW) order.
        
        2. CreateLinear(points: list, boundaryType: MSPyBentleyGeom.CurveVector.BoundaryType = <BoundaryType.eBOUNDARY_TYPE_Open: 1>, forceXYOrientation: bool = False) -> MSPyBentleyGeom.CurveVector
        
        Create a linestring or polygon from xyz data.
        
        :param (input):
        points vertex coordinates points.
        
        :param (input):
        boundaryType is one of
        
        * BOUNDARY_TYPE_Outer, or BOUNDARY_TYPE_INNER:Duplication forced on
        first/last point. Orientation optionally enforced.
        
        * BOUNDARY_TYPE_Open, BOUNDARY_TYPE_None:points copied unchanged.
        
        * BOUNDARY_TYPE_UnionRegion, BOUNDARY_TYPE_ParityRegion create two-
        level structure with polygon at second level with BOUNDARY_TYPE_Outer.
        
        :param (input):
        forceXYOrientation true to force outer and inner loops to have
        correct (CCW/CW) order.
        
        3. CreateLinear(points: List[DPoint2d], boundaryType: MSPyBentleyGeom.CurveVector.BoundaryType = <BoundaryType.eBOUNDARY_TYPE_Open: 1>, forceXYOrientation: bool = False) -> MSPyBentleyGeom.CurveVector
        
        Create a linestring or polygon from xyz data.
        
        :param (input):
        points vertex coordinates points.
        
        :param (input):
        boundaryType is one of
        
        * BOUNDARY_TYPE_Outer, or BOUNDARY_TYPE_INNER:Duplication forced on
        first/last point. Orientation optionally enforced.
        
        * BOUNDARY_TYPE_Open, BOUNDARY_TYPE_None:points copied unchanged.
        
        * BOUNDARY_TYPE_UnionRegion, BOUNDARY_TYPE_ParityRegion create two-
        level structure with polygon at second level with BOUNDARY_TYPE_Outer.
        
        :param (input):
        forceXYOrientation true to force outer and inner loops to have
        correct (CCW/CW) order.
        """
        ...
    
    @staticmethod
    def CreateRectangle(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateRectangle(x0: float, y0: float, x1: float, y1: float, z: float, boundaryType: MSPyBentleyGeom.CurveVector.BoundaryType = <BoundaryType.eBOUNDARY_TYPE_Outer: 2>) -> MSPyBentleyGeom.CurveVector
        
        2. CreateRectangle(x0: float, y0: float, x1: float, y1: float, z: float, boundaryType: MSPyBentleyGeom.CurveVector.BoundaryType = <BoundaryType.eBOUNDARY_TYPE_Outer: 2>) -> MSPyBentleyGeom.CurveVector
        
        Create a rectangle from xy corners.
        
        :param (input):
        x0 start point x coordinate
        
        :param (input):
        y0 start point y coordinate
        
        :param (input):
        x1 opposite corner x coordinate
        
        :param (input):
        y1 opposite corner y coordinate
        
        :param (input):
        z z value for all points.
        
        :param (input):
        boundaryType is one of
        
        * BOUNDARY_TYPE_Outer:force to counterclockwise and positive area
        
        * BOUNDARY_TYPE_Inner:force to clockwise and negative area
        
        * BOUNDARY_TYPE_Open, BOUNDARY_TYPE_None:point order
        (x0,y0)(x1,y0),(x1,y1),(x0,y1)
        
        * BOUNDARY_TYPE_UnionRegion, BOUNDARY_TYPE_ParityRegion create two-
        level structure with rectangle at second level with
        BOUNDARY_TYPE_Outer
        """
        ...
    
    @staticmethod
    def CreateRegularPolygonXY(*args, **kwargs):
        """
        CreateRegularPolygonXY(center: DPoint3d, xDistance: float, numEdge: int, isOuterRadius: bool, boundaryType: MSPyBentleyGeom.CurveVector.BoundaryType = <BoundaryType.eBOUNDARY_TYPE_Outer: 2>) -> MSPyBentleyGeom.CurveVector
        """
        ...
    
    @staticmethod
    def CreateXYHatch(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateXYHatch(boundary: MSPyBentleyGeom.CurveVector, startPoint: DPoint3d, angleRadians: float, spacing: float, selection: int = 0) -> MSPyBentleyGeom.CurveVector
        
        2. CreateXYHatch(boundary: MSPyBentleyGeom.CurveVector, startPoint: DPoint3d, angleRadians: float, spacing: float, selection: int = 0) -> MSPyBentleyGeom.CurveVector
        
        Return a curve vector (of type BOUNDARY_TYPE_None) containing hatch
        sticks.
        """
        ...
    
    def CurveLocationDetailCompare(*args, **kwargs):
        """
        Overloaded function.
        
        1. CurveLocationDetailCompare(self: MSPyBentleyGeom.CurveVector, location0: MSPyBentleyGeom.CurveLocationDetail, location1: MSPyBentleyGeom.CurveLocationDetail) -> int
        
        2. CurveLocationDetailCompare(self: MSPyBentleyGeom.CurveVector, location0: MSPyBentleyGeom.CurveLocationDetail, location1: MSPyBentleyGeom.CurveLocationDetail) -> int
        
        return 0 of locations are equal, -1 if location 0 is less than
        location 1, and 1 if location 0> location 1. This is a lexical
        comparison using (only) the curve index and the fraction.
        """
        ...
    
    def CurveLocationDetailIndex(*args, **kwargs):
        """
        Overloaded function.
        
        1. CurveLocationDetailIndex(self: MSPyBentleyGeom.CurveVector, location: MSPyBentleyGeom.CurveLocationDetail) -> int
        
        2. CurveLocationDetailIndex(self: MSPyBentleyGeom.CurveVector, location: MSPyBentleyGeom.CurveLocationDetail) -> int
        
        return index of curve location detail in vector (only valid for a
        vector that is a single open or closed path). Returns SIZE_MAX if not
        found.
        """
        ...
    
    def CyclicIndex(*args, **kwargs):
        """
        Overloaded function.
        
        1. CyclicIndex(self: MSPyBentleyGeom.CurveVector, index: int) -> int
        
        2. CyclicIndex(self: MSPyBentleyGeom.CurveVector, index: int) -> int
        
        return mod of index with vector length, properly corrected for
        negatives.
        """
        ...
    
    def FastLength(*args, **kwargs):
        """
        Overloaded function.
        
        1. FastLength(self: MSPyBentleyGeom.CurveVector) -> float
        
        2. FastLength(self: MSPyBentleyGeom.CurveVector) -> float
        
        Sum lengths of contained curves, using fast method that may
        overestimate the length but is reasonable for setting tolerances.
        """
        ...
    
    def FastMaxAbs(*args, **kwargs):
        """
        Overloaded function.
        
        1. FastMaxAbs(self: MSPyBentleyGeom.CurveVector) -> float
        
        2. FastMaxAbs(self: MSPyBentleyGeom.CurveVector) -> float
        
        Return a fast estimate of the maximum absolute value in any
        coordinate. This will examine all curves, but is allowed to use safe
        approximations like bspline pole coordinates instead of exact curve
        calculations.
        """
        ...
    
    def FindIndexOfPrimitive(*args, **kwargs):
        """
        Overloaded function.
        
        1. FindIndexOfPrimitive(self: MSPyBentleyGeom.CurveVector, primitive: MSPyBentleyGeom.ICurvePrimitive) -> int
        
        2. FindIndexOfPrimitive(self: MSPyBentleyGeom.CurveVector, primitive: MSPyBentleyGeom.ICurvePrimitive) -> int
        
        return index of primitive in vector (only valid for a vector that is a
        single open or closed path). Returns SIZE_MAX if not found.
        """
        ...
    
    def FindParentOfPrimitive(*args, **kwargs):
        """
        Overloaded function.
        
        1. FindParentOfPrimitive(self: MSPyBentleyGeom.CurveVector, primitive: MSPyBentleyGeom.ICurvePrimitive) -> MSPyBentleyGeom.CurveVector
        
        2. FindParentOfPrimitive(self: MSPyBentleyGeom.CurveVector, primitive: MSPyBentleyGeom.ICurvePrimitive) -> MSPyBentleyGeom.CurveVector
        
        Search the tree (below the calling instance) for the curve vector
        which is the immediate parent of given primitive.
        """
        ...
    
    def FixupXYOuterInner(*args, **kwargs):
        """
        Overloaded function.
        
        1. FixupXYOuterInner(self: MSPyBentleyGeom.CurveVector, fullGeometryCheck: bool = False) -> bool
        
        2. FixupXYOuterInner(self: MSPyBentleyGeom.CurveVector, fullGeometryCheck: bool = False) -> bool
        
        Update order, boundary type, and direction of contained loops. Loop A
        is considered " inside " loop B if (a) loop A has smaller area and (b)
        the start point of loop A is inside loop B. A loop that is " inside " an
        ODD number of other loops is considered to be a " hole " (inner loop)
        within the containing loop that has smallest area. Any other loop is
        considered an outer loop.
        
        * If there is a single outer loop, the (modified) curve vector is
        marked as a parity region. The outer loop is moved first and the inner
        loops follows.
        
        * If there are multiple outer loops, the (modified) curve vector is
        marked as a union region. Within the UnionRegion
        
        * Outer loops with no contained loops are present as simple Outer
        loops.
        
        * Outer loops with holes are parity regions.
        
        :param (input):
        fullGeometryCheck if true, perform all (expensive) tests for
        intersections among curves. When this is enabled, the returned
        curve vector is typically a (possibly significantly modified)
        clone of the original.
        """
        ...
    
    def FlattenNestedUnionRegions(self: MSPyBentleyGeom.CurveVector) -> None:
        ...
    
    def GenerateAllParts(*args, **kwargs):
        """
        Overloaded function.
        
        1. GenerateAllParts(self: MSPyBentleyGeom.CurveVector, indexA: int, fractionA: float, indexB: int, fractionB: float) -> MSPyBentleyGeom.CurveVector
        
        2. GenerateAllParts(self: MSPyBentleyGeom.CurveVector, indexA: int, fractionA: float, indexB: int, fractionB: float) -> MSPyBentleyGeom.CurveVector
        
        Return a CurveVector (BOUNDARY_TYPE_None) which is a collection of
        open CurveVectors that collectively contain all parts of the input For
        (indexA,fractionA) prededing (indexB,fractionB) the output traces the
        input in the forward direction and has the following possibilities (of
        which null ones are skipped) ul> li> BOUNDARY_TYPE_Open - (A B), (B to
        end), (start to A) li> BOUNDARY_TYPE_Inner or BOUNDARY_TYPE_Outer - (A
        B), (B to where A appears in the next period) li>
        BOUNDARY_TYPE_ParityRegion, BOUNDARY_TYPE_UnionRegion,
        BOUNDARY_TYPE_None -- no output. ul> For (indexA,fractionA) prededing
        (indexB,fractionB) the output traces the input in the reverse
        direction and has the following possibilities (of which null ones are
        skipped) ul> li> BOUNDARY_TYPE_Open - (A backwards to B), (B backwards
        to start), (end backwards to A) li> BOUNDARY_TYPE_Inner or
        BOUNDARY_TYPE_Outer - (A backwards to B), (B backwards to where A
        appears in the previous period.) li> BOUNDARY_TYPE_ParityRegion,
        BOUNDARY_TYPE_UnionRegion, BOUNDARY_TYPE_None -- no output. ul
        """
        ...
    
    def GetAnyFrenetFrame(*args, **kwargs):
        """
        Overloaded function.
        
        1. GetAnyFrenetFrame(self: MSPyBentleyGeom.CurveVector, frame: Transform) -> bool
        
        Deep search for any curve primitive that has a well defined coordinate
        frame.
        
        :param (output):
        frame coordinate frame with origin on a primitive.
        
        :returns:
        true if a primitive was found.
        
        2. GetAnyFrenetFrame(self: MSPyBentleyGeom.CurveVector, frame: Transform, searchPreference: int) -> bool
        
        Deep search for any curve primitive that has a well defined coordinate
        frame.
        
        :param (output):
        frame coordinate frame with origin on a primitive.
        
        :returns:
        true if a primitive was found.
        """
        ...
    
    def GetBoundaryType(self: MSPyBentleyGeom.CurveVector) -> MSPyBentleyGeom.CurveVector.BoundaryType:
        """
        Return the type code indicating whether the vector is a path, outer
        boundary, inner boundary, or higher level grouping.
        """
        ...
    
    def GetBsplineCurve(*args, **kwargs):
        """
        Overloaded function.
        
        1. GetBsplineCurve(self: MSPyBentleyGeom.CurveVector) -> RefCountedMSBsplineCurve
        
        2. GetBsplineCurve(self: MSPyBentleyGeom.CurveVector) -> RefCountedMSBsplineCurve
        
        Represent a curve vector that denotes an open or closed path as a
        single bspline curve.
        """
        ...
    
    def GetCyclic(*args, **kwargs):
        """
        Overloaded function.
        
        1. GetCyclic(self: MSPyBentleyGeom.CurveVector, index: int) -> MSPyBentleyGeom.ICurvePrimitive
        
        2. GetCyclic(self: MSPyBentleyGeom.CurveVector, index: int) -> MSPyBentleyGeom.ICurvePrimitive
        
        return child at cyclic index, propertly corrected for negatives.
        """
        ...
    
    def GetRange(*args, **kwargs):
        """
        Overloaded function.
        
        1. GetRange(self: MSPyBentleyGeom.CurveVector, range: DRange3d) -> bool
        
        2. GetRange(self: MSPyBentleyGeom.CurveVector, range: DRange3d, transform: Transform) -> bool
        
        3. GetRange(self: MSPyBentleyGeom.CurveVector, range: DRange3d) -> bool
        
        Return the xyz range of contained curves.
        
        4. GetRange(self: MSPyBentleyGeom.CurveVector, range: DRange3d, transform: Transform) -> bool
        
        Return the xyz range of contained curves.
        """
        ...
    
    def GetStartEnd(*args, **kwargs):
        """
        Overloaded function.
        
        1. GetStartEnd(self: MSPyBentleyGeom.CurveVector, pointA: DPoint3d, pointB: DPoint3d) -> bool
        
        2. GetStartEnd(self: MSPyBentleyGeom.CurveVector, pointA: DPoint3d, pointB: DPoint3d, unitTangentA: DVec3d, unitTangentB: DVec3d) -> bool
        
        3. GetStartEnd(self: MSPyBentleyGeom.CurveVector, pointA: DPoint3d, pointB: DPoint3d) -> bool
        
        Return first/last among children.
        
        :param (output):
        pointA start point
        
        :param (output):
        pointB end point
        
        4. GetStartEnd(self: MSPyBentleyGeom.CurveVector, pointA: DPoint3d, pointB: DPoint3d, unitTangentA: DVec3d, unitTangentB: DVec3d) -> bool
        
        Return first/last among children.
        
        :param (output):
        pointA start point
        
        :param (output):
        pointB end point
        """
        ...
    
    def GetStartPoint(*args, **kwargs):
        """
        Overloaded function.
        
        1. GetStartPoint(self: MSPyBentleyGeom.CurveVector, point: DPoint3d) -> bool
        
        2. GetStartPoint(self: MSPyBentleyGeom.CurveVector, point: DPoint3d) -> bool
        
        Return start point of the primitive (or first primitive in deep
        search)
        
        :param (output):
        point start point.
        """
        ...
    
    def HasNestedUnionRegion(self: MSPyBentleyGeom.CurveVector) -> bool:
        ...
    
    def HasSingleCurvePrimitive(self: MSPyBentleyGeom.CurveVector) -> MSPyBentleyGeom.ICurvePrimitive.CurvePrimitiveType:
        """
        Return true if the curve vector has a single element and that element
        is a primitive.
        """
        ...
    
    class InOutClassification:
        """
        Members:
        
        eINOUT_Unknown
        
        eINOUT_In
        
        eINOUT_Out
        
        eINOUT_On
        """
    
        def __init__(self: MSPyBentleyGeom.CurveVector.InOutClassification, value: int) -> None:
            ...
        
        eINOUT_In: InOutClassification
        
        eINOUT_On: InOutClassification
        
        eINOUT_Out: InOutClassification
        
        eINOUT_Unknown: InOutClassification
        
        @property
        def name(self: handle) -> str:
            ...
        
        @property
        def value(arg0: MSPyBentleyGeom.CurveVector.InOutClassification) -> int:
            ...
        
    def IsAnyRegionType(self: MSPyBentleyGeom.CurveVector) -> bool:
        """
        Query:is this any closed area type (single, parity, union)
        """
        ...
    
    def IsClosedPath(self: MSPyBentleyGeom.CurveVector) -> bool:
        """
        Query:Is this (single) closed path?
        """
        ...
    
    def IsEllipticDisk(self: MSPyBentleyGeom.CurveVector, ellipse: DEllipse3d) -> bool:
        """
        Query:Is this an outer loop with an ellipse as its only curve?
        """
        ...
    
    def IsOpenPath(self: MSPyBentleyGeom.CurveVector) -> bool:
        """
        Query:Is this an open path?
        """
        ...
    
    def IsParityRegion(self: MSPyBentleyGeom.CurveVector) -> bool:
        """
        Query:Is this a collection of loops with parity rules?
        """
        ...
    
    def IsPhysicallyClosedPath(self: MSPyBentleyGeom.CurveVector) -> bool:
        """
        Query:Is this a nominally open path but with matching start and end?
        """
        ...
    
    def IsPlanar(*args, **kwargs):
        """
        Overloaded function.
        
        1. IsPlanar(self: MSPyBentleyGeom.CurveVector, localToWorld: Transform, worldToLocal: Transform, range: DRange3d) -> bool
        
        2. IsPlanar(self: MSPyBentleyGeom.CurveVector, localToWorld: Transform, worldToLocal: Transform, range: DRange3d) -> bool
        
        Test if the contained curves are planar. If so, return transforms and
        local range.
        
        :param (output):
        localToWorld A coordinate frame somewhere on the curves. The
        curves are on the xy plane.
        
        :param (output):
        worldToLocal Inverse of localToWorld.
        
        :param (output):
        range range of the curves when worldToLocal is applied.
        
        :returns:
        true if range is computed and has small z component.
        
        Remark:
        returns true (planar!!) for a single line. Test the local range
        with IsAlmostZeroY to identify this condition.
        """
        ...
    
    def IsPlanarWithDefaultNormal(*args, **kwargs):
        """
        Overloaded function.
        
        1. IsPlanarWithDefaultNormal(self: MSPyBentleyGeom.CurveVector, localToWorld: Transform, worldToLocal: Transform, range: DRange3d, normal: DVec3d) -> bool
        
        2. IsPlanarWithDefaultNormal(self: MSPyBentleyGeom.CurveVector, localToWorld: Transform, worldToLocal: Transform, range: DRange3d, normal: DVec3d) -> bool
        
        Test if the contained curves are planar. If so, return transforms and
        local range.
        
        :param (output):
        localToWorld A coordinate frame somewhere on the curves. The
        curves are on the xy plane.
        
        :param (output):
        worldToLocal Inverse of localToWorld.
        
        :param (output):
        range range of the curves when worldToLocal is applied.
        
        :param (input):
        normal optional normal to resolve ambiguous cases. If this is
        NULL, any perpendicular to an ambiguous line will be used.
        
        :returns:
        true if range is computed and has small z component.
        """
        ...
    
    def IsRectangle(self: MSPyBentleyGeom.CurveVector, localToWorld: Transform, worldToLocal: Transform) -> bool:
        """
        Query:Is this a rectangle?
        
        :param (output):
        localToWorld transform with origin at start, x and y vectors to
        adjacent points, z vector unit normal. (i.e. the x and y vector
        lengths are the side lengths)
        
        :param (output):
        worldToLocal transform to map rectangle to 0..1 in each direction.
        """
        ...
    
    def IsSameStructure(*args, **kwargs):
        """
        Overloaded function.
        
        1. IsSameStructure(self: MSPyBentleyGeom.CurveVector, other: MSPyBentleyGeom.CurveVector) -> bool
        
        2. IsSameStructure(self: MSPyBentleyGeom.CurveVector, other: MSPyBentleyGeom.CurveVector) -> bool
        
        Recursive check for structural match (tree structure and leaf type)
        with the other curve vector.
        """
        ...
    
    def IsSameStructureAndGeometry(*args, **kwargs):
        """
        Overloaded function.
        
        1. IsSameStructureAndGeometry(self: MSPyBentleyGeom.CurveVector, other: MSPyBentleyGeom.CurveVector, tolerance: float = 0.0) -> bool
        
        2. IsSameStructureAndGeometry(self: MSPyBentleyGeom.CurveVector, other: MSPyBentleyGeom.CurveVector, tolerance: float = 0.0) -> bool
        
        Recursive check for match (tree structure. leaf type, and geometry)
        with a peer. <param name=" other ">peer for comparison</param> <param
        name=" tolerance ">distance tolerance. (See DoubleOps.AlmostEqual
        ())</param
        """
        ...
    
    def IsUnionRegion(self: MSPyBentleyGeom.CurveVector) -> bool:
        """
        Query:is this a collection of areas with union rules?
        """
        ...
    
    def Length(*args, **kwargs):
        """
        Overloaded function.
        
        1. Length(self: MSPyBentleyGeom.CurveVector) -> float
        
        2. Length(self: MSPyBentleyGeom.CurveVector, worldToLocal: RotMatrix) -> float
        
        3. Length(self: MSPyBentleyGeom.CurveVector) -> float
        
        Sum lengths of contained curves.
        
        4. Length(self: MSPyBentleyGeom.CurveVector, worldToLocal: RotMatrix) -> float
        
        Sum lengths of contained curves.
        """
        ...
    
    def MaxGapWithinPath(*args, **kwargs):
        """
        Overloaded function.
        
        1. MaxGapWithinPath(self: MSPyBentleyGeom.CurveVector) -> float
        
        2. MaxGapWithinPath(self: MSPyBentleyGeom.CurveVector) -> float
        
        Maximum gap distance between end of primitive and start of its
        successor within Open, outer, or Inner loop.
        """
        ...
    
    def PlaneSection(*args, **kwargs):
        """
        Overloaded function.
        
        1. PlaneSection(self: MSPyBentleyGeom.CurveVector, plane: DPlane3d, tolerance: float = 0.0) -> MSPyBentleyGeom.ICurvePrimitive
        
        2. PlaneSection(self: MSPyBentleyGeom.CurveVector, plane: DPlane3d, tolerance: float = 0.0) -> MSPyBentleyGeom.ICurvePrimitive
        
        Compute intersections of closed CurveVector with a plane and organize
        as start end pairs by parity rules. Return as a single curve primitive
        (which may be child vector of multiple primitives) If there are no
        intersections the smart pointer is empty (IsValid () returns false)
        
        :param (input):
        plane
        
        :param (input):
        tolerance for on-plane decisions. If 0, a tolerance is computed
        based on the coordinates in the curve.
        """
        ...
    
    def PointInOnOutXY(*args, **kwargs):
        """
        Overloaded function.
        
        1. PointInOnOutXY(self: MSPyBentleyGeom.CurveVector, xyz: DPoint3d) -> MSPyBentleyGeom.CurveVector.InOutClassification
        
        2. PointInOnOutXY(self: MSPyBentleyGeom.CurveVector, xyz: DPoint3d) -> MSPyBentleyGeom.CurveVector.InOutClassification
        
        Test if a point is in, on, or outside when looking at xy plane. return
        INOUT_Unknown if the CurveVector is not an area. (i.e. type
        BOUNDARY_TYPE_Outer, BOUNDARY_TYPE_Inner, BOUNDARY_TYPE_ParityRegion,
        or BOUNDARY_TYPE_Union
        
        :param (input):
        xyz test point
        """
        ...
    
    def ProjectedParameterRange(self: MSPyBentleyGeom.CurveVector, ray: DRay3d) -> DRange1d:
        """
        Return the range of ray parameters when contents of the CurveVector
        are projected to a ray. return DRange1d with range data.
        
        :param (input):
        ray test ray.
        
        Remark:
        If the ray's direction vector is a unit vector, the projected
        parameters are physical distances.
        
        Remark:
        If the ray's direction vector is NOT a unit vector, the projected
        parameters are fractions of the ray's direction vector.
        
        Remark:
        If the CurveVector has no curves, the returned range returns true
        on the DRange1d.IsNull() predicate.
        """
        ...
    
    def RayPierceInOnOut(*args, **kwargs):
        """
        Overloaded function.
        
        1. RayPierceInOnOut(self: MSPyBentleyGeom.CurveVector, ray: DRay3d, hitDetail: MSPyBentleyGeom.SolidLocationDetail) -> MSPyBentleyGeom.CurveVector.InOutClassification
        
        2. RayPierceInOnOut(self: MSPyBentleyGeom.CurveVector, ray: DRay3d, hitDetail: MSPyBentleyGeom.SolidLocationDetail) -> MSPyBentleyGeom.CurveVector.InOutClassification
        
        Test for a ray hit in the curve vector's planar region. return
        INOUT_Unknown if the CurveVector is not an area. (i.e. type
        BOUNDARY_TYPE_Outer, BOUNDARY_TYPE_Inner, BOUNDARY_TYPE_ParityRegion,
        or BOUNDARY_TYPE_Union
        """
        ...
    
    @staticmethod
    def ReduceToCCWAreas(*args, **kwargs):
        """
        Overloaded function.
        
        1. ReduceToCCWAreas(regionA: MSPyBentleyGeom.CurveVector) -> MSPyBentleyGeom.CurveVector
        
        2. ReduceToCCWAreas(regionA: MSPyBentleyGeom.CurveVector) -> MSPyBentleyGeom.CurveVector
        
        Return a curve vector containing only clockwise areas. Loops within
        parity regions are fixed first. Then multiple regions in a union are
        combined.
        
        :param (input):
        regionA input areas
        """
        ...
    
    def ReorderForSmallGaps(*args, **kwargs):
        """
        Overloaded function.
        
        1. ReorderForSmallGaps(self: MSPyBentleyGeom.CurveVector) -> float
        
        2. ReorderForSmallGaps(self: MSPyBentleyGeom.CurveVector) -> float
        
        Reorder curve primitives to produce small head-to-tail gaps.
        reordering is applied only within boundary types None, Open, and
        Closed. other types are updated recursively. Return the largest gap.
        """
        ...
    
    def ResolveTolerance(*args, **kwargs):
        """
        Overloaded function.
        
        1. ResolveTolerance(self: MSPyBentleyGeom.CurveVector, tolerance: float) -> float
        
        2. ResolveTolerance(self: MSPyBentleyGeom.CurveVector, tolerance: float) -> float
        
        return larger of given tolerance and default tolerance based on
        FastMasAbs of contents ...
        """
        ...
    
    def ReverseCurvesInPlace(*args, **kwargs):
        """
        Overloaded function.
        
        1. ReverseCurvesInPlace(self: MSPyBentleyGeom.CurveVector) -> bool
        
        2. ReverseCurvesInPlace(self: MSPyBentleyGeom.CurveVector) -> bool
        
        Recursively reverse. All leaf curves are reversed. Primitive order
        within path types (_Outer, _Inner, _Open) is reversed. All others
        (_Union, _Parity, _None) are unchanged.
        """
        ...
    
    def SimplifyLinestrings(*args, **kwargs):
        """
        Overloaded function.
        
        1. SimplifyLinestrings(self: MSPyBentleyGeom.CurveVector, distanceTol: float, eliminateOverdraw: bool, wrap: bool) -> None
        
        2. SimplifyLinestrings(self: MSPyBentleyGeom.CurveVector, distanceTol: float, eliminateOverdraw: bool, wrap: bool) -> None
        
        Inplace update to consolidate colinear interior points of linestrings.
        If distance tolerance is nonpositive a tolerance will be assigned from
        the range.
        """
        ...
    
    def Stroke(*args, **kwargs):
        """
        Overloaded function.
        
        1. Stroke(self: MSPyBentleyGeom.CurveVector, options: IFacetOptions) -> MSPyBentleyGeom.CurveVector
        
        2. Stroke(self: MSPyBentleyGeom.CurveVector, options: IFacetOptions) -> MSPyBentleyGeom.CurveVector
        
        Return a " deep copy " with primitives replaced by strokes. The tree
        upper levels of the tree structure are retained -- i.e. the output
        contains corresponding tree structure ParityRegion, UnionRegion,
        OuterLoop, and InnerLoop ul> li>UnionRegion and ParityRegion vectors:
        Create a new CurveVector of the same type. Recursively create
        children. li>OuterLoop, InnerLoop, OpenPath:Create a new curve vector
        of the same type. Stroke all curve primitives into a single linestring
        with the child curves' AddStrokes method. ul
        """
        ...
    
    def SwapAt(self: MSPyBentleyGeom.CurveVector, index0: int, index1: int) -> bool:
        """
        Swap the entries at given indices. Return false if either index is out
        of bounds.
        """
        ...
    
    def SwapContents(self: MSPyBentleyGeom.CurveVector, other: MSPyBentleyGeom.CurveVector) -> None:
        """
        Swap bvectors and type.
        """
        ...
    
    def ToBsplineCurve(*args, **kwargs):
        """
        Overloaded function.
        
        1. ToBsplineCurve(self: MSPyBentleyGeom.CurveVector, curve: MSBsplineCurve) -> BentleyStatus
        
        2. ToBsplineCurve(self: MSPyBentleyGeom.CurveVector, curve: MSBsplineCurve) -> BentleyStatus
        
        Represent a curve vector that denotes an open or closed path as a
        single bspline curve.
        """
        ...
    
    def TransformInPlace(*args, **kwargs):
        """
        Overloaded function.
        
        1. TransformInPlace(self: MSPyBentleyGeom.CurveVector, transform: Transform) -> bool
        
        2. TransformInPlace(self: MSPyBentleyGeom.CurveVector, transform: Transform) -> bool
        
        Apply a transform to all contained curves.
        """
        ...
    
    def TryUVFractionToXYZ(self: MSPyBentleyGeom.CurveVector, uFraction: float, vFraction: float, xyz: DPoint3d, dXdu: DVec3d, dXdv: DVec3d) -> bool:
        """
        convert u,v fraction to xyz and derivatives. This is an expensive
        operation. It has to call CloneInLocalCoordinates before it can
        multiply uv by the localToWorld transformation. To do this efficiently
        many times, call CloneInLocalCoordinates once and reuse the
        localToWorld transform.
        
        :param (input):
        uFraction fractional coordinate in u direction.
        
        :param (input):
        vFraction fractional coordinate in v direction.
        
        :param (output):
        xyz point on face.
        
        :param (output):
        dXdu derivative of face point wrt uFraction.
        
        :param (output):
        dXdv derivative of face point wrt vFraction.
        """
        ...
    
    def WireCentroid(self: MSPyBentleyGeom.CurveVector) -> tuple:
        """
        Return the centroid of the contained curves, considered as wires.
        (Isolated points are not considered.) (Bounded area centroids are not
        computed. The boundary curves are used as wires.) return false if no
        curves are found.
        
        :param (output):
        length curve length
        
        :param (output):
        centroid curve centroid
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.CurveVector, boundaryType: MSPyBentleyGeom.CurveVector.BoundaryType) -> None
        
        2. __init__(self: MSPyBentleyGeom.CurveVector, boundaryType: MSPyBentleyGeom.CurveVector.BoundaryType, primitive: MSPyBentleyGeom.ICurvePrimitive) -> None
        
        3. __init__(self: MSPyBentleyGeom.CurveVector, segments: List[DSegment3d]) -> None
        
        4. __init__(self: MSPyBentleyGeom.CurveVector, child: MSPyBentleyGeom.ICurvePrimitive, boundaryType: MSPyBentleyGeom.CurveVector.BoundaryType) -> None
        """
        ...
    
    eBOUNDARY_TYPE_Inner: BoundaryType
    
    eBOUNDARY_TYPE_None: BoundaryType
    
    eBOUNDARY_TYPE_Open: BoundaryType
    
    eBOUNDARY_TYPE_Outer: BoundaryType
    
    eBOUNDARY_TYPE_ParityRegion: BoundaryType
    
    eBOUNDARY_TYPE_UnionRegion: BoundaryType
    
    eINOUT_In: InOutClassification
    
    eINOUT_On: InOutClassification
    
    eINOUT_Out: InOutClassification
    
    eINOUT_Unknown: InOutClassification
    
class CurveVectorPtrArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.CurveVectorPtrArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.CurveVectorPtrArray, arg0: MSPyBentleyGeom.CurveVectorPtrArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.CurveVectorPtrArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.CurveVectorPtrArray, x: MSPyBentleyGeom.CurveVector) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.CurveVectorPtrArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def count(self: MSPyBentleyGeom.CurveVectorPtrArray, x: MSPyBentleyGeom.CurveVector) -> int:
        """
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.CurveVectorPtrArray, L: MSPyBentleyGeom.CurveVectorPtrArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.CurveVectorPtrArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.CurveVectorPtrArray, i: int, x: MSPyBentleyGeom.CurveVector) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.CurveVectorPtrArray) -> MSPyBentleyGeom.CurveVector
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.CurveVectorPtrArray, i: int) -> MSPyBentleyGeom.CurveVector
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(self: MSPyBentleyGeom.CurveVectorPtrArray, x: MSPyBentleyGeom.CurveVector) -> None:
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class CurveVectorWithDistanceIndex:
    """
    None
    """

    def AtEnd(self: MSPyBentleyGeom.CurveVectorWithDistanceIndex) -> MSPyBentleyGeom.PathLocationDetail:
        """
        Return the final location.
        """
        ...
    
    def AtStart(self: MSPyBentleyGeom.CurveVectorWithDistanceIndex) -> MSPyBentleyGeom.PathLocationDetail:
        """
        Return the start location.
        """
        ...
    
    def DistanceBetweenPointsXY(self: MSPyBentleyGeom.CurveVectorWithDistanceIndex, xyzA: DPoint3d, xyzB: DPoint3d) -> float:
        """
        projected distance between points
        """
        ...
    
    def DistanceXYFromPathStart(self: MSPyBentleyGeom.CurveVectorWithDistanceIndex, arg0: MSPyBentleyGeom.PathLocationDetail) -> tuple:
        """
        Given a path location, find the projected curve distance from the path
        start.
        """
        ...
    
    def IsEmpty(self: MSPyBentleyGeom.CurveVectorWithDistanceIndex) -> bool:
        """
        Return true if there are no curves.
        """
        ...
    
    def NumberOfPrimitives(self: MSPyBentleyGeom.CurveVectorWithDistanceIndex) -> int:
        """
        Return the total number of curve primitives in the path.
        """
        ...
    
    def SearchByDistanceFromPathStart(self: MSPyBentleyGeom.CurveVectorWithDistanceIndex, targetDistance: float, detail: MSPyBentleyGeom.PathLocationDetail) -> bool:
        """
        Return detailed curve location for the position at targetDistance
        along the curve.
        """
        ...
    
    def SearchByDistanceFromPathStartXY(self: MSPyBentleyGeom.CurveVectorWithDistanceIndex, targetDistanceXY: float, detail: MSPyBentleyGeom.PathLocationDetail) -> bool:
        """
        Return detailed curve location for the position at targetDistance
        along the curve, measuring in path distance. WARNING:The distance
        entry in the PositionLocationDetail is true distance (with z
        variation)
        """
        ...
    
    def SearchClosestPointBounded(self: MSPyBentleyGeom.CurveVectorWithDistanceIndex, spacePoint: DPoint3d, computeDistanceAlong: bool) -> MSPyBentleyGeom.PathLocationDetail:
        """
        Search for curve point closest to given space point.
        """
        ...
    
    def SearchFirstIntersectionWithCircleXY(self: MSPyBentleyGeom.CurveVectorWithDistanceIndex, startLocation: MSPyBentleyGeom.PathLocationDetail, signedRadius: float, intersectionLocation: MSPyBentleyGeom.PathLocationDetail) -> bool:
        """
        Start at specified location. Make a circle of given radius. Look for
        the " first " intersection of the circle with the path, moving only
        forward if the radius is positive and only backward if negative.
        """
        ...
    
    def SetExtendedPath(self: MSPyBentleyGeom.CurveVectorWithDistanceIndex, path: MSPyBentleyGeom.CurveVector, extensionDistance: float, boundedStart: MSPyBentleyGeom.PathLocationDetail, boundedEnd: MSPyBentleyGeom.PathLocationDetail, measureExtensionInView: bool = False, maxExtensionFactor: float = 4.0) -> bool:
        """
        Announce the path to be indexed. This will 1) Construct line segments
        to extend in the directions of the start and end tangents. 2) create
        the <curve,distance> index 3) return PositionLocationDetails for the
        limits of the bounded path.
        """
        ...
    
    def SetPath(self: MSPyBentleyGeom.CurveVectorWithDistanceIndex, path: MSPyBentleyGeom.CurveVector) -> None:
        """
        Announce the path to be indexed. This will:1) save a pointer to the
        path. 2) create an index of <curve,distance> to support fast search
        and navigation by distance.
        """
        ...
    
    def TotalPathLength(self: MSPyBentleyGeom.CurveVectorWithDistanceIndex) -> float:
        """
        Return complete path length.
        """
        ...
    
    def TotalPathLengthXY(self: MSPyBentleyGeom.CurveVectorWithDistanceIndex) -> float:
        """
        Return complete path length as flattened into the view.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.CurveVectorWithDistanceIndex, worldToView: RotMatrix) -> None
        
        2. __init__(self: MSPyBentleyGeom.CurveVectorWithDistanceIndex) -> None
        """
        ...
    
class DBilinearPatch3d:
    """
    None
    """

    def Evaluate(*args, **kwargs):
        """
        Overloaded function.
        
        1. Evaluate(self: MSPyBentleyGeom.DBilinearPatch3d, u: float, v: float) -> DPoint3d
        
        Return surface coordinates at u,v parameters
        
        2. Evaluate(self: MSPyBentleyGeom.DBilinearPatch3d, u: float, v: float, xyz: DPoint3d, dXdu: DVec3d, dXdv: DVec3d) -> None
        
        Return surface coordinates at u,v parameters
        """
        ...
    
    def EvaluateGrid(self: MSPyBentleyGeom.DBilinearPatch3d, numUPoint: int, numVPoint: int, gridPoints: List[DPoint3d]) -> None:
        ...
    
    def EvaluateNormal(self: MSPyBentleyGeom.DBilinearPatch3d, u: float, v: float, xyz: DPoint3d, unitNormal: DVec3d) -> None:
        """
        Return surface coordinates and unit normal at u,v parameters
        """
        ...
    
    def GetCCWEdge(self: MSPyBentleyGeom.DBilinearPatch3d, i: int) -> DSegment3d:
        """
        Return specified edge as a line segment. Edge order is:bottom, right,
        top, left with CCW loop direction.
        """
        ...
    
    def GetDiagonalFrom00(self: MSPyBentleyGeom.DBilinearPatch3d) -> DVec3d:
        """
        return diagonal vector starting at 00
        """
        ...
    
    def GetDiagonalFrom01(self: MSPyBentleyGeom.DBilinearPatch3d) -> DVec3d:
        """
        return diagonal vector starting at 01
        """
        ...
    
    def GetUEdgeVector(self: MSPyBentleyGeom.DBilinearPatch3d, i: int) -> DVec3d:
        """
        return vector along u edge (lower or upper)
        
        :param (input):
        i 0,1 for lower, upper edge.
        """
        ...
    
    def GetVEdgeVector(self: MSPyBentleyGeom.DBilinearPatch3d, i: int) -> DVec3d:
        """
        return vector along v edge (left, right)
        
        :param (input):
        i 0,1 for left, right edge.
        """
        ...
    
    def IsParallelogram(self: MSPyBentleyGeom.DBilinearPatch3d) -> bool:
        """
        Test if the patch is just a parallelogram
        """
        ...
    
    def IsPlanar(*args, **kwargs):
        """
        Overloaded function.
        
        1. IsPlanar(self: MSPyBentleyGeom.DBilinearPatch3d) -> bool
        
        Test if the patch is planar, with usual system angle tolerances
        (tight)
        
        2. IsPlanar(self: MSPyBentleyGeom.DBilinearPatch3d, angleTol: float) -> bool
        
        Test if the patch is planar, with usual system angle tolerances
        (tight)
        """
        ...
    
    def PerpendicularsOnBoundedPatch(self: MSPyBentleyGeom.DBilinearPatch3d, spacePoint: DPoint3d, uv: List[DPoint2d]) -> bool:
        """
        return uv coordinates of projections of xyz onto the (bounded) patch.
        This returns only true perpendicular projections (i.e. does not give
        " close but nonperpendicular point on edge ")
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DBilinearPatch3d) -> None
        
        2. __init__(self: MSPyBentleyGeom.DBilinearPatch3d, xyz0: DPoint3d, xyz10: DPoint3d, xyz01: DPoint3d, xyz11: DPoint3d) -> None
        
        3. __init__(self: MSPyBentleyGeom.DBilinearPatch3d, xyz0: DPoint2d, xyz10: DPoint2d, xyz01: DPoint2d, xyz11: DPoint2d) -> None
        
        4. __init__(self: MSPyBentleyGeom.DBilinearPatch3d, lowerEdge: DSegment3d, upperEdge: DSegment3d) -> None
        """
        ...
    
class DCatenary3dPlacement:
    """
    None
    """

    def AlmostEqual(self: MSPyBentleyGeom.DCatenary3dPlacement, other: MSPyBentleyGeom.DCatenary3dPlacement, tolerance: float) -> bool:
        ...
    
    def AppendPlaneIntersections(self: MSPyBentleyGeom.DCatenary3dPlacement, plane: MSPyBentleyGeom.DPlane3d, xValues: MSPyBentleyGeom.DoubleArray, bounded: bool) -> bool:
        """
        compute intersections with a plane. Return x values
        """
        ...
    
    def CloneBetweenFractions(self: MSPyBentleyGeom.DCatenary3dPlacement, fraction0: float, fraction1: float) -> MSPyBentleyGeom.DCatenary3dPlacement:
        """
        Return a clone over a fractional interval within the existing curve.
        """
        ...
    
    def EndDistance(self: MSPyBentleyGeom.DCatenary3dPlacement) -> float:
        """
        Return the local coordinate (parameter) of the catenary end.
        """
        ...
    
    def FractionToPoint(self: MSPyBentleyGeom.DCatenary3dPlacement, f: float) -> MSPyBentleyGeom.DPoint3d:
        ...
    
    def FractionToPointAndDerivatives(self: MSPyBentleyGeom.DCatenary3dPlacement, f: float) -> Transform:
        ...
    
    def FractionToPointAndTangent(self: MSPyBentleyGeom.DCatenary3dPlacement, f: float) -> MSPyBentleyGeom.DRay3d:
        ...
    
    def Get(self: MSPyBentleyGeom.DCatenary3dPlacement, basis: DPlane3dByVectors, segment: MSPyBentleyGeom.DSegment1d) -> float:
        """
        Get explicit contents ...
        """
        ...
    
    def MultiplyInPlace(self: MSPyBentleyGeom.DCatenary3dPlacement, arg0: Transform) -> None:
        """
        transform
        """
        ...
    
    def ReverseInPlace(self: MSPyBentleyGeom.DCatenary3dPlacement) -> None:
        ...
    
    def StartDistance(self: MSPyBentleyGeom.DCatenary3dPlacement) -> float:
        """
        Return the local coordinate (parameter) of the catenary start.
        """
        ...
    
    def Stroke(self: MSPyBentleyGeom.DCatenary3dPlacement, xyz: MSPyBentleyGeom.DPoint3dArray, fraction: MSPyBentleyGeom.DoubleArray, fraction0: float, fraction1: float, chordTolerance: float, angleTolerance: float, maxEdgeLength: float) -> None:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DCatenary3dPlacement) -> None
        
        2. __init__(self: MSPyBentleyGeom.DCatenary3dPlacement, a: float, basis: DPlane3dByVectors, distance0: float, distance1: float) -> None
        
        3. __init__(self: MSPyBentleyGeom.DCatenary3dPlacement, xyCurve: MSPyBentleyGeom.DCatenaryXY, basis: DPlane3dByVectors, x0: float, x1: float) -> None
        
        4. __init__(self: MSPyBentleyGeom.DCatenary3dPlacement, other: MSPyBentleyGeom.DCatenary3dPlacement) -> None
        """
        ...
    
class DCatenaryXY:
    """
    None
    """

    def AlmostEqual(self: MSPyBentleyGeom.DCatenaryXY, other: MSPyBentleyGeom.DCatenaryXY, tolerance: float) -> bool:
        ...
    
    @staticmethod
    def CoshIntersectHomogeneousLine(hLine: DVec3d, roots: MSPyBentleyGeom.DoubleArray) -> bool:
        """
        Solve for simultaneous roots of
        
        * y = cosh(x)
        
        * x*hLine.x + y*hLine.y + hLine.z = 0
        
        * Note that the cosh(x) is raw x -- NOT divided by the " a " parameter
        used in the catenary.
        
        * At most 2 roots are possible.
        
        * A false return is detection of failed iteration.
        
        * A true return with 0,1,or 2 roots is normal.
        
        * The false case is probably due to very large numbers. cosh(x) gets
        large very quickly.
        """
        ...
    
    @staticmethod
    def CoshIntersectLine(alpha: float, beta: float, gamma: float, roots: MSPyBentleyGeom.DoubleArray) -> bool:
        """
        Solve for roots of alpha + beta*x + gamma * cosh(x) = 0
        
        * Note that the cosh(x) is raw x -- NOT divided by the " a " parameter
        used in the catenary.
        
        * At most 2 roots are possible.
        
        * A false return is detection of failed iteration.
        
        * A true return with 0,1,or 2 roots is normal.
        
        * The false case is probably due to very large numbers. cosh(x) gets
        large very quickly.
        """
        ...
    
    def CurvatureAtLength(self: MSPyBentleyGeom.DCatenaryXY, s: float) -> float:
        """
        return curvature at (signed) distance along.
        """
        ...
    
    def DerivativesAtLength(self: MSPyBentleyGeom.DCatenaryXY, s: float, uv: MSPyBentleyGeom.DPoint2d, duv: DVec2d, dduv: DVec2d, ddduv: DVec2d) -> None:
        """
        Return the point and 2 derivatives at distance from min point
        """
        ...
    
    def LengthAtX(self: MSPyBentleyGeom.DCatenaryXY, x: float) -> float:
        """
        Return curve length from origin to x. This is signed.
        """
        ...
    
    def RadiansAtLength(self: MSPyBentleyGeom.DCatenaryXY, s: float) -> float:
        """
        Return the tangent angle at distance
        """
        ...
    
    def RadiansAtX(self: MSPyBentleyGeom.DCatenaryXY, x: float) -> float:
        """
        Return curve angle (from X axis) at x.
        """
        ...
    
    def TangentAtLength(self: MSPyBentleyGeom.DCatenaryXY, s: float) -> DVec2d:
        """
        Return the tangent vector (unit), derivative of XY wrt s.
        """
        ...
    
    def XYAtLength(self: MSPyBentleyGeom.DCatenaryXY, s: float) -> MSPyBentleyGeom.DPoint2d:
        """
        return x,y at arc length from the min point.
        """
        ...
    
    def YAtX(self: MSPyBentleyGeom.DCatenaryXY, x: float) -> float:
        """
        Return curve y value at x
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DCatenaryXY) -> None
        
        2. __init__(self: MSPyBentleyGeom.DCatenaryXY, a: float) -> None
        """
        ...
    
    def d2YdX2AtX(self: MSPyBentleyGeom.DCatenaryXY, x: float) -> float:
        """
        Return 2nd derivative at x.
        """
        ...
    
    def dYdXAtX(self: MSPyBentleyGeom.DCatenaryXY, x: float) -> float:
        """
        Return slope at x
        """
        ...
    
DERIVATIVE_CONTINUITY: int

class DEllipse3d:
    """
    None
    """

    def AlignedRange(self: MSPyBentleyGeom.DEllipse3d, localToGlobal: Transform, globalToLocal: Transform, range: DRange3d) -> bool:
        """
        :param (output):
        localToGlobal coordinate frame with origin at lower right of local
        range.
        
        :param (output):
        globalToLocal transformation from world to local
        
        :param (output):
        range ellipse range in the local coordinates.
        """
        ...
    
    def AngleToFraction(self: MSPyBentleyGeom.DEllipse3d, angle: float) -> float:
        """
        @description Convert an angular parameter to a fraction of bounded arc
        length.
        
        :param (input):
        angle angle (radians) to convert
        
        :returns:
        fractional parameter
        """
        ...
    
    def ArcLength(self: MSPyBentleyGeom.DEllipse3d) -> float:
        """
        @description Return arc length of ellipse.
        
        :returns:
        arc length of ellipse.
        """
        ...
    
    def ClosestApproach(self: MSPyBentleyGeom.DEllipse3d, ray: DRay3d) -> list:
        ...
    
    def ClosestPointBounded(self: MSPyBentleyGeom.DEllipse3d, point: DPoint3d) -> tuple:
        """
        @description Find the closest point on a bounded ellipse, considering
        both endpoints and perpendicular projections.
        
        :param (output):
        minAngle angular parameter at closest point
        
        :param (output):
        minDistanceSquared squared distance to closest point
        
        :param (output):
        minPoint closest point
        
        :param (input):
        point space point
        
        :returns:
        always true
        """
        ...
    
    def ClosestPointBoundedXY(*args, **kwargs):
        """
        Overloaded function.
        
        1. ClosestPointBoundedXY(self: MSPyBentleyGeom.DEllipse3d, spacePoint: DPoint3d, worldToLocal: DMatrix4d) -> tuple
        
        Find the closest point (projection or end), as viewed in xy plane,
        after applying optional transformation.
        
        :param (output):
        closePoint closest point, in coordinates of the input segment.
        
        :param (output):
        closeParam parameter at closest point
        
        :param (output):
        distanceXY distance in transformed coordinates
        
        :param (input):
        spacePoint world coordinates of test point.
        
        :param (input):
        worldToLocal optional transformation.
        
        2. ClosestPointBoundedXY(self: MSPyBentleyGeom.DEllipse3d, spacePoint: DPoint3d, worldToLocal: DMatrix4d, extend0: bool, extend1: bool) -> tuple
        
        Find the closest point (projection or end), as viewed in xy plane,
        after applying optional transformation.
        
        :param (output):
        closePoint closest point, in coordinates of the input segment.
        
        :param (output):
        closeParam parameter at closest point
        
        :param (output):
        distanceXY distance in transformed coordinates
        
        :param (input):
        spacePoint world coordinates of test point.
        
        :param (input):
        worldToLocal optional transformation.
        """
        ...
    
    def ClosestPointXYBounded(self: MSPyBentleyGeom.DEllipse3d, point: DPoint3d) -> tuple:
        """
        @description Find the closest point on a bounded ellipse, considering
        both endpoints and perpendicular projections, and ignoring z of both
        the ellipse and space point.
        
        :param (output):
        minAngle angular parameter at closest point
        
        :param (output):
        minDistanceSquared squared distance to closest point
        
        :param (output):
        minPoint closest point
        
        :param (input):
        point space point
        
        :returns:
        always true
        """
        ...
    
    def ComplementSweep(self: MSPyBentleyGeom.DEllipse3d) -> None:
        """
        @description Set the ellipse sweep to the complement of its current
        angular range.
        
        Remark:
        s Full ellipse is left unchanged.
        """
        ...
    
    @staticmethod
    def Construct_Point_Direction_TangentXY(ellipses: MSPyBentleyGeom.DEllipse3dArray, fractionB: MSPyBentleyGeom.DoubleArray, pointA: DPoint3d, directionA: DVec3d, ray: DRay3d) -> None:
        """
        Construct circular arc(s) with given start point and tangent, tangent
        to a given ray.
        
        :param (output):
        ellipse constructed ellipses.
        
        :param (output):
        fractionB parameters on the ray.
        
        :param (input):
        pointA start ponit
        
        :param (input):
        directionA start tangent
        
        :param (input):
        rayB ray for tangency. The tangency can occur anywhere on the ray.
        """
        ...
    
    @staticmethod
    def Construct_XPoint_EdgePoint_EdgePoint_XRadius(ellipses: MSPyBentleyGeom.DEllipse3dArray, xPoint: DPoint3d, edgePoint0: DPoint3d, edgePoint1: DPoint3d, a: float) -> None:
        """
        Construct (up to 3) ellipses defined by known primary radius, primary
        axis point, and two other edge points
        
        :param (output):
        ellipses computed ellipses.
        
        :param (input):
        xPoint x axis point
        
        :param (input):
        edgePoint0 any other point on the ellipse.
        
        :param (input):
        edgePoint1 any other point on the ellipse.
        
        :param (input):
        a x axis radius.
        """
        ...
    
    @staticmethod
    def Construct_XRadius_YRadius_XPoint_EdgePoint(ellipses: MSPyBentleyGeom.DEllipse3dArray, a: float, b: float, xPoint: DPoint3d, edgePoint: DPoint3d) -> None:
        """
        Construct (up to 4) ellipses defined by known primary radii, primary
        axis point, and another edge point.
        
        :param (output):
        ellipses computed ellipses.
        
        :param (input):
        a x axis radius.
        
        :param (input):
        b y axis radius.
        
        :param (input):
        xPoint x axis point
        
        :param (input):
        edgePoint any other point on the ellipse.
        """
        ...
    
    def DeterminantJXY(self: MSPyBentleyGeom.DEllipse3d) -> float:
        """
        @description Compute the determinant of the Jacobian matrix for the
        transformation from local coordinates (cosine, sine) to global xy-
        coordinates.
        
        :returns:
        determinant of Jacobian.
        """
        ...
    
    def Evaluate(*args, **kwargs):
        """
        Overloaded function.
        
        1. Evaluate(self: MSPyBentleyGeom.DEllipse3d, point: DPoint3d, xx: float, yy: float) -> None
        
        @description Compute the ellipse xyz point at a given parametric (xy)
        coordinate.
        
        :param (output):
        point evaluated point
        
        :param (input):
        xx local x coordinate:cos(theta)
        
        :param (input):
        yy local y coordinate:sin(theta)
        
        2. Evaluate(self: MSPyBentleyGeom.DEllipse3d, point3dX: DPoint3d, dX: DVec3d, ddX: DVec3d, theta: float) -> None
        
        @description Compute the ellipse xyz point at a given parametric (xy)
        coordinate.
        
        :param (output):
        point evaluated point
        
        :param (input):
        xx local x coordinate:cos(theta)
        
        :param (input):
        yy local y coordinate:sin(theta)
        
        3. Evaluate(self: MSPyBentleyGeom.DEllipse3d, numDerivative: int, theta: float) -> list
        """
        ...
    
    def EvaluateEndPoints(self: MSPyBentleyGeom.DEllipse3d, startPoint: DPoint3d, endPoint: DPoint3d) -> None:
        """
        @description Compute the ellipse start and end points.
        
        :param (output):
        startPoint start point of ellipse
        
        :param (output):
        endPoint end point of ellipse
        """
        ...
    
    def EvaluateTrigPairs(*args, **kwargs):
        """
        Overloaded function.
        
        1. EvaluateTrigPairs(self: MSPyBentleyGeom.DEllipse3d, point: List[DPoint3d], trig: List[DPoint2d], numPoint: int) -> None
        
        @description Evaluate an ellipse using given coefficients for the
        axes.
        
        Remark:
        s If the x,y components of the coefficients define a unit vector,
        the point is " on " the ellipse.
        
        :param (output):
        point array of cartesian points
        
        :param (input):
        trig array of local coords (e.g., (cos, sin)).
        
        :param (input):
        numPoint number of pairs
        
        2. EvaluateTrigPairs(self: MSPyBentleyGeom.DEllipse3d, point: list, trig: List[DPoint2d], numPoint: int) -> None
        
        @description Evaluate an ellipse using given coefficients for the
        axes.
        
        Remark:
        s If the x,y components of the coefficients define a unit vector,
        the point is " on " the ellipse.
        
        :param (output):
        point array of cartesian points
        
        :param (input):
        trig array of local coords (e.g., (cos, sin)).
        
        :param (input):
        numPoint number of pairs
        """
        ...
    
    def FractionParameterToDerivatives(self: MSPyBentleyGeom.DEllipse3d, point3dX: DPoint3d, dX: DVec3d, ddX: DVec3d, fraction: float) -> None:
        """
        @description Compute the ellipse xyz point and derivatives at a given
        fraction of the angular parametric range.
        
        :param (output):
        point3dX point on ellipse
        
        :param (output):
        dX second derivative vector
        
        :param (output):
        ddX second derivative vector
        
        :param (input):
        fraction fractional parameter for evaluation
        """
        ...
    
    def FractionParameterToPoint(self: MSPyBentleyGeom.DEllipse3d, point3dX: DPoint3d, fraction: float) -> None:
        """
        @description Compute the ellipse xyz point at a given fraction of the
        angular parametric range.
        
        :param (output):
        point3dX point on ellipse
        
        :param (input):
        fraction fractional parameter for evaluation
        """
        ...
    
    def FractionToAngle(self: MSPyBentleyGeom.DEllipse3d, fraction: float) -> float:
        """
        @description Convert a fractional parameter to ellipse
        parameterization angle.
        
        :param (input):
        fraction fraction of angular range
        
        :returns:
        angular parameter
        """
        ...
    
    def FractionToLength(self: MSPyBentleyGeom.DEllipse3d, fraction0: float, fraction1: float) -> tuple:
        """
        @description Compute the (signed) arc length between specified
        fractional parameters.
        
        Remark:
        s Fractions outside [0,1] return error.
        
        :param (output):
        arcLength computed arc length. Negative if fraction1<fraction0.
        
        :param (input):
        fraction0 start fraction for interval to measure
        
        :param (input):
        fraction1 end fraction for interval to measure
        
        :returns:
        true if the arc length was computed.
        """
        ...
    
    def FractionToPoint(self: MSPyBentleyGeom.DEllipse3d, fraction: float) -> DPoint3d:
        """
        return ellipse point at fractional position in its angular sweep.
        """
        ...
    
    @staticmethod
    def From(cx: float, cy: float, cz: float, ux: float, uy: float, uz: float, vx: float, vy: float, vz: float, theta0: float, sweep: float) -> MSPyBentleyGeom.DEllipse3d:
        """
        @description Returns a DEllipse3d with given fields.
        
        :param (input):
        cx center x coordinate
        
        :param (input):
        cy center y coordinate
        
        :param (input):
        cz center z coordinate
        
        :param (input):
        ux x part of 0 degree vector
        
        :param (input):
        uy y part of 0 degree vector
        
        :param (input):
        uz z part of 0 degree vector
        
        :param (input):
        vx x part of 90 degree vector
        
        :param (input):
        vy y part of 90 degree vector
        
        :param (input):
        vz z part of 90 degree vector
        
        :param (input):
        theta0 start angle in parameter space
        
        :param (input):
        sweep sweep angle
        
        :returns:
        DEllipse3d object.
        """
        ...
    
    @staticmethod
    def FromArcCenterStartEnd(center: DPoint3d, startPoint: DPoint3d, endTarget: DPoint3d) -> MSPyBentleyGeom.DEllipse3d:
        """
        Return a circular arc with gven center and start. Endpoint is on the
        vector to given endTarget. Sweep angle is the smaller of the two
        possible sweeps.
        
        :param (input):
        center circle center
        
        :param (input):
        startPoint arc start point. This point determines the circle
        radius.
        
        :param (input):
        endTarget Target point for end of circle. If it is at a different
        radius, the actual end point will be at the same radius as the
        start point.
        """
        ...
    
    @staticmethod
    def FromCenterNormalRadius(center: DPoint3d, normal: DVec3d, radius: float) -> MSPyBentleyGeom.DEllipse3d:
        """
        Return an (full 360 degree) circular arc with given center, plane
        normal, and radius.
        
        :param (input):
        center ellipse center.
        
        :param (input):
        normal plane normal.
        
        :param (input):
        radius circle radius.
        """
        ...
    
    @staticmethod
    def FromCenterRadiusXY(center: DPoint3d, radius: float) -> MSPyBentleyGeom.DEllipse3d:
        """
        Return an xy-plane full circle with center and radius.
        """
        ...
    
    @staticmethod
    def FromCopyWithPositiveSweep(source: MSPyBentleyGeom.DEllipse3d) -> MSPyBentleyGeom.DEllipse3d:
        """
        Return an ellipse that sweeps the same points in space (with identical
        fraction-to-point results) but is driven by a positive sweep angle.
        
        Remark:
        If the source ellipse has positive sweep it is simply copied back
        out. If it has a negative sweep, the start angle, sweep angle, and
        vector90 are negated. If a point is on the ellipse, its angular
        coordinate will be negated, but its fractional position is
        maintained.
        
        :param (input):
        source original ellipse
        """
        ...
    
    @staticmethod
    def FromFractionInterval(parent: MSPyBentleyGeom.DEllipse3d, startFraction: float, endFraction: float) -> MSPyBentleyGeom.DEllipse3d:
        """
        @description Return an ellipse defined by fractional start and end on
        a parent ellipse
        
        :param (input):
        parent existing ellipse.
        
        :param (input):
        startFraction fractional coordiante of new ellipse start on
        parent.
        
        :param (input):
        endFraction fractional coordiante of new ellipse end on parent.
        """
        ...
    
    @staticmethod
    def FromMajorMinor(source: MSPyBentleyGeom.DEllipse3d) -> MSPyBentleyGeom.DEllipse3d:
        """
        Return an ellispe that sweeps the same points as source but has axes
        adjusted so vectors to parametric 0 and 90 degree points are
        perpendicular and the 0 degree vector is the customary major (larger)
        direction.
        
        :param (input):
        source original ellipse, in which vectors might be non
        perpendicular.
        """
        ...
    
    def FromNegateVector90(self: MSPyBentleyGeom.DEllipse3d, source: MSPyBentleyGeom.DEllipse3d) -> MSPyBentleyGeom.DEllipse3d:
        """
        Return an ellipse that sweeps the same points in space (with identical
        fraction-to-point results) but has negated vector90 (and hence negated
        normal)
        """
        ...
    
    @staticmethod
    def FromPerpendicularAxes(source: MSPyBentleyGeom.DEllipse3d) -> MSPyBentleyGeom.DEllipse3d:
        """
        Return an ellispe that sweeps the same points as source but has axes
        adjusted so vectors to parametric 0 and 90 degree points are
        perpendicular. This may choose a " small " adjustment of the axes even
        if the 90 degree axis ends up longer. Use FromMajorMinor to force the
        0 degree direction to be the larger axis.
        
        :param (input):
        source original ellipse, in which vectors might be non
        perpendicular.
        """
        ...
    
    @staticmethod
    def FromPoints(center: DPoint3d, point0: DPoint3d, point90: DPoint3d, theta0: float, sweep: float) -> MSPyBentleyGeom.DEllipse3d:
        """
        @description Returns a DEllipse3d with fill in ellipse data from
        center, 0 degree, and 90 degree points.
        
        :param (input):
        center ellipse center
        
        :param (input):
        point0 0 degree point
        
        :param (input):
        point90 90 degree point
        
        :param (input):
        theta0 start angle
        
        :param (input):
        sweep sweep angle
        
        :returns:
        DEllipse3d object.
        """
        ...
    
    @staticmethod
    def FromPointsOnArc(start: DPoint3d, middle: DPoint3d, end: DPoint3d) -> MSPyBentleyGeom.DEllipse3d:
        """
        @description Initialize an elliptical arc from 3 points.
        
        :param (input):
        start start point
        
        :param (input):
        middle mid point
        
        :param (input):
        end end point
        """
        ...
    
    @staticmethod
    def FromReversed(source: MSPyBentleyGeom.DEllipse3d) -> MSPyBentleyGeom.DEllipse3d:
        """
        Return an ellipse that sweeps the same points in space but in the
        reversed direction.
        
        :param (input):
        source original ellipse
        """
        ...
    
    @staticmethod
    def FromRotatedAxes(source: MSPyBentleyGeom.DEllipse3d, newStart: float) -> MSPyBentleyGeom.DEllipse3d:
        """
        Return an ellipse that traverses the same points in space but has its
        vector0 and vector90 axes shifted so that the parametric start takes
        on specified value.
        
        :param (input):
        source original ellipse.
        
        :param (input):
        newStart the angle value that should be the start in the new
        ellispe.
        """
        ...
    
    @staticmethod
    def FromScaledRotMatrix(center: DPoint3d, matrix: RotMatrix, r0: float, r90: float, theta0: float, sweep: float) -> MSPyBentleyGeom.DEllipse3d:
        """
        Return an (arc of an) ellipse, with axes defined by a RotMatrix XY
        columns and scale factors.
        """
        ...
    
    @staticmethod
    def FromScaledVectors(*args, **kwargs):
        """
        Overloaded function.
        
        1. FromScaledVectors(center: DPoint3d, vector0: DVec3d, vector90: DVec3d, r0: float, r90: float, theta0: float, sweep: float) -> MSPyBentleyGeom.DEllipse3d
        
        Return an (arc of an) ellipse with axes defined directly by scaled
        vectors.
        
        2. FromScaledVectors(source: MSPyBentleyGeom.DEllipse3d, factor: float) -> MSPyBentleyGeom.DEllipse3d
        
        Return an (arc of an) ellipse with axes defined directly by scaled
        vectors.
        """
        ...
    
    @staticmethod
    def FromStartTangentNormalRadiusSweep(pointA: DPoint3d, tangent: DVec3d, planeNormal: DVec3d, radius: float, sweepRadians: float) -> MSPyBentleyGeom.ValidatedDEllipse3d:
        """
        Construct an arc from start point, start tangent, radius and sweep
        (and plane normal)
        """
        ...
    
    @staticmethod
    def FromVectors(center: DPoint3d, vector0: DVec3d, vector90: DVec3d, theta0: float, sweep: float) -> MSPyBentleyGeom.DEllipse3d:
        """
        Return a (arc of an) ellipse with given 0 and 90 degree vectors.
        """
        ...
    
    @staticmethod
    def FromXYMajorMinor(cx: float, cy: float, cz: float, rx: float, ry: float, thetaX: float, theta0: float, sweep: float) -> MSPyBentleyGeom.DEllipse3d:
        """
        @description Returns a DEllipse3d with fill in ellipse data from 2D
        major and minor axis lengths and the angle from the global to the
        local x-axis.
        
        :param (input):
        cx center x coordinate
        
        :param (input):
        cy center y coordinate
        
        :param (input):
        cz z coordinate of all points on the ellipse
        
        :param (input):
        rx radius along local x axis
        
        :param (input):
        ry radius along local y axis
        
        :param (input):
        thetaX angle from global x to local x
        
        :param (input):
        theta0 start angle in parameter space
        
        :param (input):
        sweep sweep angle
        
        :returns:
        DEllipse3d object.
        """
        ...
    
    def GetDGNFields2d(self: MSPyBentleyGeom.DEllipse3d) -> tuple:
        ...
    
    def GetDGNFields3d(self: MSPyBentleyGeom.DEllipse3d) -> tuple:
        """
        @description Fill in ellipse data from data fields in DGN 3d ellipse
        element.
        
        :param (output):
        centerOUT center of ellipse.
        
        :param (output):
        pQuatWXYZ quaternion for orthogonal frame. As per DGN convention,
        ordered WXYZ. If this is NULL, major and minor directions must be
        supplied as pDirection0 and pDirection90;
        
        :param (output):
        directionX unit vector in ellipse x direction.
        
        :param (output):
        directionY unit vector in ellipse y direction.
        
        :param (output):
        rx scale factor (usually a true distance) for x direction.
        
        :param (output):
        ry scale factor (usually a true distance) for y direction.
        
        :param (output):
        startAngle start angle.
        
        :param (output):
        sweepAngle sweep angle.
        """
        ...
    
    def GetLimits(self: MSPyBentleyGeom.DEllipse3d) -> tuple:
        """
        @description Get the start and end angles of the ellipse.
        
        :param (output):
        startAngle start angle
        
        :param (output):
        endAngle end angle
        """
        ...
    
    def GetLocalFrame(self: MSPyBentleyGeom.DEllipse3d, frame: Transform, inverse: Transform) -> bool:
        """
        @description Get the coordinate frame for an ellipse. X,Y axes are at
        0 and 90 degrees. Z axis is perpendicular with magnitude equal to the
        geometric mean of the other two.
        
        :param (output):
        frame transformation from (cosine, sine, z) coordinates to global
        xyz.
        
        :param (output):
        inverse inverse of frame.
        
        :returns:
        true if the requested frames were returned.
        """
        ...
    
    def GetLocalRange(self: MSPyBentleyGeom.DEllipse3d, range: DRange2d) -> None:
        """
        @description Compute the range of the ellipse in its own coordinate
        system.
        
        Remark:
        s This depends on the start and sweep angles but not the center or
        axis coordinates.
        
        :param (output):
        range computed range
        """
        ...
    
    def GetMajorMinorRangeMidlines(self: MSPyBentleyGeom.DEllipse3d, longSegment: DSegment3d, shortSegment: DSegment3d) -> float:
        """
        @description Compute the range box of the ellipse in its major-minor
        axis coordinate system. Compute line segments that are the horizontal
        and vertical midlines in that system. Return those line segments
        ordered with the longest first, and return the shorter length.
        
        Remark:
        s The typical use of this is that if the shorter length is less
        than some tolerance the points swept out by the ellipse are the
        longer segment. (But beware that the start and end points of the
        segment can be other than the start and end points of the
        ellipse.)
        
        :param (output):
        longSegment longer axis of local conic range box
        
        :param (output):
        shortSegment shorter axis of local conic range box
        
        :returns:
        size of the shorter dimension
        """
        ...
    
    def GetRange(self: MSPyBentleyGeom.DEllipse3d, range: DRange3d) -> None:
        """
        @description Compute the xyz range limits of a 3D ellipse.
        
        :param (output):
        range computed range
        """
        ...
    
    def GetScaledRotMatrix(self: MSPyBentleyGeom.DEllipse3d) -> tuple:
        """
        @description Extract major minor axis form of the ellipse.
        
        :param (output):
        center ellipse center
        
        :param (output):
        matrix columns 0, 1 are normalized ellipse basis vectors, column 2
        is their cross product
        
        :param (output):
        r0 scale factor for column 0
        
        :param (output):
        r1 scale factor for column 1
        
        :param (output):
        theta0 start angle
        
        :param (output):
        sweep sweep angle
        """
        ...
    
    def GetScaledTransforms(self: MSPyBentleyGeom.DEllipse3d) -> tuple:
        """
        @description Extract major minor axis form of the ellipse.
        
        :param (output):
        localToWorld orthogonal frame with origin at center, xy axes n
        major and minor axes.
        
        :param (output):
        r0 scale factor for column 0
        
        :param (output):
        r1 scale factor for column 1
        
        :param (output):
        theta0 start angle
        
        :param (output):
        sweep sweep angle
        
        :param (output):
        worldToLocal inverse of localToWorld.
        """
        ...
    
    def GetStrokeCount(self: MSPyBentleyGeom.DEllipse3d, nDefault: int = 12, nMax: int = 180, chordTol: float = 0.0, angTol: float = 0.0) -> int:
        """
        @description Compute an estimated number of points needed to stroke a
        full ellipse to within the given chord height tolerance.
        
        :param (input):
        nDefault default number of points on full ellipse
        
        :param (input):
        nMax max number of points on full ellipse
        
        :param (input):
        chordTol distance tolerance
        
        :param (input):
        angleTol turning angle tolerance
        
        :returns:
        number of strokes required on the full ellipse
        """
        ...
    
    def GetSweep(self: MSPyBentleyGeom.DEllipse3d) -> tuple:
        """
        @description Get the start and sweep angles of the ellipse.
        
        :param (output):
        startAngle start angle
        
        :param (output):
        sweepAngle sweep angle
        """
        ...
    
    def GetXYLocalFrame(self: MSPyBentleyGeom.DEllipse3d, frame: Transform, inverse: Transform) -> bool:
        """
        @description Get the coordinate frame and inverse of an ellipse as
        viewed along the global z axis.
        
        :param (output):
        frame transformation from (cosine, sine, z) coordinates to global
        xyz.
        
        :param (output):
        inverse inverse of frame.
        
        :returns:
        true if the requested frames were returned.
        """
        ...
    
    def Init(self: MSPyBentleyGeom.DEllipse3d, cx: float, cy: float, cz: float, ux: float, uy: float, uz: float, vx: float, vy: float, vz: float, theta0: float, sweep: float) -> None:
        ...
    
    def InitArcFromPointPointArcLength(self: MSPyBentleyGeom.DEllipse3d, startIN: DPoint3d, end: DPoint3d, arcLength: float, planeVector: DVec3d) -> bool:
        """
        @description Initialize a circlular arc from start point, end point,
        another vector which determines the plane, and the arc length.
        
        :param (input):
        startIN start point
        
        :param (input):
        end end point
        
        :param (input):
        arcLength required arc length
        
        :param (input):
        planeVector vector to be used to determine the plane of the arc.
        The plane is chosen so that it contains both the start-to-end
        vector and the plane vector, and the arc bulge is in the direction
        of the plane vector (rather than opposite).
        
        :returns:
        true if the arc length exceeds the chord length and the 2 points
        and plane vector determine a clear plane.
        """
        ...
    
    def InitArcFromPointTangentPoint(*args, **kwargs):
        """
        Overloaded function.
        
        1. InitArcFromPointTangentPoint(self: MSPyBentleyGeom.DEllipse3d, startIN: DPoint3d, tangent: DVec3d, end: DPoint3d) -> bool
        
        @description Initialize a circular arc from start point, start
        tangent, and end point.
        
        :param (input):
        startIN start point
        
        :param (input):
        tangent start tangent
        
        :param (input):
        end end point
        
        :returns:
        true if circular arc computed. false if start, end and tangent are
        colinear.
        
        2. InitArcFromPointTangentPoint(self: MSPyBentleyGeom.DEllipse3d, startIn: DPoint3d, tangent: DVec3d, end: DPoint3d) -> bool
        """
        ...
    
    def InitFromArcCenterStartEnd(self: MSPyBentleyGeom.DEllipse3d, centerIn: DPoint3d, startIn: DPoint3d, end: DPoint3d) -> bool:
        ...
    
    def InitFromCenterMajorAxisPointAndThirdPoint(self: MSPyBentleyGeom.DEllipse3d, center: DPoint3d, point0: DPoint3d, point1: DPoint3d) -> bool:
        """
        @description Initialize an ellipse from center, primary axis point,
        and additional pass-though point.
        
        :param (input):
        centerIN center point of ellipse.
        
        :param (input):
        point0 point to appear at the zero degree point. The ellipse must
        pass through this point as a major or minor axis point, i.e. its
        tangent must be perpendicular to the vector from the center to
        this point.
        
        :param (input):
        point1 additional pass-through point.
        
        :returns:
        false if center, point0 and point1 are not independent, or if
        point1 is too far away from center to allow ellipse constrution.
        """
        ...
    
    def InitFromDGNFields2d(*args, **kwargs):
        """
        Overloaded function.
        
        1. InitFromDGNFields2d(self: MSPyBentleyGeom.DEllipse3d, center: DPoint2d, direction0: DVec2d, rX: float, rY: float, startAngle: float, sweepAngle: float, zDepth: float) -> None
        
        @description Fill in ellipse data from data fields in DGN 2d ellipse
        element.
        
        :param (input):
        centerIN center of ellipse.
        
        :param (input):
        direction0 ellipse x axis direction.
        
        :param (input):
        rX scale factor for ellipse x direction.
        
        :param (input):
        rY scale factor for ellipse y direction.
        
        :param (input):
        startAngle start angle.
        
        :param (input):
        sweepAngle sweep angle.
        
        :param (input):
        zDepth z value for ellipse.
        
        2. InitFromDGNFields2d(self: MSPyBentleyGeom.DEllipse3d, center: DPoint2d, xAngle: float, rX: float, rY: float, startAngle: float, sweepAngle: float, zDepth: float) -> None
        
        @description Fill in ellipse data from data fields in DGN 2d ellipse
        element.
        
        :param (input):
        centerIN center of ellipse.
        
        :param (input):
        direction0 ellipse x axis direction.
        
        :param (input):
        rX scale factor for ellipse x direction.
        
        :param (input):
        rY scale factor for ellipse y direction.
        
        :param (input):
        startAngle start angle.
        
        :param (input):
        sweepAngle sweep angle.
        
        :param (input):
        zDepth z value for ellipse.
        """
        ...
    
    def InitFromDGNFields3d(*args, **kwargs):
        """
        Overloaded function.
        
        1. InitFromDGNFields3d(self: MSPyBentleyGeom.DEllipse3d, center: DPoint3d, directionX: DVec3d, directionY: DVec3d, rX: float, rY: float, startAngle: float, sweepAngle: float) -> None
        
        @description Fill in ellipse data from data fields in DGN 3d ellipse
        element.
        
        :param (input):
        centerIN center of ellipse.
        
        :param (input):
        directionX vector in the x axis direction. This is scaled by rX.
        (It is NOT normalized before scaling. In common use, it will be a
        unit vector.)
        
        :param (input):
        directionY vector in the y axis direction. This is scaled by rY.
        (It is NOT normalized before scaling. In common use, it will be a
        unit vector.)
        
        :param (input):
        rX scale factor (usually a true distance) for x direction.
        
        :param (input):
        rY scale factor (usually a true distance) for y direction.
        
        :param (input):
        startAngle start angle
        
        :param (input):
        sweepAngle sweep angle
        
        2. InitFromDGNFields3d(self: MSPyBentleyGeom.DEllipse3d, center: DPoint3d, quatWXYZ: DPoint4d, rX: float, rY: float, startAngle: float, sweepAngle: float) -> None
        
        @description Fill in ellipse data from data fields in DGN 3d ellipse
        element.
        
        :param (input):
        centerIN center of ellipse.
        
        :param (input):
        directionX vector in the x axis direction. This is scaled by rX.
        (It is NOT normalized before scaling. In common use, it will be a
        unit vector.)
        
        :param (input):
        directionY vector in the y axis direction. This is scaled by rY.
        (It is NOT normalized before scaling. In common use, it will be a
        unit vector.)
        
        :param (input):
        rX scale factor (usually a true distance) for x direction.
        
        :param (input):
        rY scale factor (usually a true distance) for y direction.
        
        :param (input):
        startAngle start angle
        
        :param (input):
        sweepAngle sweep angle
        """
        ...
    
    def InitFromPoints(self: MSPyBentleyGeom.DEllipse3d, center0: DPoint3d, point0: DPoint3d, point90: DPoint3d, startRadiansIn: float, sweepIn: float) -> None:
        ...
    
    def InitFromPointsOnArc(self: MSPyBentleyGeom.DEllipse3d, start: DPoint3d, middle: DPoint3d, end: DPoint3d) -> bool:
        ...
    
    def InitFromVectors(self: MSPyBentleyGeom.DEllipse3d, centerIn: DPoint3d, vector01In: DVec3d, vector90In: DVec3d, startRadiansIn: float, sweepIn: float) -> None:
        ...
    
    def InitWithPerpendicularAxes(self: MSPyBentleyGeom.DEllipse3d, source: MSPyBentleyGeom.DEllipse3d) -> None:
        """
        @description Make a copy of the source ellipse, altering the axis
        vectors and angular limits so that the revised ellipse has
        perpendicular axes in the conventional major/minor axis form.
        
        Remark:
        s Inputs may be the same.
        
        :param (input):
        source ellipse with unconstrained axes
        """
        ...
    
    def IntersectPlane(self: MSPyBentleyGeom.DEllipse3d, plane: DPoint4d) -> list:
        """
        @description Find intersections of a (full) ellipse with a plane.
        
        Remark:
        s Return value n=1 is a single tangency point returned in
        trigPoints[0]; n=2 is two simple intersections returned in
        trigPoints[0..1]
        
        Remark:
        s The three component values in trigPoints are:<UL> <LI>x ==
        cosine of angle <LI>y == sine of angle <LI>z == angle in radians
        </UL>
        
        :param (output):
        trigPoints 2 points:cosine, sine, theta values of plane
        intersection
        
        :param (input):
        plane homogeneous plane equation
        
        :returns:
        The number of intersections, i.e. 0, 1, or 2
        """
        ...
    
    def IntersectSweptDEllipse3d(self: MSPyBentleyGeom.DEllipse3d, ellipse1: MSPyBentleyGeom.DEllipse3d) -> list:
        ...
    
    def IntersectSweptDEllipse3dBounded(self: MSPyBentleyGeom.DEllipse3d, ellipse1: MSPyBentleyGeom.DEllipse3d) -> list:
        ...
    
    def IntersectSweptDSegment3d(self: MSPyBentleyGeom.DEllipse3d, segment: DSegment3d) -> list:
        ...
    
    def IntersectSweptDSegment3dBounded(self: MSPyBentleyGeom.DEllipse3d, segment: DSegment3d) -> list:
        ...
    
    def IntersectXYDEllipse3d(self: MSPyBentleyGeom.DEllipse3d, ellipse1: MSPyBentleyGeom.DEllipse3d) -> list:
        ...
    
    def IntersectXYDEllipse3dBounded(self: MSPyBentleyGeom.DEllipse3d, ellipse1: MSPyBentleyGeom.DEllipse3d) -> list:
        ...
    
    def IntersectXYLine(self: MSPyBentleyGeom.DEllipse3d, startPoint: DPoint3d, endPoint: DPoint3d) -> list:
        ...
    
    def IntersectXYLineBounded(self: MSPyBentleyGeom.DEllipse3d, startPoint: DPoint3d, endPoint: DPoint3d) -> list:
        ...
    
    def InverseArcLength(self: MSPyBentleyGeom.DEllipse3d, arcLength: float) -> float:
        """
        @description Return the sweep angle corresponding to an arc length.
        
        Remark:
        s Negative returned sweep angle corresponds to arclength traversed
        in the opposite direction of the ellipse sweep.
        
        :param (input):
        arcLength arc length to invert
        
        :returns:
        sweep angle
        """
        ...
    
    def IsAlmostEqual(self: MSPyBentleyGeom.DEllipse3d, other: MSPyBentleyGeom.DEllipse3d, tolerance: float) -> bool:
        """
        :returns:
        true if AlmostEqual center, vectors, and angles.
        """
        ...
    
    def IsAngleInSweep(self: MSPyBentleyGeom.DEllipse3d, angle: float) -> bool:
        """
        @description Test if a specified angle is within the sweep of the
        ellipse.
        
        :param (input):
        angle angle (radians) to test
        
        :returns:
        true if angle is within the sweep angle of the elliptical arc.
        """
        ...
    
    def IsCCWSweepXY(self: MSPyBentleyGeom.DEllipse3d) -> bool:
        """
        @description Test if the XY projection of the ellipse is CCW when
        considering both the sweep sign and the vector directions.
        
        :returns:
        true if circular
        """
        ...
    
    def IsCircular(*args, **kwargs):
        """
        Overloaded function.
        
        1. IsCircular(self: MSPyBentleyGeom.DEllipse3d) -> bool
        
        @description Test if the ellipse is circular.
        
        :returns:
        true if circular
        
        2. IsCircular(self: MSPyBentleyGeom.DEllipse3d) -> tuple
        
        @description Test if the ellipse is circular.
        
        :returns:
        true if circular
        """
        ...
    
    def IsCircularXY(*args, **kwargs):
        """
        Overloaded function.
        
        1. IsCircularXY(self: MSPyBentleyGeom.DEllipse3d) -> bool
        
        @description Test if the XY projection of the ellipse is circular.
        
        :returns:
        true if circular
        
        2. IsCircularXY(self: MSPyBentleyGeom.DEllipse3d) -> tuple
        
        @description Test if the XY projection of the ellipse is circular.
        
        :returns:
        true if circular
        """
        ...
    
    def IsFullEllipse(self: MSPyBentleyGeom.DEllipse3d) -> bool:
        """
        @description Test whether the ellipse is complete (2pi range).
        
        :returns:
        true if the ellipse is complete
        """
        ...
    
    def IsNearZeroRadius(self: MSPyBentleyGeom.DEllipse3d) -> bool:
        """
        @description Test whether both vectors are near zero length.
        
        :returns:
        true if both radii are near zero.
        """
        ...
    
    def MakeFullSweep(self: MSPyBentleyGeom.DEllipse3d) -> None:
        """
        @description Set the ellipse sweep to a full 360 degrees (2pi
        radians), preserving direction of sweep.
        
        Remark:
        s Start angle is left unchanged.
        """
        ...
    
    @property
    def MaxAbs(arg0: MSPyBentleyGeom.DEllipse3d) -> float:
        ...
    
    def PointToAngle(self: MSPyBentleyGeom.DEllipse3d, point: DPoint3d) -> float:
        """
        @description Compute the angular position of the point relative to the
        ellipse's local coordinates.
        
        Remark:
        s If the point is on the ellipse, this is the inverse of
        evaluating the ellipse at the angle.
        
        :param (input):
        point point to evaluate
        
        :returns:
        angle in ellipse parameterization
        """
        ...
    
    def PointToXYLocal(self: MSPyBentleyGeom.DEllipse3d, localPoint: DPoint3d, point: DPoint3d) -> bool:
        """
        @description Compute the local coordinates of a point in the skewed
        coordinates of the ellipse, using only xy parts of both the ellipse
        and starting point.
        
        Remark:
        s This is equivalent to computing the intersection of the ellipse
        plane with a line through the point and parallel to the z axis,
        and returning the coordinates of the intersection relative to the
        skewed axes of the ellipse.
        
        :param (output):
        localPoint evaluated point. Coordinates x,y are multipliers for
        the ellipse axes. Coordinate z is height of the initial point from
        the plane of the ellipse.
        
        :param (input):
        point point to convert to local coordinates
        
        :returns:
        true if ellipse axes are independent.
        """
        ...
    
    def ProjectPoint(self: MSPyBentleyGeom.DEllipse3d, point: DPoint3d) -> list:
        ...
    
    def ProjectPointBounded(self: MSPyBentleyGeom.DEllipse3d, point: DPoint3d) -> list:
        ...
    
    def ProjectPointToPlane(self: MSPyBentleyGeom.DEllipse3d, xyz: DPoint3d) -> tuple:
        """
        @description Project a point onto the plane of the ellipse.
        
        :param (output):
        xYZNear projection of point onto ellipse plane
        
        :param (output):
        coff0 coefficient on vector towards 0 degree point
        
        :param (output):
        coff90 coefficient on vector towards 90 degree point
        
        :param (input):
        xYZ point to project onto plane
        
        :returns:
        true if the plane is well defined.
        """
        ...
    
    def ProjectPointXY(self: MSPyBentleyGeom.DEllipse3d, point: DPoint3d) -> list:
        ...
    
    def ProjectPointXYBounded(self: MSPyBentleyGeom.DEllipse3d, point: DPoint3d) -> list:
        ...
    
    def ProjectedParameterRange(self: MSPyBentleyGeom.DEllipse3d, ray: DRay3d) -> DRange1d:
        """
        :returns:
        range when projected to fraction space of the ray
        
        :param (input):
        ray
        """
        ...
    
    def RadiansToPoint(self: MSPyBentleyGeom.DEllipse3d, theta: float) -> DPoint3d:
        """
        @description return the point on the ellipse at parameteric angle.
        """
        ...
    
    def SetLimits(self: MSPyBentleyGeom.DEllipse3d, startAngle: float, endAngle: float) -> None:
        """
        @description Set the start and end angles of the ellipse.
        
        :param (input):
        startAngle start angle
        
        :param (input):
        endAngle end angle
        """
        ...
    
    def SetStartEnd(self: MSPyBentleyGeom.DEllipse3d, startPoint: DPoint3d, endPoint: DPoint3d, ccw: bool) -> bool:
        """
        @description Set angular parameters to have given start and end
        points.
        
        Remark:
        s If the given points are really on the ellipse, this does the
        expected thing.
        
        Remark:
        s If the given points are not on the ellipse, here's exactly what
        happens. The start/end points are placed on the original ellipse
        at the point where the ellipse intersects the plane formed by the
        ellipse axis and the given point. This leaves the problem that the
        ellipse defines two paths from the given start to end. This is
        resolved as follows. The ellipse's existing 0 and 90 degree
        vectors define a coordinate system. In that system, the short
        sweep from the 0 degree vector to the 90 degree vector is
        considered " counterclockwise ".
        
        Remark:
        s Beware that the relation of supposed start/end points to the
        ellipse is ambiguous.
        
        :param (input):
        startPoint new start point
        
        :param (input):
        endPoint new end point
        
        :param (input):
        ccw true to force counterclockwise direction, false for clockwise.
        
        :returns:
        true if the ellipse axes are independent. false if the ellipse is
        degenerate.
        """
        ...
    
    def SetSweep(self: MSPyBentleyGeom.DEllipse3d, startAngle: float, sweep: float) -> None:
        """
        @description Set the start and sweep angles of the ellipse.
        
        :param (input):
        startAngle start angle
        
        :param (input):
        sweepIN sweep angle
        """
        ...
    
    def SolveTangentsPerpendicularToVector(self: MSPyBentleyGeom.DEllipse3d, vector: DVec3d) -> list:
        """
        @description Find angles at which the ellipse tangent vector is
        perpendicular to given vector.
        
        :param (output):
        angles 0,1, or 2 angles. This is an array that must be allocated
        by the caller.
        
        :param (input):
        vector perpendicular vector.
        
        :returns:
        The number of solutions, i.e. 0, 1, or 2
        """
        ...
    
    def TangentMagnitude(self: MSPyBentleyGeom.DEllipse3d, theta: float) -> float:
        """
        @description Compute the magnitude of the tangent vector to the
        ellipse at the specified angle.
        
        :param (input):
        theta angular parameter
        
        :returns:
        tangent magnitude
        """
        ...
    
    def TestAndEvaluateTrigPairs(*args, **kwargs):
        """
        Overloaded function.
        
        1. TestAndEvaluateTrigPairs(self: MSPyBentleyGeom.DEllipse3d, point: List[DPoint3d], trig: List[DPoint2d], numPoint: int) -> int
        
        @description Evaluate an ellipse at a number of (cosine, sine) pairs,
        removing pairs whose corresponding angle is not in range.
        
        :param (output):
        point array of cartesian points
        
        :param (input):
        trig array of local coords
        
        :param (input):
        numPoint number of pairs
        
        :returns:
        number of points found to be in the angular range of the ellipse.
        
        2. TestAndEvaluateTrigPairs(self: MSPyBentleyGeom.DEllipse3d, point: list, trig: List[DPoint2d], numPoint: int) -> int
        
        @description Evaluate an ellipse at a number of (cosine, sine) pairs,
        removing pairs whose corresponding angle is not in range.
        
        :param (output):
        point array of cartesian points
        
        :param (input):
        trig array of local coords
        
        :param (input):
        numPoint number of pairs
        
        :returns:
        number of points found to be in the angular range of the ellipse.
        """
        ...
    
    @staticmethod
    def TryConstruct_EdgePoint_XPoint_EdgePoint_XAngle(ellipse: MSPyBentleyGeom.DEllipse3d, edgePoint0: DPoint3d, xPoint: DPoint3d, edgePoint1: DPoint3d, xAngle: float) -> bool:
        """
        Construct an ellipse (it is unique if it exists) with given x axis,
        start point, x axis point, and end point.
        
        :param (output):
        ellipse constructed ellipse.
        
        :param (input):
        edgePoint0 start point
        
        :param (input):
        xPoint x axis extrema
        
        :param (input):
        edgePoint1 end point
        
        :param (input):
        xAngle angle from global x axis to ellipse x axis
        """
        ...
    
    def WireCentroid(self: MSPyBentleyGeom.DEllipse3d, fraction0: float, fraction1: float) -> tuple:
        """
        Compute the length (unit density) and wire centroid. Note that an
        ellipse with zero sweephas zero length but the (single) coordinate is
        a well defined centroid.
        
        :param (output):
        length length.
        
        :param (output):
        centroid centroid point.
        
        :param (input):
        fraction0 start fraction of active part of sweep.
        
        :param (input):
        fraction1 end fraction of active part of sweep.
        """
        ...
    
    def XySweepProperties(self: MSPyBentleyGeom.DEllipse3d, point: DPoint3d) -> tuple:
        """
        @description Compute area and swept angle as seen from given point.
        
        :param (output):
        area swept area
        
        :param (output):
        sweepOUT swept angle (in radians)
        
        :param (input):
        point base point for sweep line.
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.DEllipse3d) -> None:
        ...
    
    @property
    def center(self: MSPyBentleyGeom.DEllipse3d) -> DPoint3d:
        ...
    @center.setter
    def center(self: MSPyBentleyGeom.DEllipse3d, arg0: DPoint3d) -> None:
        ...
    
    @property
    def start(self: MSPyBentleyGeom.DEllipse3d) -> float:
        ...
    @start.setter
    def start(self: MSPyBentleyGeom.DEllipse3d, arg0: float) -> None:
        ...
    
    @property
    def sweep(self: MSPyBentleyGeom.DEllipse3d) -> float:
        ...
    @sweep.setter
    def sweep(self: MSPyBentleyGeom.DEllipse3d, arg0: float) -> None:
        ...
    
    @property
    def vector0(self: MSPyBentleyGeom.DEllipse3d) -> DVec3d:
        ...
    @vector0.setter
    def vector0(self: MSPyBentleyGeom.DEllipse3d, arg0: DVec3d) -> None:
        ...
    
    @property
    def vector90(self: MSPyBentleyGeom.DEllipse3d) -> DVec3d:
        ...
    @vector90.setter
    def vector90(self: MSPyBentleyGeom.DEllipse3d, arg0: DVec3d) -> None:
        ...
    
class DEllipse3dArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DEllipse3dArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.DEllipse3dArray, arg0: MSPyBentleyGeom.DEllipse3dArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.DEllipse3dArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.DEllipse3dArray, x: MSPyBentleyGeom.DEllipse3d) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.DEllipse3dArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.DEllipse3dArray, L: MSPyBentleyGeom.DEllipse3dArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.DEllipse3dArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.DEllipse3dArray, i: int, x: MSPyBentleyGeom.DEllipse3d) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.DEllipse3dArray) -> MSPyBentleyGeom.DEllipse3d
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.DEllipse3dArray, i: int) -> MSPyBentleyGeom.DEllipse3d
        
        Remove and return the item at index ``i``
        """
        ...
    
DISCONNECT: float

class DMap4d:
    """
    None
    """

    def Explode(self: MSPyBentleyGeom.DMap4d, matrix: RotMatrix, translation: DPoint3d, perspective: DPoint4d, inverse: bool) -> None:
        """
        Copy various parts of the 4x4 matrix to separate data structures.
        
        :param (output):
        matrix upper 3x3
        
        :param (output):
        translation last column (above diagonal)
        
        :param (output):
        perspective last row (including diagonal)
        
        :param (input):
        inverse false for forward part, true for inverse
        
        Remark:
        The separate pieces do not " mean " much if there is perspective.
        """
        ...
    
    @staticmethod
    def FromPrincipleProjection(height: float, axis: int) -> MSPyBentleyGeom.DMap4d:
        """
        Initialize a transform that is a (noninvertible) projection to a
        principle plane.
        
        :param (input):
        height distance of plane from origin
        
        :param (input):
        axis 0,1,2 for x,y,z normal
        """
        ...
    
    @staticmethod
    def FromQuadrantRotation(multiple: int, vx: float, vy: float, vz: float) -> MSPyBentleyGeom.DMap4d:
        """
        Rotate about vx,yv,vz by an integer multiple of 90 degrees. Providing
        the angle as an integer allows exact table lookup without
        approximation of pi.
        
        :param (input):
        multiple rotation angle is multiple * 90 degrees
        
        :param (input):
        vx x component of rotation axis
        
        :param (input):
        vy y component of rotation axis
        
        :param (input):
        vz z component of rotation axis
        """
        ...
    
    @staticmethod
    def FromRotation(c: float, s: float, vx: float, vy: float, vz: float) -> MSPyBentleyGeom.DMap4d:
        """
        Initialize a rotation about axis vx,vy,vz by angle whose cosine and
        sine are (proportional to) c and s.
        
        :param (input):
        c cosine of angle
        
        :param (input):
        s sine of angle
        
        :param (input):
        vx x component of rotation axis
        
        :param (input):
        vy y component of rotation axis
        
        :param (input):
        vz z component of rotation axis
        """
        ...
    
    @staticmethod
    def FromScale(*args, **kwargs):
        """
        Overloaded function.
        
        1. FromScale(ax: float, ay: float, az: float) -> MSPyBentleyGeom.DMap4d
        
        Initialize a pure scaling transformation. If any scale factor is zero,
        the corresponding inverse entry is also zero.
        
        :param (input):
        ax x scale factor
        
        :param (input):
        ay y scale factor
        
        :param (input):
        az z scale factor
        
        2. FromScale(a: float) -> MSPyBentleyGeom.DMap4d
        
        Initialize a pure scaling transformation. If any scale factor is zero,
        the corresponding inverse entry is also zero.
        
        :param (input):
        ax x scale factor
        
        :param (input):
        ay y scale factor
        
        :param (input):
        az z scale factor
        """
        ...
    
    @staticmethod
    def FromTranslation(tx: float, ty: float, tz: float) -> MSPyBentleyGeom.DMap4d:
        """
        Initialize a translation transform.
        
        :param (input):
        tx x component of translation
        
        :param (input):
        ty y component of translation
        
        :param (input):
        tz z component of translation
        """
        ...
    
    def InitFrom(self: MSPyBentleyGeom.DMap4d, forwardMatrix: DMatrix4d, inverseMatrix: DMatrix4d) -> None:
        """
        Direct initialization from matrices. Caller is responsible for correct
        inverse relationship.
        
        :param (input):
        forwardMatrix " forward " matrix.
        
        :param (input):
        inverseMatrix " inverse " matrix.
        """
        ...
    
    def InitFromRanges(self: MSPyBentleyGeom.DMap4d, loAP: DPoint3d, hiAP: DPoint3d, loBP: DPoint3d, hiBP: DPoint3d) -> bool:
        """
        Initialize a transform which translates and scales along principle
        axes so box loAP..hiAP maps to box loBP..hiBP
        
        :param (input):
        loAP corner of box A
        
        :param (input):
        hiAP diagonally opposite corner of box A
        
        :param (input):
        loBP corner of box B
        
        :param (input):
        hiBP diagonally opposite corner of box B
        
        :returns:
        int
        """
        ...
    
    def InitFromSkewBox(self: MSPyBentleyGeom.DMap4d, point0001: DPoint4d, point1001: DPoint4d, point0101: DPoint4d, point0010: DPoint4d) -> bool:
        """
        Fill a mapping between a unit prism and homogeneous skew space.
        Example use:We want to map a unit rectangle from font space to
        screen, under a full perspective mapping. That is, given font space
        point (x,y) we want A * (x,y,0,1)^T = the visible pixel. Also, given
        pixel (i,j) we want Ainverse * (i,j,0,1) to map back into font space.
        A long time ago, we were told points P0,P1,P2 which are the
        preperspective points that correspond to font space (0,0), (1,0), and
        (0,1). Since then, P00, P10, P01 have been through a homogeneous
        transformation. (For instance, there may be 'weight' of other than 1
        on each one.) The transformed (homogeneous) points are Q00, Q10, Q01
        In device space, we do a projection in the z direction. Hence we need
        a 4th point Qz=(0,0,1,0). Build this matrix by calling
        jmdlDMap4d_fillHomogeneousSkewFrame (pHMap, Q00, Q10,Q01,Qz)
        
        :param point0001:
        0001 in the unit space maps here
        
        :param point1001:
        1001 in the unit space maps here
        
        :param point0101:
        0100 in the unit space maps here
        
        :param point0010:
        0010 in the unit space maps here
        
        :returns:
        true if the 4 points are independent
        """
        ...
    
    def InitFromTaper(self: MSPyBentleyGeom.DMap4d, taper: float) -> bool:
        """
        Initialize a transform with perspective entries for a (nonzero) taper
        in the z direction.
        
        :param (input):
        taper taper fraction
        
        :returns:
        true if an invertible map was constructed.
        """
        ...
    
    def InitFromTransform(self: MSPyBentleyGeom.DMap4d, transform: Transform, invert: bool) -> bool:
        """
        :param (input):
        transform affine transformation 3x4 matrix
        
        :param (input):
        invert true to treat this matrix as the inverse of the mapping,
        false if forward.
        
        :returns:
        true if the Transfrom was invertible.
        """
        ...
    
    def InitProduct(*args, **kwargs):
        """
        Overloaded function.
        
        1. InitProduct(self: MSPyBentleyGeom.DMap4d, A: MSPyBentleyGeom.DMap4d, B: MSPyBentleyGeom.DMap4d) -> None
        
        Multiply transforms
        
        :param (input):
        A transform A
        
        :param (input):
        B transform B
        
        2. InitProduct(self: MSPyBentleyGeom.DMap4d, A: MSPyBentleyGeom.DMap4d, invertA: bool, B: MSPyBentleyGeom.DMap4d, invertB: bool) -> None
        
        Multiply transforms
        
        :param (input):
        A transform A
        
        :param (input):
        B transform B
        """
        ...
    
    def InverseOf(self: MSPyBentleyGeom.DMap4d, B: MSPyBentleyGeom.DMap4d) -> None:
        """
        Sets pA to the inverse of B.
        
        :param (input):
        B original mapping
        """
        ...
    
    def IsAffine(self: MSPyBentleyGeom.DMap4d) -> bool:
        """
        Test if a transform is affiine.
        
        :returns:
        true if the mapping is affine.
        """
        ...
    
    def IsIdentity(self: MSPyBentleyGeom.DMap4d) -> bool:
        """
        :returns:
        true if the mapping is an identity
        """
        ...
    
    def IsIndependent(self: MSPyBentleyGeom.DMap4d, xChange: int, yChange: int, zChange: int) -> bool:
        """
        Checks if the mapping is strictly a scale/translate in specified
        directions.
        
        :param (input):
        xChange 1 if x may change, 0 if it must stay fixed
        
        :param (input):
        yChange 1 if y may change, 0 if it must stay fixed
        
        :param (input):
        zChange 1 if z may change, 0 if it must stay fixed
        
        :returns:
        true if independence tests are satisfied.
        """
        ...
    
    def IsPerspective(self: MSPyBentleyGeom.DMap4d) -> bool:
        """
        Test if a transform is perspective.
        
        :returns:
        true if the mapping contains perspective.
        """
        ...
    
    def IsSingular(self: MSPyBentleyGeom.DMap4d) -> bool:
        """
        Test if a transform is singular
        
        :returns:
        true if the mapping is singular
        """
        ...
    
    @property
    def M0(self: MSPyBentleyGeom.DMap4d) -> DMatrix4d:
        ...
    @M0.setter
    def M0(self: MSPyBentleyGeom.DMap4d, arg0: DMatrix4d) -> None:
        ...
    
    @property
    def M1(self: MSPyBentleyGeom.DMap4d) -> DMatrix4d:
        ...
    @M1.setter
    def M1(self: MSPyBentleyGeom.DMap4d, arg0: DMatrix4d) -> None:
        ...
    
    def SandwichOf(self: MSPyBentleyGeom.DMap4d, A: MSPyBentleyGeom.DMap4d, B: MSPyBentleyGeom.DMap4d, C: MSPyBentleyGeom.DMap4d) -> None:
        """
        Form the product C * Binv * A * B * Cinv
        
        :param (input):
        A inside term of sandwich
        
        :param (input):
        B middle term of sandwich
        
        :param (input):
        C outer term of sandwich
        """
        ...
    
    def SandwichOfBABinverse(self: MSPyBentleyGeom.DMap4d, A: MSPyBentleyGeom.DMap4d, B: MSPyBentleyGeom.DMap4d) -> None:
        """
        Form the product B * A * BInv A NULL for B or C skips that part.
        
        :param (input):
        A inside term of sandwich
        
        :param (input):
        B outer term of sandwich
        """
        ...
    
    def SandwichOfBinverseAB(self: MSPyBentleyGeom.DMap4d, A: MSPyBentleyGeom.DMap4d, B: MSPyBentleyGeom.DMap4d) -> None:
        """
        Form the product Binv * A * B
        
        :param (input):
        A inside term of sandwich
        
        :param (input):
        B outer term of sandwich
        """
        ...
    
    def ZFrustum(self: MSPyBentleyGeom.DMap4d, z0: float, zetaHalf: float) -> None:
        """
        :param (input):
        z0 reference z. Normalized projective coordinate is 0 at this z
        
        :param (input):
        zetaHalf controls rate of growth of normalized projective z.
        Projective z at z0/k is k-1*zetahalf, i.e. is zetahalf at z0/2
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DMap4d) -> None
        
        2. __init__(self: MSPyBentleyGeom.DMap4d, forwardMatrix: DMatrix4d, inverseMatrix: DMatrix4d) -> None
        
        3. __init__(self: MSPyBentleyGeom.DMap4d, radians: float, vx: float, vy: float, vz: float) -> None
        """
        ...
    
    @property
    def mask(self: MSPyBentleyGeom.DMap4d) -> int:
        ...
    @mask.setter
    def mask(self: MSPyBentleyGeom.DMap4d, arg0: int) -> None:
        ...
    
class DMatrix4d:
    """
    None
    """

    def Add(*args, **kwargs):
        """
        Overloaded function.
        
        1. Add(self: MSPyBentleyGeom.DMatrix4d, delta: MSPyBentleyGeom.DMatrix4d) -> None
        
        Add a matrix (componentwise) to the instance.
        
        :param (input):
        delta matrix to add
        
        2. Add(self: MSPyBentleyGeom.DMatrix4d, delta: MSPyBentleyGeom.DMatrix4d, scaleFactor: float) -> None
        
        Add a matrix (componentwise) to the instance.
        
        :param (input):
        delta matrix to add
        """
        ...
    
    def AddSymmetricScaledOuterProduct(*args, **kwargs):
        """
        Overloaded function.
        
        1. AddSymmetricScaledOuterProduct(self: MSPyBentleyGeom.DMatrix4d, xyz: DPoint3d, scale: float) -> None
        
        Add [xx xy xz x; xy yy yz y; xz yz zz 1; x y z 1] * scale
        
        :param (input):
        xyz x,y,z for products. Implicitly extened to DPoint4d [x,y,z,1]
        for products
        
        :param (input):
        scale scale to apply to all terms.
        
        2. AddSymmetricScaledOuterProduct(self: MSPyBentleyGeom.DMatrix4d, xyzw: DPoint4d, scale: float) -> None
        
        Add [xx xy xz x; xy yy yz y; xz yz zz 1; x y z 1] * scale
        
        :param (input):
        xyz x,y,z for products. Implicitly extened to DPoint4d [x,y,z,1]
        for products
        
        :param (input):
        scale scale to apply to all terms.
        
        3. AddSymmetricScaledOuterProduct(self: MSPyBentleyGeom.DMatrix4d, U: DPoint4d, V: DPoint4d, scale: float) -> None
        
        Add [xx xy xz x; xy yy yz y; xz yz zz 1; x y z 1] * scale
        
        :param (input):
        xyz x,y,z for products. Implicitly extened to DPoint4d [x,y,z,1]
        for products
        
        :param (input):
        scale scale to apply to all terms.
        """
        ...
    
    def ApproximateNullVectorForUpperTriangle(self: MSPyBentleyGeom.DMatrix4d) -> tuple:
        """
        Approximate solution of A*X=0, i.e. find an approximate null vector; A
        is assumed upper triangular. Method:Find the smallest diagonal. Set
        that entry in X to 1. Backsolve the linear system with RHS 0 and the
        chosen X component fixed.
        
        :param (output):
        nullVector approximate null space vector.
        
        :param (output):
        residual estimate of error in A*X. (Squared residual.)
        """
        ...
    
    def ConvertInertiaProductsToPrincipalAreaMoments(self: MSPyBentleyGeom.DMatrix4d, localToWorld: Transform) -> tuple:
        """
        Input matrix contains products of inertia{[xx,xy,xz,x; xy yy yz y; xz
        yz zz z; x y z v]}. returned values are centroid, principal directions
        and 2nd moment tensor entries (yy+zz,xx+zz,xx+yy)
        
        :param (input):
        localToWorld transformation from local coordinate system (where
        the products were computed) to world
        
        :param (output):
        area area
        
        :param (output):
        centroid center of mass
        
        :param (output):
        axes columns of this matrix are the principal x,y,z directions.
        
        :param (output):
        momentTensorDiagonal tensor entries (inertias for rotation around
        each axis)
        """
        ...
    
    def ConvertInertiaProductsToPrincipalMoments(*args, **kwargs):
        """
        Overloaded function.
        
        1. ConvertInertiaProductsToPrincipalMoments(self: MSPyBentleyGeom.DMatrix4d) -> tuple
        
        Input matrix contains products of inertia{[xx,xy,xz,x; xy yy yz y; xz
        yz zz z; x y z v]}. returned values are centroid, principal directions
        and 2nd moment tensor entries (yy+zz,xx+zz,xx+yy)
        
        :param (output):
        volume volume
        
        :param (output):
        centroid center of mass
        
        :param (output):
        axes columns of this matrix are the principal x,y,z directions.
        
        :param (output):
        momentTensorDiagonal tensor entries (inertias for rotation around
        each axis)
        
        2. ConvertInertiaProductsToPrincipalMoments(self: MSPyBentleyGeom.DMatrix4d, localToWorld: Transform) -> tuple
        
        Input matrix contains products of inertia{[xx,xy,xz,x; xy yy yz y; xz
        yz zz z; x y z v]}. returned values are centroid, principal directions
        and 2nd moment tensor entries (yy+zz,xx+zz,xx+yy)
        
        :param (output):
        volume volume
        
        :param (output):
        centroid center of mass
        
        :param (output):
        axes columns of this matrix are the principal x,y,z directions.
        
        :param (output):
        momentTensorDiagonal tensor entries (inertias for rotation around
        each axis)
        """
        ...
    
    def ConvertInertiaProductsToPrincipalWireMoments(self: MSPyBentleyGeom.DMatrix4d, localToWorld: Transform) -> tuple:
        """
        Input matrix contains products of inertia{[xx,xy,xz,x; xy yy yz y; xz
        yz zz z; x y z v]}. returned values are centroid, principal directions
        and 2nd moment tensor entries (yy+zz,xx+zz,xx+yy)
        
        :param (input):
        localToWorld transformation from local coordinate system (where
        the products were computed) to world
        
        :param (output):
        length length
        
        :param (output):
        centroid center of mass
        
        :param (output):
        axes columns of this matrix are the principal x,y,z directions.
        
        :param (output):
        momentTensorDiagonal tensor entries (inertias for rotation around
        each axis)
        """
        ...
    
    def CopyUpperTriangleToLower(self: MSPyBentleyGeom.DMatrix4d) -> None:
        """
        Copy all 6 values from the upper triangle to mirrored positions in the
        lower triangle.
        """
        ...
    
    def DifferenceOf(self: MSPyBentleyGeom.DMatrix4d, A: MSPyBentleyGeom.DMatrix4d, B: MSPyBentleyGeom.DMatrix4d) -> None:
        """
        Subtract two 4x4 matrices.
        
        :param (input):
        A A matrix of A - B
        
        :param (input):
        B B matrix of A - B
        """
        ...
    
    def EvaluateImageGrid(self: MSPyBentleyGeom.DMatrix4d, grid: List[DPoint2d], x00: float, y00: float, m: int, n: int, tol: float) -> bool:
        """
        Evaluate pA*X for m*n points X arranged in a grid. The homogeneous
        coordinates of the i,j point in the grid is (x0 + i, y0 + j, 0, 1) The
        returned point grid[i * m + j] is the xy components of the image of
        grid poitn ij AFTER normalization.
        
        :param (output):
        grid Array of mXn mapped, normalized points
        
        :param (input):
        x00 grid origin x
        
        :param (input):
        y00 grid origin y
        
        :param (input):
        m number of grid points in x direction
        
        :param (input):
        n number of grid points in y direction
        
        :param (input):
        tol relative tolerance for 0-weight tests. If 0, 1.0e-10 is used *
        """
        ...
    
    @staticmethod
    def From(*args, **kwargs):
        """
        Overloaded function.
        
        1. From(B: RotMatrix) -> MSPyBentleyGeom.DMatrix4d
        
        Copy a RotMatrix into corresponding parts of a 4x4 matrix with 4th row
        and column both 0001.
        
        :param (input):
        B 3x3 part to fill
        
        2. From(transform: Transform) -> MSPyBentleyGeom.DMatrix4d
        
        Copy a RotMatrix into corresponding parts of a 4x4 matrix with 4th row
        and column both 0001.
        
        :param (input):
        B 3x3 part to fill
        """
        ...
    
    @staticmethod
    def From101WeightedProduct(transformA: Transform, matrixB: RotMatrix, transformC: Transform) -> MSPyBentleyGeom.DMatrix4d:
        """
        Promote 3 inputs to 4x4 carrier matrices, with respective scale terms
        1,0,1. Return the product of the carriers. (Huh? What is this for? If
        a transform is defined as A*F*C, and the derivative part of F is has
        nonzero derivative B only for its matrix part, A*B*C is the derivative
        4x4 matrix.
        
        :param (input):
        transformA First term. Promoted to 4x4 with final row 0001.
        
        :param (input):
        matrixB Second term. Promoted to 4x4 with final row 0000.
        
        :param (input):
        transformC Third term. Promoted to 4x4 with final row 0001.
        """
        ...
    
    @staticmethod
    def FromColumnVectors(col0: DVec3d, col1: DVec3d, col2: DVec3d, translation: DPoint3d) -> MSPyBentleyGeom.DMatrix4d:
        """
        Fill the affine part using xyz vectors for each column of the basis
        part and an xyz vector for the translation
        
        :param (input):
        col0 data for column 0 of leading 3x3 submatrix
        
        :param (input):
        col1 data for column 1 of leading 3x3 submatrix
        
        :param (input):
        col2 data for column 2 of leading 3x3 submatrix
        
        :param (input):
        translation data for translation part of matrix
        """
        ...
    
    @staticmethod
    def FromPerspective(px: float, py: float, pz: float) -> MSPyBentleyGeom.DMatrix4d:
        """
        Fill a matrix with entries in the perspective row, otherwise an
        identity matrix.
        
        :param (input):
        px x component
        
        :param (input):
        py y component
        
        :param (input):
        pz z component
        """
        ...
    
    @staticmethod
    def FromRowValues(x00: float, x01: float, x02: float, x03: float, x10: float, x11: float, x12: float, x13: float, x20: float, x21: float, x22: float, x23: float, x30: float, x31: float, x32: float, x33: float) -> MSPyBentleyGeom.DMatrix4d:
        """
        Copies the double values directly into the rows of this instance.
        
        :param (input):
        x00 (0,0) entry of matrix (row, column)
        
        :param (input):
        x01 (0,1) entry
        
        :param (input):
        x02 (0,2) entry
        
        :param (input):
        x03 (0,3) entry
        
        :param (input):
        x10 (1,0) entry of matrix (row, column)
        
        :param (input):
        x11 (1,1) entry
        
        :param (input):
        x12 (1,2) entry
        
        :param (input):
        x13 (1,3) entry
        
        :param (input):
        x20 (2,0) entry of matrix (row, column)
        
        :param (input):
        x21 (2,1) entry
        
        :param (input):
        x22 (2,2) entry
        
        :param (input):
        x23 (2,3) entry
        
        :param (input):
        x30 (3,0) entry of matrix (row, column)
        
        :param (input):
        x31 (3,1) entry
        
        :param (input):
        x32 (3,2) entry
        
        :param (input):
        x33 (3,3) entry
        """
        ...
    
    @staticmethod
    def FromSandwichProduct(transform: Transform, momentMatrix: MSPyBentleyGeom.DMatrix4d, scaleFactor: float) -> MSPyBentleyGeom.DMatrix4d:
        """
        Return{A = T * B * Tt * s} where T is an affine transform (expanded
        to 4x4 with 0001 final row), B is a DMatrix4d, and s is a scale
        factor.
        
        This is used to do change of basis when entries in B are xx,xy,xz,x
        moments etc, T is the (possibly non-uniform) transformation, and s is
        a scale factor for changing the integration domain. (If the
        integrations were volume integrals, s is the determinant of the
        orientation part of T. If the integrations were area integrals in a
        plane, s is the jacobian of the plane-to-plane transformation.)
        
        :param (input):
        transform transform to apply
        
        :param (input):
        momentMatrix matrix{B}
        
        :param (input):
        scaleFactor
        """
        ...
    
    @staticmethod
    def FromScaleAndTranslation(scale: DPoint3d, translation: DPoint3d) -> MSPyBentleyGeom.DMatrix4d:
        """
        Fill the scale and translate entries in an otherwise identity matrix
        
        :param (input):
        scale scale factor for each diagonal of leading 3x3 submatrix
        
        :param (input):
        translation translation vector
        """
        ...
    
    @staticmethod
    def FromTranslation(tx: float, ty: float, tz: float) -> MSPyBentleyGeom.DMatrix4d:
        """
        Fill a 4x4 matrix with a given translation vector and otherwise an
        identity.
        
        :param (input):
        tx x component
        
        :param (input):
        ty y component
        
        :param (input):
        tz z component
        """
        ...
    
    @staticmethod
    def FromZero() -> MSPyBentleyGeom.DMatrix4d:
        """
        Fill a matrix with zeros.
        """
        ...
    
    def GetBlocks(self: MSPyBentleyGeom.DMatrix4d) -> tuple:
        """
        Return matrix, final row, final column, and scalar parts
        
        :param (output):
        products upper 3x3 part
        
        :param (output):
        row xyz parts of final row
        
        :param (output):
        column xyz parts of final column
        
        :param (output):
        scalar ww entry.
        """
        ...
    
    def GetColumn(self: MSPyBentleyGeom.DMatrix4d, vec: DPoint4d, i: int) -> None:
        """
        Copy data from a matrix column to a DPoint4d structure.
        
        :param (output):
        vec point copied from column
        
        :param (input):
        i index of column 0 <= i<4 whose values are to be set
        """
        ...
    
    def GetRow(self: MSPyBentleyGeom.DMatrix4d, vec: DPoint4d, i: int) -> None:
        """
        Copy data from a matrix row to a DPoint4d structure.
        
        :param (output):
        vec point copied from row
        
        :param (input):
        i index of row 0 <= i<4 whose values are to be set
        """
        ...
    
    def GetRows(self: MSPyBentleyGeom.DMatrix4d, row0: DPoint4d, row1: DPoint4d, row2: DPoint4d, row3: DPoint4d) -> None:
        """
        Copy data from a matrix rows to DPoint4d structures.
        
        :param (output):
        row0 row 0 data. May be NULL.
        
        :param (output):
        row1 row 1 data. May be NULL.
        
        :param (output):
        row2 row 2 data. May be NULL.
        
        :param (output):
        row3 row 3 data. May be NULL.
        """
        ...
    
    def InitFrom(*args, **kwargs):
        """
        Overloaded function.
        
        1. InitFrom(self: MSPyBentleyGeom.DMatrix4d, B: RotMatrix) -> None
        
        Copy a RotMatrix into corresponding parts of a 4x4 matrix with 4th row
        and column both 0001.
        
        :param (input):
        B 3x3 part to fill
        
        2. InitFrom(self: MSPyBentleyGeom.DMatrix4d, transform: Transform) -> None
        
        Copy a RotMatrix into corresponding parts of a 4x4 matrix with 4th row
        and column both 0001.
        
        :param (input):
        B 3x3 part to fill
        """
        ...
    
    def InitFromColumnVectors(self: MSPyBentleyGeom.DMatrix4d, col0: DVec3d, col1: DVec3d, col2: DVec3d, translation: DPoint3d) -> None:
        """
        Fill the affine part using xyz vectors for each column of the basis
        part and an xyz vector for the translation
        
        :param (input):
        col0 data for column 0 of leading 3x3 submatrix
        
        :param (input):
        col1 data for column 1 of leading 3x3 submatrix
        
        :param (input):
        col2 data for column 2 of leading 3x3 submatrix
        
        :param (input):
        translation data for translation part of matrix
        """
        ...
    
    def InitFromPerspective(self: MSPyBentleyGeom.DMatrix4d, px: float, py: float, pz: float) -> None:
        """
        Fill a matrix with entries in the perspective row, otherwise an
        identity matrix.
        
        :param (input):
        px x component
        
        :param (input):
        py y component
        
        :param (input):
        pz z component
        """
        ...
    
    def InitFromRowValues(self: MSPyBentleyGeom.DMatrix4d, x00: float, x01: float, x02: float, x03: float, x10: float, x11: float, x12: float, x13: float, x20: float, x21: float, x22: float, x23: float, x30: float, x31: float, x32: float, x33: float) -> None:
        """
        Copies the double values directly into the rows of this instance.
        
        :param (input):
        x00 (0,0) entry of matrix (row, column)
        
        :param (input):
        x01 (0,1) entry
        
        :param (input):
        x02 (0,2) entry
        
        :param (input):
        x03 (0,3) entry
        
        :param (input):
        x10 (1,0) entry of matrix (row, column)
        
        :param (input):
        x11 (1,1) entry
        
        :param (input):
        x12 (1,2) entry
        
        :param (input):
        x13 (1,3) entry
        
        :param (input):
        x20 (2,0) entry of matrix (row, column)
        
        :param (input):
        x21 (2,1) entry
        
        :param (input):
        x22 (2,2) entry
        
        :param (input):
        x23 (2,3) entry
        
        :param (input):
        x30 (3,0) entry of matrix (row, column)
        
        :param (input):
        x31 (3,1) entry
        
        :param (input):
        x32 (3,2) entry
        
        :param (input):
        x33 (3,3) entry
        """
        ...
    
    def InitFromScaleAndTranslation(self: MSPyBentleyGeom.DMatrix4d, scale: DPoint3d, translation: DPoint3d) -> None:
        """
        Fill the scale and translate entries in an otherwise identity matrix
        
        :param (input):
        scale scale factor for each diagonal of leading 3x3 submatrix
        
        :param (input):
        translation translation vector
        """
        ...
    
    def InitFromTranslation(self: MSPyBentleyGeom.DMatrix4d, tx: float, ty: float, tz: float) -> None:
        """
        Fill a 4x4 matrix with a given translation vector and otherwise an
        identity.
        
        :param (input):
        tx x component
        
        :param (input):
        ty y component
        
        :param (input):
        tz z component
        """
        ...
    
    def InitIdentity(self: MSPyBentleyGeom.DMatrix4d) -> None:
        """
        initialize an identity matrix.
        """
        ...
    
    def InitProduct(*args, **kwargs):
        """
        Overloaded function.
        
        1. InitProduct(self: MSPyBentleyGeom.DMatrix4d, A: MSPyBentleyGeom.DMatrix4d, B: MSPyBentleyGeom.DMatrix4d) -> None
        
        Form the product of two 4x4 matrices.
        
        :param (input):
        A first matrix of product A*B
        
        :param (input):
        B second matrix of product A*B
        
        2. InitProduct(self: MSPyBentleyGeom.DMatrix4d, A: MSPyBentleyGeom.DMatrix4d, B: MSPyBentleyGeom.DMatrix4d, C: MSPyBentleyGeom.DMatrix4d) -> None
        
        Form the product of two 4x4 matrices.
        
        :param (input):
        A first matrix of product A*B
        
        :param (input):
        B second matrix of product A*B
        """
        ...
    
    def InitSymmetricProduct(self: MSPyBentleyGeom.DMatrix4d, sigma: DPoint4d, B: MSPyBentleyGeom.DMatrix4d) -> None:
        """
        Compute A = Bt * D * B where B is a matrix and D is a diagonal matrix
        given as a vector. REMARK:This is a Very Bad Thing for numerical
        purposes. Are you sure you can't get your result without forming this
        product?
        
        :param (input):
        sigma entries of diagonal matrix D
        
        :param (input):
        B matrix B
        """
        ...
    
    def IsAffine(self: MSPyBentleyGeom.DMatrix4d) -> bool:
        """
        Tests if the instance has 0001 final row, within tolerance.
        
        :returns:
        true if matrix is approximately affine.
        """
        ...
    
    def IsIdentity(self: MSPyBentleyGeom.DMatrix4d) -> bool:
        """
        Tests if pInstance is an identity transform and returns the bool
        indicator. The matrix is considered an identity if the sum of squared
        components after subtracting 1 from the diagonals is less than a small
        tolerance
        
        :returns:
        true if matrix is approximately an identity.
        """
        ...
    
    def MaxAbs(self: MSPyBentleyGeom.DMatrix4d) -> tuple:
        """
        Search the matrix for the entry with the largest absolute value.
        
        :returns:
        max absolute value entry in the matrix.
        """
        ...
    
    def MaxAbsDiff(self: MSPyBentleyGeom.DMatrix4d, other: MSPyBentleyGeom.DMatrix4d) -> tuple:
        """
        Compute max absolute difference between various parts of matrices.
        
        :param (input):
        other matrix to compare to.
        
        :param (output):
        matrixDiff difference in matrix part.
        
        :param (output):
        colDiff difference in final column XYZ part
        
        :param (output):
        rowDiff difference in final row XYZ part
        
        :param (output):
        weightDiff difference in final diagonal entry
        
        :returns:
        max absolute difference
        """
        ...
    
    def MaxAbsValue(self: MSPyBentleyGeom.DMatrix4d) -> float:
        """
        Search the matrix for the entry with the largest absolute value.
        
        :returns:
        max absolute value entry in the matrix.
        """
        ...
    
    def Multiply(*args, **kwargs):
        """
        Overloaded function.
        
        1. Multiply(self: MSPyBentleyGeom.DMatrix4d, outPoints: List[DPoint4d], inPoints: List[DPoint4d]) -> None
        
        Matrix multiplication, using all components of both the matrix and the
        points.
        
        :param (output):
        outPoint Array of homogeneous products A*inPoint[i]
        
        :param (input):
        inPoint Array of homogeneous points
        
        :param (input):
        n number of points
        
        2. Multiply(self: MSPyBentleyGeom.DMatrix4d, xyz: DPoint3d, w: float) -> DPoint4d
        
        Matrix multiplication, using all components of both the matrix and the
        points.
        
        :param (output):
        outPoint Array of homogeneous products A*inPoint[i]
        
        :param (input):
        inPoint Array of homogeneous points
        
        :param (input):
        n number of points
        
        3. Multiply(self: MSPyBentleyGeom.DMatrix4d, outPoints: List[DPoint4d], inPoints: List[DPoint4d]) -> None
        
        Matrix multiplication, using all components of both the matrix and the
        points.
        
        :param (output):
        outPoint Array of homogeneous products A*inPoint[i]
        
        :param (input):
        inPoint Array of homogeneous points
        
        :param (input):
        n number of points
        
        4. Multiply(self: MSPyBentleyGeom.DMatrix4d, outPoints: List[GraphicsPoint], inPoints: List[GraphicsPoint]) -> None
        
        Matrix multiplication, using all components of both the matrix and the
        points.
        
        :param (output):
        outPoint Array of homogeneous products A*inPoint[i]
        
        :param (input):
        inPoint Array of homogeneous points
        
        :param (input):
        n number of points
        
        5. Multiply(self: MSPyBentleyGeom.DMatrix4d, outPoints: List[DPoint4d], inPoints: List[DPoint3d], weight: MSPyBentleyGeom.DoubleArray) -> None
        
        Matrix multiplication, using all components of both the matrix and the
        points.
        
        :param (output):
        outPoint Array of homogeneous products A*inPoint[i]
        
        :param (input):
        inPoint Array of homogeneous points
        
        :param (input):
        n number of points
        
        6. Multiply(self: MSPyBentleyGeom.DMatrix4d, outPoints: List[DPoint4d], inPoints: list, weight: MSPyBentleyGeom.DoubleArray) -> None
        
        Matrix multiplication, using all components of both the matrix and the
        points.
        
        :param (output):
        outPoint Array of homogeneous products A*inPoint[i]
        
        :param (input):
        inPoint Array of homogeneous points
        
        :param (input):
        n number of points
        
        7. Multiply(self: MSPyBentleyGeom.DMatrix4d, outPoint: DPoint4d, inPoint: DPoint4d) -> None
        
        Matrix multiplication, using all components of both the matrix and the
        points.
        
        :param (output):
        outPoint Array of homogeneous products A*inPoint[i]
        
        :param (input):
        inPoint Array of homogeneous points
        
        :param (input):
        n number of points
        """
        ...
    
    def MultiplyAffine(*args, **kwargs):
        """
        Overloaded function.
        
        1. MultiplyAffine(self: MSPyBentleyGeom.DMatrix4d, outPoints: List[DPoint4d], inPoints: List[DPoint4d]) -> None
        
        Matrix*point multiplication, using full 4d points but assuming the
        matrix is affine, i.e. assume 0001 4th row.
        
        :param (output):
        outPoint Array of homogeneous products A*pPoint[i]
        
        :param (input):
        inPoint Array of homogeneous points
        
        :param (input):
        n number of points
        
        2. MultiplyAffine(self: MSPyBentleyGeom.DMatrix4d, outPoints: List[DPoint3d], inPoints: List[DPoint3d]) -> None
        
        Matrix*point multiplication, using full 4d points but assuming the
        matrix is affine, i.e. assume 0001 4th row.
        
        :param (output):
        outPoint Array of homogeneous products A*pPoint[i]
        
        :param (input):
        inPoint Array of homogeneous points
        
        :param (input):
        n number of points
        
        3. MultiplyAffine(self: MSPyBentleyGeom.DMatrix4d, outPoints: list, inPoints: list) -> None
        
        Matrix*point multiplication, using full 4d points but assuming the
        matrix is affine, i.e. assume 0001 4th row.
        
        :param (output):
        outPoint Array of homogeneous products A*pPoint[i]
        
        :param (input):
        inPoint Array of homogeneous points
        
        :param (input):
        n number of points
        """
        ...
    
    def MultiplyAffineVectors(*args, **kwargs):
        """
        Overloaded function.
        
        1. MultiplyAffineVectors(self: MSPyBentleyGeom.DMatrix4d, outPoints: List[DPoint3d], inPoints: List[DPoint3d]) -> None
        
        Matrix times vector multiplication, assume 0001 4th row and padding 3d
        data with 0 weight.
        
        :param (output):
        out Destination array
        
        :param (input):
        in Source array
        
        :param (input):
        n number of vectors
        
        2. MultiplyAffineVectors(self: MSPyBentleyGeom.DMatrix4d, outPoints: list, inPoints: list) -> None
        
        Matrix times vector multiplication, assume 0001 4th row and padding 3d
        data with 0 weight.
        
        :param (output):
        out Destination array
        
        :param (input):
        in Source array
        
        :param (input):
        n number of vectors
        """
        ...
    
    def MultiplyAndNormalize(*args, **kwargs):
        """
        Overloaded function.
        
        1. MultiplyAndNormalize(self: MSPyBentleyGeom.DMatrix4d, outPoints: List[DPoint3d], inPoints: List[DPoint4d]) -> None
        
        Multiply an array of points by a matrix, using all components of both
        the matrix and the points.
        
        :param (output):
        outPoint Array of products A*inPoint[i] normalized
        
        :param (input):
        inPoint Array of points points
        
        :param (input):
        n number of points
        
        2. MultiplyAndNormalize(self: MSPyBentleyGeom.DMatrix4d, outPoints: list, inPoints: List[DPoint4d]) -> None
        
        Multiply an array of points by a matrix, using all components of both
        the matrix and the points.
        
        :param (output):
        outPoint Array of products A*inPoint[i] normalized
        
        :param (input):
        inPoint Array of points points
        
        :param (input):
        n number of points
        """
        ...
    
    def MultiplyAndRenormalize(*args, **kwargs):
        """
        Overloaded function.
        
        1. MultiplyAndRenormalize(self: MSPyBentleyGeom.DMatrix4d, outPoints: List[DPoint3d], inPoints: List[DPoint3d]) -> None
        
        Multiply an array of points by a matrix, using all components of both
        the matrix and the points.
        
        :param (output):
        outPoint Array of products A*pPoint[i] renormalized
        
        :param (input):
        inPoint Array of points points
        
        :param (input):
        n number of points
        
        2. MultiplyAndRenormalize(self: MSPyBentleyGeom.DMatrix4d, outPoints: list, inPoints: list) -> None
        
        Multiply an array of points by a matrix, using all components of both
        the matrix and the points.
        
        :param (output):
        outPoint Array of products A*pPoint[i] renormalized
        
        :param (input):
        inPoint Array of points points
        
        :param (input):
        n number of points
        
        3. MultiplyAndRenormalize(self: MSPyBentleyGeom.DMatrix4d, outPoint: DPoint3d, inPoint: DPoint3d) -> None
        
        Multiply an array of points by a matrix, using all components of both
        the matrix and the points.
        
        :param (output):
        outPoint Array of products A*pPoint[i] renormalized
        
        :param (input):
        inPoint Array of points points
        
        :param (input):
        n number of points
        """
        ...
    
    def MultiplyScaleAndTranslate(*args, **kwargs):
        """
        Overloaded function.
        
        1. MultiplyScaleAndTranslate(self: MSPyBentleyGeom.DMatrix4d, outPoints: List[DPoint4d], inPoints: List[DPoint4d]) -> None
        
        Matrix*point multiplication, using full 4d points but assuming the
        matrix is has 3D only scaling and translation.
        
        :param (output):
        outPoint Array of homogeneous products A*pPoint[i]
        
        :param (input):
        inPoint Array of homogeneous points
        
        :param (input):
        n number of points
        
        2. MultiplyScaleAndTranslate(self: MSPyBentleyGeom.DMatrix4d, outPoints: List[DPoint3d], inPoints: List[DPoint3d]) -> None
        
        Matrix*point multiplication, using full 4d points but assuming the
        matrix is has 3D only scaling and translation.
        
        :param (output):
        outPoint Array of homogeneous products A*pPoint[i]
        
        :param (input):
        inPoint Array of homogeneous points
        
        :param (input):
        n number of points
        
        3. MultiplyScaleAndTranslate(self: MSPyBentleyGeom.DMatrix4d, outPoints: list, inPoints: list) -> None
        
        Matrix*point multiplication, using full 4d points but assuming the
        matrix is has 3D only scaling and translation.
        
        :param (output):
        outPoint Array of homogeneous products A*pPoint[i]
        
        :param (input):
        inPoint Array of homogeneous points
        
        :param (input):
        n number of points
        """
        ...
    
    def MultiplyTranspose(self: MSPyBentleyGeom.DMatrix4d, outPoints: List[DPoint4d], inPoints: List[DPoint4d]) -> None:
        """
        Multiply the transformed matrix times points. (Equivalent to
        multiplying transposed points times the matrix.)
        
        :param (output):
        outPoint Array of homogeneous products A^T *pPoint[i]
        
        :param (input):
        inPoint Array of homogeneous points
        
        :param (input):
        n number of points
        """
        ...
    
    def PreMultiplyByTranslateAndScale(self: MSPyBentleyGeom.DMatrix4d, tx: float, ty: float, tz: float, sx: float, sy: float, sz: float, matrixA: MSPyBentleyGeom.DMatrix4d) -> None:
        """
        Premultiply matirx A by a matrix with sx,sy,sz,1 on diagonal,
        tx,ty,tz,1 in last column
        
        :param (input):
        tx 03 entry (x translate) of mutliplier.
        
        :param (input):
        ty 13 entry (y translate) of multiplier.
        
        :param (input):
        tz 23 entry (z translate) of multiplier.
        
        :param (input):
        sx 00 entry (x scale) of multiplier.
        
        :param (input):
        sy 11 entry (y scale) of multiplier.
        
        :param (input):
        sz 22 entry (z scale) of multiplier.
        
        :param (input):
        matrixA existing matrix
        """
        ...
    
    def Scale(self: MSPyBentleyGeom.DMatrix4d, scaleFactor: float) -> None:
        """
        Scale in place.
        
        :param (input):
        scaleFactor scale to apply
        """
        ...
    
    def SetColumn(*args, **kwargs):
        """
        Overloaded function.
        
        1. SetColumn(self: MSPyBentleyGeom.DMatrix4d, i: int, r0: float, r1: float, r2: float, r3: float) -> None
        
        Install r0, r1, r2, r3 in an indicated column of an DMatrix4d.
        
        :param (input):
        i index of column 0 <= i<4 whose values are to be set
        
        :param (input):
        r0 row 0 value
        
        :param (input):
        r1 row 1 value
        
        :param (input):
        r2 row 2 value
        
        :param (input):
        r3 row 3 value
        
        2. SetColumn(self: MSPyBentleyGeom.DMatrix4d, i: int, point: DPoint4d) -> None
        
        Install r0, r1, r2, r3 in an indicated column of an DMatrix4d.
        
        :param (input):
        i index of column 0 <= i<4 whose values are to be set
        
        :param (input):
        r0 row 0 value
        
        :param (input):
        r1 row 1 value
        
        :param (input):
        r2 row 2 value
        
        :param (input):
        r3 row 3 value
        """
        ...
    
    def SetRow(*args, **kwargs):
        """
        Overloaded function.
        
        1. SetRow(self: MSPyBentleyGeom.DMatrix4d, i: int, c0: float, c1: float, c2: float, c3: float) -> None
        
        Install c0, c1, c2, c3 in an indicated row of an DMatrix4d.
        
        :param (input):
        i index of row 0 <= i<4 whose values are to be set
        
        :param (input):
        c0 column 0 value
        
        :param (input):
        c1 column 1 value
        
        :param (input):
        c2 column 2 value
        
        :param (input):
        c3 column 3 value
        
        2. SetRow(self: MSPyBentleyGeom.DMatrix4d, i: int, data: DPoint4d) -> None
        
        Install c0, c1, c2, c3 in an indicated row of an DMatrix4d.
        
        :param (input):
        i index of row 0 <= i<4 whose values are to be set
        
        :param (input):
        c0 column 0 value
        
        :param (input):
        c1 column 1 value
        
        :param (input):
        c2 column 2 value
        
        :param (input):
        c3 column 3 value
        """
        ...
    
    def Subtract(self: MSPyBentleyGeom.DMatrix4d, delta: MSPyBentleyGeom.DMatrix4d) -> None:
        """
        Subtract a matrix (componentwise) from the instance
        
        :param (input):
        delta matrix to subtract
        """
        ...
    
    def SwapColumns(self: MSPyBentleyGeom.DMatrix4d, i: int, j: int) -> None:
        """
        Install a DPoint4d in an indicated column of an DMatrix4d.
        
        :param (input):
        i first column index
        
        :param (input):
        j second column index
        """
        ...
    
    def SwapRows(self: MSPyBentleyGeom.DMatrix4d, i: int, j: int) -> None:
        """
        Install a DPoint4d in an indicated column of an DMatrix4d.
        
        :param (input):
        i first column index
        
        :param (input):
        j second column index
        """
        ...
    
    @staticmethod
    def SweepMomentProducts(baseProducts: MSPyBentleyGeom.DMatrix4d, sweepVector: DVec3d) -> MSPyBentleyGeom.DMatrix4d:
        """
        Return the product matrix resulting from sweeping geometry with given
        baseProducts;
        
        :param (input):
        baseProducts products integrated on base curve or area.
        
        :param (input):
        sweepVector vector for sweep (extrusion)
        
        :returns:
        products for integration over swept body.
        """
        ...
    
    def SymmetricEigenvectors(self: MSPyBentleyGeom.DMatrix4d, Q: MSPyBentleyGeom.DMatrix4d, D: DPoint4d) -> None:
        """
        Compute eigenvectors, assuming A is symmetric.
        
        :param (output):
        Q orthogonal, unit eigenvectors.
        
        :param (output):
        D corresponding eigenvalues.
        """
        ...
    
    def TransposeOf(self: MSPyBentleyGeom.DMatrix4d, B: MSPyBentleyGeom.DMatrix4d) -> None:
        """
        Transpose a 4x4 matrix.
        
        :param (input):
        B original matrix
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.DMatrix4d) -> None:
        ...
    
    @property
    def coff(arg0: MSPyBentleyGeom.DMatrix4d) -> numpy.typing.NDArray:
        ...
    @coff.setter
    def coff(arg0: MSPyBentleyGeom.DMatrix4d, arg1: numpy.typing.NDArray) -> None:
        ...
    
class DPlane3d:
    """
    None
    """

    def Evaluate(self: MSPyBentleyGeom.DPlane3d, point: DPoint3d) -> float:
        """
        Dot the plane normal with the vector from the plane
        origin to the point.
        
        Remark:
        s If the plane normal is a unit vector, this is the true distance
        from the plane to the point. If not, it is a scaled distance.
        
        :param (input):
        point point for evaluation
        
        :returns:
        dot product
        """
        ...
    
    def EvaluateMaxAbs(*args, **kwargs):
        """
        Overloaded function.
        
        1. EvaluateMaxAbs(self: MSPyBentleyGeom.DPlane3d, points: List[DPoint3d]) -> float
        
        :returns:
        The maximum absolute value of plane evaluation among points in an
        array.
        
        :param (input):
        points points to search
        
        :param (input):
        n number of points.
        
        2. EvaluateMaxAbs(self: MSPyBentleyGeom.DPlane3d, points: list) -> float
        
        :returns:
        The maximum absolute value of plane evaluation among points in an
        array.
        
        :param (input):
        points points to search
        
        :param (input):
        n number of points.
        """
        ...
    
    def EvaluateRange(*args, **kwargs):
        """
        Overloaded function.
        
        1. EvaluateRange(self: MSPyBentleyGeom.DPlane3d, points: List[DPoint3d]) -> tuple
        
        :returns:
        min and max signed evaluations among points in an array.
        
        :param (input):
        points points to search
        
        :param (input):
        n number of points
        
        :param (output):
        maxIndex index where (signed) max occurs.
        
        :param (output):
        minIndex index where (signed) min occurs.
        
        2. EvaluateRange(self: MSPyBentleyGeom.DPlane3d, points: list) -> tuple
        
        :returns:
        min and max signed evaluations among points in an array.
        
        :param (input):
        points points to search
        
        :param (input):
        n number of points
        
        :param (output):
        maxIndex index where (signed) max occurs.
        
        :param (output):
        minIndex index where (signed) min occurs.
        """
        ...
    
    def EvaluateVector(self: MSPyBentleyGeom.DPlane3d, vector: DVec3d) -> float:
        """
        Dot the plane normal with the given vector.
        
        Remark:
        s If the plane normal is a unit vector, this is the true distance
        of altitude change due to motion along by this vector. If not, it
        is a scaled distance.
        
        :param (input):
        vector vector for evaluation
        
        :returns:
        dot product
        """
        ...
    
    def GetCoefficients(self: MSPyBentleyGeom.DPlane3d) -> tuple:
        """
        Convert the plane to implicit coeffcients ax+by+cz=d.
        
        Remark:
        s WARNING:Check your usage. It is about equally common to write
        the plane equation with negated d, i.e. ax+by+cz+d=0. If so, pass
        in (a,b,c,-d).
        
        :param (output):
        coffA 4D plane x-coefficient
        
        :param (output):
        coffB 4D plane y-coefficient
        
        :param (output):
        coffC 4D plane z-coefficient
        
        :param (output):
        coffD 4D plane constant coefficient
        """
        ...
    
    def GetDPoint4d(self: MSPyBentleyGeom.DPlane3d, hPlane: DPoint4d) -> None:
        """
        Return the plane as a DPoint4d.
        
        :param (output):
        hPlane 4D plane coefficients
        """
        ...
    
    def Init(*args, **kwargs):
        """
        Overloaded function.
        
        1. Init(self: MSPyBentleyGeom.DPlane3d, hPlane: DPoint4d) -> bool
        
        Extract origin and normal from 4D plane coefficients.
        
        :param (input):
        hPlane 4D plane coefficients
        
        :returns:
        true if plane has a nonzero normal
        
        2. Init(self: MSPyBentleyGeom.DPlane3d, a: float, b: float, c: float, d: float) -> bool
        
        Extract origin and normal from 4D plane coefficients.
        
        :param (input):
        hPlane 4D plane coefficients
        
        :returns:
        true if plane has a nonzero normal
        """
        ...
    
    def InitFrom3Points(self: MSPyBentleyGeom.DPlane3d, origin: DPoint3d, xpoint: DPoint3d, ypoint: DPoint3d) -> None:
        """
        Initialize with first point as origin, normal as
        unnormalized cross product of vectors to 2nd and 3rd points.
        
        :param (input):
        origin origin point
        
        :param (input):
        xPoint first point in plane (e.g., x-axis point)
        
        :param (input):
        yPoint second point in plane (e.g., y-axis point)
        """
        ...
    
    def InitFromArray(*args, **kwargs):
        """
        Overloaded function.
        
        1. InitFromArray(self: MSPyBentleyGeom.DPlane3d, points: List[DPoint3d]) -> bool
        
        Compute the origin and normal so the plane passes
        (approximiately) through the array of points.
        
        :param (input):
        points array of points defining the plane
        
        :returns:
        true if the points define a clear plane (and are close to it!!!)
        false if the points are (a) closely clustered, (b) nearly
        colinear, or (c) not close to a single plane.
        
        2. InitFromArray(self: MSPyBentleyGeom.DPlane3d, points: list) -> bool
        
        Compute the origin and normal so the plane passes
        (approximiately) through the array of points.
        
        :param (input):
        points array of points defining the plane
        
        :returns:
        true if the points define a clear plane (and are close to it!!!)
        false if the points are (a) closely clustered, (b) nearly
        colinear, or (c) not close to a single plane.
        """
        ...
    
    def InitFromOriginAndNormal(*args, **kwargs):
        """
        Overloaded function.
        
        1. InitFromOriginAndNormal(self: MSPyBentleyGeom.DPlane3d, x0: float, y0: float, z0: float, ux: float, uy: float, uz: float) -> None
        
        Store origin and unnormalized vector.
        
        :param (input):
        x0 x-coordinate of origin point
        
        :param (input):
        y0 y-coordinate of origin point
        
        :param (input):
        z0 z-coordinate of origin point
        
        :param (input):
        ux x-coordinate of normal vector
        
        :param (input):
        uy y-coordinate of normal vector
        
        :param (input):
        uz z-coordinate of normal vector
        
        2. InitFromOriginAndNormal(self: MSPyBentleyGeom.DPlane3d, origin: DPoint3d, normal: DVec3d) -> None
        
        Store origin and unnormalized vector.
        
        :param (input):
        x0 x-coordinate of origin point
        
        :param (input):
        y0 y-coordinate of origin point
        
        :param (input):
        z0 z-coordinate of origin point
        
        :param (input):
        ux x-coordinate of normal vector
        
        :param (input):
        uy y-coordinate of normal vector
        
        :param (input):
        uz z-coordinate of normal vector
        """
        ...
    
    @staticmethod
    def Intersect3Planes(*args, **kwargs):
        """
        Overloaded function.
        
        1. Intersect3Planes(unitNormalA: DVec3d, distanceA: float, unitNormalB: DVec3d, distanceB: float, unitNormalC: DVec3d, distanceC: float) -> ValidatedValue<DPoint3d>
        
        Compute the point of intersection of 3 planes given as normal and
        distance from origin. ul> li>All normals are ASSUMED to be unit
        length.
        
        :returns:
        valid point if the three normals are independent. Otherwise
        returns origin of planeA, but marked invalid.
        
        2. Intersect3Planes(planeA: MSPyBentleyGeom.DPlane3d, planeB: MSPyBentleyGeom.DPlane3d, planeC: MSPyBentleyGeom.DPlane3d) -> ValidatedValue<DPoint3d>
        
        Compute the point of intersection of 3 planes given as normal and
        distance from origin. ul> li>All normals are ASSUMED to be unit
        length.
        
        :returns:
        valid point if the three normals are independent. Otherwise
        returns origin of planeA, but marked invalid.
        """
        ...
    
    def IsZero(self: MSPyBentleyGeom.DPlane3d) -> bool:
        """
        Test if the numeric entries in the plane are all
        absolutely zero (no tolerances).
        
        :returns:
        true if the plane contains only zero coordinates.
        """
        ...
    
    def Normalize(self: MSPyBentleyGeom.DPlane3d) -> bool:
        """
        Normalize the plane vector.
        
        :returns:
        true if normal vector has nonzero length.
        """
        ...
    
    def ProjectPoint(self: MSPyBentleyGeom.DPlane3d, projection: DPoint3d, point: DPoint3d) -> bool:
        """
        Project a (generally off-plane) point onto the plane.
        
        :param (output):
        projection projection of point onto the plane
        
        :param (input):
        point point to project to plane
        
        :returns:
        true if the plane has a well defined normal.
        """
        ...
    
    def Zero(self: MSPyBentleyGeom.DPlane3d) -> None:
        """
        Fill the plane data with zeros.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DPlane3d) -> None
        
        2. __init__(self: MSPyBentleyGeom.DPlane3d, x0: float, y0: float, z0: float, ux: float, uy: float, uz: float) -> None
        
        3. __init__(self: MSPyBentleyGeom.DPlane3d, origin: DPoint3d, normal: DVec3d) -> None
        
        4. __init__(self: MSPyBentleyGeom.DPlane3d, normal: DVec3d, distance: float) -> None
        
        5. __init__(self: MSPyBentleyGeom.DPlane3d, origin: DPoint3d, xpoint: DPoint3d, ypoint: DPoint3d) -> None
        """
        ...
    
    @property
    def normal(self: MSPyBentleyGeom.DPlane3d) -> DVec3d:
        ...
    @normal.setter
    def normal(self: MSPyBentleyGeom.DPlane3d, arg0: DVec3d) -> None:
        ...
    
    @property
    def origin(self: MSPyBentleyGeom.DPlane3d) -> DPoint3d:
        ...
    @origin.setter
    def origin(self: MSPyBentleyGeom.DPlane3d, arg0: DPoint3d) -> None:
        ...
    
class DPlane3dArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DPlane3dArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.DPlane3dArray, arg0: MSPyBentleyGeom.DPlane3dArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.DPlane3dArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.DPlane3dArray, x: MSPyBentleyGeom.DPlane3d) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.DPlane3dArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.DPlane3dArray, L: MSPyBentleyGeom.DPlane3dArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.DPlane3dArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.DPlane3dArray, i: int, x: MSPyBentleyGeom.DPlane3d) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.DPlane3dArray) -> MSPyBentleyGeom.DPlane3d
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.DPlane3dArray, i: int) -> MSPyBentleyGeom.DPlane3d
        
        Remove and return the item at index ``i``
        """
        ...
    
class DPlane3dByVectors:
    """
    None
    """

    @property
    def DPlane3dWithUnitNormal(arg0: MSPyBentleyGeom.DPlane3dByVectors) -> MSPyBentleyGeom.ValidatedDPlane3d:
        ...
    
    def Evaluate(*args, **kwargs):
        """
        Overloaded function.
        
        1. Evaluate(self: MSPyBentleyGeom.DPlane3dByVectors, u: float, v: float) -> MSPyBentleyGeom.DPoint3d
        
        return{origin + u * vectorU + v * vectorV}
        
        2. Evaluate(self: MSPyBentleyGeom.DPlane3dByVectors, uv: MSPyBentleyGeom.DPoint2d) -> MSPyBentleyGeom.DPoint3d
        
        return{origin + u * vectorU + v * vectorV}
        """
        ...
    
    def EvaluateTangents(self: MSPyBentleyGeom.DPlane3dByVectors, u: float, v: float) -> MSPyBentleyGeom.DPlane3dByVectors:
        """
        Evaluate point and tangents at u,v. (Of course, the tangents are just
        the originals)
        """
        ...
    
    def EvaluateVectorOnly(*args, **kwargs):
        """
        Overloaded function.
        
        1. EvaluateVectorOnly(self: MSPyBentleyGeom.DPlane3dByVectors, u: float, v: float) -> DVec3d
        
        return{u*vectorU + v*vectorV}
        
        2. EvaluateVectorOnly(self: MSPyBentleyGeom.DPlane3dByVectors, uv: MSPyBentleyGeom.DPoint2d) -> DVec3d
        
        return{u*vectorU + v*vectorV}
        """
        ...
    
    @staticmethod
    def FromOriginAndParallelToXY(origin: MSPyBentleyGeom.DPoint3d, sizeU: float, sizeV: float) -> MSPyBentleyGeom.DPlane3dByVectors:
        """
        Return a plane parallel to XY from given origin.
        """
        ...
    
    @staticmethod
    def FromOriginAndParallelToXZ(origin: MSPyBentleyGeom.DPoint3d, sizeU: float, sizeV: float) -> MSPyBentleyGeom.DPlane3dByVectors:
        """
        Return a plane parallel to XZ from given origin.
        """
        ...
    
    @staticmethod
    def FromOriginAndParallelToYZ(origin: MSPyBentleyGeom.DPoint3d, sizeU: float, sizeV: float) -> MSPyBentleyGeom.DPlane3dByVectors:
        """
        Return a plane parallel to YZ from given origin.
        """
        ...
    
    @staticmethod
    def FromOriginAndTargets(origin: MSPyBentleyGeom.DPoint3d, UTarget: MSPyBentleyGeom.DPoint3d, VTarget: MSPyBentleyGeom.DPoint3d) -> MSPyBentleyGeom.DPlane3dByVectors:
        """
        Return a plane from orgin and u,v target points
        """
        ...
    
    @staticmethod
    def FromXYPlane() -> MSPyBentleyGeom.DPlane3dByVectors:
        """
        Construct basis for XY plane.
        """
        ...
    
    def GetDPlane3dWithUnitNormal(self: MSPyBentleyGeom.DPlane3dByVectors) -> MSPyBentleyGeom.ValidatedDPlane3d:
        """
        Return DPlane3d form with unit normal.
        """
        ...
    
    def GetTransformsUnitZ(self: MSPyBentleyGeom.DPlane3dByVectors, localToWorld: Transform, worldToLocal: Transform) -> bool:
        """
        Return coordinate transforms, with unit perpendicular as Z vector in
        local to world.
        """
        ...
    
    def MaxDiff(self: MSPyBentleyGeom.DPlane3dByVectors, other: MSPyBentleyGeom.DPlane3dByVectors) -> float:
        """
        return max difference between corresponding components
        """
        ...
    
    def ProjectPoint(self: MSPyBentleyGeom.DPlane3dByVectors, spacePoint: MSPyBentleyGeom.DPoint3d) -> MSPyBentleyGeom.ValidatedDPoint2d:
        """
        :returns:
        u,v coordinates of the projection. This is marked valid in the
        usual case of independent (nonzero, non-parallel) plane vectors.
        
        Remark:
        if the plane vectors are parallel, the returned parameters do a
        projection to the longer vector, and are marked invalid
        
        Remark:
        if the plane vectors are both zero, the returned parameters are
        zero and are marked invalid.
        """
        ...
    
    def TransverseIntersection(self: MSPyBentleyGeom.DPlane3dByVectors, segment: MSPyBentleyGeom.DSegment3d, uv: MSPyBentleyGeom.DPoint2d) -> tuple:
        """
        Compute the simple intersection of a segment with the plane. Returns
        false in any parallel case (both in-plane and off-plane)
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DPlane3dByVectors) -> None
        
        2. __init__(self: MSPyBentleyGeom.DPlane3dByVectors, origin: MSPyBentleyGeom.DPoint3d, vectorU: DVec3d, vectorV: DVec3d) -> None
        
        3. __init__(self: MSPyBentleyGeom.DPlane3dByVectors, ax: float, ay: float, az: float, ux: float, uy: float, uz: float, vx: float, vy: float, vz: float) -> None
        
        4. __init__(self: MSPyBentleyGeom.DPlane3dByVectors, ellipse: MSPyBentleyGeom.DEllipse3d) -> None
        
        5. __init__(self: MSPyBentleyGeom.DPlane3dByVectors, triangle: MSPyBentleyGeom.DTriangle3d) -> None
        """
        ...
    
    @property
    def origin(self: MSPyBentleyGeom.DPlane3dByVectors) -> MSPyBentleyGeom.DPoint3d:
        ...
    @origin.setter
    def origin(self: MSPyBentleyGeom.DPlane3dByVectors, arg0: MSPyBentleyGeom.DPoint3d) -> None:
        ...
    
    @property
    def vectorU(self: MSPyBentleyGeom.DPlane3dByVectors) -> DVec3d:
        ...
    @vectorU.setter
    def vectorU(self: MSPyBentleyGeom.DPlane3dByVectors, arg0: DVec3d) -> None:
        ...
    
    @property
    def vectorV(self: MSPyBentleyGeom.DPlane3dByVectors) -> DVec3d:
        ...
    @vectorV.setter
    def vectorV(self: MSPyBentleyGeom.DPlane3dByVectors, arg0: DVec3d) -> None:
        ...
    
class DPoint2d:
    """
    None
    """

    def Add(self: MSPyBentleyGeom.DPoint2d, vector: MSPyBentleyGeom.DPoint2d) -> None:
        """
        Add a vector to the instance.
        
        :param (input):
        vector vector to add
        """
        ...
    
    def AlmostEqual(self: MSPyBentleyGeom.DPoint2d, dataB: MSPyBentleyGeom.DPoint2d) -> bool:
        """
        test if two points are equal. Uses library " small angle " as both
        absolute and relative tolerance. points are equal if squared distance
        between is less than (squared abstol) plus (squared relTol) * sum of
        cmponent squares
        
        :param (input):
        dataB second DPoint2d
        
        :returns:
        true if within tolerance.
        """
        ...
    
    def AngleTo(self: MSPyBentleyGeom.DPoint2d, vector2: MSPyBentleyGeom.DPoint2d) -> float:
        """
        Returns (signed, counterclockwise) angle between two
        vectors. The angle is in radians. The angle range is from -pi to +pi;
        positive angles are counterclockwise, negative angles are clockwise.
        
        :param (input):
        vector2 second vector
        
        :returns:
        angle in radians
        """
        ...
    
    def CrossProduct(self: MSPyBentleyGeom.DPoint2d, vector1: MSPyBentleyGeom.DPoint2d) -> float:
        """
        Returns the (scalar) cross product of two vectors.
        
        :param (input):
        vector1 first vector
        """
        ...
    
    def CrossProductToPoints(self: MSPyBentleyGeom.DPoint2d, target1: MSPyBentleyGeom.DPoint2d, target2: MSPyBentleyGeom.DPoint2d) -> float:
        """
        Returns the (scalar) cross product of two vectors. The
        vectors are computed from the Origin to Target1 and Target2.
        
        :param (input):
        target1 target of first vector
        
        :param (input):
        target2 target of second vector
        """
        ...
    
    def DifferenceOf(self: MSPyBentleyGeom.DPoint2d, point1: MSPyBentleyGeom.DPoint2d, point2: MSPyBentleyGeom.DPoint2d) -> None:
        """
        Return the difference of two points or vectors.
        
        :param (input):
        point1 First point or vector.
        
        :param (input):
        point2 Second (subtracted) point or vector.
        """
        ...
    
    def Distance(self: MSPyBentleyGeom.DPoint2d, point1: MSPyBentleyGeom.DPoint2d) -> float:
        """
        Returns the distance between 2 points
        
        :param (input):
        point1 second point
        
        :returns:
        distance from point 0 to point 1
        """
        ...
    
    def DistanceSquared(self: MSPyBentleyGeom.DPoint2d, point2: MSPyBentleyGeom.DPoint2d) -> float:
        """
        Return the squared distance between two points or
        vectors.
        
        :param (input):
        point2 end point
        
        :returns:
        squared distance between points
        """
        ...
    
    def DotProduct(self: MSPyBentleyGeom.DPoint2d, vector2: MSPyBentleyGeom.DPoint2d) -> float:
        """
        Returns the (scalar) dot product of two vectors.
        
        :param (input):
        vector2 second vector.
        
        :returns:
        dot product of the two vectors
        """
        ...
    
    def DotProductToPoints(self: MSPyBentleyGeom.DPoint2d, target1: MSPyBentleyGeom.DPoint2d, target2: MSPyBentleyGeom.DPoint2d) -> float:
        """
        Returns the (scalar) dot product of two vectors. The
        vectors are computed from the Origin to Target1 and Target2.
        
        :param (input):
        target1 target of first vector
        
        :param (input):
        target2 target of second vector
        """
        ...
    
    @staticmethod
    def From(*args, **kwargs):
        """
        Overloaded function.
        
        1. From(ax: float, ay: float) -> MSPyBentleyGeom.DPoint2d
        
        Returns a DPoint2d with 2 components (xy) from given
        components
        
        :param (input):
        ax x coordinate
        
        :param (input):
        ay y coordinate
        
        2. From(source: DPoint3d) -> MSPyBentleyGeom.DPoint2d
        
        Returns a DPoint2d with 2 components (xy) from given
        components
        
        :param (input):
        ax x coordinate
        
        :param (input):
        ay y coordinate
        """
        ...
    
    @staticmethod
    def FromInterpolate(point0: MSPyBentleyGeom.DPoint2d, fraction: float, point1: MSPyBentleyGeom.DPoint2d) -> MSPyBentleyGeom.DPoint2d:
        """
        Returns an interpolated point.
        
        :param (input):
        point0 point at fraction 0
        
        :param (input):
        fraction fraction from interpolation.
        
        :param (input):
        point1 point at fraction 1
        """
        ...
    
    @staticmethod
    def FromInterpolateBilinear(point00: MSPyBentleyGeom.DPoint2d, point10: MSPyBentleyGeom.DPoint2d, point01: MSPyBentleyGeom.DPoint2d, point11: MSPyBentleyGeom.DPoint2d, u: float, v: float) -> MSPyBentleyGeom.DPoint2d:
        """
        Returns a bilinear interpolation from corners
        (00)(10)(01)(11)
        
        :param (input):
        point00 point at (0,0)
        
        :param (input):
        point10 point at (1,0)
        
        :param (input):
        point01 point at (0,1)
        
        :param (input):
        point11 point at (1,1)
        
        :param (input):
        u interpolation fraction for edges (point00,point10) and
        (point01,point11)
        
        :param (input):
        v interpolation fraction for edges (point00,point10) and
        (point10,point11)
        """
        ...
    
    @staticmethod
    def FromOne() -> MSPyBentleyGeom.DPoint2d:
        """
        Return a DPoint2d with xy = 1.
        """
        ...
    
    @staticmethod
    def FromScale(point: MSPyBentleyGeom.DPoint2d, scale: float) -> MSPyBentleyGeom.DPoint2d:
        """
        Returns a scalar multiple of a DPoint2d
        
        :param (input):
        point input point
        
        :param (input):
        scale scale factor
        """
        ...
    
    @staticmethod
    def FromSumOf(*args, **kwargs):
        """
        Overloaded function.
        
        1. FromSumOf(point0: MSPyBentleyGeom.DPoint2d, scale0: float, point1: MSPyBentleyGeom.DPoint2d, scale1: float) -> MSPyBentleyGeom.DPoint2d
        
        Returns a linear combination of points
        
        :param (input):
        point0 first point
        
        :param (input):
        scale0 first scale
        
        :param (input):
        point1 second point
        
        :param (input):
        scale1 second scale
        
        2. FromSumOf(point0: MSPyBentleyGeom.DPoint2d, scale0: float, point1: MSPyBentleyGeom.DPoint2d, scale1: float, point2: MSPyBentleyGeom.DPoint2d, scale2: float) -> MSPyBentleyGeom.DPoint2d
        
        Returns a linear combination of points
        
        :param (input):
        point0 first point
        
        :param (input):
        scale0 first scale
        
        :param (input):
        point1 second point
        
        :param (input):
        scale1 second scale
        
        3. FromSumOf(origin: MSPyBentleyGeom.DPoint2d, vector: DVec2d, scaleFactor: float) -> MSPyBentleyGeom.DPoint2d
        
        Returns a linear combination of points
        
        :param (input):
        point0 first point
        
        :param (input):
        scale0 first scale
        
        :param (input):
        point1 second point
        
        :param (input):
        scale1 second scale
        
        4. FromSumOf(origin: MSPyBentleyGeom.DPoint2d, vector0: DVec2d, scaleFactor0: float, vector1: DVec2d, scaleFactor1: float) -> MSPyBentleyGeom.DPoint2d
        
        Returns a linear combination of points
        
        :param (input):
        point0 first point
        
        :param (input):
        scale0 first scale
        
        :param (input):
        point1 second point
        
        :param (input):
        scale1 second scale
        
        5. FromSumOf(origin: MSPyBentleyGeom.DPoint2d, vector0: DVec2d, scaleFactor0: float, vector1: DVec2d, scaleFactor1: float, vector2: DVec2d, scaleFactor2: float) -> MSPyBentleyGeom.DPoint2d
        
        Returns a linear combination of points
        
        :param (input):
        point0 first point
        
        :param (input):
        scale0 first scale
        
        :param (input):
        point1 second point
        
        :param (input):
        scale1 second scale
        """
        ...
    
    @staticmethod
    def FromZero() -> MSPyBentleyGeom.DPoint2d:
        """
        Return a DPoint2d with xy = 0.
        """
        ...
    
    def GetComponent(self: MSPyBentleyGeom.DPoint2d, index: int) -> float:
        """
        Gets a single component of a point. If the index is out
        of range 0,1, it is interpreted cyclically.
        
        :param (input):
        index 0=x, 1=y, others cyclic
        
        :returns:
        specified component of the point or vector.
        """
        ...
    
    def GetComponents(self: MSPyBentleyGeom.DPoint2d) -> Tuple[float, float]:
        ...
    
    def Init(*args, **kwargs):
        """
        Overloaded function.
        
        1. Init(self: MSPyBentleyGeom.DPoint2d, x: float, y: float) -> None
        
        Initialize with given components
        
        :param (input):
        x x component
        
        :param (input):
        y y component
        
        2. Init(self: MSPyBentleyGeom.DPoint2d, source: DPoint3d) -> None
        
        Initialize with given components
        
        :param (input):
        x x component
        
        :param (input):
        y y component
        """
        ...
    
    def InitDisconnect(self: MSPyBentleyGeom.DPoint2d) -> None:
        """
        Initialize a point with all coordinates as the disconnect value.
        """
        ...
    
    def Interpolate(self: MSPyBentleyGeom.DPoint2d, point0: MSPyBentleyGeom.DPoint2d, s: float, point1: MSPyBentleyGeom.DPoint2d) -> None:
        """
        Compute the point at an interpolated (fractional) position between a
        start and end point.
        
        :param (input):
        point0 start point (at parameter s=0)
        
        :param (input):
        s interpolation parameter
        
        :param (input):
        point1 end point (at parameter s=1)
        """
        ...
    
    def IsConvexPair(self: MSPyBentleyGeom.DPoint2d) -> bool:
        """
        return true if the point has x, y, and x+1 all between 0 and 1
        (inclusive).
        """
        ...
    
    def IsDisconnect(self: MSPyBentleyGeom.DPoint2d) -> bool:
        """
        :returns:
        true if the point has coordinates which indicate it is a
        disconnect (separator) ponit.
        """
        ...
    
    def IsEqual(*args, **kwargs):
        """
        Overloaded function.
        
        1. IsEqual(self: MSPyBentleyGeom.DPoint2d, vector2: MSPyBentleyGeom.DPoint2d) -> bool
        
        Test if two points or vectors are exactly equal.
        
        :param (input):
        vector2 Second point or vector
        
        :returns:
        true if the points are identical. (DPoint2dCR, double)
        
        2. IsEqual(self: MSPyBentleyGeom.DPoint2d, vector2: MSPyBentleyGeom.DPoint2d, tolerance: float) -> bool
        
        Test if two points or vectors are exactly equal.
        
        :param (input):
        vector2 Second point or vector
        
        :returns:
        true if the points are identical. (DPoint2dCR, double)
        """
        ...
    
    def IsParallelTo(self: MSPyBentleyGeom.DPoint2d, vector2: MSPyBentleyGeom.DPoint2d) -> bool:
        """
        Test if two vectors are parallel.
        
        :param (input):
        vector2 Second vector
        
        :returns:
        true if vectors are (nearly) parallel.
        """
        ...
    
    def IsPerpendicularTo(self: MSPyBentleyGeom.DPoint2d, vector2: MSPyBentleyGeom.DPoint2d) -> bool:
        """
        Test if two vectors are perpendicular.
        
        :param (input):
        vector2 Second vector
        
        :returns:
        true if vectors are (nearly) parallel.
        """
        ...
    
    def Magnitude(self: MSPyBentleyGeom.DPoint2d) -> float:
        """
        Returns the magnitude (length) of a vector.
        
        :returns:
        Length of the vector.
        """
        ...
    
    def MagnitudeSquared(self: MSPyBentleyGeom.DPoint2d) -> float:
        """
        :returns:
        squared magnitude of the vector
        """
        ...
    
    def MaxAbs(self: MSPyBentleyGeom.DPoint2d) -> float:
        """
        Finds the largest absolute value among the components of
        a point or vector.
        
        :returns:
        largest absolute value among point coordinates.
        """
        ...
    
    def Negate(self: MSPyBentleyGeom.DPoint2d, vector: MSPyBentleyGeom.DPoint2d) -> None:
        """
        returns the negative of a vector.
        
        :param (input):
        vector input
        """
        ...
    
    def Normalize(*args, **kwargs):
        """
        Overloaded function.
        
        1. Normalize(self: MSPyBentleyGeom.DPoint2d) -> float
        
        normalizes pVector1 in place, and returns the original magnitude. If
        the original magnitude is 0 the vector is left unchanged.
        
        :returns:
        original length
        
        2. Normalize(self: MSPyBentleyGeom.DPoint2d, vector1: MSPyBentleyGeom.DPoint2d) -> float
        
        normalizes pVector1 in place, and returns the original magnitude. If
        the original magnitude is 0 the vector is left unchanged.
        
        :returns:
        original length
        """
        ...
    
    def NormalizedDifferenceOf(self: MSPyBentleyGeom.DPoint2d, point1: MSPyBentleyGeom.DPoint2d, point2: MSPyBentleyGeom.DPoint2d) -> float:
        """
        Sets pNormal to the unit vector in the direction of point1 point2
        
        :param (input):
        point1 point 1
        
        :param (input):
        point2 point 2
        
        :returns:
        double distance between input points
        """
        ...
    
    def One(self: MSPyBentleyGeom.DPoint2d) -> None:
        """
        Returns a point or vector with all components 1.0.
        """
        ...
    
    def Rotate90(self: MSPyBentleyGeom.DPoint2d, vec: MSPyBentleyGeom.DPoint2d) -> None:
        """
        :param (input):
        vec original vector
        """
        ...
    
    def RotateCCW(self: MSPyBentleyGeom.DPoint2d, vec: MSPyBentleyGeom.DPoint2d, radians: float) -> None:
        """
        :param (input):
        vec original vector
        
        :param (input):
        radians rotation angle
        
        Remark:
        Note that this is a counterclockwise rotation. The " rotate " method
        in prior api was clockwise.
        """
        ...
    
    def Scale(*args, **kwargs):
        """
        Overloaded function.
        
        1. Scale(self: MSPyBentleyGeom.DPoint2d, source: MSPyBentleyGeom.DPoint2d, s: float) -> None
        
        Scale the instance coordinates from source
        
        :param (input):
        source input point
        
        :param (input):
        s scale factor
        
        2. Scale(self: MSPyBentleyGeom.DPoint2d, s: float) -> None
        
        Scale the instance coordinates from source
        
        :param (input):
        source input point
        
        :param (input):
        s scale factor
        """
        ...
    
    def ScaleToLength(*args, **kwargs):
        """
        Overloaded function.
        
        1. ScaleToLength(self: MSPyBentleyGeom.DPoint2d, source: MSPyBentleyGeom.DPoint2d, length: float) -> float
        
        Scales a vector to specified length. If the input vector
        length is 0, the output vector is a zero vector and the returned
        length is 0.
        
        :param (input):
        source The original vector.
        
        :param (input):
        length The requested length.
        
        :returns:
        The length prior to scaling.
        
        2. ScaleToLength(self: MSPyBentleyGeom.DPoint2d, length: float) -> float
        
        Scales a vector to specified length. If the input vector
        length is 0, the output vector is a zero vector and the returned
        length is 0.
        
        :param (input):
        source The original vector.
        
        :param (input):
        length The requested length.
        
        :returns:
        The length prior to scaling.
        """
        ...
    
    def SetComponent(self: MSPyBentleyGeom.DPoint2d, a: float, index: int) -> None:
        """
        Sets a single component of a point. If the index is out
        of range 0,1, it is interpreted cyclically.
        
        :param (input):
        a value for component
        
        :param (input):
        index 0=x, 1=y, others cyclic
        """
        ...
    
    def Subtract(self: MSPyBentleyGeom.DPoint2d, vector: MSPyBentleyGeom.DPoint2d) -> None:
        """
        Subtract one vector from another in place.
        
        :param (input):
        vector vector to subtract
        """
        ...
    
    def SumOf(*args, **kwargs):
        """
        Overloaded function.
        
        1. SumOf(self: MSPyBentleyGeom.DPoint2d, point1: MSPyBentleyGeom.DPoint2d, point2: MSPyBentleyGeom.DPoint2d) -> None
        
        Compute the sum of two points or vectors.
        
        :param (input):
        point1 First point or vector
        
        :param (input):
        point2 Second point or vector
        
        2. SumOf(self: MSPyBentleyGeom.DPoint2d, vector1: MSPyBentleyGeom.DPoint2d, scale1: float, vector2: MSPyBentleyGeom.DPoint2d, scale2: float, vector3: MSPyBentleyGeom.DPoint2d, scale3: float) -> None
        
        Compute the sum of two points or vectors.
        
        :param (input):
        point1 First point or vector
        
        :param (input):
        point2 Second point or vector
        
        3. SumOf(self: MSPyBentleyGeom.DPoint2d, point: MSPyBentleyGeom.DPoint2d, vector: MSPyBentleyGeom.DPoint2d, s: float) -> None
        
        Compute the sum of two points or vectors.
        
        :param (input):
        point1 First point or vector
        
        :param (input):
        point2 Second point or vector
        
        4. SumOf(self: MSPyBentleyGeom.DPoint2d, origin: MSPyBentleyGeom.DPoint2d, vector1: MSPyBentleyGeom.DPoint2d, scale1: float, vector2: MSPyBentleyGeom.DPoint2d, scale2: float) -> None
        
        Compute the sum of two points or vectors.
        
        :param (input):
        point1 First point or vector
        
        :param (input):
        point2 Second point or vector
        
        5. SumOf(self: MSPyBentleyGeom.DPoint2d, origin: MSPyBentleyGeom.DPoint2d, vector1: MSPyBentleyGeom.DPoint2d, scale1: float, vector2: MSPyBentleyGeom.DPoint2d, scale2: float, vector3: MSPyBentleyGeom.DPoint2d, scale3: float) -> None
        
        Compute the sum of two points or vectors.
        
        :param (input):
        point1 First point or vector
        
        :param (input):
        point2 Second point or vector
        """
        ...
    
    def Swap(self: MSPyBentleyGeom.DPoint2d, other: MSPyBentleyGeom.DPoint2d) -> None:
        """
        Swap contents of instance, other.
        
        :param [in,out]:
        other second point.
        """
        ...
    
    @property
    def X(self: MSPyBentleyGeom.DPoint2d) -> float:
        ...
    @X.setter
    def X(self: MSPyBentleyGeom.DPoint2d, arg0: float) -> None:
        ...
    
    @property
    def Y(self: MSPyBentleyGeom.DPoint2d) -> float:
        ...
    @Y.setter
    def Y(self: MSPyBentleyGeom.DPoint2d, arg0: float) -> None:
        ...
    
    def Zero(self: MSPyBentleyGeom.DPoint2d) -> None:
        """
        Sets all components of a point or vector to zero.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DPoint2d) -> None
        
        2. __init__(self: MSPyBentleyGeom.DPoint2d, vector: DVec2d) -> None
        
        3. __init__(self: MSPyBentleyGeom.DPoint2d, ax: float, ay: float) -> None
        """
        ...
    
    @property
    def x(self: MSPyBentleyGeom.DPoint2d) -> float:
        ...
    @x.setter
    def x(self: MSPyBentleyGeom.DPoint2d, arg0: float) -> None:
        ...
    
    @property
    def y(self: MSPyBentleyGeom.DPoint2d) -> float:
        ...
    @y.setter
    def y(self: MSPyBentleyGeom.DPoint2d, arg0: float) -> None:
        ...
    
class DPoint2dArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DPoint2dArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.DPoint2dArray, arg0: MSPyBentleyGeom.DPoint2dArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.DPoint2dArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.DPoint2dArray, x: MSPyBentleyGeom.DPoint2d) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.DPoint2dArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def count(self: MSPyBentleyGeom.DPoint2dArray, x: MSPyBentleyGeom.DPoint2d) -> int:
        """
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.DPoint2dArray, L: MSPyBentleyGeom.DPoint2dArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.DPoint2dArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.DPoint2dArray, i: int, x: MSPyBentleyGeom.DPoint2d) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.DPoint2dArray) -> MSPyBentleyGeom.DPoint2d
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.DPoint2dArray, i: int) -> MSPyBentleyGeom.DPoint2d
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(self: MSPyBentleyGeom.DPoint2dArray, x: MSPyBentleyGeom.DPoint2d) -> None:
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class DPoint2dVecArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DPoint2dVecArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.DPoint2dVecArray, arg0: MSPyBentleyGeom.DPoint2dVecArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.DPoint2dVecArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.DPoint2dVecArray, x: MSPyBentleyGeom.DPoint2dArray) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.DPoint2dVecArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def count(self: MSPyBentleyGeom.DPoint2dVecArray, x: MSPyBentleyGeom.DPoint2dArray) -> int:
        """
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.DPoint2dVecArray, L: MSPyBentleyGeom.DPoint2dVecArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.DPoint2dVecArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.DPoint2dVecArray, i: int, x: MSPyBentleyGeom.DPoint2dArray) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.DPoint2dVecArray) -> MSPyBentleyGeom.DPoint2dArray
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.DPoint2dVecArray, i: int) -> MSPyBentleyGeom.DPoint2dArray
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(self: MSPyBentleyGeom.DPoint2dVecArray, x: MSPyBentleyGeom.DPoint2dArray) -> None:
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class DPoint3d:
    """
    None
    """

    def Add(*args, **kwargs):
        """
        Overloaded function.
        
        1. Add(self: MSPyBentleyGeom.DPoint3d, vector: DVec3d) -> None
        
        @description Adds a vector to a pointer or vector, returns the result
        in place.
        
        :param (input):
        vector The vector to add.
        
        2. Add(self: MSPyBentleyGeom.DPoint3d, vector: MSPyBentleyGeom.DPoint3d) -> None
        
        @description Adds a vector to a pointer or vector, returns the result
        in place.
        
        :param (input):
        vector The vector to add.
        """
        ...
    
    @staticmethod
    def AddToArray(*args, **kwargs):
        """
        Overloaded function.
        
        1. AddToArray(points: MSPyBentleyGeom.DPoint3dArray, delta: MSPyBentleyGeom.DPoint3d) -> None
        
        Add translation to all points.
        
        2. AddToArray(points: list, delta: MSPyBentleyGeom.DPoint3d) -> None
        
        Add translation to all points.
        """
        ...
    
    def AlmostEqual(*args, **kwargs):
        """
        Overloaded function.
        
        1. AlmostEqual(self: MSPyBentleyGeom.DPoint3d, dataB: MSPyBentleyGeom.DPoint3d) -> bool
        
        test if two points are equal. Uses library " small angle " as both
        absolute and relative tolerance. points are equal if squared distance
        between is less than (squared abstol) plus (squared relTol) * sum of
        cmponent squares
        
        :param (input):
        dataB second DPoint3d
        
        :returns:
        true if within tolerance.
        
        2. AlmostEqual(self: MSPyBentleyGeom.DPoint3d, dataB: MSPyBentleyGeom.DPoint3d, abstol: float) -> bool
        
        test if two points are equal. Uses library " small angle " as both
        absolute and relative tolerance. points are equal if squared distance
        between is less than (squared abstol) plus (squared relTol) * sum of
        cmponent squares
        
        :param (input):
        dataB second DPoint3d
        
        :returns:
        true if within tolerance.
        """
        ...
    
    def AlmostEqualXY(*args, **kwargs):
        """
        Overloaded function.
        
        1. AlmostEqualXY(self: MSPyBentleyGeom.DPoint3d, dataB: MSPyBentleyGeom.DPoint3d) -> bool
        
        test if two points are equal. Uses library " small angle " as both
        absolute and relative tolerance. points are equal if squared distance
        between is less than (squared abstol) plus (squared relTol) * sum of
        cmponent squares
        
        :param (input):
        dataB second DPoint3d
        
        :returns:
        true if within tolerance.
        
        2. AlmostEqualXY(self: MSPyBentleyGeom.DPoint3d, dataB: MSPyBentleyGeom.DPoint3d, abstol: float) -> bool
        
        test if two points are equal. Uses library " small angle " as both
        absolute and relative tolerance. points are equal if squared distance
        between is less than (squared abstol) plus (squared relTol) * sum of
        cmponent squares
        
        :param (input):
        dataB second DPoint3d
        
        :returns:
        true if within tolerance.
        """
        ...
    
    def AngleTo(self: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d) -> float:
        """
        @description Returns the angle between two vectors. This angle is
        between 0 and pi. Rotating the first vector by this angle around the
        cross product between the vectors aligns it with the second vector.
        
        :param (input):
        point2 The second vector
        
        :returns:
        The angle between the vectors.
        """
        ...
    
    def AngleToXY(self: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d) -> float:
        """
        @description Returns the angle from Vector1 to Vector2 using only xy
        parts. This angle is between -pi and +pi.
        
        :param (input):
        point2 The second vector
        
        :returns:
        The angle between vectors.
        """
        ...
    
    def AngleXY(self: MSPyBentleyGeom.DPoint3d) -> float:
        """
        @description Computes the (signed) angle from xy axis to the vector,
        using only xy parts.
        """
        ...
    
    def ComponentRange(self: MSPyBentleyGeom.DPoint3d) -> DRange1d:
        """
        :returns:
        min and max of componetns.
        """
        ...
    
    def CrossProduct(self: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d) -> None:
        """
        @description Returns the cross (vector) cross product of two vectors.
        
        :param (input):
        point1 The first vector
        
        :param (input):
        point2 The second vector
        """
        ...
    
    def CrossProductToPoints(self: MSPyBentleyGeom.DPoint3d, origin: MSPyBentleyGeom.DPoint3d, target1: MSPyBentleyGeom.DPoint3d, target2: MSPyBentleyGeom.DPoint3d) -> None:
        """
        @description Returns the (vector) cross product of two vectors. The
        vectors are computed from the Origin to target1 and target2.
        
        :param (input):
        origin The base point for computing vectors.
        
        :param (input):
        target1 The target point for the first vector.
        
        :param (input):
        target2 The target point for the second vector.
        """
        ...
    
    def CrossProductToPointsXY(self: MSPyBentleyGeom.DPoint3d, target1: MSPyBentleyGeom.DPoint3d, target2: MSPyBentleyGeom.DPoint3d) -> float:
        """
        @description Returns the (scalar) cross product of the xy parts of two
        vectors. The vectors are computed from the Origin to target1 and
        target2.
        
        :param (input):
        target1 The target point for the first vector.
        
        :param (input):
        target2 The target point for the second vector.
        """
        ...
    
    def CrossProductXY(self: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d) -> float:
        """
        @description Return the (scalar) cross product of the xy parts of two
        vectors.
        
        :param (input):
        point2 The second vector
        
        :returns:
        The 2d cross product.
        """
        ...
    
    def DifferenceOf(self: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d) -> None:
        """
        @description Subtract coordinates of two vectors or points. (Compute
        Point1 - Point2)
        
        :param (input):
        point1 The first point
        
        :param (input):
        point2 The second (subtracted) point.
        """
        ...
    
    def Distance(self: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d) -> float:
        """
        @description Computes the (cartesian) distance between two points
        
        :param (input):
        point2 The second point
        
        :returns:
        The distance between points.
        """
        ...
    
    def DistanceSquared(self: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d) -> float:
        """
        @description Computes the squared distance between two points.
        
        :param (input):
        point2 The second point.
        
        :returns:
        The squared distance between the points.
        """
        ...
    
    def DistanceSquaredXY(self: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d) -> float:
        """
        @description Computes the squared distance between two points, using
        only the xy parts.
        
        :param (input):
        point2 The second point
        
        :returns:
        The squared distance between the XY projections of the two points.
        (i.e. any z difference is ignored)
        """
        ...
    
    def DistanceXY(*args, **kwargs):
        """
        Overloaded function.
        
        1. DistanceXY(self: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d) -> float
        
        @description Computes the distance between two points, using only x
        and y components.
        
        :param (input):
        point2 The second point
        
        :returns:
        The distance between the XY projections of the two points. (i.e.
        any z difference is ignored)
        
        2. DistanceXY(self: MSPyBentleyGeom.DPoint3d, otherPoint: MSPyBentleyGeom.DPoint3d, matrix: MSPyBentleyGeom.DMatrix4d) -> tuple
        
        @description Computes the distance between two points, using only x
        and y components.
        
        :param (input):
        point2 The second point
        
        :returns:
        The distance between the XY projections of the two points. (i.e.
        any z difference is ignored)
        """
        ...
    
    @staticmethod
    def DivideArrayByScales(*args, **kwargs):
        """
        Overloaded function.
        
        1. DivideArrayByScales(outPoints: MSPyBentleyGeom.DPoint3dArray, inPoints: MSPyBentleyGeom.DPoint3dArray, scales: MSPyBentleyGeom.DoubleArray) -> None
        
        @description Divide each point in an array by its corresponding scale
        factor. Leave any point with near zero weight unchanged.
        
        :param (output):
        pDest destination array.
        
        :param (input):
        pSource source array.
        
        :param (input):
        pScales scale factors
        
        :param (input):
        n number of points.
        
        2. DivideArrayByScales(outPoints: list, inPoints: list, scales: MSPyBentleyGeom.DoubleArray) -> None
        
        @description Divide each point in an array by its corresponding scale
        factor. Leave any point with near zero weight unchanged.
        
        :param (output):
        pDest destination array.
        
        :param (input):
        pSource source array.
        
        :param (input):
        pScales scale factors
        
        :param (input):
        n number of points.
        """
        ...
    
    def DotDifference(self: MSPyBentleyGeom.DPoint3d, origin: MSPyBentleyGeom.DPoint3d, vector: DVec3d) -> float:
        """
        @description Returns the (scalar) dot product of a two vectors. One
        vector is computed internally as the difference of the TargetPoint and
        Origin. (TargetPoint-Origin) The other is given directly as a single
        argument.
        
        :param (input):
        origin The start (orign) point of the first vector of the cross
        product.
        
        :param (input):
        vector The second
        """
        ...
    
    def DotProduct(*args, **kwargs):
        """
        Overloaded function.
        
        1. DotProduct(self: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d) -> float
        
        @description Returns the (scalar) dot product of two vectors.
        
        :param (input):
        point2 The second vector
        
        :returns:
        The dot product of the two vectors
        
        2. DotProduct(self: MSPyBentleyGeom.DPoint3d, ax: float, ay: float, az: float) -> float
        
        @description Returns the (scalar) dot product of two vectors.
        
        :param (input):
        point2 The second vector
        
        :returns:
        The dot product of the two vectors
        """
        ...
    
    def DotProductToPoints(self: MSPyBentleyGeom.DPoint3d, target1: MSPyBentleyGeom.DPoint3d, target2: MSPyBentleyGeom.DPoint3d) -> float:
        """
        @description Returns the (scalar) dot product of two vectors. The
        vectors are computed from the Origin to target1 and target2.
        
        :param (input):
        target1 The target point for the first vector.
        
        :param (input):
        target2 The target point for the second vector.
        """
        ...
    
    def DotProductToPointsXY(self: MSPyBentleyGeom.DPoint3d, target1: MSPyBentleyGeom.DPoint3d, target2: MSPyBentleyGeom.DPoint3d) -> float:
        """
        @description Returns the (scalar) dot product of xy parts of two
        vectors. The vectors are computed from the BasePoint to target1 and
        target2.
        
        :param (input):
        target1 The target point for the first vector.
        
        :param (input):
        target2 The target point for the second vector.
        """
        ...
    
    def DotProductXY(self: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d) -> float:
        """
        @description Returns the (scalar) dot product of xy parts of two
        vectors.
        
        :param (input):
        point2 The second vector
        
        :returns:
        The dot product of the xy parts of the two vectors
        """
        ...
    
    @staticmethod
    def From(*args, **kwargs):
        """
        Overloaded function.
        
        1. From(x: float, y: float, z: float = 0.0) -> MSPyBentleyGeom.DPoint3d
        
        Return a DPoint3d with given xyz.
        
        2. From(xy: MSPyBentleyGeom.DPoint2d) -> MSPyBentleyGeom.DPoint3d
        
        Return a DPoint3d with given xyz.
        """
        ...
    
    @staticmethod
    def FromInterpolate(pointA: MSPyBentleyGeom.DPoint3d, fraction: float, pointB: MSPyBentleyGeom.DPoint3d) -> MSPyBentleyGeom.DPoint3d:
        """
        interpolate between points.
        
        :param (input):
        pointA start point
        
        :param (input):
        fraction fractional parameter
        
        :param (input):
        pointB end point
        """
        ...
    
    @staticmethod
    def FromInterpolateAndPerpendicularXY(pointA: MSPyBentleyGeom.DPoint3d, fraction: float, pointB: MSPyBentleyGeom.DPoint3d, fractionXYPerp: float) -> MSPyBentleyGeom.DPoint3d:
        """
        interpolate between points. Then add a shift in the xy plane by a
        fraction of the XY projection perpendicular
        
        :param (input):
        pointA start point
        
        :param (input):
        fraction fractional parameter along the line from A to B
        
        :param (input):
        pointB end point
        
        :param (input):
        fractionXYPerp fractional parameter applied to vector that is the
        XY parts of (B-A), rotated CCW in plane.
        """
        ...
    
    @staticmethod
    def FromInterpolateBilinear(point00: MSPyBentleyGeom.DPoint3d, point10: MSPyBentleyGeom.DPoint3d, point01: MSPyBentleyGeom.DPoint3d, point11: MSPyBentleyGeom.DPoint3d, u: float, v: float) -> MSPyBentleyGeom.DPoint3d:
        """
        @description Returns a bilinear interpolation from corners
        (00)(10)(01)(11)
        
        :param (input):
        point00 point at (0,0)
        
        :param (input):
        point10 point at (1,0)
        
        :param (input):
        point01 point at (0,1)
        
        :param (input):
        point11 point at (1,1)
        
        :param (input):
        u interpolation fraction for edges (point00,point10) and
        (point01,point11)
        
        :param (input):
        v interpolation fraction for edges (point00,point10) and
        (point10,point11)
        """
        ...
    
    @staticmethod
    def FromOne() -> MSPyBentleyGeom.DPoint3d:
        """
        Return a DPoint3d with xyz = 1.
        """
        ...
    
    @staticmethod
    def FromProduct(*args, **kwargs):
        """
        Overloaded function.
        
        1. FromProduct(transform: Transform, x: float, y: float, z: float) -> MSPyBentleyGeom.DPoint3d
        
        return product of transform times point given as components.
        
        :param (input):
        transform affine transform.
        
        :param (input):
        x x component
        
        :param (input):
        y y component
        
        :param (input):
        z z component
        
        2. FromProduct(transform: Transform, point: MSPyBentleyGeom.DPoint3d) -> MSPyBentleyGeom.DPoint3d
        
        return product of transform times point given as components.
        
        :param (input):
        transform affine transform.
        
        :param (input):
        x x component
        
        :param (input):
        y y component
        
        :param (input):
        z z component
        
        3. FromProduct(point: MSPyBentleyGeom.DPoint3d, matrix: RotMatrix, x: float, y: float, z: float) -> MSPyBentleyGeom.DPoint3d
        
        return product of transform times point given as components.
        
        :param (input):
        transform affine transform.
        
        :param (input):
        x x component
        
        :param (input):
        y y component
        
        :param (input):
        z z component
        
        4. FromProduct(point: MSPyBentleyGeom.DPoint3d, matrix: RotMatrix, vector: DVec3d) -> MSPyBentleyGeom.DPoint3d
        
        return product of transform times point given as components.
        
        :param (input):
        transform affine transform.
        
        :param (input):
        x x component
        
        :param (input):
        y y component
        
        :param (input):
        z z component
        """
        ...
    
    @staticmethod
    def FromScale(point: MSPyBentleyGeom.DPoint3d, scale: float) -> MSPyBentleyGeom.DPoint3d:
        """
        @description Returns a scalar multiple of a DPoint3d
        
        :param (input):
        point input point
        
        :param (input):
        scale scale factor
        """
        ...
    
    @staticmethod
    def FromSumOf(*args, **kwargs):
        """
        Overloaded function.
        
        1. FromSumOf(origin: MSPyBentleyGeom.DPoint3d, vector: MSPyBentleyGeom.DPoint3d) -> MSPyBentleyGeom.DPoint3d
        
        Add a point and a vector.
        
        :param (input):
        origin start point
        
        :param (input):
        vector vector add
        
        2. FromSumOf(origin: MSPyBentleyGeom.DPoint3d, vector: MSPyBentleyGeom.DPoint3d, scaleFactor: float) -> MSPyBentleyGeom.DPoint3d
        
        Add a point and a vector.
        
        :param (input):
        origin start point
        
        :param (input):
        vector vector add
        
        3. FromSumOf(origin: MSPyBentleyGeom.DPoint3d, point0: MSPyBentleyGeom.DPoint3d, scaleFactor0: float, point1: MSPyBentleyGeom.DPoint3d, scaleFactor1: float) -> MSPyBentleyGeom.DPoint3d
        
        Add a point and a vector.
        
        :param (input):
        origin start point
        
        :param (input):
        vector vector add
        
        4. FromSumOf(origin: MSPyBentleyGeom.DPoint3d, point0: MSPyBentleyGeom.DPoint3d, scaleFactor0: float, point1: MSPyBentleyGeom.DPoint3d, scaleFactor1: float, point2: MSPyBentleyGeom.DPoint3d, scaleFactor2: float) -> MSPyBentleyGeom.DPoint3d
        
        Add a point and a vector.
        
        :param (input):
        origin start point
        
        :param (input):
        vector vector add
        
        5. FromSumOf(point0: MSPyBentleyGeom.DPoint3d, scale0: float, point1: MSPyBentleyGeom.DPoint3d, scale1: float) -> MSPyBentleyGeom.DPoint3d
        
        Add a point and a vector.
        
        :param (input):
        origin start point
        
        :param (input):
        vector vector add
        
        6. FromSumOf(point0: MSPyBentleyGeom.DPoint3d, scale0: float, point1: MSPyBentleyGeom.DPoint3d, scale1: float, point2: MSPyBentleyGeom.DPoint3d, scale2: float) -> MSPyBentleyGeom.DPoint3d
        
        Add a point and a vector.
        
        :param (input):
        origin start point
        
        :param (input):
        vector vector add
        """
        ...
    
    @staticmethod
    def FromWeightedAverage(*args, **kwargs):
        """
        Overloaded function.
        
        1. FromWeightedAverage(pointA: MSPyBentleyGeom.DPoint3d, weightA: float, pointB: MSPyBentleyGeom.DPoint3d, weightB: float) -> MSPyBentleyGeom.DPoint3d
        
        return the centroid for points with specified weights
        
        2. FromWeightedAverage(pointA: MSPyBentleyGeom.DPoint3d, weightA: float, pointB: MSPyBentleyGeom.DPoint3d, weightB: float, pointC: MSPyBentleyGeom.DPoint3d, weightC: float) -> MSPyBentleyGeom.DPoint3d
        
        return the centroid for points with specified weights
        """
        ...
    
    @staticmethod
    def FromZero() -> MSPyBentleyGeom.DPoint3d:
        """
        Return a DPoint3d with xyz = 0.
        """
        ...
    
    def GeometricMeanCrossProduct(self: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d) -> float:
        """
        @description Computes the cross product of two vectors and scales it
        to the geometric mean of the lengths of the two vectors. This is
        useful because it has the direction of the cross product (i.e. normal
        to the plane of the two vectors) and a size in between the two
        vectors.
        
        :param (input):
        point1 The first vector
        
        :param (input):
        point2 The second vector
        
        :returns:
        The length of original vector.
        """
        ...
    
    def GetComponent(self: MSPyBentleyGeom.DPoint3d, index: int) -> float:
        """
        @description Gets a single component of a point. If the index is out
        of range 0,1,2, it is interpreted cyclically.
        
        :param (input):
        index Indicates which component is accessed. The values are 0=x,
        1=y, 2=z. Other values are treated cyclically.
        
        :returns:
        The specified component of the point or vector.
        """
        ...
    
    def GetComponents(self: MSPyBentleyGeom.DPoint3d) -> Tuple[float, float, float]:
        ...
    
    def Init(*args, **kwargs):
        """
        Overloaded function.
        
        1. Init(self: MSPyBentleyGeom.DPoint3d, source: MSPyBentleyGeom.DPoint2d) -> None
        
        @description Copy from a 2d point setting z to zero.
        
        :param (input):
        source source point
        
        2. Init(self: MSPyBentleyGeom.DPoint3d, ax: float, ay: float, az: float) -> None
        
        @description Copy from a 2d point setting z to zero.
        
        :param (input):
        source source point
        
        3. Init(self: MSPyBentleyGeom.DPoint3d, ax: float, ay: float) -> None
        
        @description Copy from a 2d point setting z to zero.
        
        :param (input):
        source source point
        
        4. Init(self: MSPyBentleyGeom.DPoint3d, vector: DVec3d) -> None
        
        @description Copy from a 2d point setting z to zero.
        
        :param (input):
        source source point
        """
        ...
    
    def InitDisconnect(self: MSPyBentleyGeom.DPoint3d) -> None:
        """
        Initialize a point with all coordinates as the disconnect value.
        """
        ...
    
    def Interpolate(self: MSPyBentleyGeom.DPoint3d, point0: MSPyBentleyGeom.DPoint3d, fractionParameter: float, point1: MSPyBentleyGeom.DPoint3d) -> None:
        """
        @description Computes a point whose position is given by a fractional
        argument and two endpoints.
        
        :param (input):
        point0 The point corresponding to fractionParameter of 0.
        
        :param (input):
        fractionParameter The fractional parametric coordinate. 0.0 is the
        start of the segment, 1.0 is the end, 0.5 is midpoint.
        
        :param (input):
        point1 The point corresponding to fractionParameter of 1.
        """
        ...
    
    def IsDisconnect(self: MSPyBentleyGeom.DPoint3d) -> bool:
        """
        :returns:
        true if the point has coordinates which indicate it is a
        disconnect (separator) ponit.
        """
        ...
    
    def IsEqual(*args, **kwargs):
        """
        Overloaded function.
        
        1. IsEqual(self: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d) -> bool
        
        @description Test for exact equality between all components of two
        points or vectors.
        
        :param (input):
        point2 The second point or vector
        
        :returns:
        true if the points are identical.
        
        2. IsEqual(self: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d, tolerance: float) -> bool
        
        @description Test for exact equality between all components of two
        points or vectors.
        
        :param (input):
        point2 The second point or vector
        
        :returns:
        true if the points are identical.
        """
        ...
    
    def IsParallelTo(self: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d) -> bool:
        """
        @description Tests if two vectors are parallel.
        
        :param (input):
        point2 The second vector
        
        :returns:
        true if the vectors are parallel within default tolerance
        """
        ...
    
    def IsPerpendicularTo(self: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d) -> bool:
        """
        @description Tests if two vectors are perpendicular.
        
        :param (input):
        point2 The second vector
        
        :returns:
        true if vectors are perpendicular within default tolerance
        """
        ...
    
    def IsPointInCCWector(self: MSPyBentleyGeom.DPoint3d, origin: MSPyBentleyGeom.DPoint3d, target0: MSPyBentleyGeom.DPoint3d, target1: MSPyBentleyGeom.DPoint3d, upVector: DVec3d) -> bool:
        """
        @description Test if a point is within the counter-clockwise sector
        defined by an origin and two boundary points, with an up vector to
        determine which direction is counter clockwise.
        
        :param (input):
        origin The point to test.
        
        :param (input):
        target0 The first target point.
        
        :param (input):
        target1 The second target point.
        
        :param (input):
        upVector vector towards eye to resolve direction.
        
        :returns:
        true if the test point is within the angle.
        """
        ...
    
    def IsPointInSmallerSector(self: MSPyBentleyGeom.DPoint3d, origin: MSPyBentleyGeom.DPoint3d, target1: MSPyBentleyGeom.DPoint3d, target2: MSPyBentleyGeom.DPoint3d) -> bool:
        """
        @description Form vectors from the origin to the test point and the
        two boundary vectors. Test if the test vector is within the smaller
        angle between the other two vectors.
        
        :param (input):
        origin The point to test.
        
        :param (input):
        target1 The first target point.
        
        :param (input):
        target2 The second target point.
        
        :returns:
        true if the test point is within the angle.
        """
        ...
    
    def IsVectorInCCWSector(self: MSPyBentleyGeom.DPoint3d, point0: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d, upVector: MSPyBentleyGeom.DPoint3d) -> bool:
        """
        @description Test if the test vector vector is " between " point0 and
        point1, with CCW direction resolved by an up vector. The cross product
        of point0 and point1 is considered the positive plane normal if its
        dot product with the up vector is positive.
        
        :param (input):
        point0 The boundary vector.
        
        :param (input):
        point1 The boundary vector.
        
        :param (input):
        upVector The out of plane vector.
        
        :returns:
        true if test vector is within the angle.
        """
        ...
    
    def IsVectorInSmallerSector(self: MSPyBentleyGeom.DPoint3d, point0: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d) -> bool:
        """
        @description Test a vector is " between " point0 and point1. If the
        vectors are coplanar and point0 is neither parallel nor antiparallel
        to point1, betweenness has the expected meaning:there are two angles
        between point0 and point1; one is less than 180; the test vector is
        tested to see if it is in the smaller angle. If the vectors are not
        coplanar, the test is based on the projection of the test vector into
        the plane of the other two vectors.
        
        Zero testing is untoleranced, and is biased to all parallel conditions
        " false ". That is, if any pair of the input vectors is parallel or
        antiparallel, the mathematical answer is false. Floating point
        tolerances will cause " nearby " cases to be unpredictable. It is
        assumed that if the caller considers the " parallel " cases important
        they will be checked explicitly.
        
        :param (input):
        point0 The first boundary vector.
        
        :param (input):
        point1 The second boundary vector.
        
        :returns:
        true if the test vector is within the angle.
        """
        ...
    
    def Magnitude(self: MSPyBentleyGeom.DPoint3d) -> float:
        """
        @description Computes the magnitude of a vector.
        
        :returns:
        The length of the vector
        """
        ...
    
    def MagnitudeSquared(self: MSPyBentleyGeom.DPoint3d) -> float:
        """
        @description Computes the squared magnitude of a vector.
        
        :returns:
        The squared magnitude of the vector.
        """
        ...
    
    def MagnitudeSquaredXY(self: MSPyBentleyGeom.DPoint3d) -> float:
        """
        @description Computes the squared magnitude of the xy part of a
        vector.
        
        :returns:
        The squared magnitude of the xy parts of the given vector.
        """
        ...
    
    def MagnitudeXY(self: MSPyBentleyGeom.DPoint3d) -> float:
        """
        @description Computes the magnitude of the xy part of a vector.
        
        :returns:
        The magnitude of the xy parts of the given vector.
        """
        ...
    
    def MaxAbs(self: MSPyBentleyGeom.DPoint3d) -> float:
        """
        @description Finds the largest absolute value among the components of
        a point or vector.
        
        :returns:
        The largest absolute value among point coordinates.
        """
        ...
    
    def MaxAbsIndex(self: MSPyBentleyGeom.DPoint3d) -> int:
        """
        return in the index of the MaxAbs () value.
        """
        ...
    
    def MinAbs(self: MSPyBentleyGeom.DPoint3d) -> float:
        """
        @description Finds the smallest absolute value among the components of
        a point or vector.
        
        :returns:
        The smallest absolute value among point coordinates.
        """
        ...
    
    def MinAbsIndex(self: MSPyBentleyGeom.DPoint3d) -> int:
        """
        return in the index of the MinAbs () value
        """
        ...
    
    @staticmethod
    def MultiplyArrayByScales(*args, **kwargs):
        """
        Overloaded function.
        
        1. MultiplyArrayByScales(outPoints: MSPyBentleyGeom.DPoint3dArray, inPoints: MSPyBentleyGeom.DPoint3dArray, scales: MSPyBentleyGeom.DoubleArray) -> None
        
        @description Multiply each point in an array by its corresponding
        scale factor.
        
        :param (output):
        pDest destination array.
        
        :param (input):
        pSource source array.
        
        :param (input):
        pScales scale factors
        
        :param (input):
        n number of points.
        
        2. MultiplyArrayByScales(outPoints: list, inPoints: list, scales: MSPyBentleyGeom.DoubleArray) -> None
        
        @description Multiply each point in an array by its corresponding
        scale factor.
        
        :param (output):
        pDest destination array.
        
        :param (input):
        pSource source array.
        
        :param (input):
        pScales scale factors
        
        :param (input):
        n number of points.
        """
        ...
    
    def Negate(*args, **kwargs):
        """
        Overloaded function.
        
        1. Negate(self: MSPyBentleyGeom.DPoint3d, vector: MSPyBentleyGeom.DPoint3d) -> None
        
        @description Computes a negated (opposite) vector.
        
        :param (input):
        vector The vector to be negated.
        
        2. Negate(self: MSPyBentleyGeom.DPoint3d) -> None
        
        @description Computes a negated (opposite) vector.
        
        :param (input):
        vector The vector to be negated.
        """
        ...
    
    def Normalize(*args, **kwargs):
        """
        Overloaded function.
        
        1. Normalize(self: MSPyBentleyGeom.DPoint3d, vector: MSPyBentleyGeom.DPoint3d) -> float
        
        @description Normalizes (scales) a vector to length 1. If the input
        vector length is 0, the output vector is a zero vector and the
        returned length is 0.
        
        :param (input):
        vector The vector to be normalized.
        
        :returns:
        The length prior to normalization
        
        2. Normalize(self: MSPyBentleyGeom.DPoint3d) -> float
        
        @description Normalizes (scales) a vector to length 1. If the input
        vector length is 0, the output vector is a zero vector and the
        returned length is 0.
        
        :param (input):
        vector The vector to be normalized.
        
        :returns:
        The length prior to normalization
        """
        ...
    
    def NormalizedCrossProduct(self: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d) -> float:
        """
        @description Compute the normalized cross product of two vectors and
        return the length of the unnormalized cross product.
        
        :param (input):
        point1 The first vector
        
        :param (input):
        point2 The second vector
        
        :returns:
        The length of the original (prenormalization) cross product vector
        """
        ...
    
    def NormalizedDifference(self: MSPyBentleyGeom.DPoint3d, target: MSPyBentleyGeom.DPoint3d, origin: MSPyBentleyGeom.DPoint3d) -> float:
        """
        @description Computes a unit vector in the direction of the difference
        of the points or vectors (Second parameter vector is subtracted from
        the first parameter vector, exactly as in the subtract function.)
        
        :param (input):
        target The target point.
        
        :param (input):
        origin The origin point.
        
        :returns:
        The length of original difference vector.
        """
        ...
    
    def NpcCoordinatesOf(self: MSPyBentleyGeom.DPoint3d, point: MSPyBentleyGeom.DPoint3d, cube: DRange3d) -> None:
        """
        @description Computes the coordinates of point under the translation
        and scaling that puts 000 at cube>low and 111 at cube>high.
        
        :param (input):
        point Point whose NPC coordinates are to be computed
        
        :param (input):
        cube Cube whose corners map to 000 and 111
        """
        ...
    
    def One(self: MSPyBentleyGeom.DPoint3d) -> None:
        """
        @description Returns a point or vector with all components 1.0.
        """
        ...
    
    def PlanarAngleTo(self: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d, planeNormal: MSPyBentleyGeom.DPoint3d) -> float:
        """
        @description Computes the signed angle between the projection of two
        vectors onto a plane with given normal.
        
        :param (input):
        point2 The second vector
        
        :param (input):
        planeNormal The plane normal vector
        
        :returns:
        The angle in plane
        """
        ...
    
    def RotateXY(*args, **kwargs):
        """
        Overloaded function.
        
        1. RotateXY(self: MSPyBentleyGeom.DPoint3d, vector: MSPyBentleyGeom.DPoint3d, theta: float) -> None
        
        @description Rotate vector around the z axis, return as calling
        instance.
        
        :param (input):
        vector vector to rotate.
        
        :param (input):
        theta The rotation angle.
        
        2. RotateXY(self: MSPyBentleyGeom.DPoint3d, theta: float) -> None
        
        @description Rotate vector around the z axis, return as calling
        instance.
        
        :param (input):
        vector vector to rotate.
        
        :param (input):
        theta The rotation angle.
        """
        ...
    
    def SafeDivide(self: MSPyBentleyGeom.DPoint3d, vector: MSPyBentleyGeom.DPoint3d, denominator: float) -> bool:
        """
        @description Try to divide each component of a vector by a scalar. If
        the denominator near zero compared to any numerator component, return
        the original vector.
        
        :param (input):
        vector The initial vector.
        
        :param (input):
        denominator The divisor.
        
        :returns:
        true if division is numerically safe.
        """
        ...
    
    def Scale(*args, **kwargs):
        """
        Overloaded function.
        
        1. Scale(self: MSPyBentleyGeom.DPoint3d, vector: MSPyBentleyGeom.DPoint3d, scale: float) -> None
        
        @description Multiplies a vector by a scale factor.
        
        :param (input):
        vector The vector to be scaled.
        
        :param (input):
        scale The scale factor.
        
        2. Scale(self: MSPyBentleyGeom.DPoint3d, scale: float) -> None
        
        @description Multiplies a vector by a scale factor.
        
        :param (input):
        vector The vector to be scaled.
        
        :param (input):
        scale The scale factor.
        """
        ...
    
    def ScaleToLength(*args, **kwargs):
        """
        Overloaded function.
        
        1. ScaleToLength(self: MSPyBentleyGeom.DPoint3d, vector: MSPyBentleyGeom.DPoint3d, length: float) -> float
        
        @description Scales a vector to specified length. If the input vector
        length is 0, the output vector is a zero vector and the returned
        length is 0.
        
        :param (input):
        vector The original vector.
        
        :param (input):
        length The requested length.
        
        :returns:
        The length prior to scaling.
        
        2. ScaleToLength(self: MSPyBentleyGeom.DPoint3d, length: float) -> float
        
        @description Scales a vector to specified length. If the input vector
        length is 0, the output vector is a zero vector and the returned
        length is 0.
        
        :param (input):
        vector The original vector.
        
        :param (input):
        length The requested length.
        
        :returns:
        The length prior to scaling.
        """
        ...
    
    def SetComponent(self: MSPyBentleyGeom.DPoint3d, a: float, index: int) -> None:
        """
        @description Set one of three components (x,y,z) of the point.
        
        :param (input):
        a The component value.
        
        :param (input):
        index Selects the the axis:0=x, 1=y, 2=z, others cyclic.
        """
        ...
    
    def SignedAngleTo(self: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d, orientationVector: MSPyBentleyGeom.DPoint3d) -> float:
        """
        @description Computes the signed from one vector to another, in the
        plane of the two vectors. Initial computation using only the two
        vectors yields two possible angles depending on which side of the
        plane of the vectors is viewed. To choose which side to view, go on
        the side whose normal has a positive dot product with the orientation
        vector. This angle can be between -pi and +pi.
        
        :param (input):
        point2 The second vector
        
        :param (input):
        orientationVector The vector used to determine orientation.
        
        :returns:
        The signed angle
        """
        ...
    
    def SizedCrossProduct(self: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d, productLength: float) -> float:
        """
        @description Computes the cross product of the two parameter vectors
        and scales it to a given length. The scaled vector is stored as the
        product vector, and the length of the original cross product vector is
        returned.
        
        :param (input):
        point1 The first vector
        
        :param (input):
        point2 The second vector
        
        :param (input):
        productLength The Desired length
        
        :returns:
        The length of original vector.
        """
        ...
    
    def SmallerUnorientedAngleTo(self: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d) -> float:
        """
        @description Returns the angle between two vectors, choosing the
        smaller of the two possible angles when both the vectors and their
        negations are considered. This angle is between 0 and pi/2.
        
        :param (input):
        point2 The second vector
        
        :returns:
        The angle between the vectors.
        """
        ...
    
    def SmallerUnorientedAngleToXY(self: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d) -> float:
        """
        @description Returns the angle between two vectors, considering both
        the vectors and their negations and choosing the smaller. This angle
        is between 0 and pi/2.
        
        :param (input):
        point2 The second vector
        
        :returns:
        The angle between vectors.
        """
        ...
    
    def Subtract(*args, **kwargs):
        """
        Overloaded function.
        
        1. Subtract(self: MSPyBentleyGeom.DPoint3d, base: MSPyBentleyGeom.DPoint3d, vector: DVec3d) -> None
        
        @description Subtract a vector from a point.
        
        :param (input):
        base The the first point or vector
        
        :param (input):
        vector The second point or vector
        
        2. Subtract(self: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d) -> None
        
        @description Subtract a vector from a point.
        
        :param (input):
        base The the first point or vector
        
        :param (input):
        vector The second point or vector
        """
        ...
    
    def SumOf(*args, **kwargs):
        """
        Overloaded function.
        
        1. SumOf(self: MSPyBentleyGeom.DPoint3d, origin: MSPyBentleyGeom.DPoint3d, vector: DVec3d, scale: float) -> None
        
        @description Adds an origin and a scaled vector.
        
        :param (input):
        origin Origin for the sum.
        
        :param (input):
        vector The vector to be added.
        
        :param (input):
        scale The scale factor.
        
        2. SumOf(self: MSPyBentleyGeom.DPoint3d, origin: MSPyBentleyGeom.DPoint3d, point1: DVec3d, scale1: float, point2: DVec3d, scale2: float) -> None
        
        @description Adds an origin and a scaled vector.
        
        :param (input):
        origin Origin for the sum.
        
        :param (input):
        vector The vector to be added.
        
        :param (input):
        scale The scale factor.
        
        3. SumOf(self: MSPyBentleyGeom.DPoint3d, origin: MSPyBentleyGeom.DPoint3d, point1: DVec3d, scale1: float, point2: DVec3d, scale2: float, point3: DVec3d, scale3: float) -> None
        
        @description Adds an origin and a scaled vector.
        
        :param (input):
        origin Origin for the sum.
        
        :param (input):
        vector The vector to be added.
        
        :param (input):
        scale The scale factor.
        
        4. SumOf(self: MSPyBentleyGeom.DPoint3d, origin: MSPyBentleyGeom.DPoint3d, vector: MSPyBentleyGeom.DPoint3d, scale: float) -> None
        
        @description Adds an origin and a scaled vector.
        
        :param (input):
        origin Origin for the sum.
        
        :param (input):
        vector The vector to be added.
        
        :param (input):
        scale The scale factor.
        
        5. SumOf(self: MSPyBentleyGeom.DPoint3d, origin: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d, scale1: float, point2: MSPyBentleyGeom.DPoint3d, scale2: float) -> None
        
        @description Adds an origin and a scaled vector.
        
        :param (input):
        origin Origin for the sum.
        
        :param (input):
        vector The vector to be added.
        
        :param (input):
        scale The scale factor.
        
        6. SumOf(self: MSPyBentleyGeom.DPoint3d, origin: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d, scale1: float, point2: MSPyBentleyGeom.DPoint3d, scale2: float, point3: MSPyBentleyGeom.DPoint3d, scale3: float) -> None
        
        @description Adds an origin and a scaled vector.
        
        :param (input):
        origin Origin for the sum.
        
        :param (input):
        vector The vector to be added.
        
        :param (input):
        scale The scale factor.
        
        7. SumOf(self: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d, a1: float, point2: MSPyBentleyGeom.DPoint3d, a2: float) -> None
        
        @description Adds an origin and a scaled vector.
        
        :param (input):
        origin Origin for the sum.
        
        :param (input):
        vector The vector to be added.
        
        :param (input):
        scale The scale factor.
        
        8. SumOf(self: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d, a1: float, point2: MSPyBentleyGeom.DPoint3d, a2: float, point3: MSPyBentleyGeom.DPoint3d, a3: float) -> None
        
        @description Adds an origin and a scaled vector.
        
        :param (input):
        origin Origin for the sum.
        
        :param (input):
        vector The vector to be added.
        
        :param (input):
        scale The scale factor.
        
        9. SumOf(self: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d) -> None
        
        @description Adds an origin and a scaled vector.
        
        :param (input):
        origin Origin for the sum.
        
        :param (input):
        vector The vector to be added.
        
        :param (input):
        scale The scale factor.
        """
        ...
    
    def Swap(self: MSPyBentleyGeom.DPoint3d, other: MSPyBentleyGeom.DPoint3d) -> None:
        """
        Swap contents of instance, other.
        
        :param [in,out]:
        other second point.
        """
        ...
    
    def TripleProduct(self: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d, point3: MSPyBentleyGeom.DPoint3d) -> float:
        """
        @description Computes the triple product of three vectors. The
        following are equivalent definitions of the triple product of three
        vectors V1, V2, and V3:
        
        <UL> <LI> (V1 cross V2) dot V3 <LI> V1 dot (V2 cross V3) <LI>The
        determinant of the 3x3 matrix with the three vectors as its columns.
        <LI>The determinant of the 3x3 matrix with the three vectors as its
        rows. <LI>The (signed)volume of the parallelepiped whose 4 vertices
        are at the origin and at the ends of the 3 vectors placed at the
        origin. </UL>
        
        :param (input):
        point2 The second vector.
        
        :param (input):
        point3 The third vector.
        
        :returns:
        The triple product
        """
        ...
    
    def TripleProductToPoints(self: MSPyBentleyGeom.DPoint3d, target1: MSPyBentleyGeom.DPoint3d, target2: MSPyBentleyGeom.DPoint3d, target3: MSPyBentleyGeom.DPoint3d) -> float:
        """
        @description Computes the triple product of vectors from a base point
        three target points.
        
        :param (input):
        target1 The target point for the first vector.
        
        :param (input):
        target2 The target point for the second vector.
        
        :param (input):
        target3 The target point for the third vector.
        
        :returns:
        The triple product
        """
        ...
    
    def UnitPerpendicularXY(self: MSPyBentleyGeom.DPoint3d, vector: MSPyBentleyGeom.DPoint3d) -> bool:
        """
        @description Compute a unit vector perpendicular to the xy parts of
        given vector.
        
        :param (input):
        vector The source vector
        
        :returns:
        true if the input vector has nonzero length
        """
        ...
    
    def WeightedDifferenceCrossProduct(self: MSPyBentleyGeom.DPoint3d, basePoint: DPoint4d, target1: DPoint4d, target2: DPoint4d) -> None:
        """
        @description Form the cross product of the weighted differences from
        point0 to point1 and point2.
        
        :param (input):
        basePoint The common base point (second point for differences)
        
        :param (input):
        target1 The first target point.
        
        :param (input):
        target2 The second target point.
        """
        ...
    
    def WeightedDifferenceOf(self: MSPyBentleyGeom.DPoint3d, point1: DPoint4d, point2: DPoint4d) -> None:
        """
        @description Scale each point by the other's weight and subtract, i.e.
        form (point1 * point2.w - point2 * point1.w). The weight term
        vanishes. Copy the xyz parts back as a vector.
        
        :param (input):
        point1 The first point
        
        :param (input):
        point2 The second pont.
        """
        ...
    
    @property
    def X(self: MSPyBentleyGeom.DPoint3d) -> float:
        ...
    @X.setter
    def X(self: MSPyBentleyGeom.DPoint3d, arg0: float) -> None:
        ...
    
    def XyzOf(self: MSPyBentleyGeom.DPoint3d, hPoint: DPoint4d) -> None:
        """
        @description Sets the x,y, and z components of a DPoint3d structure
        from the corresponding parts of a DPoint4d. Weight part of DPoint4d is
        not used.
        
        :param (input):
        hPoint The homogeneous point
        """
        ...
    
    @property
    def Y(self: MSPyBentleyGeom.DPoint3d) -> float:
        ...
    @Y.setter
    def Y(self: MSPyBentleyGeom.DPoint3d, arg0: float) -> None:
        ...
    
    @property
    def Z(self: MSPyBentleyGeom.DPoint3d) -> float:
        ...
    @Z.setter
    def Z(self: MSPyBentleyGeom.DPoint3d, arg0: float) -> None:
        ...
    
    def Zero(self: MSPyBentleyGeom.DPoint3d) -> None:
        """
        @description Sets all components of a point or vector to zero.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DPoint3d, vector: DVec3d) -> None
        
        2. __init__(self: MSPyBentleyGeom.DPoint3d) -> None
        
        3. __init__(self: MSPyBentleyGeom.DPoint3d, x: float, y: float, z: float = 0.0) -> None
        
        4. __init__(self: MSPyBentleyGeom.DPoint3d, xy: MSPyBentleyGeom.DPoint2d) -> None
        """
        ...
    
    @property
    def x(self: MSPyBentleyGeom.DPoint3d) -> float:
        ...
    @x.setter
    def x(self: MSPyBentleyGeom.DPoint3d, arg0: float) -> None:
        ...
    
    @property
    def y(self: MSPyBentleyGeom.DPoint3d) -> float:
        ...
    @y.setter
    def y(self: MSPyBentleyGeom.DPoint3d, arg0: float) -> None:
        ...
    
    @property
    def z(self: MSPyBentleyGeom.DPoint3d) -> float:
        ...
    @z.setter
    def z(self: MSPyBentleyGeom.DPoint3d, arg0: float) -> None:
        ...
    
class DPoint3dArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DPoint3dArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.DPoint3dArray, arg0: MSPyBentleyGeom.DPoint3dArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.DPoint3dArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.DPoint3dArray, x: MSPyBentleyGeom.DPoint3d) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.DPoint3dArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def count(self: MSPyBentleyGeom.DPoint3dArray, x: MSPyBentleyGeom.DPoint3d) -> int:
        """
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.DPoint3dArray, L: MSPyBentleyGeom.DPoint3dArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.DPoint3dArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.DPoint3dArray, i: int, x: MSPyBentleyGeom.DPoint3d) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.DPoint3dArray) -> MSPyBentleyGeom.DPoint3d
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.DPoint3dArray, i: int) -> MSPyBentleyGeom.DPoint3d
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(self: MSPyBentleyGeom.DPoint3dArray, x: MSPyBentleyGeom.DPoint3d) -> None:
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class DPoint3dOps:
    """
    None
    """

    @staticmethod
    def Add(xyz: MSPyBentleyGeom.DPoint3dArray, delta: MSPyBentleyGeom.DVec3d) -> None:
        ...
    
    def __init__(*args, **kwargs):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    
class DPoint3dSizeSize:
    """
    None
    """

    def Get(self: MSPyBentleyGeom.DPoint3dSizeSize) -> MSPyBentleyGeom.DPoint3d:
        ...
    
    def GetCR(self: MSPyBentleyGeom.DPoint3dSizeSize) -> MSPyBentleyGeom.DPoint3d:
        ...
    
    def GetTag(self: MSPyBentleyGeom.DPoint3dSizeSize, tagA: bool) -> int:
        ...
    
    def GetTagA(self: MSPyBentleyGeom.DPoint3dSizeSize) -> int:
        ...
    
    def GetTagB(self: MSPyBentleyGeom.DPoint3dSizeSize) -> int:
        ...
    
    def Set(self: MSPyBentleyGeom.DPoint3dSizeSize, value: MSPyBentleyGeom.DPoint3d) -> None:
        ...
    
    def SetTagA(self: MSPyBentleyGeom.DPoint3dSizeSize, tag: int) -> None:
        ...
    
    def SetTagB(self: MSPyBentleyGeom.DPoint3dSizeSize, tag: int) -> None:
        ...
    
    def SwapTags(self: MSPyBentleyGeom.DPoint3dSizeSize) -> None:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DPoint3dSizeSize) -> None
        
        2. __init__(self: MSPyBentleyGeom.DPoint3dSizeSize, value: MSPyBentleyGeom.DPoint3d, tagA: int, tagB: int) -> None
        """
        ...
    
class DPoint3dVecArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DPoint3dVecArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.DPoint3dVecArray, arg0: MSPyBentleyGeom.DPoint3dVecArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.DPoint3dVecArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.DPoint3dVecArray, x: MSPyBentleyGeom.DPoint3dArray) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.DPoint3dVecArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def count(self: MSPyBentleyGeom.DPoint3dVecArray, x: MSPyBentleyGeom.DPoint3dArray) -> int:
        """
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.DPoint3dVecArray, L: MSPyBentleyGeom.DPoint3dVecArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.DPoint3dVecArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.DPoint3dVecArray, i: int, x: MSPyBentleyGeom.DPoint3dArray) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.DPoint3dVecArray) -> MSPyBentleyGeom.DPoint3dArray
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.DPoint3dVecArray, i: int) -> MSPyBentleyGeom.DPoint3dArray
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(self: MSPyBentleyGeom.DPoint3dVecArray, x: MSPyBentleyGeom.DPoint3dArray) -> None:
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class DPoint3dVecVecArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DPoint3dVecVecArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.DPoint3dVecVecArray, arg0: MSPyBentleyGeom.DPoint3dVecVecArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.DPoint3dVecVecArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.DPoint3dVecVecArray, x: MSPyBentleyGeom.DPoint3dVecArray) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.DPoint3dVecVecArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def count(self: MSPyBentleyGeom.DPoint3dVecVecArray, x: MSPyBentleyGeom.DPoint3dVecArray) -> int:
        """
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.DPoint3dVecVecArray, L: MSPyBentleyGeom.DPoint3dVecVecArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.DPoint3dVecVecArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.DPoint3dVecVecArray, i: int, x: MSPyBentleyGeom.DPoint3dVecArray) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.DPoint3dVecVecArray) -> MSPyBentleyGeom.DPoint3dVecArray
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.DPoint3dVecVecArray, i: int) -> MSPyBentleyGeom.DPoint3dVecArray
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(self: MSPyBentleyGeom.DPoint3dVecVecArray, x: MSPyBentleyGeom.DPoint3dVecArray) -> None:
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class DPoint4d:
    """
    None
    """

    def Add(self: MSPyBentleyGeom.DPoint4d, vector: MSPyBentleyGeom.DPoint4d) -> None:
        """
        Add a vector to the instance.
        
        :param (input):
        vector vector to add
        """
        ...
    
    @staticmethod
    def AlmostEqual(dataA: MSPyBentleyGeom.DPoint4dArray, dataB: MSPyBentleyGeom.DPoint4dArray, xyzTol: float, wTol: float) -> bool:
        """
        test for nearly equal points in two arrays
        """
        ...
    
    @staticmethod
    def AlmostEqualReversed(dataA: MSPyBentleyGeom.DPoint4dArray, dataB: MSPyBentleyGeom.DPoint4dArray, xyzTol: float, wTol: float) -> bool:
        """
        test for nearly equal points in two arrays, reversing the second
        """
        ...
    
    def DifferenceOf(self: MSPyBentleyGeom.DPoint4d, point1: MSPyBentleyGeom.DPoint4d, point2: MSPyBentleyGeom.DPoint4d) -> None:
        """
        Subtract second point from first.
        
        :param (input):
        point1 first point
        
        :param (input):
        point2 second point
        """
        ...
    
    def DotProduct(*args, **kwargs):
        """
        Overloaded function.
        
        1. DotProduct(self: MSPyBentleyGeom.DPoint4d, point: MSPyBentleyGeom.DPoint4d) -> float
        
        Return the full 4d (xyzw) dot product of two homogeneous points.
        
        :param (input):
        point second point of dot product.
        
        :returns:
        dot product of two homogeneous points.
        
        2. DotProduct(self: MSPyBentleyGeom.DPoint4d, x: float, y: float, z: float, w: float) -> float
        
        Return the full 4d (xyzw) dot product of two homogeneous points.
        
        :param (input):
        point second point of dot product.
        
        :returns:
        dot product of two homogeneous points.
        
        3. DotProduct(self: MSPyBentleyGeom.DPoint4d, point2: MSPyBentleyGeom.DPoint3d, w: float) -> float
        
        Return the full 4d (xyzw) dot product of two homogeneous points.
        
        :param (input):
        point second point of dot product.
        
        :returns:
        dot product of two homogeneous points.
        """
        ...
    
    def DotProductXY(self: MSPyBentleyGeom.DPoint4d, point: MSPyBentleyGeom.DPoint4d) -> float:
        """
        Return the dot product of only the xy parts of two homogeneous points.
        Ignore z, ignore w.
        
        :param (input):
        point second point
        
        :returns:
        dot product of two homogeneous points.
        """
        ...
    
    def DotProductXYW(self: MSPyBentleyGeom.DPoint4d, point: MSPyBentleyGeom.DPoint4d) -> float:
        """
        Return the xyz dot product of two homogeneous points, i.e. ignore z.
        
        :param (input):
        point second second
        
        :returns:
        dot product of two homogeneous points.
        """
        ...
    
    def DotProductXYZ(self: MSPyBentleyGeom.DPoint4d, point: MSPyBentleyGeom.DPoint4d) -> float:
        """
        Return the xyz dot product of two homogeneous points, i.e. ignore w.
        
        :param (input):
        point2 second point of dot product.
        
        :returns:
        dot product of two homogeneous points.
        """
        ...
    
    def EyePlaneTest(self: MSPyBentleyGeom.DPoint4d, origin: MSPyBentleyGeom.DPoint3d, normal: MSPyBentleyGeom.DPoint3d) -> float:
        """
        Return the dot product of a plane normal and a vector 'to the
        eyepoint'. The plane is given as cartesian origin and normal; the eye
        is given as homogeneous point, i.e. weight zero for flat view, nonzero
        for perspective. Eyepoints constucted 'by hand' usually look like
        this:Flat view " from infinity " looking in direction (xyz):eyepoint =
        (x,y,z,0) i.e. a top view has eyepoint (0,0,1,0) Perspective from
        eyepoint at (x,y,z):eyepoint (x,y,z,1) When viewing is constructed by
        a sequence of homogeneous transformations, with the final (device)
        projection to the xy plane, the (pretransform) eyepoint is 'by
        definition' Tinverse * (0,0,1,0)' i.e column 2 (zero based) of the
        composite viewing transform. (Note that the weight part can be
        nonzero.)
        
        :param (input):
        origin any cartesian point on plane
        
        :param (input):
        normal cartesian plane normal
        
        :returns:
        dot product of plane normal with vector towards eye.
        """
        ...
    
    @staticmethod
    def From(*args, **kwargs):
        """
        Overloaded function.
        
        1. From(x: float, y: float, z: float, w: float) -> MSPyBentleyGeom.DPoint4d
        
        Return point with direct initialization
        
        :param (input):
        x x coordinate
        
        :param (input):
        y y coordinate
        
        :param (input):
        z z coordinate
        
        :param (input):
        w w coordinate
        
        2. From(xyz: MSPyBentleyGeom.DPoint3d, w: float) -> MSPyBentleyGeom.DPoint4d
        
        Return point with direct initialization
        
        :param (input):
        x x coordinate
        
        :param (input):
        y y coordinate
        
        :param (input):
        z z coordinate
        
        :param (input):
        w w coordinate
        """
        ...
    
    @staticmethod
    def FromCrossProduct(pointA: MSPyBentleyGeom.DPoint4d, pointB: MSPyBentleyGeom.DPoint4d, pointC: MSPyBentleyGeom.DPoint4d) -> MSPyBentleyGeom.DPoint4d:
        """
        Return a point " perpendicular " to all 3 inputs.
        """
        ...
    
    @staticmethod
    def FromInterpolate(point0: MSPyBentleyGeom.DPoint4d, s: float, point1: MSPyBentleyGeom.DPoint4d) -> MSPyBentleyGeom.DPoint4d:
        """
        Interpolates between two homogeneous vectors. |
        
        :param (input):
        point0 s=0 point
        
        :param (input):
        s interpolation parameter
        
        :param (input):
        point1 s=1 point
        
        :returns:
        interpolated point
        """
        ...
    
    @staticmethod
    def FromMultiply(*args, **kwargs):
        """
        Overloaded function.
        
        1. FromMultiply(matrix: MSPyBentleyGeom.DMatrix4d, point: MSPyBentleyGeom.DPoint3d) -> MSPyBentleyGeom.DPoint4d
        
        Return product of 3d point with (possibly omitted) DMatrix4d
        
        :param (input):
        matrix if missing, identity matrix is implied.
        
        :param (input):
        point 3d point.
        
        2. FromMultiply(matrix: MSPyBentleyGeom.DMatrix4d, point: MSPyBentleyGeom.DPoint4d) -> MSPyBentleyGeom.DPoint4d
        
        Return product of 3d point with (possibly omitted) DMatrix4d
        
        :param (input):
        matrix if missing, identity matrix is implied.
        
        :param (input):
        point 3d point.
        """
        ...
    
    @staticmethod
    def FromSumOf(xyzw0: MSPyBentleyGeom.DPoint4d, scale0: float, xyzw1: MSPyBentleyGeom.DPoint4d, scale1: float, xyzw2: MSPyBentleyGeom.DPoint4d, scale2: float) -> MSPyBentleyGeom.DPoint4d:
        """
        Return point with sum of scaled inputs
        """
        ...
    
    def GetComponent(self: MSPyBentleyGeom.DPoint4d, index: int) -> float:
        """
        :param (input):
        index 0=x, 1=y, 2=z, 3=w, others cyclic
        
        :returns:
        specified component of the point or vector
        """
        ...
    
    def GetComponents(self: MSPyBentleyGeom.DPoint4d) -> tuple:
        """
        Copies component data out of this instance into doubles pXCoord,
        pYCoord, pZCoord and pWCoord.
        
        :param (output):
        xCoord x component
        
        :param (output):
        yCoord y component
        
        :param (output):
        zCoord z component
        
        :param (output):
        wCoord w component
        """
        ...
    
    def GetProjectedXYZ(self: MSPyBentleyGeom.DPoint4d, rPoint: MSPyBentleyGeom.DPoint3d) -> bool:
        """
        Normalizes a homogeneous point (by dividing by w part.)
        
        :param (output):
        rPoint normalized point
        
        :returns:
        true if normalization succeeded
        """
        ...
    
    def GetRotationAngleAndVectorFromQuaternion(self: MSPyBentleyGeom.DPoint4d, axis: MSPyBentleyGeom.DPoint3d) -> float:
        """
        Returns the angle of rotation represented by this instance quaternion
        and sets axis to be the normalized vector about which this instance
        rotates. The instance is assumed to be a normalized quaternion, i.e.
        of the form (x,y,z,w) where
        
        x*x + y*y + z*z + w*w = 1.
        
        The angle is returned within the closed interval [0,Pi].
        
        :param (output):
        axis normalized axis of rotation
        
        :returns:
        rotation angle (in radians) between 0 and Pi, inclusive
        """
        ...
    
    def GetXYW(self: MSPyBentleyGeom.DPoint4d, point: MSPyBentleyGeom.DPoint3d) -> None:
        """
        Copy the xyw components out of a homogeneous point. The z component
        not referenced. This is a copy, not a normalization.
        
        :param (output):
        point xyw parts copied to xyz
        """
        ...
    
    def GetXYZ(*args, **kwargs):
        """
        Overloaded function.
        
        1. GetXYZ(self: MSPyBentleyGeom.DPoint4d, point: MSPyBentleyGeom.DPoint3d) -> None
        
        Copy the xyz components out of a homogeneous point. The weight is not
        referenced, i.e. the xyz components are NOT normalized.
        
        :param (output):
        point cartesian point
        
        2. GetXYZ(self: MSPyBentleyGeom.DPoint4d, point: MSPyBentleyGeom.DPoint3d, xIndex: int, yIndex: int, zIndex: int) -> None
        
        Copy the xyz components out of a homogeneous point. The weight is not
        referenced, i.e. the xyz components are NOT normalized.
        
        :param (output):
        point cartesian point
        """
        ...
    
    def Init(*args, **kwargs):
        """
        Overloaded function.
        
        1. Init(self: MSPyBentleyGeom.DPoint4d, source: MSPyBentleyGeom.DPoint3d, w: float) -> None
        
        Fill a DPoint4d, using given xyz components and weight. All components
        are copied in directly -- the xyz components are not multiplied by the
        weight.
        
        :param (input):
        source xyz components
        
        :param (input):
        w w component
        
        2. Init(self: MSPyBentleyGeom.DPoint4d, x: float, y: float, z: float, w: float) -> None
        
        Fill a DPoint4d, using given xyz components and weight. All components
        are copied in directly -- the xyz components are not multiplied by the
        weight.
        
        :param (input):
        source xyz components
        
        :param (input):
        w w component
        """
        ...
    
    def InitDisconnect(self: MSPyBentleyGeom.DPoint4d) -> None:
        """
        Initialize a point with all coordinates as the disconnect value.
        """
        ...
    
    def InitFrom(self: MSPyBentleyGeom.DPoint4d, point: MSPyBentleyGeom.DPoint3d, w: float) -> None:
        """
        Initializ a homogeneous point from a 3D point and separate weight.
        NOTE The xyz components copied unchanged, i.e. not multiplied by the
        weight.
        
        :param (input):
        point cartesian point
        
        :param (input):
        w weight component
        """
        ...
    
    def InitWithNormalizedWeight(self: MSPyBentleyGeom.DPoint4d, source: MSPyBentleyGeom.DPoint4d) -> bool:
        """
        Initializes the instance by normalizing the weight of the source.
        
        :returns:
        true if normalization succeeded
        """
        ...
    
    def Interpolate(self: MSPyBentleyGeom.DPoint4d, point0: MSPyBentleyGeom.DPoint4d, s: float, point1: MSPyBentleyGeom.DPoint4d) -> None:
        """
        Interpolates between two homogeneous vectors. |
        
        :param (input):
        point0 s=0 point
        
        :param (input):
        s interpolation parameter
        
        :param (input):
        point1 s=1 point
        """
        ...
    
    def IsDisconnect(self: MSPyBentleyGeom.DPoint4d) -> bool:
        """
        :returns:
        true if the point has coordinates which indicate it is a
        disconnect (separator) ponit.
        """
        ...
    
    def IsEqual(*args, **kwargs):
        """
        Overloaded function.
        
        1. IsEqual(self: MSPyBentleyGeom.DPoint4d, vec2: MSPyBentleyGeom.DPoint4d) -> bool
        
        Exact equality test between points. (Also see method with same name
        but added tolerance argument.)
        
        :param (input):
        vec2 vector
        
        :returns:
        true if the points are identical. (DPoint4dCR, double)
        
        2. IsEqual(self: MSPyBentleyGeom.DPoint4d, vec2: MSPyBentleyGeom.DPoint4d, tolerance: float) -> bool
        
        Exact equality test between points. (Also see method with same name
        but added tolerance argument.)
        
        :param (input):
        vec2 vector
        
        :returns:
        true if the points are identical. (DPoint4dCR, double)
        
        3. IsEqual(self: MSPyBentleyGeom.DPoint4d, vec2: MSPyBentleyGeom.DPoint4d, xyzTol: float, wTol: float) -> bool
        
        Exact equality test between points. (Also see method with same name
        but added tolerance argument.)
        
        :param (input):
        vec2 vector
        
        :returns:
        true if the points are identical. (DPoint4dCR, double)
        """
        ...
    
    def MagnitudeXYZW(self: MSPyBentleyGeom.DPoint4d) -> float:
        """
        magnitude as pure 4d point -- sqrt sum of squares.
        """
        ...
    
    def MaxAbs(self: MSPyBentleyGeom.DPoint4d) -> float:
        """
        :returns:
        largest absoluted value among point coordinates.
        """
        ...
    
    def MaxAbsUnnormalizedXYZ(self: MSPyBentleyGeom.DPoint4d) -> float:
        """
        :returns:
        largest absoluted value among xyz coordinates, ignoring weight.
        """
        ...
    
    def MaxUnnormalizedXYZDiff(self: MSPyBentleyGeom.DPoint4d, other: MSPyBentleyGeom.DPoint4d) -> float:
        """
        :returns:
        largest absoluted value among xyz coordinates coordinates,
        ignoring weight.
        """
        ...
    
    def Negate(*args, **kwargs):
        """
        Overloaded function.
        
        1. Negate(self: MSPyBentleyGeom.DPoint4d, point: MSPyBentleyGeom.DPoint4d) -> None
        
        Negate a point.
        
        :param (input):
        point input point
        
        2. Negate(self: MSPyBentleyGeom.DPoint4d) -> None
        
        Negate a point.
        
        :param (input):
        point input point
        """
        ...
    
    def NormalizePlaneOf(self: MSPyBentleyGeom.DPoint4d, plane0: MSPyBentleyGeom.DPoint4d) -> bool:
        """
        Normalizes a homogeneous plane (by dividing through by the vector
        magnitude).
        
        :param (input):
        plane0 homogeneous plane
        
        :returns:
        true unless normal is zero vector.
        """
        ...
    
    def NormalizeWeightInPlace(self: MSPyBentleyGeom.DPoint4d) -> bool:
        """
        Divide through by weight component.
        
        :returns:
        true if normalization succeeded
        """
        ...
    
    def OriginAndNormalFromPlane(self: MSPyBentleyGeom.DPoint4d, origin: MSPyBentleyGeom.DPoint3d, normal: MSPyBentleyGeom.DPoint3d) -> bool:
        """
        :param (output):
        origin cartesian orign
        
        :param (output):
        normal cartesian normal
        
        :returns:
        true if
        """
        ...
    
    def PlaneFrom3Points(self: MSPyBentleyGeom.DPoint4d, origin: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d) -> bool:
        """
        Computes the homogeneous coordinate vector for a plane defined by 3 3D
        points.
        
        :param (output):
        origin origin point
        
        :param (output):
        point1 another point on plane
        
        :param (output):
        point2 another point on plane
        
        :returns:
        true if normal is well defined.
        """
        ...
    
    def PlaneFromOriginAndNormal(self: MSPyBentleyGeom.DPoint4d, origin: MSPyBentleyGeom.DPoint3d, normal: MSPyBentleyGeom.DPoint3d) -> bool:
        """
        Computes the homogeneous vector for a plane defined by 3D origin and
        normal. NOTE If the normal vector is null, a 0000 vector is returned.
        
        :param (output):
        origin origin point
        
        :param (output):
        normal normal vector
        
        :returns:
        true unless normal is null
        """
        ...
    
    def PlaneFromOriginAndVectors(self: MSPyBentleyGeom.DPoint4d, origin: MSPyBentleyGeom.DPoint4d, vector0: MSPyBentleyGeom.DPoint3d, vector1: MSPyBentleyGeom.DPoint3d) -> bool:
        """
        Computes the homogeneous coordinate vector for a plane defined by a
        DPoint4d origin and a pair of 3D vectors.
        
        :param (output):
        origin a point on the plane.
        
        :param (output):
        vector0 a vector in the plane.
        
        :param (output):
        vector1 another vector in the plane.
        
        :returns:
        false if origin, vectors are not independent.
        """
        ...
    
    def RealDistance(self: MSPyBentleyGeom.DPoint4d, vec2: MSPyBentleyGeom.DPoint4d) -> float:
        """
        :param (input):
        vec2 second point
        
        :returns:
        distance between projections of two homnogeneous points.
        """
        ...
    
    def RealDistanceSquared(*args, **kwargs):
        """
        Overloaded function.
        
        1. RealDistanceSquared(self: MSPyBentleyGeom.DPoint4d, vec2: MSPyBentleyGeom.DPoint3d) -> tuple
        
        :param (output):
        pDistanceSquared squared distance
        
        :param (input):
        vec2 second point
        
        :returns:
        true iff the homogeneous point was properly normalized.
        
        2. RealDistanceSquared(self: MSPyBentleyGeom.DPoint4d, vec2: MSPyBentleyGeom.DPoint4d) -> tuple
        
        :param (output):
        pDistanceSquared squared distance
        
        :param (input):
        vec2 second point
        
        :returns:
        true iff the homogeneous point was properly normalized.
        """
        ...
    
    def RealDistanceSquaredXY(self: MSPyBentleyGeom.DPoint4d, vec2: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        :param (output):
        pDistanceSquared squared distance
        
        :param (input):
        vec2 second point
        
        :returns:
        true iff the homogeneous point was properly normalized.
        """
        ...
    
    def RealDistanceXY(self: MSPyBentleyGeom.DPoint4d, vec2: MSPyBentleyGeom.DPoint4d) -> tuple:
        """
        :param (output):
        distance distance between xy parts
        
        :param (input):
        pointB other point.
        
        :returns:
        true iff the homogeneous points could be normalized
        """
        ...
    
    def Scale(*args, **kwargs):
        """
        Overloaded function.
        
        1. Scale(self: MSPyBentleyGeom.DPoint4d, point: MSPyBentleyGeom.DPoint4d, scale: float) -> None
        
        sets pOutVec to pInVec*scale.
        
        :param (input):
        point input vector
        
        :param (input):
        scale scale
        
        2. Scale(self: MSPyBentleyGeom.DPoint4d, scale: float) -> None
        
        sets pOutVec to pInVec*scale.
        
        :param (input):
        point input vector
        
        :param (input):
        scale scale
        """
        ...
    
    def SetComponent(self: MSPyBentleyGeom.DPoint4d, a: float, index: int) -> None:
        """
        Set x,y,z or w component of a point.
        
        :param (input):
        a component value
        
        :param (input):
        index 0=x, 1=y, 2=z, 3=w, others cyclic
        """
        ...
    
    def SetComponents(self: MSPyBentleyGeom.DPoint4d, xComponent: float, yComponent: float, zComponent: float, wComponent: float) -> None:
        """
        :param (input):
        xComponent x component
        
        :param (input):
        yComponent y component
        
        :param (input):
        zComponent z component
        
        :param (input):
        wComponent w component
        """
        ...
    
    def Subtract(self: MSPyBentleyGeom.DPoint4d, vector: MSPyBentleyGeom.DPoint4d) -> None:
        """
        Subtract a vector from the instance.
        
        :param (input):
        vector vector to subtract
        """
        ...
    
    def SumOf(*args, **kwargs):
        """
        Overloaded function.
        
        1. SumOf(self: MSPyBentleyGeom.DPoint4d, pt1: MSPyBentleyGeom.DPoint4d, pt2: MSPyBentleyGeom.DPoint4d) -> None
        
        Adds two homogeneous points.
        
        :param (input):
        pt1 point 1
        
        :param (input):
        pt2 point 2
        
        2. SumOf(self: MSPyBentleyGeom.DPoint4d, point0: MSPyBentleyGeom.DPoint4d, point1: MSPyBentleyGeom.DPoint4d, scale1: float) -> None
        
        Adds two homogeneous points.
        
        :param (input):
        pt1 point 1
        
        :param (input):
        pt2 point 2
        
        3. SumOf(self: MSPyBentleyGeom.DPoint4d, point0: MSPyBentleyGeom.DPoint4d, point1: MSPyBentleyGeom.DPoint4d, scale1: float, point2: MSPyBentleyGeom.DPoint4d, scale2: float) -> None
        
        Adds two homogeneous points.
        
        :param (input):
        pt1 point 1
        
        :param (input):
        pt2 point 2
        
        4. SumOf(self: MSPyBentleyGeom.DPoint4d, point0: MSPyBentleyGeom.DPoint4d, point1: MSPyBentleyGeom.DPoint4d, scale1: float, point2: MSPyBentleyGeom.DPoint4d, scale2: float, point3: MSPyBentleyGeom.DPoint4d, scale3: float) -> None
        
        Adds two homogeneous points.
        
        :param (input):
        pt1 point 1
        
        :param (input):
        pt2 point 2
        
        5. SumOf(self: MSPyBentleyGeom.DPoint4d, point1: MSPyBentleyGeom.DPoint4d, scale1: float, point2: MSPyBentleyGeom.DPoint4d, scale2: float) -> None
        
        Adds two homogeneous points.
        
        :param (input):
        pt1 point 1
        
        :param (input):
        pt2 point 2
        
        6. SumOf(self: MSPyBentleyGeom.DPoint4d, point1: MSPyBentleyGeom.DPoint4d, scale1: float, point2: MSPyBentleyGeom.DPoint4d, scale2: float, point3: MSPyBentleyGeom.DPoint4d, scale3: float) -> None
        
        Adds two homogeneous points.
        
        :param (input):
        pt1 point 1
        
        :param (input):
        pt2 point 2
        """
        ...
    
    @staticmethod
    def TryNormalizePointAndDerivatives(homogeneousPoint: MSPyBentleyGeom.DPoint4d, homogeneousDerivative1: MSPyBentleyGeom.DPoint4d, homogeneousDerivative2: MSPyBentleyGeom.DPoint4d) -> ValidatedValue<DPlane3dByVectors:
        """
        Return point and vectors that are the cartesian image of a homoegneous
        point and derivatives ul> li>The return is marked invalid if weight is
        zero. ul>
        
        :returns:
        origin and vectors after normalization.
        """
        ...
    
    @property
    def W(self: MSPyBentleyGeom.DPoint4d) -> float:
        ...
    @W.setter
    def W(self: MSPyBentleyGeom.DPoint4d, arg0: float) -> None:
        ...
    
    def WeightedDifferenceOf(*args, **kwargs):
        """
        Overloaded function.
        
        1. WeightedDifferenceOf(self: MSPyBentleyGeom.DPoint4d, A: MSPyBentleyGeom.DPoint4d, B: MSPyBentleyGeom.DPoint4d) -> None
        
        Scale each point by the other's weight and return the difference
        
        2. WeightedDifferenceOf(self: MSPyBentleyGeom.DPoint4d, A: MSPyBentleyGeom.DPoint4d, B: MSPyBentleyGeom.DPoint3d, wB: float) -> None
        
        Scale each point by the other's weight and return the difference
        
        3. WeightedDifferenceOf(self: MSPyBentleyGeom.DPoint4d, A: MSPyBentleyGeom.DPoint3d, wA: float, B: MSPyBentleyGeom.DPoint4d) -> None
        
        Scale each point by the other's weight and return the difference
        """
        ...
    
    @property
    def X(self: MSPyBentleyGeom.DPoint4d) -> float:
        ...
    @X.setter
    def X(self: MSPyBentleyGeom.DPoint4d, arg0: float) -> None:
        ...
    
    @property
    def Y(self: MSPyBentleyGeom.DPoint4d) -> float:
        ...
    @Y.setter
    def Y(self: MSPyBentleyGeom.DPoint4d, arg0: float) -> None:
        ...
    
    @property
    def Z(self: MSPyBentleyGeom.DPoint4d) -> float:
        ...
    @Z.setter
    def Z(self: MSPyBentleyGeom.DPoint4d, arg0: float) -> None:
        ...
    
    def Zero(self: MSPyBentleyGeom.DPoint4d) -> None:
        """
        zero out this point.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DPoint4d, x: float, y: float, z: float, w: float) -> None
        
        2. __init__(self: MSPyBentleyGeom.DPoint4d, xyz: MSPyBentleyGeom.DPoint3d, w: float) -> None
        
        3. __init__(self: MSPyBentleyGeom.DPoint4d) -> None
        """
        ...
    
    @property
    def w(self: MSPyBentleyGeom.DPoint4d) -> float:
        ...
    @w.setter
    def w(self: MSPyBentleyGeom.DPoint4d, arg0: float) -> None:
        ...
    
    @property
    def x(self: MSPyBentleyGeom.DPoint4d) -> float:
        ...
    @x.setter
    def x(self: MSPyBentleyGeom.DPoint4d, arg0: float) -> None:
        ...
    
    @property
    def y(self: MSPyBentleyGeom.DPoint4d) -> float:
        ...
    @y.setter
    def y(self: MSPyBentleyGeom.DPoint4d, arg0: float) -> None:
        ...
    
    @property
    def z(self: MSPyBentleyGeom.DPoint4d) -> float:
        ...
    @z.setter
    def z(self: MSPyBentleyGeom.DPoint4d, arg0: float) -> None:
        ...
    
class DPoint4dArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DPoint4dArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.DPoint4dArray, arg0: MSPyBentleyGeom.DPoint4dArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.DPoint4dArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.DPoint4dArray, x: MSPyBentleyGeom.DPoint4d) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.DPoint4dArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.DPoint4dArray, L: MSPyBentleyGeom.DPoint4dArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.DPoint4dArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.DPoint4dArray, i: int, x: MSPyBentleyGeom.DPoint4d) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.DPoint4dArray) -> MSPyBentleyGeom.DPoint4d
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.DPoint4dArray, i: int) -> MSPyBentleyGeom.DPoint4d
        
        Remove and return the item at index ``i``
        """
        ...
    
class DRange1d:
    """
    None
    """

    @staticmethod
    def AppendClips(dataA: MSPyBentleyGeom.DRange1dArray, clipper: MSPyBentleyGeom.DRange1d, dataOut: MSPyBentleyGeom.DRange1dArray) -> None:
        """
        Intersect each range in dataA with clipper. Append non-
        empty results to dataOut. Note that if the same array is passed for
        dataA and dataOut, all input contents will remain. (Use{ClipInPlace}
        to get compaction)
        """
        ...
    
    @staticmethod
    def ClipInPlace(dataA: MSPyBentleyGeom.DRange1dArray, clipper: MSPyBentleyGeom.DRange1d) -> None:
        """
        Intersect each range in dataA with clipper. Retain non-
        empty result parts.
        """
        ...
    
    def Contains(self: MSPyBentleyGeom.DRange1d, a: float) -> bool:
        """
        Test if the range contains a given value.
        """
        ...
    
    @staticmethod
    def DifferenceSorted(dataA: MSPyBentleyGeom.DRange1dArray, dataB: MSPyBentleyGeom.DRange1dArray, dataOut: MSPyBentleyGeom.DRange1dArray) -> None:
        """
        Intersect intervals in two pre-sorted sets. Output may
        NOT be the same as either input.
        """
        ...
    
    def DoubleToFraction(self: MSPyBentleyGeom.DRange1d, x: float, defaultReturnX: float = 0.0) -> tuple:
        """
        map real to fraction. Returns false if null range or
        single point.
        """
        ...
    
    def Extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. Extend(self: MSPyBentleyGeom.DRange1d, valueA: float) -> None
        
        Extend to include a value.
        
        2. Extend(self: MSPyBentleyGeom.DRange1d, valueA: float, valueB: float) -> None
        
        Extend to include a value.
        
        3. Extend(self: MSPyBentleyGeom.DRange1d, values: MSPyBentleyGeom.DoubleArray) -> None
        
        Extend to include a value.
        
        4. Extend(self: MSPyBentleyGeom.DRange1d, other: MSPyBentleyGeom.DRange1d) -> None
        
        Extend to include a value.
        """
        ...
    
    def ExtendBySignedShift(self: MSPyBentleyGeom.DRange1d, tol: float) -> None:
        """
        If non empty, shift endpoints by (-tol, +tol). No change if empty !!!
        """
        ...
    
    def FractionToDouble(self: MSPyBentleyGeom.DRange1d, fraction: float, defaultReturnX: float = 0.0) -> tuple:
        """
        map fractional coordinate to real. Returns false if null
        range.
        """
        ...
    
    @staticmethod
    def From(*args, **kwargs):
        """
        Overloaded function.
        
        1. From(value: float) -> MSPyBentleyGeom.DRange1d
        
        Return a range containing a single value.
        
        2. From(valueA: float, valueB: float) -> MSPyBentleyGeom.DRange1d
        
        Return a range containing a single value.
        
        3. From(valueA: float, valueB: float, valueC: float) -> MSPyBentleyGeom.DRange1d
        
        Return a range containing a single value.
        
        4. From(arg0: List[float]) -> MSPyBentleyGeom.DRange1d
        """
        ...
    
    @staticmethod
    def FromAltitudes(points: MSPyBentleyGeom.DPoint3dArray, plane: MSPyBentleyGeom.DPlane3d) -> MSPyBentleyGeom.DRange1d:
        """
        Return a (sorted) range of altitudes of points.
        """
        ...
    
    @staticmethod
    def FromExtent(data: MSPyBentleyGeom.DRange1dArray) -> MSPyBentleyGeom.DRange1d:
        """
        Return the encompassing single range.
        """
        ...
    
    @staticmethod
    def FromIntersection(*args, **kwargs):
        """
        Overloaded function.
        
        1. FromIntersection(rangeA: MSPyBentleyGeom.DRange1d, rangeB: MSPyBentleyGeom.DRange1d) -> MSPyBentleyGeom.DRange1d
        
        return the (possibly null) intersection of two ranges.
        
        2. FromIntersection(data: MSPyBentleyGeom.DRange1dArray) -> MSPyBentleyGeom.DRange1d
        
        return the (possibly null) intersection of two ranges.
        """
        ...
    
    @staticmethod
    def FromLowHigh(low: float, high: float) -> MSPyBentleyGeom.DRange1d:
        """
        Return a range with explicit (possibly reversed) low and
        high.
        """
        ...
    
    @staticmethod
    def FromUnion(rangeA: MSPyBentleyGeom.DRange1d, rangeB: MSPyBentleyGeom.DRange1d) -> MSPyBentleyGeom.DRange1d:
        """
        return the (possibly null) union of two ranges.
        """
        ...
    
    def GetTolerance(self: MSPyBentleyGeom.DRange1d, absTol: float = 1e-14, localRelTol: float = 1e-14, globalRelTol: float = 0.0) -> float:
        """
        return a tolerance computed as{absTol + localRelTol *
        Extent() + globalRelTol * MaxAbs ()}
        """
        ...
    
    def HasNonEmptyIntersectionWith(self: MSPyBentleyGeom.DRange1d, other: MSPyBentleyGeom.DRange1d) -> bool:
        """
        Test if the instance range is a (possibly complete, but
        not empty) subset of{other} range.
        """
        ...
    
    def HasPositiveLengthIntersectionWith(self: MSPyBentleyGeom.DRange1d, other: MSPyBentleyGeom.DRange1d) -> bool:
        """
        Test if the instance range has a positive-length (more
        than single point) intersection with{other}.
        """
        ...
    
    def High(self: MSPyBentleyGeom.DRange1d) -> float:
        """
        Get the low limit (unchecked).
        """
        ...
    
    @staticmethod
    def InfiniteRange() -> MSPyBentleyGeom.DRange1d:
        """
        Return a complete range (-DBL_MAX to DBL_MAX)
        """
        ...
    
    def InitNull(self: MSPyBentleyGeom.DRange1d) -> None:
        """
        Set this range to the{NullRange}
        """
        ...
    
    def IntersectInPlace(self: MSPyBentleyGeom.DRange1d, other: MSPyBentleyGeom.DRange1d) -> None:
        """
        Restrict to overlap with another (possibly null!!) range.
        """
        ...
    
    @staticmethod
    def IntersectSorted(dataA: MSPyBentleyGeom.DRange1dArray, dataB: MSPyBentleyGeom.DRange1dArray, dataOut: MSPyBentleyGeom.DRange1dArray) -> None:
        """
        Intersect intervals in two pre-sorted sets. Output may
        NOT be the same as either input.
        """
        ...
    
    def IsDoublyInfinite(self: MSPyBentleyGeom.DRange1d) -> bool:
        """
        Test if the range has the most negative{low} and most
        positive{high}
        """
        ...
    
    def IsEmpty(self: MSPyBentleyGeom.DRange1d) -> bool:
        """
        Test if the range has{low> high}, i.e. there are no x
        for which{low &le x && x &le high}
        """
        ...
    
    def IsEmptyOrSinglePoint(self: MSPyBentleyGeom.DRange1d) -> bool:
        """
        Test if the range has{high >= low}, i.e. is empty or
        just one point.
        """
        ...
    
    def IsEqualInterval(self: MSPyBentleyGeom.DRange1d, other: MSPyBentleyGeom.DRange1d) -> bool:
        """
        Test if equal intervals in point set sense. Any pair of
        empty intervals (even if different low and high) are equal.
        """
        ...
    
    def IsEqualLowHigh(self: MSPyBentleyGeom.DRange1d, other: MSPyBentleyGeom.DRange1d) -> bool:
        """
        Direct equality test for low and high parts.
        """
        ...
    
    @staticmethod
    def IsIncreasing(data: MSPyBentleyGeom.DRange1dArray, allowZeroLength: bool = False, allowZeroGaps: bool = False) -> bool:
        """
        Test for increasing relationships, optionally allowing
        zero length.
        """
        ...
    
    def IsInfiniteNegative(self: MSPyBentleyGeom.DRange1d) -> bool:
        """
        Test if the range has the most negative possible{low}
        """
        ...
    
    def IsInfinitePositive(self: MSPyBentleyGeom.DRange1d) -> bool:
        """
        Test if the range has the largest possible{high}
        """
        ...
    
    def IsNull(self: MSPyBentleyGeom.DRange1d) -> bool:
        """
        Test if the range is exactly the same as the null ranges
        returned by NullRange ().
        """
        ...
    
    def IsPositiveLength(self: MSPyBentleyGeom.DRange1d) -> bool:
        """
        Test if the range has{high> low}, i.e. has a non-empty
        set of points with properly sorted lower and upper limit.
        """
        ...
    
    def IsSinglePoint(*args, **kwargs):
        """
        Overloaded function.
        
        1. IsSinglePoint(self: MSPyBentleyGeom.DRange1d) -> bool
        
        Test if the range is a single point.
        
        2. IsSinglePoint(self: MSPyBentleyGeom.DRange1d, arg0: float) -> bool
        
        value
        """
        ...
    
    def IsSubsetOf(self: MSPyBentleyGeom.DRange1d, other: MSPyBentleyGeom.DRange1d) -> bool:
        """
        Test if the instance range is a (possibly complete,
        possibly empty) subset of{other} range.
        """
        ...
    
    def Length(self: MSPyBentleyGeom.DRange1d) -> float:
        """
        Return{MAX(0, high - low)} The DRange1.NullRange
        returns 0. A single-point interval returns 0. An interval with{high <
        low} returns 0. Normal case returns{high - low}
        """
        ...
    
    @staticmethod
    def LengthSum(data: MSPyBentleyGeom.DRange1dArray) -> float:
        """
        Sum the interval lengths
        """
        ...
    
    def Low(self: MSPyBentleyGeom.DRange1d) -> float:
        """
        Get the low limit (unchecked).
        """
        ...
    
    def MaxAbs(self: MSPyBentleyGeom.DRange1d, defaultValeForNullRange: float = 0.0) -> float:
        """
        return the largest coordinate (absolute value) in the
        range.
        """
        ...
    
    @staticmethod
    def NullRange() -> MSPyBentleyGeom.DRange1d:
        """
        Return a range which satisfies IsNull ()
        """
        ...
    
    @staticmethod
    def SimplifyInPlace(data: MSPyBentleyGeom.DRange1dArray) -> None:
        """
        Combine intervals so there are no overlaps.
        """
        ...
    
    @staticmethod
    def SortLowInPlace(data: MSPyBentleyGeom.DRange1dArray) -> None:
        """
        Sort on low values.
        """
        ...
    
    def StrictlyNonEmptyFractionalIntersection(self: MSPyBentleyGeom.DRange1d, rangeB: MSPyBentleyGeom.DRange1d, fractionalIntersection: MSPyBentleyGeom.DRange1d) -> bool:
        """
        Compute intersection of the instance with rangeB. Return
        the intersection as fractions of the instance.
        
        :returns:
        true if the fractional intersection is more than single point.
        """
        ...
    
    @staticmethod
    def UnionSorted(dataA: MSPyBentleyGeom.DRange1dArray, dataB: MSPyBentleyGeom.DRange1dArray, dataOut: MSPyBentleyGeom.DRange1dArray) -> None:
        """
        Union of intervals in two pre-sorted sets. Output may NOT
        be the same as either input.
        """
        ...
    
    def UpdateRay1dIntersection(self: MSPyBentleyGeom.DRange1d, x0: float, dxds: float, xA: float, xB: float) -> bool:
        """
        Update a bounding interval of a line based on the variation of that
        line within one dimension. The ray parameterized{x = x0+s*dxdx} The
        instance is an{s} range that is live. This is usually initialized to
        InfiniteRange before clipping.{xA,xB} is an interval of the{x}
        space. (xA and xB are not required to be sorted.}
        
        :param (input):
        x0 ray start coordinate in this dimension
        
        :param (input):
        dxds Rate of change of ray in this dimension.
        
        :param (input):
        xA x limit
        
        :param (input):
        xB x limit.
        
        :returns:
        true if interval is nonempty at return.
        """
        ...
    
    @staticmethod
    def ZeroAndNegativeRange() -> MSPyBentleyGeom.DRange1d:
        """
        Return a complete 0 and negative range (-DBL_MAX to 0)
        """
        ...
    
    @staticmethod
    def ZeroAndPositiveRange() -> MSPyBentleyGeom.DRange1d:
        """
        Return a complete 0 and positive range (0 to DBL_MAX)
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DRange1d) -> None
        
        2. __init__(self: MSPyBentleyGeom.DRange1d, low: float, high: float) -> None
        
        3. __init__(self: MSPyBentleyGeom.DRange1d, source: MSPyBentleyGeom.DRange1d) -> None
        """
        ...
    
class DRange1dArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DRange1dArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.DRange1dArray, arg0: MSPyBentleyGeom.DRange1dArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.DRange1dArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.DRange1dArray, x: MSPyBentleyGeom.DRange1d) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.DRange1dArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.DRange1dArray, L: MSPyBentleyGeom.DRange1dArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.DRange1dArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.DRange1dArray, i: int, x: MSPyBentleyGeom.DRange1d) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.DRange1dArray) -> MSPyBentleyGeom.DRange1d
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.DRange1dArray, i: int) -> MSPyBentleyGeom.DRange1d
        
        Remove and return the item at index ``i``
        """
        ...
    
class DRange2d:
    """
    None
    """

    def Area(self: MSPyBentleyGeom.DRange2d) -> float:
        """
        returns product of axis extents. No test for zero or negative axes.
        """
        ...
    
    def Contains(*args, **kwargs):
        """
        Overloaded function.
        
        1. Contains(self: MSPyBentleyGeom.DRange2d, point: MSPyBentleyGeom.DPoint3d) -> bool
        
        Test if a point is contained in a range.
        
        :param (input):
        point point to test. (z is ignored)
        
        :returns:
        true if the point is in (or on boundary of)
        
        2. Contains(self: MSPyBentleyGeom.DRange2d, point: MSPyBentleyGeom.DPoint2d) -> bool
        
        Test if a point is contained in a range.
        
        :param (input):
        point point to test. (z is ignored)
        
        :returns:
        true if the point is in (or on boundary of)
        
        3. Contains(self: MSPyBentleyGeom.DRange2d, x: float, y: float) -> bool
        
        Test if a point is contained in a range.
        
        :param (input):
        point point to test. (z is ignored)
        
        :returns:
        true if the point is in (or on boundary of)
        """
        ...
    
    def Extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. Extend(self: MSPyBentleyGeom.DRange2d, point: MSPyBentleyGeom.DPoint2d) -> None
        
        Extends the coordinates of the range cube points in pRange so as to
        include the single additional point point.
        
        :param (input):
        point new point to be included in the range.
        
        2. Extend(self: MSPyBentleyGeom.DRange2d, point: MSPyBentleyGeom.DPoint3d) -> None
        
        Extends the coordinates of the range cube points in pRange so as to
        include the single additional point point.
        
        :param (input):
        point new point to be included in the range.
        
        3. Extend(self: MSPyBentleyGeom.DRange2d, point: MSPyBentleyGeom.DPoint4d) -> None
        
        Extends the coordinates of the range cube points in pRange so as to
        include the single additional point point.
        
        :param (input):
        point new point to be included in the range.
        
        4. Extend(self: MSPyBentleyGeom.DRange2d, x: float, y: float) -> None
        
        Extends the coordinates of the range cube points in pRange so as to
        include the single additional point point.
        
        :param (input):
        point new point to be included in the range.
        
        5. Extend(self: MSPyBentleyGeom.DRange2d, points: MSPyBentleyGeom.DPoint2dArray) -> None
        
        Extends the coordinates of the range cube points in pRange so as to
        include the single additional point point.
        
        :param (input):
        point new point to be included in the range.
        
        6. Extend(self: MSPyBentleyGeom.DRange2d, extend: float) -> None
        
        Extends the coordinates of the range cube points in pRange so as to
        include the single additional point point.
        
        :param (input):
        point new point to be included in the range.
        
        7. Extend(self: MSPyBentleyGeom.DRange2d, rangeB: MSPyBentleyGeom.DRange2d) -> None
        
        Extends the coordinates of the range cube points in pRange so as to
        include the single additional point point.
        
        :param (input):
        point new point to be included in the range.
        """
        ...
    
    def ExtentSquared(self: MSPyBentleyGeom.DRange2d) -> float:
        """
        :returns:
        0 if null range (as decided by IsNull ()), otherwise sum of
        squared axis extents.
        """
        ...
    
    @staticmethod
    def From(points: list) -> MSPyBentleyGeom.DRange2d:
        ...
    
    @staticmethod
    def FromUnitArcSweep(theta0: float, sweep: float) -> MSPyBentleyGeom.DRange2d:
        """
        Initialize the range from an arc of the unit circle
        
        :param (input):
        theta0 start angle
        
        :param (input):
        sweep angular sweep
        """
        ...
    
    def Get4Corners(self: MSPyBentleyGeom.DRange2d, box: MSPyBentleyGeom.DPoint2dArray) -> None:
        """
        Generates a 4 point box around around a range cube. Point ordering is
        by " x varies fastest " --- 00, 10, 01, 11 for the unit range.
        
        :param (output):
        box array of 4 points of the box
        """
        ...
    
    def Get4Lines(self: MSPyBentleyGeom.DRange2d, originalArray: MSPyBentleyGeom.DPoint2dArray, normalArray: MSPyBentleyGeom.DPoint2dArray) -> None:
        """
        Extract the 4 bounding lines for a range rectangle, in origin normal
        form
        
        :param (output):
        originArray array of line origins
        
        :param (output):
        normalArray array of plane normals. Directions down, left, right,
        up.
        """
        ...
    
    def Init(self: MSPyBentleyGeom.DRange2d) -> None:
        """
        Initializes a range cube with (inverted) large positive and negative
        values.
        """
        ...
    
    def InitFromUnitArcSweep(self: MSPyBentleyGeom.DRange2d, theta0: float, sweep: float) -> None:
        """
        Initialize the range from an arc of the unit circle
        
        :param (input):
        theta0 start angle
        
        :param (input):
        sweep angular sweep
        """
        ...
    
    def IntersectRay(self: MSPyBentleyGeom.DRange2d, start: MSPyBentleyGeom.DPoint2d, direction: MSPyBentleyGeom.DPoint2d) -> tuple:
        """
        Compute the intersection of a range cube and a ray.
        
        If there is not a finite intersection, both params are set to 0 and
        and both points to point0.
        
        :param (output):
        param0 ray parameter where cube is entered
        
        :param (output):
        param1 ray parameter where cube is left
        
        :param (output):
        point0 entry point
        
        :param (output):
        point1 exit point
        
        :param (input):
        start start point of ray
        
        :param (input):
        direction direction of ray
        
        :returns:
        true if non-empty intersection.
        """
        ...
    
    def IntersectionExtentSquared(self: MSPyBentleyGeom.DRange2d, range2: MSPyBentleyGeom.DRange2d) -> float:
        """
        Compute the intersection of given range with another range and return
        the extentSquared of the intersection range.
        
        :param (input):
        range2 second range
        
        :returns:
        extentSquared() for the intersection range.
        """
        ...
    
    def IntersectionOf(self: MSPyBentleyGeom.DRange2d, range1: MSPyBentleyGeom.DRange2d, range2: MSPyBentleyGeom.DRange2d) -> bool:
        """
        Compute the intersection of two ranges and test if it is nonempty. If
        empty (non overlap), result range null range.
        
        Remark:
        In earlier API (bsiDRange2d_intersect, DRange2d.intersectionOf
        (DRange2dCP, DRange2dCP) the result was uninitialized in the no-
        intersection case)
        
        :param (input):
        range1 first range
        
        :param (input):
        range2 second range
        
        :returns:
        same result as checkOverlap(range1,range2).
        """
        ...
    
    def IntersectsWith(self: MSPyBentleyGeom.DRange2d, range2: MSPyBentleyGeom.DRange2d) -> bool:
        """
        Test if two ranges have strictly non-null overlap (intersection)
        
        :param (input):
        range2 second range
        
        :returns:
        true if ranges overlap, false if not.
        """
        ...
    
    def IsContained(self: MSPyBentleyGeom.DRange2d, outerRange: MSPyBentleyGeom.DRange2d) -> bool:
        """
        Test if the given range is a (possible improper) subset of outerRange.
        
        :param (input):
        outerRange outer range
        
        :returns:
        true if the given range is a (possibly improper) subset of
        outerRange.
        """
        ...
    
    def IsEmpty(self: MSPyBentleyGeom.DRange2d) -> bool:
        """
        Test if high component is (strictly) less than low in any direction.
        Note that equal components do not indicate empty. returns true if any
        low component is less than the corresponding high component
        """
        ...
    
    def IsEqual(*args, **kwargs):
        """
        Overloaded function.
        
        1. IsEqual(self: MSPyBentleyGeom.DRange2d, range1: MSPyBentleyGeom.DRange2d) -> bool
        
        Test if two ranges are exactly equal.
        
        :param (input):
        range1 second range
        
        :returns:
        true if ranges are identical in all components.
        
        2. IsEqual(self: MSPyBentleyGeom.DRange2d, range1: MSPyBentleyGeom.DRange2d, tolerance: float) -> bool
        
        Test if two ranges are exactly equal.
        
        :param (input):
        range1 second range
        
        :returns:
        true if ranges are identical in all components.
        """
        ...
    
    def IsNull(self: MSPyBentleyGeom.DRange2d) -> bool:
        """
        Check if the range is exactly the same as the null ranges returned by
        bsiDRange2d_init. (Note that ranges with other values with low> high
        are not necessarily null by this condition.)
        """
        ...
    
    def IsPoint(self: MSPyBentleyGeom.DRange2d) -> bool:
        """
        :returns:
        true if high is less than or equal to low in every direction.
        """
        ...
    
    def MoveChangesIntersection(self: MSPyBentleyGeom.DRange2d, newRange: MSPyBentleyGeom.DRange2d, outerRange: MSPyBentleyGeom.DRange2d) -> bool:
        """
        Test if a modification of the given (instance) range would have a
        different touching relationship with outerRange.
        
        Remark:
        This may only be meaningful in context of range tree tests where
        some prior relationship among ranges is known to apply.
        
        :param (input):
        newRange candidate for modified range relationship.
        
        :param (input):
        outerRange containing range
        
        :returns:
        true if touching condition occurs.
        """
        ...
    
    @staticmethod
    def NullRange() -> MSPyBentleyGeom.DRange2d:
        """
        Initializes a range cube with (inverted) large positive and negative
        values.
        """
        ...
    
    def RestrictToMinMax(self: MSPyBentleyGeom.DRange2d, range0: MSPyBentleyGeom.DRange2d, minMax: MSPyBentleyGeom.DRange2d) -> None:
        """
        Returns a range which is the intersection of two ranges. The first
        range is treated as a signed range, i.e. decreasing values from low to
        high are a nonempty range, and the output will maintain the direction.
        In a direction where there is no overlap, pRange high and low values
        are identical and are at the limit of pRange1 that is nearer to the
        values in range0. (Intended use:range0 is the 'actual' stroking range
        of a surface i.e. may go 'backwards'. pRange1 is the nominal full
        surface range, i.e. is known a priori to be 'forwards'. The clipping
        restricts unreliable range0 to the nominal surface range pRange1.
        range0 and pRange may be the same address. minMax must be different.
        
        :param (input):
        range0 range to be restricted
        
        :param (input):
        minMax allowable minmax range. Assumed to have low<high
        """
        ...
    
    def TryFractionsToRangePoint(self: MSPyBentleyGeom.DRange2d, fractions: MSPyBentleyGeom.DPoint2d, xy: MSPyBentleyGeom.DPoint2d) -> bool:
        """
        map a fractional point to the range coordinates. (0,0) is low point,
        (1,1) is high point.
        
        :param (input):
        fractions fractional coordinates
        
        :param (output):
        xy computed coordinates.
        
        :returns:
        false if range is null range.
        """
        ...
    
    def TryRangePointToFractions(self: MSPyBentleyGeom.DRange2d, xy: MSPyBentleyGeom.DPoint2d, fractions: MSPyBentleyGeom.DPoint2d) -> bool:
        """
        map a range point to the fractional coordinates. (0,0) is low point,
        (1,1) is high point.
        
        :param (output):
        fractions fractional coordinates
        
        :param (input):
        xy computed coordinates.
        
        :returns:
        false if range is null range or single point.
        """
        ...
    
    def UnionOf(self: MSPyBentleyGeom.DRange2d, range1: MSPyBentleyGeom.DRange2d, range2: MSPyBentleyGeom.DRange2d) -> None:
        """
        Form the union of two ranges.
        
        :param (input):
        range1 first range.
        
        :param (input):
        range2 second range.
        """
        ...
    
    def XLength(self: MSPyBentleyGeom.DRange2d) -> float:
        """
        Returns difference of high and low in x direction -- 0 if high<low.
        """
        ...
    
    def YLength(self: MSPyBentleyGeom.DRange2d) -> float:
        """
        Returns difference of high and low in y direction -- 0 if high<low.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DRange2d) -> None
        
        2. __init__(self: MSPyBentleyGeom.DRange2d, arg0: MSPyBentleyGeom.DPoint2d) -> None
        
        point_a
        
        3. __init__(self: MSPyBentleyGeom.DRange2d, range: DRange3d) -> None
        
        4. __init__(self: MSPyBentleyGeom.DRange2d, points: MSPyBentleyGeom.DPoint3dArray) -> None
        
        5. __init__(self: MSPyBentleyGeom.DRange2d, x: float, y: float) -> None
        
        6. __init__(self: MSPyBentleyGeom.DRange2d, point0: MSPyBentleyGeom.DPoint2d, point1: MSPyBentleyGeom.DPoint2d) -> None
        
        7. __init__(self: MSPyBentleyGeom.DRange2d, x0: float, y0: float, x1: float, y1: float) -> None
        
        8. __init__(self: MSPyBentleyGeom.DRange2d, point0: MSPyBentleyGeom.DPoint2d, point1: MSPyBentleyGeom.DPoint2d, point2: MSPyBentleyGeom.DPoint2d) -> None
        
        9. __init__(self: MSPyBentleyGeom.DRange2d, points: MSPyBentleyGeom.DPoint2dArray) -> None
        """
        ...
    
    @property
    def high(arg0: MSPyBentleyGeom.DRange2d) -> MSPyBentleyGeom.DPoint2d:
        ...
    @high.setter
    def high(arg0: MSPyBentleyGeom.DRange2d, arg1: MSPyBentleyGeom.DPoint2d) -> MSPyBentleyGeom.DPoint2d:
        ...
    
    @property
    def low(arg0: MSPyBentleyGeom.DRange2d) -> MSPyBentleyGeom.DPoint2d:
        ...
    @low.setter
    def low(arg0: MSPyBentleyGeom.DRange2d, arg1: MSPyBentleyGeom.DPoint2d) -> MSPyBentleyGeom.DPoint2d:
        ...
    
class DRange3d:
    """
    None
    """

    def DiagonalDistance(self: MSPyBentleyGeom.DRange3d) -> float:
        """
        Returns the length of the xyz diagonal -- 0 if null range.
        """
        ...
    
    def DiagonalDistanceXY(self: MSPyBentleyGeom.DRange3d) -> float:
        """
        Returns the length of the xy diagonal -- 0 if null range.
        """
        ...
    
    def DiagonalVector(self: MSPyBentleyGeom.DRange3d) -> DVec3d:
        """
        Returns the diagonal vector -- 000 if null range.
        """
        ...
    
    def DiagonalVectorXY(self: MSPyBentleyGeom.DRange3d) -> DVec3d:
        """
        Returns the XY part of the diagonal vector -- 000 if null range.
        """
        ...
    
    def DistanceOutside(self: MSPyBentleyGeom.DRange3d, xyz: MSPyBentleyGeom.DPoint3d) -> float:
        """
        Compute the smallest distance from xyz to the range. This
        is 0 for any point inside the range.
        
        :param (input):
        xyz space point.
        
        :returns:
        distance from xyz to closest point of the range.
        """
        ...
    
    def DistanceSquaredOutside(self: MSPyBentleyGeom.DRange3d, xyz: MSPyBentleyGeom.DPoint3d) -> float:
        """
        Compute the smallest distance squared from xyz to the
        range. This is 0 for any point inside the range.
        
        :param (input):
        xyz space point.
        
        :returns:
        distance squared from xyz to closest point of the range.
        """
        ...
    
    def DistanceSquaredTo(self: MSPyBentleyGeom.DRange3d, other: MSPyBentleyGeom.DRange3d) -> float:
        """
        Compute the smallest distance to the other range. This is
        0 if the ranges overlap.
        
        :param (input):
        other second range
        
        :returns:
        distance between range cubes (i.e. edge to edge or vertex to edge)
        """
        ...
    
    def Extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. Extend(self: MSPyBentleyGeom.DRange3d, extend: float) -> None
        
        Extends the coordinates of the range cube points in
        pRange so as to include the single additional point point.
        
        :param (input):
        point new point to be included in the range.
        
        2. Extend(self: MSPyBentleyGeom.DRange3d, range1: MSPyBentleyGeom.DRange3d) -> None
        
        Extends the coordinates of the range cube points in
        pRange so as to include the single additional point point.
        
        :param (input):
        point new point to be included in the range.
        
        3. Extend(self: MSPyBentleyGeom.DRange3d, ellipse: MSPyBentleyGeom.DEllipse3d) -> None
        
        Extends the coordinates of the range cube points in
        pRange so as to include the single additional point point.
        
        :param (input):
        point new point to be included in the range.
        
        4. Extend(self: MSPyBentleyGeom.DRange3d, point: MSPyBentleyGeom.DPoint3d) -> None
        
        Extends the coordinates of the range cube points in
        pRange so as to include the single additional point point.
        
        :param (input):
        point new point to be included in the range.
        
        5. Extend(self: MSPyBentleyGeom.DRange3d, point: MSPyBentleyGeom.DPoint3d, weight: float) -> None
        
        Extends the coordinates of the range cube points in
        pRange so as to include the single additional point point.
        
        :param (input):
        point new point to be included in the range.
        
        6. Extend(self: MSPyBentleyGeom.DRange3d, point: MSPyBentleyGeom.DPoint4d) -> None
        
        Extends the coordinates of the range cube points in
        pRange so as to include the single additional point point.
        
        :param (input):
        point new point to be included in the range.
        
        7. Extend(self: MSPyBentleyGeom.DRange3d, x: float, y: float, z: float) -> None
        
        Extends the coordinates of the range cube points in
        pRange so as to include the single additional point point.
        
        :param (input):
        point new point to be included in the range.
        
        8. Extend(self: MSPyBentleyGeom.DRange3d, points: MSPyBentleyGeom.DPoint2dArray, zVal: float) -> None
        
        Extends the coordinates of the range cube points in
        pRange so as to include the single additional point point.
        
        :param (input):
        point new point to be included in the range.
        
        9. Extend(self: MSPyBentleyGeom.DRange3d, points: MSPyBentleyGeom.DPoint3dArray) -> None
        
        Extends the coordinates of the range cube points in
        pRange so as to include the single additional point point.
        
        :param (input):
        point new point to be included in the range.
        
        10. Extend(self: MSPyBentleyGeom.DRange3d, points: list) -> None
        
        Extends the coordinates of the range cube points in
        pRange so as to include the single additional point point.
        
        :param (input):
        point new point to be included in the range.
        
        11. Extend(self: MSPyBentleyGeom.DRange3d, points: MSPyBentleyGeom.DPoint4dArray) -> None
        
        Extends the coordinates of the range cube points in
        pRange so as to include the single additional point point.
        
        :param (input):
        point new point to be included in the range.
        
        12. Extend(self: MSPyBentleyGeom.DRange3d, transform: Transform, points: MSPyBentleyGeom.DPoint3dArray) -> None
        
        Extends the coordinates of the range cube points in
        pRange so as to include the single additional point point.
        
        :param (input):
        point new point to be included in the range.
        
        13. Extend(self: MSPyBentleyGeom.DRange3d, transform: Transform, points: list) -> None
        
        Extends the coordinates of the range cube points in
        pRange so as to include the single additional point point.
        
        :param (input):
        point new point to be included in the range.
        
        14. Extend(self: MSPyBentleyGeom.DRange3d, transform: Transform, points: MSPyBentleyGeom.DPoint4dArray) -> None
        
        Extends the coordinates of the range cube points in
        pRange so as to include the single additional point point.
        
        :param (input):
        point new point to be included in the range.
        
        15. Extend(self: MSPyBentleyGeom.DRange3d, transform: Transform, points: List[MSPyBentleyGeom.DPoint3d], weights: List[float]) -> None
        
        Extends the coordinates of the range cube points in
        pRange so as to include the single additional point point.
        
        :param (input):
        point new point to be included in the range.
        """
        ...
    
    def ExtendBySweep(self: MSPyBentleyGeom.DRange3d, vector: DVec3d) -> None:
        """
        Extend either low or high of each axis by corresponding
        vector entry for sweep of the range cube. Any axis with low> high is
        left unchanged.
        
        :param (input):
        vector sweep drection
        """
        ...
    
    def ExtentSquared(self: MSPyBentleyGeom.DRange3d) -> float:
        """
        returns 0 if the range is null (Range3dIsNull), otherwise
        sum of squared axis extents.
        
        :returns:
        squared magnitude of the diagonal vector.
        """
        ...
    
    @staticmethod
    def From(*args, **kwargs):
        """
        Overloaded function.
        
        1. From(points: list) -> MSPyBentleyGeom.DRange3d
        
        2. From(transform: Transform, points: list) -> MSPyBentleyGeom.DRange3d
        """
        ...
    
    @staticmethod
    def FromMinMax(v0: float, v1: float) -> MSPyBentleyGeom.DRange3d:
        """
        Initialize the range.InitFrom given min and max in all
        directions. Given values will be swapped if needed.
        
        :param (input):
        v0 min (or max)
        
        :param (input):
        v1 max (or min)
        """
        ...
    
    def Get6Planes(*args, **kwargs):
        """
        Overloaded function.
        
        1. Get6Planes(self: MSPyBentleyGeom.DRange3d, planes: MSPyBentleyGeom.DPlane3dArray, normalLength: float = 1.0) -> None
        
        Generates 6 planes for the faces of the box.
        
        :param (output):
        planes array of 6 planes. (Declared and allocated by caller)
        
        :param (input):
        normalLength scale factor for plane normals. 1.0 is outward unit
        normals, -1.0 is inward unit normals
        
        2. Get6Planes(self: MSPyBentleyGeom.DRange3d, origins: MSPyBentleyGeom.DPoint3dArray, normals: MSPyBentleyGeom.DPoint3dArray = 1.0) -> None
        
        Generates 6 planes for the faces of the box.
        
        :param (output):
        planes array of 6 planes. (Declared and allocated by caller)
        
        :param (input):
        normalLength scale factor for plane normals. 1.0 is outward unit
        normals, -1.0 is inward unit normals
        
        3. Get6Planes(self: MSPyBentleyGeom.DRange3d, origins: list, normals: list = 1.0) -> None
        
        Generates 6 planes for the faces of the box.
        
        :param (output):
        planes array of 6 planes. (Declared and allocated by caller)
        
        :param (input):
        normalLength scale factor for plane normals. 1.0 is outward unit
        normals, -1.0 is inward unit normals
        """
        ...
    
    def Get8Corners(self: MSPyBentleyGeom.DRange3d, box: MSPyBentleyGeom.DPoint3d) -> None:
        """
        Generates an 8point box around around a range cube. Point ordering is
        maintained from the cube.
        
        :param (output):
        box array of 8 points of the box
        """
        ...
    
    def GetComponentDRange1d(self: MSPyBentleyGeom.DRange3d, index: int) -> MSPyBentleyGeom.DRange1d:
        """
        Extract a single component (x,y,z) as a DRange1d.
        
        :param (input):
        index component index interpretted cyclically.
        
        :returns:
        single component range. Ranges may be null independently.
        """
        ...
    
    def GetCornerRange(*args, **kwargs):
        """
        Overloaded function.
        
        1. GetCornerRange(self: MSPyBentleyGeom.DRange3d, ray: DRay3d) -> MSPyBentleyGeom.DRange1d
        
        Compute range of dot products of ray.direction with vectors from
        ray.origin to corners of the range. (The ray direction is NOT
        renormalized on each call)
        
        :param (input):
        ray origin and vector for dot products.
        
        2. GetCornerRange(self: MSPyBentleyGeom.DRange3d, plane: MSPyBentleyGeom.DPlane3d) -> MSPyBentleyGeom.DRange1d
        
        Compute range of dot products of ray.direction with vectors from
        ray.origin to corners of the range. (The ray direction is NOT
        renormalized on each call)
        
        :param (input):
        ray origin and vector for dot products.
        """
        ...
    
    def GetEdges(self: MSPyBentleyGeom.DRange3d, edges: List[DSegment3d]) -> None:
        """
        Generates individual DSegment3d for the 12 edges of the box.
        
        :param (output):
        edges array of 12 edges
        """
        ...
    
    def IndexOfMaximalAxis(self: MSPyBentleyGeom.DRange3d) -> int:
        """
        Return the index of the axis with largest absolute range.
        """
        ...
    
    def Init(self: MSPyBentleyGeom.DRange3d) -> None:
        """
        Initializes a range cube with (inverted) large positive
        and negative values.
        """
        ...
    
    def InitFromMinMax(self: MSPyBentleyGeom.DRange3d, v0: float, v1: float) -> None:
        """
        Initialize the range from given min and max in all
        directions. Given values will be swapped if needed.
        
        :param (input):
        v0 min (or max)
        
        :param (input):
        v1 max (or min)
        """
        ...
    
    def IntersectBounded(self: MSPyBentleyGeom.DRange3d, clipped: DSegment3d, segment: DSegment3d) -> tuple:
        """
        Compute the intersection of a range cube and a ray.
        
        If there is not a finite intersection, both params are set to 0 and
        and the output segment consists of only the start point.
        
        :param (output):
        param0 ray parameter where cube is entered
        
        :param (output):
        param1 ray parameter where cube is left
        
        :param (output):
        clipped clipped segment
        
        :param (output):
        segment line segment to intersect with range cube.
        
        :returns:
        true if non-empty intersection.
        """
        ...
    
    def IntersectIndependentComponentsOf(self: MSPyBentleyGeom.DRange3d, range1: MSPyBentleyGeom.DRange3d, range2: MSPyBentleyGeom.DRange3d) -> None:
        """
        Compute intersection of x,y,z components independently.
        
        :param (input):
        range1 first range
        
        :param (input):
        range2 second range
        """
        ...
    
    def IntersectRay(self: MSPyBentleyGeom.DRange3d, point0: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d, start: MSPyBentleyGeom.DPoint3d, direction: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        Compute the intersection of a range cube and a ray.
        
        If there is not a finite intersection, both params are set to 0 and
        and both points to point0.
        
        :param (output):
        param0 ray parameter where cube is entered
        
        :param (output):
        param1 ray parameter where cube is left
        
        :param (output):
        point0 entry point
        
        :param (output):
        point1 exit point
        
        :param (input):
        start start point of ray
        
        :param (input):
        direction direction of ray
        
        :returns:
        true if non-empty intersection.
        """
        ...
    
    def IntersectionExtentSquared(self: MSPyBentleyGeom.DRange3d, range2: MSPyBentleyGeom.DRange3d) -> float:
        """
        Compute the intersection of given range with another range and return
        the extentSquared of the intersection range.
        
        :param (input):
        range2 second range
        
        :returns:
        extentSquared() for the intersection range.
        """
        ...
    
    def IntersectionOf(self: MSPyBentleyGeom.DRange3d, range1: MSPyBentleyGeom.DRange3d, range2: MSPyBentleyGeom.DRange3d) -> None:
        """
        Compute the intersection of two ranges. If any direction has no
        intersection the result range is initialized to a null range. (Zero
        thickness intersection is null.)
        
        :param (input):
        range1 first range
        
        :param (input):
        range2 second range
        """
        ...
    
    def IntersectsWith(*args, **kwargs):
        """
        Overloaded function.
        
        1. IntersectsWith(self: MSPyBentleyGeom.DRange3d, range2: MSPyBentleyGeom.DRange3d) -> bool
        
        Test if two ranges have strictly non-null overlap (intersection)
        
        :param (input):
        range2 second range
        
        :returns:
        true if ranges overlap, false if not.
        
        2. IntersectsWith(self: MSPyBentleyGeom.DRange3d, range2: MSPyBentleyGeom.DRange3d, numDimensions: int) -> bool
        
        Test if two ranges have strictly non-null overlap (intersection)
        
        :param (input):
        range2 second range
        
        :returns:
        true if ranges overlap, false if not.
        
        3. IntersectsWith(self: MSPyBentleyGeom.DRange3d, range2: MSPyBentleyGeom.DRange3d, gapSize: float, numDimensions: int) -> bool
        
        Test if two ranges have strictly non-null overlap (intersection)
        
        :param (input):
        range2 second range
        
        :returns:
        true if ranges overlap, false if not.
        """
        ...
    
    def IsAlmostZeroX(self: MSPyBentleyGeom.DRange3d) -> bool:
        """
        Test if x size is small compared to y and z
        """
        ...
    
    def IsAlmostZeroY(self: MSPyBentleyGeom.DRange3d) -> bool:
        """
        Test if y size is small compared to x and z
        """
        ...
    
    def IsAlmostZeroZ(self: MSPyBentleyGeom.DRange3d) -> bool:
        """
        Test if z size is small compared to x and y.
        """
        ...
    
    def IsContained(*args, **kwargs):
        """
        Overloaded function.
        
        1. IsContained(self: MSPyBentleyGeom.DRange3d, outerRange: MSPyBentleyGeom.DRange3d) -> bool
        
        Test if the first range is contained in the second range.
        
        :param (input):
        outerRange candidate outer range.
        
        :returns:
        true if the inner range is a (possibly improper) subset of the
        outer range.
        
        2. IsContained(self: MSPyBentleyGeom.DRange3d, point: MSPyBentleyGeom.DPoint3d) -> bool
        
        Test if the first range is contained in the second range.
        
        :param (input):
        outerRange candidate outer range.
        
        :returns:
        true if the inner range is a (possibly improper) subset of the
        outer range.
        
        3. IsContained(self: MSPyBentleyGeom.DRange3d, point: MSPyBentleyGeom.DPoint3d, numDistance: int) -> bool
        
        Test if the first range is contained in the second range.
        
        :param (input):
        outerRange candidate outer range.
        
        :returns:
        true if the inner range is a (possibly improper) subset of the
        outer range.
        
        4. IsContained(self: MSPyBentleyGeom.DRange3d, x: float, y: float, z: float) -> bool
        
        Test if the first range is contained in the second range.
        
        :param (input):
        outerRange candidate outer range.
        
        :returns:
        true if the inner range is a (possibly improper) subset of the
        outer range.
        """
        ...
    
    def IsContainedXY(self: MSPyBentleyGeom.DRange3d, point: MSPyBentleyGeom.DPoint3d) -> bool:
        """
        Test if a point is contained in a range, using only xy
        parts.
        
        :param (input):
        point point to test.
        
        :returns:
        true if the point is in (or on boundary of)
        """
        ...
    
    def IsEmpty(self: MSPyBentleyGeom.DRange3d) -> bool:
        """
        Test if low component is (strictly) less than high in any direction.
        Note that equal components do not indicate empty. returns true if any
        low component is less than the corresponding high component
        """
        ...
    
    def IsEqual(*args, **kwargs):
        """
        Overloaded function.
        
        1. IsEqual(self: MSPyBentleyGeom.DRange3d, range1: MSPyBentleyGeom.DRange3d) -> bool
        
        Test if two ranges are exactly equal.
        
        :param (input):
        range1 second range
        
        :returns:
        true if ranges are identical in all components.
        
        2. IsEqual(self: MSPyBentleyGeom.DRange3d, range1: MSPyBentleyGeom.DRange3d, tolerance: float) -> bool
        
        Test if two ranges are exactly equal.
        
        :param (input):
        range1 second range
        
        :returns:
        true if ranges are identical in all components.
        """
        ...
    
    def IsNull(self: MSPyBentleyGeom.DRange3d) -> bool:
        """
        Check if the range is exactly the same as the null ranges
        of a just-initialized range.
        
        :returns:
        true if the range is null.
        """
        ...
    
    def IsPoint(self: MSPyBentleyGeom.DRange3d) -> bool:
        """
        :returns:
        true if high is exactly equal to low in every direction.
        """
        ...
    
    def IsStrictlyContainedXY(self: MSPyBentleyGeom.DRange3d, outerRange: MSPyBentleyGeom.DRange3d) -> bool:
        """
        Test if the given range is a proper subset of outerRange, using only
        xy parts
        
        :param (input):
        outerRange outer range
        
        :returns:
        true if the given range is a proper subset of outerRange.
        """
        ...
    
    def LargestCoordinate(self: MSPyBentleyGeom.DRange3d) -> float:
        """
        :returns:
        the largest individual coordinate value among (a) range min point,
        (b) range max point, and (c) range diagonal vector.
        """
        ...
    
    def LargestCoordinateXY(self: MSPyBentleyGeom.DRange3d) -> float:
        """
        :returns:
        the largest individual XY coordinate value among (a) range min
        point, (b) range max point, and (c) range diagonal vector.
        """
        ...
    
    def LocalToGlobal(self: MSPyBentleyGeom.DRange3d, xFraction: float, yFraction: float, zFraction: float) -> MSPyBentleyGeom.DPoint3d:
        """
        Convert fractional coordinates in x,y,z directions to global
        coordinates.
        
        :param (input):
        xFraction
        
        :param (input):
        yFraction
        
        :param (input):
        zFraction
        
        :returns:
        interpolated point.
        """
        ...
    
    def MaxAbs(self: MSPyBentleyGeom.DRange3d) -> float:
        """
        :returns:
        the largest individual coordinate value among range low and high,
        zero if empty range.
        """
        ...
    
    def MoveChangesIntersection(self: MSPyBentleyGeom.DRange3d, newRange: MSPyBentleyGeom.DRange3d, outerRange: MSPyBentleyGeom.DRange3d) -> bool:
        """
        Test if a modification of the given (instance) range would have a
        different touching relationship with outerRange.
        
        Remark:
        This may only be meaningful in context of range tree tests where
        some prior relationship among ranges is known to apply.
        
        :param (input):
        newRange candidate for modified range relationship.
        
        :param (input):
        outerRange containing range
        
        :returns:
        true if touching condition occurs.
        """
        ...
    
    @staticmethod
    def NullRange() -> MSPyBentleyGeom.DRange3d:
        """
        Initializes a range cube with (inverted) large positive
        and negative values.
        """
        ...
    
    def RestrictToMinMax(self: MSPyBentleyGeom.DRange3d, range0: MSPyBentleyGeom.DRange3d, minMax: MSPyBentleyGeom.DRange3d) -> None:
        """
        Returns a range which is the intersection of two ranges. The first
        range is treated as a signed range, i.e. decreasing values from low to
        high are a nonempty range, and the output will maintain the direction.
        In a direction where there is no overlap, instance high and low values
        are identical and are at the limit of minMax that is nearer to the
        values in range0. (Intended use:range0 is the 'actual' stroking range
        of a surface i.e. may go 'backwards'. minMax is the nominal full
        surface range, i.e. is known a priori to be 'forwards'. The clipping
        restricts unreliable range0 to the nominal surface range pRange1.
        range0 and instance may be the same address. minMax must be different.
        
        :param (input):
        range0 range to be restricted
        
        :param (input):
        minMax allowable minmax range. Assumed to have low<high
        """
        ...
    
    def UnionOf(self: MSPyBentleyGeom.DRange3d, range0: MSPyBentleyGeom.DRange3d, range1: MSPyBentleyGeom.DRange3d) -> None:
        """
        returns the union of two ranges.
        
        :param (input):
        range0 first range
        
        :param (input):
        range1 second range
        """
        ...
    
    def Volume(self: MSPyBentleyGeom.DRange3d) -> float:
        """
        returns product of axis extents. No test for zero or negative axes.
        """
        ...
    
    def XLength(self: MSPyBentleyGeom.DRange3d) -> float:
        """
        Returns difference of high and low in x direction -- 0 if high<low.
        """
        ...
    
    def YLength(self: MSPyBentleyGeom.DRange3d) -> float:
        """
        Returns difference of high and low in y direction -- 0 if high<low.
        """
        ...
    
    def ZLength(self: MSPyBentleyGeom.DRange3d) -> float:
        """
        Returns difference of high and low in z direction -- 0 if high<low.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DRange3d) -> None
        
        2. __init__(self: MSPyBentleyGeom.DRange3d, point: MSPyBentleyGeom.DPoint3d) -> None
        
        3. __init__(self: MSPyBentleyGeom.DRange3d, point0: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d) -> None
        
        4. __init__(self: MSPyBentleyGeom.DRange3d, point0: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d) -> None
        
        5. __init__(self: MSPyBentleyGeom.DRange3d, x: float, y: float, z: float) -> None
        
        6. __init__(self: MSPyBentleyGeom.DRange3d, x0: float, y0: float, z0: float, x1: float, y1: float, z1: float) -> None
        
        7. __init__(self: MSPyBentleyGeom.DRange3d, points: MSPyBentleyGeom.DPoint2dArray, zVal: float) -> None
        
        8. __init__(self: MSPyBentleyGeom.DRange3d, points: MSPyBentleyGeom.DPoint3dArray) -> None
        
        9. __init__(self: MSPyBentleyGeom.DRange3d, points: MSPyBentleyGeom.DPoint4dArray) -> None
        
        10. __init__(self: MSPyBentleyGeom.DRange3d, points: MSPyBentleyGeom.DPoint3dVecArray) -> None
        
        11. __init__(self: MSPyBentleyGeom.DRange3d, points: MSPyBentleyGeom.DPoint3dVecVecArray) -> None
        
        12. __init__(self: MSPyBentleyGeom.DRange3d, points: List[MSPyBentleyGeom.DPoint3d], weights: List[float]) -> None
        
        13. __init__(self: MSPyBentleyGeom.DRange3d, transform: Transform, points: List[MSPyBentleyGeom.DPoint3d], weights: List[float]) -> None
        
        14. __init__(self: MSPyBentleyGeom.DRange3d, transform: Transform, points: MSPyBentleyGeom.DPoint3dArray) -> None
        
        15. __init__(self: MSPyBentleyGeom.DRange3d, transform: Transform, points: MSPyBentleyGeom.DPoint4dArray) -> None
        """
        ...
    
    @property
    def high(arg0: MSPyBentleyGeom.DRange3d) -> MSPyBentleyGeom.DPoint3d:
        ...
    @high.setter
    def high(arg0: MSPyBentleyGeom.DRange3d, arg1: MSPyBentleyGeom.DPoint3d) -> MSPyBentleyGeom.DPoint3d:
        ...
    
    @property
    def low(arg0: MSPyBentleyGeom.DRange3d) -> MSPyBentleyGeom.DPoint3d:
        ...
    @low.setter
    def low(arg0: MSPyBentleyGeom.DRange3d, arg1: MSPyBentleyGeom.DPoint3d) -> MSPyBentleyGeom.DPoint3d:
        ...
    
class DRange3dSizeSize:
    """
    None
    """

    def Get(self: MSPyBentleyGeom.DRange3dSizeSize) -> MSPyBentleyGeom.DRange3d:
        ...
    
    def GetCR(self: MSPyBentleyGeom.DRange3dSizeSize) -> MSPyBentleyGeom.DRange3d:
        ...
    
    def GetTag(self: MSPyBentleyGeom.DRange3dSizeSize, tagA: bool) -> int:
        ...
    
    def GetTagA(self: MSPyBentleyGeom.DRange3dSizeSize) -> int:
        ...
    
    def GetTagB(self: MSPyBentleyGeom.DRange3dSizeSize) -> int:
        ...
    
    def Set(self: MSPyBentleyGeom.DRange3dSizeSize, value: MSPyBentleyGeom.DRange3d) -> None:
        ...
    
    def SetTagA(self: MSPyBentleyGeom.DRange3dSizeSize, tag: int) -> None:
        ...
    
    def SetTagB(self: MSPyBentleyGeom.DRange3dSizeSize, tag: int) -> None:
        ...
    
    def SwapTags(self: MSPyBentleyGeom.DRange3dSizeSize) -> None:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DRange3dSizeSize) -> None
        
        2. __init__(self: MSPyBentleyGeom.DRange3dSizeSize, value: MSPyBentleyGeom.DRange3d, tagA: int, tagB: int) -> None
        """
        ...
    
class DRay3d:
    """
    None
    """

    @staticmethod
    def ClosestApproachUnboundedRayBoundedSegment(ray: MSPyBentleyGeom.DRay3d, segment: DSegment3d) -> tuple:
        """
        :param (output):
        fractionRay computed fraction on (unbounded) ray
        
        :param (output):
        fractionSegment computed fraction on (bounded) segment
        
        :param (output):
        pointRay computed point on (unbounded) ray
        
        :param (output):
        pointSegment computed point on (bounded) segment
        
        :param (input):
        ray unbounded ray
        
        :param (input):
        segment bounded segment
        """
        ...
    
    @staticmethod
    def ClosestApproachUnboundedRayUnboundedRay(rayA: MSPyBentleyGeom.DRay3d, rayB: MSPyBentleyGeom.DRay3d) -> tuple:
        """
        :param (output):
        fractionA computed fraction on (unbounded) ray
        
        :param (output):
        fractionB computed fraction on (bounded) segment
        
        :param (output):
        pointA computed point on (unbounded) ray
        
        :param (output):
        pointB computed point on (bounded) segment
        
        :param (input):
        rayA unbounded ray
        
        :param (input):
        rayB bounded segment
        
        :returns:
        false (with rayA start projected to rayB) if parallel rays.
        """
        ...
    
    def DirectionDotVector(self: MSPyBentleyGeom.DRay3d, vector: DVec3d) -> float:
        """
        :param (input):
        vector
        
        :returns:
        dot product of (unnormalized) ray vector with input vector.
        """
        ...
    
    def DirectionDotVectorToTarget(self: MSPyBentleyGeom.DRay3d, target: MSPyBentleyGeom.DPoint3d) -> float:
        """
        :param (input):
        target
        
        :returns:
        dot product of (unnormalized) ray vector with vector from ray
        origin to given point.
        """
        ...
    
    def EvaluateEndPoints(self: MSPyBentleyGeom.DRay3d, point0: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d) -> None:
        """
        Return the origin and target of the ray.
        """
        ...
    
    def FractionParameterToPoint(self: MSPyBentleyGeom.DRay3d, param: float) -> MSPyBentleyGeom.DPoint3d:
        """
        :param (input):
        param fractional parameter
        
        :returns:
        evaluated point.
        """
        ...
    
    @staticmethod
    def FromIinterpolateWithScaledDifference(point0: MSPyBentleyGeom.DPoint3d, fraction: float, point1: MSPyBentleyGeom.DPoint3d, vectorScale: float) -> MSPyBentleyGeom.DRay3d:
        """
        Return a ray with origin interpolated between points. The ray
        direction is the point0 to point1 vector scaled by vectorScale
        """
        ...
    
    def InitFrom(self: MSPyBentleyGeom.DRay3d, segment: DSegment3d) -> None:
        """
        Initialize a ray from a segment.
        """
        ...
    
    def InitFromOriginAndTarget(*args, **kwargs):
        """
        Overloaded function.
        
        1. InitFromOriginAndTarget(self: MSPyBentleyGeom.DRay3d, point0: MSPyBentleyGeom.DPoint2d, point1: MSPyBentleyGeom.DPoint2d) -> None
        
        Initialize a ray from 2d endpoints
        
        2. InitFromOriginAndTarget(self: MSPyBentleyGeom.DRay3d, point0: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d) -> None
        
        Initialize a ray from 2d endpoints
        """
        ...
    
    def InitFromOriginAndVector(self: MSPyBentleyGeom.DRay3d, origin: MSPyBentleyGeom.DPoint3d, vector: DVec3d) -> None:
        """
        Initialize a ray from origina and vector
        """
        ...
    
    def InitFromPlanePlaneIntersection(self: MSPyBentleyGeom.DRay3d, planeA: MSPyBentleyGeom.DPlane3d, planeB: MSPyBentleyGeom.DPlane3d) -> bool:
        """
        Initialize as intersection of two planes.
        
        :returns:
        false if planes are parallel.
        """
        ...
    
    def Intersect(self: MSPyBentleyGeom.DRay3d, plane: MSPyBentleyGeom.DPlane3d) -> tuple:
        """
        Return the intersection of the (unbounded) ray with a plane.
        
        :param (output):
        intPoint intersection point
        
        :param (output):
        intParam parameter along the ray
        
        :param (input):
        plane plane (origin and normal)
        
        :returns:
        false if ray, plane are parallel.
        """
        ...
    
    def IntersectCircleXY(self: MSPyBentleyGeom.DRay3d, center: MSPyBentleyGeom.DPoint3d, radius: float) -> list:
        ...
    
    def IntersectZPlane(self: MSPyBentleyGeom.DRay3d, frame: Transform, localZ: float) -> tuple:
        """
        Return the intersection of this ray with a specified z plane of a
        coordinate frame.
        
        :param (input):
        frame coordinate frame, e.g. often called localWorldFrame for an
        object
        
        :param (input):
        localZ z coordinate in local frame (e.g. 0 for local xy plane
        pierce point.)
        
        :param (output):
        uvw local uvw coordinates. (w matches input z)
        
        :param (output):
        t parameter along ray.
        
        :returns:
        true if the ray is not parallel to the plane
        """
        ...
    
    def ProjectPointBounded(self: MSPyBentleyGeom.DRay3d, point: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        Project a point onto the bounded line in 3D. If nearest point of
        extended line is outside the 0..1 parameter range, returned values are
        for nearest endpoint.
        
        :param (output):
        closestPoint computed point
        
        :param (output):
        closestParam fraction parameter at closest point.
        
        :param (input):
        point space point
        """
        ...
    
    def ProjectPointUnBounded(self: MSPyBentleyGeom.DRay3d, point: MSPyBentleyGeom.DPoint3d) -> tuple:
        ...
    
    def ValidatedNormalize(self: MSPyBentleyGeom.DRay3d) -> MSPyBentleyGeom.ValidatedDRay3d:
        """
        Return a (validated) copy with normalized direction.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DRay3d) -> None
        
        2. __init__(self: MSPyBentleyGeom.DRay3d, segment: DSegment3d) -> None
        
        3. __init__(self: MSPyBentleyGeom.DRay3d, origin: MSPyBentleyGeom.DPoint3d, vector: DVec3d) -> None
        
        4. __init__(self: MSPyBentleyGeom.DRay3d, point0: MSPyBentleyGeom.DPoint2d, point1: MSPyBentleyGeom.DPoint2d) -> None
        
        5. __init__(self: MSPyBentleyGeom.DRay3d, point0: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d) -> None
        """
        ...
    
    @property
    def direction(self: MSPyBentleyGeom.DRay3d) -> DVec3d:
        ...
    @direction.setter
    def direction(self: MSPyBentleyGeom.DRay3d, arg0: DVec3d) -> None:
        ...
    
    @property
    def origin(self: MSPyBentleyGeom.DRay3d) -> MSPyBentleyGeom.DPoint3d:
        ...
    @origin.setter
    def origin(self: MSPyBentleyGeom.DRay3d, arg0: MSPyBentleyGeom.DPoint3d) -> None:
        ...
    
class DSPiral2dViennese:
    """
    None
    """

    class ASLSACollector:
        """
        None
        """
    
        def Collect(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector, centerA: MSPyBentleyGeom.DPoint3d, arcToSpiralA: MSPyBentleyGeom.DPoint3d, sprialA: MSPyBentleyGeom.DSpiral2dBase, sprialToLineA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, arcToSpiralB: MSPyBentleyGeom.DPoint3d, spiralB: MSPyBentleyGeom.DSpiral2dBase, spiralToLibeB: MSPyBentleyGeom.DPoint3d) -> None:
            ...
        
        def __init__(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> None:
            ...
        
    def ArcSpiralLineSpiralArcTransition(centerA: MSPyBentleyGeom.DPoint3d, radiusA: float, lengthA: float, centerB: MSPyBentleyGeom.DPoint3d, radiusB: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, collector: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> int:
        ...
    
    def Clone(self: MSPyBentleyGeom.DSpiral2dBase) -> MSPyBentleyGeom.DSpiral2dBase:
        ...
    
    def ClosestPoint(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, spiralToWorld: Transform, spacePoint: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        Compute the closest spiral point for a given space point.
        
        :param (input):
        spiral spiral to evaluate.
        
        :param (input):
        startFraction start fraction of search range
        
        :param (input):
        endFraction endFraction of search range
        
        :param (input):
        spiralToWorld transform placing the spiral local coordinates into
        the world coordinate system
        
        :param (input):
        spacePoint world coordinates of space point.
        
        :param (output):
        spiralPoint world coordinates of closest point on spiral
        
        :param (output):
        spiralFraction fractional coordinates of closest point on spiral
        
        :param (output):
        minDistance distance from space point to spiralPoint.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def CopyBaseParameters(self: MSPyBentleyGeom.DSpiral2dBase, pSource: MSPyBentleyGeom.DSpiral2dBase) -> None:
        ...
    
    def CreateBearingCurvatureBearingCurvature(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float, extraData: MSPyBentleyGeom.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def CreateBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float, extraData: MSPyBentleyGeom.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def DefaultStrokeAngle() -> float:
        ...
    
    def DistanceToCurvature(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToCurvatureDerivative(self: MSPyBentleyGeom.DSpiral2dBase, arg0: float) -> float:
        """
        distance
        """
        ...
    
    def DistanceToFraction(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToGlobalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToLocalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(s: float, length: float, curvature1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: DVec2d, d2XY: DVec2d, d3XY: DVec2d) -> bool:
        """
        (input) distance for evaluation (input) nominal length. ASSUMED NONZERO (input)
        exit curvature. ASSUMED NONZERO (output) coordinates on spiral (output)
        first derivative wrt distance (output) second derivative wrt distance
        (output) third derivative wrt distance
        """
        ...
    
    def EvaluateVectorIntegrand(self: MSPyBentleyGeom.DSpiral2dBase, distance: float, pF: float) -> None:
        ...
    
    @staticmethod
    def FillExtraDataArray(extraData: MSPyBentleyGeom.DoubleArray, cant: float, h: float, e: float) -> None:
        """
        Return the extra data array for the parameters of a viennese spiral
        """
        ...
    
    def FractionToDerivatives(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float, dXdf: DVec2d, ddXdfdf: DVec2d, dddXdfdfdf: DVec2d) -> bool:
        ...
    
    def FractionToDistance(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float) -> float:
        ...
    
    def GetExtraData(self: MSPyBentleyGeom.DSpiral2dBase, extraData: MSPyBentleyGeom.DoubleArray) -> None:
        """
        Get the extra data for this spiral. REMARK:This should be a virtual,
        but is implemented as special cases because of API change restriction
        """
        ...
    
    def GetIntervalCount(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, minInterval: int = 0, maxStrokeLength: float = 10000.0) -> int:
        """
        Return an interval count for stroking or integration. Except for
        degenerate single interval cases, the interval count is always even.
        That is the possible values are
        
        :param (input):
        spiral spiral being queried.
        
        :param (input):
        startFraction start of interval to stroke.
        
        :param (input):
        endFraction end of interval to stroke.
        
        :param (input):
        maxRadians max turn between strokes.
        
        :param (input):
        minInterval smallest number of intervals.
        
        :param (input):
        maxStrokeLength largest stroke size. Recommended 10 meters
        """
        ...
    
    def GetTransitionTypeCode(self: MSPyBentleyGeom.DSpiral2dBase) -> int:
        ...
    
    def GetVectorIntegrandCount(self: MSPyBentleyGeom.DSpiral2dBase) -> int:
        ...
    
    def IsValidRLCombination(lengthFromInflection: float, radius: float, spiralType: int = 0) -> bool:
        """
        test if a length-from-inflection and final radius
        combination is " small enough " for reasonable use. Test depends on
        spiral type:
        
        * DSpiral2dBase.TransitionType_None indicates apply the strictest
        test (same as Czech and Italian)
        
        * DSpiral2dBase.TransitionType_Czech and
        DSpiral2dBase.TransitionType_Italian indicate a strict test L<2*R
        
        * other types have no restrictions.
        
        :param (input):
        lengthFromInflection (input) distance along spiral starting at
        inflection and ending at finalRadius.
        
        :param (input):
        finalRadius (input) final radius
        
        :param (input):
        spiralType (input) spiral type.
        
        :param (input):
        lengthFactor expansion or reduction factor to apply to the allowed
        length. +---------------+---------------+---------------+---------
        ------+------
        """
        ...
    
    def LineSpiralArcSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, radius: float, lengthA: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralAToArc: MSPyBentleyGeom.DPoint3d, spiralBToArc: MSPyBentleyGeom.DPoint3d, arc: MSPyBentleyGeom.DEllipse3d) -> bool:
        """
        compute spirals and arc to make a line-to-line
        transition.
        
        :param (input):
        lineAPoint point on line A.
        
        :param (input):
        lineBPoint point on line B.
        
        :param (input):
        lineLineIntersection intersection of lines.
        
        :param (input):
        radius radius for circular part of transition.
        
        :param (input):
        lengthA length of spiral from line A to circle.
        
        :param (input):
        lengthB length of spiral from line B to circle.
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        lineToSpiralA tangency point from line to spiral
        
        :param (output):
        spiralAToArc tangency point from spiral to arc
        
        :param (output):
        lineToSpiralB tangency point from line to spiral
        
        :param (output):
        spiralBToArc tangency point from spiral to arc
        
        :param (output):
        arc arc between spirals.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def ScaleInPlace(self: MSPyBentleyGeom.DSpiral2dBase, s: float) -> bool:
        ...
    
    def SetBearingAndCurvatureLimits(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, theta1: float, curvature1: float) -> bool:
        ...
    
    def SetBearingCurvatureLengthBearing(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, theta1: float) -> bool:
        """
        Set start bearing, start curvature, length, and end
        curvature. (Compute end bearing)
        
        :param (input):
        theta0 start bearing
        
        :param (input):
        curvature0 start curvature
        
        :param (input):
        length arc length
        
        :param (input):
        theta1 end bearing
        """
        ...
    
    def SetBearingCurvatureLengthCurvature(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, curvature1: float) -> bool:
        ...
    
    def StringToTransitionType(name: str) -> int:
        """
        return the integer code for the string name.
        """
        ...
    
    def Stroke(*args, **kwargs):
        """
        Overloaded function.
        
        1. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, pDXY: DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        2. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, xyz0: MSPyBentleyGeom.DPoint3d, pXYZ: MSPyBentleyGeom.DPoint3d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        3. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: DVec2d) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        4. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        5. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: DVec2d, pFraction: float, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        6. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: DVec2d, maxStrokeLength: float) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        7. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, uvPoints: List[DVec2d], fractions: MSPyBentleyGeom.DoubleArray, maxStrokeLength: float = 10000.0) -> tuple
        """
        ...
    
    def StrokeToAnnouncer(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, F: MSPyBentleyGeom.AnnounceDoubleDPoint2d, minIndex: int = 0, maxStrokeLength: float = 10000.0) -> tuple:
        """
        Integrate the vector displacements of a clothoid over a
        fractional interval. This uses the angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        startFraction start fraction for integral.
        
        :param (input):
        endFraction end fraction for integral.
        
        :param (input):
        maxRadians maximum bearing change between computed points. A
        default is used if 0.0 is passed.
        
        :param (input):
        F object with a method F->Announce (f, uv) called to announce
        fraction and coordinate as computed.
        
        :param (output):
        errorBound estimated bound on error.
        
        :param (output):
        minInterval smallest number of intervals allowed
        
        :param (output):
        maxStrokeLength maximum allowed stroke length
        
        :returns:
        false if point integration failed
        """
        ...
    
    def SymmetricLineSpiralSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, length: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralToSpiral: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        compute spirals and arc to make a line-to-line
        transition.
        
        :param (input):
        lineAPoint point on line A.
        
        :param (input):
        lineBPoint point on line B.
        
        :param (input):
        lineLineIntersection intersection of lines.
        
        :param (input):
        length length of spiral from line A to junction
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        lineToSpiralA tangency point from line to spiral
        
        :param (output):
        lineToSpiralB tangency point from line to spiral
        
        :param (output):
        spiralToSpiral tangency point from spiral to to spiral
        
        :param (output):
        junctionRadius radius at transition between the spirals.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def SymmetricPointShoulderTargetTransition(startPoint: MSPyBentleyGeom.DPoint2d, shoulderPoint: MSPyBentleyGeom.DPoint2d, targetPoint: MSPyBentleyGeom.DPoint2d, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, junctionPoint: MSPyBentleyGeom.DPoint2d, endPoint: MSPyBentleyGeom.DPoint2d) -> bool:
        """
        compute 2 spirals.
        
        :param (input):
        startPoint start point
        
        :param (input):
        shoulderPoint target point for first and last tangents
        
        :param (input):
        targetPoint target point for last tangent
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        junctionPoint transition between spirals. This is the max
        curvature point.
        
        :param (output):
        endPoint end of second spiral.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def TransitionTypeToString(type: int) -> str:
        """
        return the string name of the type
        """
        ...
    
    TransitionType_Arema: int
    
    TransitionType_AustralianRailCorp: int
    
    TransitionType_Biquadratic: int
    
    TransitionType_Bloss: int
    
    TransitionType_ChineseCubic: int
    
    TransitionType_Clothoid: int
    
    TransitionType_Cosine: int
    
    TransitionType_Czech: int
    
    TransitionType_CzechAlongTangent: int
    
    TransitionType_DirectHalfCosine: int
    
    TransitionType_FirstDirectEvaluate: int
    
    TransitionType_Italian: int
    
    TransitionType_JapaneseCubic: int
    
    TransitionType_MXCubicAlongArc: int
    
    TransitionType_MXCubicAlongTangent: int
    
    TransitionType_PolishCubic: int
    
    TransitionType_Sine: int
    
    TransitionType_Unknown: int
    
    TransitionType_Viennese: int
    
    TransitionType_WeightedViennese: int
    
    TransitionType_WesternAustralian: int
    
    def VectorIntegrandCount(self: MSPyBentleyGeom.BSIVectorIntegrand) -> int:
        ...
    
    def __init__(self: MSPyBentleyGeom.DSPiral2dViennese, cant: float, h: float, e: float) -> None:
        ...
    
    @property
    def mLength(arg0: MSPyBentleyGeom.DSpiral2dBase) -> float:
        ...
    
class DSPiral2dWeightedViennese:
    """
    None
    """

    class ASLSACollector:
        """
        None
        """
    
        def Collect(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector, centerA: MSPyBentleyGeom.DPoint3d, arcToSpiralA: MSPyBentleyGeom.DPoint3d, sprialA: MSPyBentleyGeom.DSpiral2dBase, sprialToLineA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, arcToSpiralB: MSPyBentleyGeom.DPoint3d, spiralB: MSPyBentleyGeom.DSpiral2dBase, spiralToLibeB: MSPyBentleyGeom.DPoint3d) -> None:
            ...
        
        def __init__(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> None:
            ...
        
    def ArcSpiralLineSpiralArcTransition(centerA: MSPyBentleyGeom.DPoint3d, radiusA: float, lengthA: float, centerB: MSPyBentleyGeom.DPoint3d, radiusB: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, collector: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> int:
        ...
    
    def Clone(self: MSPyBentleyGeom.DSpiral2dBase) -> MSPyBentleyGeom.DSpiral2dBase:
        ...
    
    def ClosestPoint(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, spiralToWorld: Transform, spacePoint: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        Compute the closest spiral point for a given space point.
        
        :param (input):
        spiral spiral to evaluate.
        
        :param (input):
        startFraction start fraction of search range
        
        :param (input):
        endFraction endFraction of search range
        
        :param (input):
        spiralToWorld transform placing the spiral local coordinates into
        the world coordinate system
        
        :param (input):
        spacePoint world coordinates of space point.
        
        :param (output):
        spiralPoint world coordinates of closest point on spiral
        
        :param (output):
        spiralFraction fractional coordinates of closest point on spiral
        
        :param (output):
        minDistance distance from space point to spiralPoint.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def CopyBaseParameters(self: MSPyBentleyGeom.DSpiral2dBase, pSource: MSPyBentleyGeom.DSpiral2dBase) -> None:
        ...
    
    def CreateBearingCurvatureBearingCurvature(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float, extraData: MSPyBentleyGeom.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def CreateBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float, extraData: MSPyBentleyGeom.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def DefaultStrokeAngle() -> float:
        ...
    
    def DistanceToCurvature(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToCurvatureDerivative(self: MSPyBentleyGeom.DSpiral2dBase, arg0: float) -> float:
        """
        distance
        """
        ...
    
    def DistanceToFraction(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToGlobalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToLocalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(s: float, length: float, curvature1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: DVec2d, d2XY: DVec2d, d3XY: DVec2d) -> bool:
        """
        (input) distance for evaluation (input) nominal length. ASSUMED NONZERO (input)
        exit curvature. ASSUMED NONZERO (output) coordinates on spiral (output)
        first derivative wrt distance (output) second derivative wrt distance
        (output) third derivative wrt distance
        """
        ...
    
    def EvaluateVectorIntegrand(self: MSPyBentleyGeom.DSpiral2dBase, distance: float, pF: float) -> None:
        ...
    
    @staticmethod
    def FillExtraDataArray(extraData: MSPyBentleyGeom.DoubleArray, cant: float, h: float, e: float, weight0: float, weight1: float) -> None:
        """
        Return the extra data array for the parameters of a weighted viennese
        spiral
        """
        ...
    
    def FractionToDerivatives(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float, dXdf: DVec2d, ddXdfdf: DVec2d, dddXdfdfdf: DVec2d) -> bool:
        ...
    
    def FractionToDistance(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float) -> float:
        ...
    
    def GetExtraData(self: MSPyBentleyGeom.DSpiral2dBase, extraData: MSPyBentleyGeom.DoubleArray) -> None:
        """
        Get the extra data for this spiral. REMARK:This should be a virtual,
        but is implemented as special cases because of API change restriction
        """
        ...
    
    def GetIntervalCount(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, minInterval: int = 0, maxStrokeLength: float = 10000.0) -> int:
        """
        Return an interval count for stroking or integration. Except for
        degenerate single interval cases, the interval count is always even.
        That is the possible values are
        
        :param (input):
        spiral spiral being queried.
        
        :param (input):
        startFraction start of interval to stroke.
        
        :param (input):
        endFraction end of interval to stroke.
        
        :param (input):
        maxRadians max turn between strokes.
        
        :param (input):
        minInterval smallest number of intervals.
        
        :param (input):
        maxStrokeLength largest stroke size. Recommended 10 meters
        """
        ...
    
    def GetTransitionTypeCode(self: MSPyBentleyGeom.DSpiral2dBase) -> int:
        ...
    
    def GetVectorIntegrandCount(self: MSPyBentleyGeom.DSpiral2dBase) -> int:
        ...
    
    def IsValidRLCombination(lengthFromInflection: float, radius: float, spiralType: int = 0) -> bool:
        """
        test if a length-from-inflection and final radius
        combination is " small enough " for reasonable use. Test depends on
        spiral type:
        
        * DSpiral2dBase.TransitionType_None indicates apply the strictest
        test (same as Czech and Italian)
        
        * DSpiral2dBase.TransitionType_Czech and
        DSpiral2dBase.TransitionType_Italian indicate a strict test L<2*R
        
        * other types have no restrictions.
        
        :param (input):
        lengthFromInflection (input) distance along spiral starting at
        inflection and ending at finalRadius.
        
        :param (input):
        finalRadius (input) final radius
        
        :param (input):
        spiralType (input) spiral type.
        
        :param (input):
        lengthFactor expansion or reduction factor to apply to the allowed
        length. +---------------+---------------+---------------+---------
        ------+------
        """
        ...
    
    def LineSpiralArcSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, radius: float, lengthA: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralAToArc: MSPyBentleyGeom.DPoint3d, spiralBToArc: MSPyBentleyGeom.DPoint3d, arc: MSPyBentleyGeom.DEllipse3d) -> bool:
        """
        compute spirals and arc to make a line-to-line
        transition.
        
        :param (input):
        lineAPoint point on line A.
        
        :param (input):
        lineBPoint point on line B.
        
        :param (input):
        lineLineIntersection intersection of lines.
        
        :param (input):
        radius radius for circular part of transition.
        
        :param (input):
        lengthA length of spiral from line A to circle.
        
        :param (input):
        lengthB length of spiral from line B to circle.
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        lineToSpiralA tangency point from line to spiral
        
        :param (output):
        spiralAToArc tangency point from spiral to arc
        
        :param (output):
        lineToSpiralB tangency point from line to spiral
        
        :param (output):
        spiralBToArc tangency point from spiral to arc
        
        :param (output):
        arc arc between spirals.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def ScaleInPlace(self: MSPyBentleyGeom.DSpiral2dBase, s: float) -> bool:
        ...
    
    def SetBearingAndCurvatureLimits(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, theta1: float, curvature1: float) -> bool:
        ...
    
    def SetBearingCurvatureLengthBearing(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, theta1: float) -> bool:
        """
        Set start bearing, start curvature, length, and end
        curvature. (Compute end bearing)
        
        :param (input):
        theta0 start bearing
        
        :param (input):
        curvature0 start curvature
        
        :param (input):
        length arc length
        
        :param (input):
        theta1 end bearing
        """
        ...
    
    def SetBearingCurvatureLengthCurvature(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, curvature1: float) -> bool:
        ...
    
    def StringToTransitionType(name: str) -> int:
        """
        return the integer code for the string name.
        """
        ...
    
    def Stroke(*args, **kwargs):
        """
        Overloaded function.
        
        1. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, pDXY: DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        2. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, xyz0: MSPyBentleyGeom.DPoint3d, pXYZ: MSPyBentleyGeom.DPoint3d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        3. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: DVec2d) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        4. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        5. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: DVec2d, pFraction: float, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        6. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: DVec2d, maxStrokeLength: float) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        7. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, uvPoints: List[DVec2d], fractions: MSPyBentleyGeom.DoubleArray, maxStrokeLength: float = 10000.0) -> tuple
        """
        ...
    
    def StrokeToAnnouncer(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, F: MSPyBentleyGeom.AnnounceDoubleDPoint2d, minIndex: int = 0, maxStrokeLength: float = 10000.0) -> tuple:
        """
        Integrate the vector displacements of a clothoid over a
        fractional interval. This uses the angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        startFraction start fraction for integral.
        
        :param (input):
        endFraction end fraction for integral.
        
        :param (input):
        maxRadians maximum bearing change between computed points. A
        default is used if 0.0 is passed.
        
        :param (input):
        F object with a method F->Announce (f, uv) called to announce
        fraction and coordinate as computed.
        
        :param (output):
        errorBound estimated bound on error.
        
        :param (output):
        minInterval smallest number of intervals allowed
        
        :param (output):
        maxStrokeLength maximum allowed stroke length
        
        :returns:
        false if point integration failed
        """
        ...
    
    def SymmetricLineSpiralSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, length: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralToSpiral: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        compute spirals and arc to make a line-to-line
        transition.
        
        :param (input):
        lineAPoint point on line A.
        
        :param (input):
        lineBPoint point on line B.
        
        :param (input):
        lineLineIntersection intersection of lines.
        
        :param (input):
        length length of spiral from line A to junction
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        lineToSpiralA tangency point from line to spiral
        
        :param (output):
        lineToSpiralB tangency point from line to spiral
        
        :param (output):
        spiralToSpiral tangency point from spiral to to spiral
        
        :param (output):
        junctionRadius radius at transition between the spirals.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def SymmetricPointShoulderTargetTransition(startPoint: MSPyBentleyGeom.DPoint2d, shoulderPoint: MSPyBentleyGeom.DPoint2d, targetPoint: MSPyBentleyGeom.DPoint2d, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, junctionPoint: MSPyBentleyGeom.DPoint2d, endPoint: MSPyBentleyGeom.DPoint2d) -> bool:
        """
        compute 2 spirals.
        
        :param (input):
        startPoint start point
        
        :param (input):
        shoulderPoint target point for first and last tangents
        
        :param (input):
        targetPoint target point for last tangent
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        junctionPoint transition between spirals. This is the max
        curvature point.
        
        :param (output):
        endPoint end of second spiral.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def TransitionTypeToString(type: int) -> str:
        """
        return the string name of the type
        """
        ...
    
    TransitionType_Arema: int
    
    TransitionType_AustralianRailCorp: int
    
    TransitionType_Biquadratic: int
    
    TransitionType_Bloss: int
    
    TransitionType_ChineseCubic: int
    
    TransitionType_Clothoid: int
    
    TransitionType_Cosine: int
    
    TransitionType_Czech: int
    
    TransitionType_CzechAlongTangent: int
    
    TransitionType_DirectHalfCosine: int
    
    TransitionType_FirstDirectEvaluate: int
    
    TransitionType_Italian: int
    
    TransitionType_JapaneseCubic: int
    
    TransitionType_MXCubicAlongArc: int
    
    TransitionType_MXCubicAlongTangent: int
    
    TransitionType_PolishCubic: int
    
    TransitionType_Sine: int
    
    TransitionType_Unknown: int
    
    TransitionType_Viennese: int
    
    TransitionType_WeightedViennese: int
    
    TransitionType_WesternAustralian: int
    
    def VectorIntegrandCount(self: MSPyBentleyGeom.BSIVectorIntegrand) -> int:
        ...
    
    def __init__(self: MSPyBentleyGeom.DSPiral2dWeightedViennese, cant: float, h: float, e: float, weight0: float, weight1: float) -> None:
        ...
    
    @property
    def mLength(arg0: MSPyBentleyGeom.DSpiral2dBase) -> float:
        ...
    
class DSegment1d:
    """
    None
    """

    def BetweenFractions(self: MSPyBentleyGeom.DSegment1d, f0: float, f1: float) -> MSPyBentleyGeom.DSegment1d:
        """
        Return a segment with endpoints at fractions of input segment.
        """
        ...
    
    def Delta(self: MSPyBentleyGeom.DSegment1d) -> float:
        """
        Return signed distance from start to end
        """
        ...
    
    @staticmethod
    def DirectedOverlap(primary: MSPyBentleyGeom.DSegment1d, clipper: MSPyBentleyGeom.DSegment1d, result: MSPyBentleyGeom.DSegment1d) -> bool:
        """
        Find overlap of primary with clipper. If empty, return false and
        primary unchanged. If nonempty, result maintains orientation of
        primary. Note that single point intersection is non-empty.
        """
        ...
    
    @property
    def End(arg0: MSPyBentleyGeom.DSegment1d) -> float:
        ...
    @End.setter
    def End(arg0: MSPyBentleyGeom.DSegment1d, arg1: float) -> None:
        ...
    
    def EndPointProduct(self: MSPyBentleyGeom.DSegment1d, x: float) -> float:
        """
        return (x-x0) * (x-x1). This is negative " inside " the interval
        """
        ...
    
    def FractionToPoint(self: MSPyBentleyGeom.DSegment1d, fraction: float) -> float:
        """
        Return coordinate at fractional parameter from start to end.
        """
        ...
    
    def GetEnd(self: MSPyBentleyGeom.DSegment1d) -> float:
        """
        Return end coordinate.
        """
        ...
    
    def GetStart(self: MSPyBentleyGeom.DSegment1d) -> float:
        """
        Return start coordinate.
        """
        ...
    
    def IsEqual(self: MSPyBentleyGeom.DSegment1d, other: MSPyBentleyGeom.DSegment1d) -> bool:
        """
        Exact equality test.
        """
        ...
    
    def IsReversed(self: MSPyBentleyGeom.DSegment1d, other: MSPyBentleyGeom.DSegment1d) -> bool:
        """
        Exact equality test for reversed coordinates.
        """
        ...
    
    def IsStrictInterior(self: MSPyBentleyGeom.DSegment1d, x: float) -> bool:
        """
        Test if the EndPointProduct is strictly negative
        """
        ...
    
    def Length(self: MSPyBentleyGeom.DSegment1d) -> float:
        """
        Return absolute length of the segment.
        """
        ...
    
    @staticmethod
    def NonZeroDirectedOverlap(primary: MSPyBentleyGeom.DSegment1d, clipper: MSPyBentleyGeom.DSegment1d, result: MSPyBentleyGeom.DSegment1d) -> bool:
        """
        Find overlap of primary with clipper, treating single point
        intersection as empty. If empty or single point, return false and
        primary unchanged. If nonempty, result maintains orientation of
        primary.
        """
        ...
    
    def PointToFraction(self: MSPyBentleyGeom.DSegment1d, point: float) -> tuple:
        """
        Find fractional parameter for specified coordinate.
        
        :returns:
        false if endpoints are identical.
        """
        ...
    
    def Reverse(self: MSPyBentleyGeom.DSegment1d) -> MSPyBentleyGeom.DSegment1d:
        """
        return reverse of the instance
        """
        ...
    
    def ReverseInPlace(self: MSPyBentleyGeom.DSegment1d) -> None:
        """
        reverse the instance in place
        """
        ...
    
    def SetEnd(self: MSPyBentleyGeom.DSegment1d, x: float) -> None:
        """
        Change end coordinate.
        """
        ...
    
    def SetStart(self: MSPyBentleyGeom.DSegment1d, x: float) -> None:
        """
        Change start coordinate.
        """
        ...
    
    @property
    def Start(arg0: MSPyBentleyGeom.DSegment1d) -> float:
        ...
    @Start.setter
    def Start(arg0: MSPyBentleyGeom.DSegment1d, arg1: float) -> None:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DSegment1d) -> None
        
        2. __init__(self: MSPyBentleyGeom.DSegment1d, x: float) -> None
        
        3. __init__(self: MSPyBentleyGeom.DSegment1d, x0: float, x1: float) -> None
        """
        ...
    
class DSegment1dArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DSegment1dArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.DSegment1dArray, arg0: MSPyBentleyGeom.DSegment1dArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.DSegment1dArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.DSegment1dArray, x: MSPyBentleyGeom.DSegment1d) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.DSegment1dArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.DSegment1dArray, L: MSPyBentleyGeom.DSegment1dArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.DSegment1dArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.DSegment1dArray, i: int, x: MSPyBentleyGeom.DSegment1d) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.DSegment1dArray) -> MSPyBentleyGeom.DSegment1d
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.DSegment1dArray, i: int) -> MSPyBentleyGeom.DSegment1d
        
        Remove and return the item at index ``i``
        """
        ...
    
class DSegment3d:
    """
    None
    """

    @staticmethod
    def ClosestApproachBounded(segment0: MSPyBentleyGeom.DSegment3d, segment1: MSPyBentleyGeom.DSegment3d) -> tuple:
        """
        Find the closest approach of two bounded segments
        
        :param (output):
        fraction0 parameter on first segment.
        
        :param (output):
        fraction1 parameter on second segment.
        
        :param (output):
        point0 point on first ray.
        
        :param (output):
        point1 point on second ray.
        
        :param (output):
        segment0 first segment
        
        :param (output):
        segment1 second segment
        """
        ...
    
    @staticmethod
    def ClosestApproachBoundedXY(segment0: MSPyBentleyGeom.DSegment3d, segment1: MSPyBentleyGeom.DSegment3d) -> tuple:
        """
        Find the closest approach of two bounded segments, considering only xy
        parts of distance
        
        :param (output):
        fraction0 parameter on first segment
        
        :param (output):
        fraction1 parameter on second segment
        
        :param (output):
        point0 point on first ray.
        
        :param (output):
        point1 point on second ray.
        
        :param (output):
        segment0 first segment
        
        :param (output):
        segment1 second segment
        """
        ...
    
    @staticmethod
    def ClosestApproachUnbounded(segment0: MSPyBentleyGeom.DSegment3d, segment1: MSPyBentleyGeom.DSegment3d) -> tuple:
        """
        Find the closest approach of two unbounded segments
        
        :param (output):
        fraction0 parameter on first segment.
        
        :param (output):
        fraction1 parameter on second segment.
        
        :param (output):
        point0 point on first ray.
        
        :param (output):
        point1 point on second ray.
        
        :param (output):
        segment0 first segment
        
        :param (output):
        segment1 second segment
        
        :returns:
        false if parallel segments
        """
        ...
    
    def ClosestPointBoundedXY(*args, **kwargs):
        """
        Overloaded function.
        
        1. ClosestPointBoundedXY(self: MSPyBentleyGeom.DSegment3d, spacePoint: MSPyBentleyGeom.DPoint3d, worldToLocal: MSPyBentleyGeom.DMatrix4d) -> tuple
        
        Find the closest point (projection or end), as viewed in xy plane,
        after applying optional transformation.
        
        :param (output):
        closePoint closest point, in coordinates of the input segment.
        
        :param (output):
        closeParam parameter at closest point
        
        :param (output):
        distanceXY distance in transformed coordinates
        
        :param (input):
        spacePoint world coordinates of test point.
        
        :param (input):
        worldToLocal optional transformation.
        
        2. ClosestPointBoundedXY(self: MSPyBentleyGeom.DSegment3d, spacePoint: MSPyBentleyGeom.DPoint3d, worldToLocal: MSPyBentleyGeom.DMatrix4d, extend0: bool, extend1: bool) -> tuple
        
        Find the closest point (projection or end), as viewed in xy plane,
        after applying optional transformation.
        
        :param (output):
        closePoint closest point, in coordinates of the input segment.
        
        :param (output):
        closeParam parameter at closest point
        
        :param (output):
        distanceXY distance in transformed coordinates
        
        :param (input):
        spacePoint world coordinates of test point.
        
        :param (input):
        worldToLocal optional transformation.
        """
        ...
    
    @property
    def EndPoint(arg0: MSPyBentleyGeom.DSegment3d) -> MSPyBentleyGeom.DPoint3d:
        ...
    @EndPoint.setter
    def EndPoint(arg0: MSPyBentleyGeom.DSegment3d, arg1: MSPyBentleyGeom.DPoint3d) -> None:
        ...
    
    def FractionParameterToPoint(self: MSPyBentleyGeom.DSegment3d, point: MSPyBentleyGeom.DPoint3d, param: float) -> bool:
        """
        :param (output):
        point coordinates at fractional parameter.
        
        :param (input):
        param fractional parameter
        
        Remark:
        This is a deprecated form of FractionToPoint.
        """
        ...
    
    def FractionParameterToTangent(self: MSPyBentleyGeom.DSegment3d, point: MSPyBentleyGeom.DPoint3d, tangent: DVec3d, param: float) -> bool:
        """
        :param (output):
        point point on line at fractional parameter.
        
        :param (output):
        tangent tangent vector at fractional parameter.
        
        :param (input):
        param fractional parameter.
        """
        ...
    
    def FractionToLength(self: MSPyBentleyGeom.DSegment3d, fraction0: float, fraction1: float) -> tuple:
        """
        Compute the (signed) arc length between specified fractional
        parameters.
        
        :param (output):
        arcLength computed arc length. Negative if fraction1<fraction0.
        
        :param (input):
        fraction0 start fraction for interval to measure.
        
        :param (input):
        fraction1 end fraction for interval to measure.
        
        :returns:
        true if the arc length was computed.
        """
        ...
    
    def FractionToPoint(self: MSPyBentleyGeom.DSegment3d, fraction: float) -> MSPyBentleyGeom.DPoint3d:
        """
        :returns:
        point coordinates at fractional parameter.
        
        :param (input):
        fraction fractional parameter
        """
        ...
    
    def GetEndPoint(self: MSPyBentleyGeom.DSegment3d, pt: MSPyBentleyGeom.DPoint3d) -> None:
        """
        Get end point from the line segment.
        
        :param (output):
        pt end point of object.
        """
        ...
    
    def GetEndPoints(self: MSPyBentleyGeom.DSegment3d, point0: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d) -> None:
        """
        Return the endpoints of the segment.
        
        :param (output):
        point0 start point
        
        :param (output):
        point1 end point
        """
        ...
    
    def GetPoint(self: MSPyBentleyGeom.DSegment3d, pt: MSPyBentleyGeom.DPoint3d, index: int) -> bool:
        """
        :param (output):
        pt returned point.
        
        :param (input):
        index index of point to return.
        """
        ...
    
    def GetRange(self: MSPyBentleyGeom.DSegment3d, range: MSPyBentleyGeom.DRange3d) -> bool:
        """
        :param (output):
        range range of segment.
        
        :returns:
        always true
        """
        ...
    
    def GetStartPoint(self: MSPyBentleyGeom.DSegment3d, pt: MSPyBentleyGeom.DPoint3d) -> None:
        """
        Get start point from the line segment.
        
        :param (output):
        pt start point of object.
        """
        ...
    
    def Init(*args, **kwargs):
        """
        Overloaded function.
        
        1. Init(self: MSPyBentleyGeom.DSegment3d, x0: float, y0: float, z0: float, x1: float, y1: float, z1: float) -> None
        
        2. Init(self: MSPyBentleyGeom.DSegment3d, point0: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d) -> None
        
        3. Init(self: MSPyBentleyGeom.DSegment3d, point0: MSPyBentleyGeom.DPoint2d, point1: MSPyBentleyGeom.DPoint2d) -> None
        """
        ...
    
    def InitFrom(self: MSPyBentleyGeom.DSegment3d, ray: MSPyBentleyGeom.DRay3d) -> None:
        ...
    
    def InitFromOriginAndDirection(self: MSPyBentleyGeom.DSegment3d, point0: MSPyBentleyGeom.DPoint3d, tangent: MSPyBentleyGeom.DPoint3d) -> None:
        ...
    
    def InitProduct(self: MSPyBentleyGeom.DSegment3d, transform: Transform, other: MSPyBentleyGeom.DSegment3d) -> None:
        """
        initialize as transform of other segment.
        """
        ...
    
    def InterpolateUniformArray(self: MSPyBentleyGeom.DSegment3d, points: MSPyBentleyGeom.DPoint3dArray, numPoints: int) -> None:
        """
        Computes equidistant points along the segment.
        
        :param (output):
        points array of computed points
        
        :param (input):
        numPoints # points to compute.
        """
        ...
    
    def Intersect(self: MSPyBentleyGeom.DSegment3d, point: MSPyBentleyGeom.DPlane3d) -> tuple:
        """
        Return the intersection of the (unbounded) segment with a plane.
        
        :param (input):
        intPoint intersection point
        
        :param (input):
        intParam parameter along the line
        
        :param (input):
        plane plane (origin and normal)
        
        :returns:
        false if line, plane are parallel.
        """
        ...
    
    def IntersectCircleXY(self: MSPyBentleyGeom.DSegment3d, center: MSPyBentleyGeom.DPoint3d, radius: float) -> list:
        ...
    
    @staticmethod
    def IntersectXY(segment0: MSPyBentleyGeom.DSegment3d, segment1: MSPyBentleyGeom.DSegment3d) -> tuple:
        """
        Return the (simple, single point) intersection of two (unbounded)
        segments as viewed in XY. (z coordinates of the outputs pointA and
        pointB may differ)
        
        :param (output):
        fractionA fractional position on segmentA
        
        :param (output):
        fractionB fractional position on segmentB
        
        :param (output):
        pointA point on segmentA
        
        :param (output):
        pointB point on segmentB
        
        :param (input):
        segmentA first line segment.
        
        :param (input):
        segmentB second line segment.
        
        :returns:
        false if segments are parallel.
        """
        ...
    
    def IsAlmostEqual(self: MSPyBentleyGeom.DSegment3d, other: MSPyBentleyGeom.DSegment3d, tolerance: float) -> bool:
        """
        :returns:
        true if AlmostEqual endpoints
        """
        ...
    
    def IsAlmostSinglePoint(self: MSPyBentleyGeom.DSegment3d) -> bool:
        """
        :returns:
        true if endpoint are AlmostEqual()
        """
        ...
    
    def IsSinglePoint(self: MSPyBentleyGeom.DSegment3d) -> bool:
        """
        :returns:
        true if endpoint are identical (bitwise)
        """
        ...
    
    def Length(self: MSPyBentleyGeom.DSegment3d) -> float:
        """
        :returns:
        line segment length.
        """
        ...
    
    def LengthSquared(self: MSPyBentleyGeom.DSegment3d) -> float:
        """
        :returns:
        squared length of the segment.
        """
        ...
    
    def LengthToFraction(self: MSPyBentleyGeom.DSegment3d, fraction0: float, arcStep: float) -> tuple:
        """
        Compute the fraction parameter corresponding to a specified arc length
        away from a specified start fraction. (inverse of fractions to
        arcStep)
        
        :param (output):
        fraction1 fraction at end of interval.
        
        :param (input):
        fraction0 start fraction for interval to measure.
        
        :param (input):
        arcStep arc length to move. Negative arc length moves backwards.
        
        :returns:
        true if the fractional step was computed.
        """
        ...
    
    def PointToFractionParameter(self: MSPyBentleyGeom.DSegment3d, point: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        Returns the parameter at which a point projects to the
        *unbounded) line containing the segment. Parameters less than zero and
        greater than one mean the projection is outside the bounds of the line
        segment.
        
        :param (output):
        param fraction where point projects to the line.
        
        :param (input):
        point point to project to the line.
        """
        ...
    
    def ProjectPoint(self: MSPyBentleyGeom.DSegment3d, point: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        Project a point onto the extended line in 3D.
        
        :param (output):
        closestPoint point on extended line
        
        :param (output):
        closestParam parameter for closest point
        
        :param (input):
        point space point.
        """
        ...
    
    def ProjectPointBounded(*args, **kwargs):
        """
        Overloaded function.
        
        1. ProjectPointBounded(self: MSPyBentleyGeom.DSegment3d, point: MSPyBentleyGeom.DPoint3d) -> tuple
        
        Project a point onto the bounded line in 3D. If nearest point of
        extended line is outside the 0..1 parameter range, returned values are
        optinally restricted to nearest endpoint.
        
        :param (output):
        closestPoint point on extended line
        
        :param (output):
        closestParam parameter for closest point
        
        :param (input):
        point space point.
        
        :param (input):
        extend0 true to extend backwards before 0
        
        :param (input):
        extend1 true to extend forwards from 1
        
        2. ProjectPointBounded(self: MSPyBentleyGeom.DSegment3d, point: MSPyBentleyGeom.DPoint3d, extend0: bool, extend1: bool) -> tuple
        
        Project a point onto the bounded line in 3D. If nearest point of
        extended line is outside the 0..1 parameter range, returned values are
        optinally restricted to nearest endpoint.
        
        :param (output):
        closestPoint point on extended line
        
        :param (output):
        closestParam parameter for closest point
        
        :param (input):
        point space point.
        
        :param (input):
        extend0 true to extend backwards before 0
        
        :param (input):
        extend1 true to extend forwards from 1
        """
        ...
    
    def ProjectPointXY(self: MSPyBentleyGeom.DSegment3d, point: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        Project a point onto the extended line using only xy parts.
        
        :param (output):
        closestPoint point on extended line
        
        :param (output):
        closestParam parameter for closest point
        
        :param (input):
        point space point.
        """
        ...
    
    def ProjectedParameterRange(self: MSPyBentleyGeom.DSegment3d, ray: MSPyBentleyGeom.DRay3d) -> MSPyBentleyGeom.DRange1d:
        """
        :returns:
        range when projected to fraction space of the ray
        
        :param (input):
        ray
        """
        ...
    
    def SetEndPoint(self: MSPyBentleyGeom.DSegment3d, point: MSPyBentleyGeom.DPoint3d) -> None:
        """
        Set the " end " point for the line segment.
        
        :param point:
        new end point.
        """
        ...
    
    def SetPoint(self: MSPyBentleyGeom.DSegment3d, pt: MSPyBentleyGeom.DPoint3d, index: int) -> bool:
        """
        :param (output):
        pt returned point.
        
        :param (input):
        index index of point to return.
        """
        ...
    
    def SetStartPoint(self: MSPyBentleyGeom.DSegment3d, point: MSPyBentleyGeom.DPoint3d) -> None:
        """
        Set the " start " point for the line segment.
        
        :param point:
        new start point.
        """
        ...
    
    @property
    def StartPoint(arg0: MSPyBentleyGeom.DSegment3d) -> MSPyBentleyGeom.DPoint3d:
        ...
    @StartPoint.setter
    def StartPoint(arg0: MSPyBentleyGeom.DSegment3d, arg1: MSPyBentleyGeom.DPoint3d) -> None:
        ...
    
    def WireCentroid(self: MSPyBentleyGeom.DSegment3d, fraction0: float = 0.0, fraction1: float = 1.0) -> tuple:
        """
        Compute the length (unit density) and wire centroid. Note that a zero
        length line has zero length but the (single) coordinate is a well
        defined centroid.
        
        :param (output):
        length line length.
        
        :param (output):
        centroid centroid point.
        
        :param (input):
        fraction0 start fraction for interval to measure.
        
        :param (input):
        fraction1 end fraction for interval to measure.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DSegment3d) -> None
        
        2. __init__(self: MSPyBentleyGeom.DSegment3d, ray: MSPyBentleyGeom.DRay3d) -> None
        
        3. __init__(self: MSPyBentleyGeom.DSegment3d, x0: float, y0: float, z0: float, x1: float, y1: float, z1: float) -> None
        
        4. __init__(self: MSPyBentleyGeom.DSegment3d, point0: MSPyBentleyGeom.DPoint2d, point1: MSPyBentleyGeom.DPoint2d) -> None
        
        5. __init__(self: MSPyBentleyGeom.DSegment3d, point0: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d) -> None
        
        6. __init__(self: MSPyBentleyGeom.DSegment3d, point0: MSPyBentleyGeom.DPoint3d, tangent: MSPyBentleyGeom.DPoint3d) -> None
        
        7. __init__(self: MSPyBentleyGeom.DSegment3d, parent: MSPyBentleyGeom.DSegment3d, startFraction: float, endFraction: float) -> None
        
        8. __init__(self: MSPyBentleyGeom.DSegment3d, parent: MSPyBentleyGeom.DSegment3d, interval: MSPyBentleyGeom.DSegment1d) -> None
        """
        ...
    
    @property
    def point(arg0: MSPyBentleyGeom.DSegment3d) -> tuple:
        ...
    @point.setter
    def point(arg0: MSPyBentleyGeom.DSegment3d, arg1: numpy.typing.NDArray) -> None:
        ...
    
class DSegment3dArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DSegment3dArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.DSegment3dArray, arg0: MSPyBentleyGeom.DSegment3dArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.DSegment3dArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.DSegment3dArray, x: MSPyBentleyGeom.DSegment3d) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.DSegment3dArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.DSegment3dArray, L: MSPyBentleyGeom.DSegment3dArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.DSegment3dArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.DSegment3dArray, i: int, x: MSPyBentleyGeom.DSegment3d) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.DSegment3dArray) -> MSPyBentleyGeom.DSegment3d
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.DSegment3dArray, i: int) -> MSPyBentleyGeom.DSegment3d
        
        Remove and return the item at index ``i``
        """
        ...
    
class DSpiral2dArema:
    """
    None
    """

    class ASLSACollector:
        """
        None
        """
    
        def Collect(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector, centerA: MSPyBentleyGeom.DPoint3d, arcToSpiralA: MSPyBentleyGeom.DPoint3d, sprialA: MSPyBentleyGeom.DSpiral2dBase, sprialToLineA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, arcToSpiralB: MSPyBentleyGeom.DPoint3d, spiralB: MSPyBentleyGeom.DSpiral2dBase, spiralToLibeB: MSPyBentleyGeom.DPoint3d) -> None:
            ...
        
        def __init__(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> None:
            ...
        
    def ApplyCCWRotation(radians: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: DVec2d, d2XYZ: DVec2d, d3XYZ: DVec2d) -> None:
        """
        rotate xy and optional derivatives by radians. (To be called by
        derived class EvaluateAtDistance when to rotate EvaluateAtDistance
        results from standard position)
        """
        ...
    
    def ArcSpiralLineSpiralArcTransition(centerA: MSPyBentleyGeom.DPoint3d, radiusA: float, lengthA: float, centerB: MSPyBentleyGeom.DPoint3d, radiusB: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, collector: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> int:
        ...
    
    def Clone(self: MSPyBentleyGeom.DSpiral2dBase) -> MSPyBentleyGeom.DSpiral2dBase:
        ...
    
    def ClosestPoint(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, spiralToWorld: Transform, spacePoint: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        Compute the closest spiral point for a given space point.
        
        :param (input):
        spiral spiral to evaluate.
        
        :param (input):
        startFraction start fraction of search range
        
        :param (input):
        endFraction endFraction of search range
        
        :param (input):
        spiralToWorld transform placing the spiral local coordinates into
        the world coordinate system
        
        :param (input):
        spacePoint world coordinates of space point.
        
        :param (output):
        spiralPoint world coordinates of closest point on spiral
        
        :param (output):
        spiralFraction fractional coordinates of closest point on spiral
        
        :param (output):
        minDistance distance from space point to spiralPoint.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def CopyBaseParameters(self: MSPyBentleyGeom.DSpiral2dBase, pSource: MSPyBentleyGeom.DSpiral2dBase) -> None:
        ...
    
    def CreateBearingCurvatureBearingCurvature(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float, extraData: MSPyBentleyGeom.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def CreateBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float, extraData: MSPyBentleyGeom.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def DefaultStrokeAngle() -> float:
        ...
    
    def DistanceToCurvature(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToCurvatureDerivative(self: MSPyBentleyGeom.DSpiral2dBase, arg0: float) -> float:
        """
        distance
        """
        ...
    
    def DistanceToFraction(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToGlobalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToLocalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def EvaluateAtFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: DVec2d, d2XYZ: DVec2d, d3XYZ: DVec2d) -> bool:
        """
        Evaluate the spiral and derivatives at specified fractional position
        return true if valid evaluation. DSpiral2dDirectEvaluation default
        implementation returns false.
        """
        ...
    
    def EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(s: float, length: float, curvature1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: DVec2d, d2XY: DVec2d, d3XY: DVec2d) -> bool:
        """
        (input) distance for evaluation (input) nominal length. ASSUMED NONZERO (input)
        exit curvature. ASSUMED NONZERO (output) coordinates on spiral (output)
        first derivative wrt distance (output) second derivative wrt distance
        (output) third derivative wrt distance
        """
        ...
    
    def EvaluateVectorIntegrand(self: MSPyBentleyGeom.DSpiral2dBase, distance: float, pF: float) -> None:
        ...
    
    def FractionToCurvature(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float:
        """
        Return the true curvature at fractional position. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDCurvatureDFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> tuple:
        """
        Return the true curvature derivative wrt fraction. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDerivatives(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float, dXdf: DVec2d, ddXdfdf: DVec2d, dddXdfdfdf: DVec2d) -> bool:
        ...
    
    def FractionToDistance(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float) -> float:
        ...
    
    def FractionToLocalAngle(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float:
        """
        Return the tangent angle (in radians) in local coordinates
        """
        ...
    
    def FractionToVelocity(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float:
        """
        Return the magnitude of the true derivative of position wrt fraction.
        Implemented in DSpiral2dDirectEvaluation, not individual classes.
        Assume EvaluateAtFraction.
        """
        ...
    
    def GetExtraData(self: MSPyBentleyGeom.DSpiral2dBase, extraData: MSPyBentleyGeom.DoubleArray) -> None:
        """
        Get the extra data for this spiral. REMARK:This should be a virtual,
        but is implemented as special cases because of API change restriction
        """
        ...
    
    def GetIntervalCount(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, minInterval: int = 0, maxStrokeLength: float = 10000.0) -> int:
        """
        Return an interval count for stroking or integration. Except for
        degenerate single interval cases, the interval count is always even.
        That is the possible values are
        
        :param (input):
        spiral spiral being queried.
        
        :param (input):
        startFraction start of interval to stroke.
        
        :param (input):
        endFraction end of interval to stroke.
        
        :param (input):
        maxRadians max turn between strokes.
        
        :param (input):
        minInterval smallest number of intervals.
        
        :param (input):
        maxStrokeLength largest stroke size. Recommended 10 meters
        """
        ...
    
    def GetTransitionTypeCode(self: MSPyBentleyGeom.DSpiral2dBase) -> int:
        ...
    
    def GetVectorIntegrandCount(self: MSPyBentleyGeom.DSpiral2dBase) -> int:
        ...
    
    def IsValidRLCombination(lengthFromInflection: float, radius: float, spiralType: int = 0) -> bool:
        """
        test if a length-from-inflection and final radius
        combination is " small enough " for reasonable use. Test depends on
        spiral type:
        
        * DSpiral2dBase.TransitionType_None indicates apply the strictest
        test (same as Czech and Italian)
        
        * DSpiral2dBase.TransitionType_Czech and
        DSpiral2dBase.TransitionType_Italian indicate a strict test L<2*R
        
        * other types have no restrictions.
        
        :param (input):
        lengthFromInflection (input) distance along spiral starting at
        inflection and ending at finalRadius.
        
        :param (input):
        finalRadius (input) final radius
        
        :param (input):
        spiralType (input) spiral type.
        
        :param (input):
        lengthFactor expansion or reduction factor to apply to the allowed
        length. +---------------+---------------+---------------+---------
        ------+------
        """
        ...
    
    def LineSpiralArcSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, radius: float, lengthA: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralAToArc: MSPyBentleyGeom.DPoint3d, spiralBToArc: MSPyBentleyGeom.DPoint3d, arc: MSPyBentleyGeom.DEllipse3d) -> bool:
        """
        compute spirals and arc to make a line-to-line
        transition.
        
        :param (input):
        lineAPoint point on line A.
        
        :param (input):
        lineBPoint point on line B.
        
        :param (input):
        lineLineIntersection intersection of lines.
        
        :param (input):
        radius radius for circular part of transition.
        
        :param (input):
        lengthA length of spiral from line A to circle.
        
        :param (input):
        lengthB length of spiral from line B to circle.
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        lineToSpiralA tangency point from line to spiral
        
        :param (output):
        spiralAToArc tangency point from spiral to arc
        
        :param (output):
        lineToSpiralB tangency point from line to spiral
        
        :param (output):
        spiralBToArc tangency point from spiral to arc
        
        :param (output):
        arc arc between spirals.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def ScaleInPlace(self: MSPyBentleyGeom.DSpiral2dBase, s: float) -> bool:
        ...
    
    def SetBearingAndCurvatureLimits(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, theta1: float, curvature1: float) -> bool:
        ...
    
    def SetBearingCurvatureLengthBearing(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, theta1: float) -> bool:
        """
        Set start bearing, start curvature, length, and end
        curvature. (Compute end bearing)
        
        :param (input):
        theta0 start bearing
        
        :param (input):
        curvature0 start curvature
        
        :param (input):
        length arc length
        
        :param (input):
        theta1 end bearing
        """
        ...
    
    def SetBearingCurvatureLengthCurvature(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, curvature1: float) -> bool:
        ...
    
    def StringToTransitionType(name: str) -> int:
        """
        return the integer code for the string name.
        """
        ...
    
    def Stroke(*args, **kwargs):
        """
        Overloaded function.
        
        1. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, pDXY: DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        2. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, xyz0: MSPyBentleyGeom.DPoint3d, pXYZ: MSPyBentleyGeom.DPoint3d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        3. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: DVec2d) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        4. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        5. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: DVec2d, pFraction: float, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        6. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: DVec2d, maxStrokeLength: float) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        7. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, uvPoints: List[DVec2d], fractions: MSPyBentleyGeom.DoubleArray, maxStrokeLength: float = 10000.0) -> tuple
        """
        ...
    
    def StrokeToAnnouncer(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, F: MSPyBentleyGeom.AnnounceDoubleDPoint2d, minIndex: int = 0, maxStrokeLength: float = 10000.0) -> tuple:
        """
        Integrate the vector displacements of a clothoid over a
        fractional interval. This uses the angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        startFraction start fraction for integral.
        
        :param (input):
        endFraction end fraction for integral.
        
        :param (input):
        maxRadians maximum bearing change between computed points. A
        default is used if 0.0 is passed.
        
        :param (input):
        F object with a method F->Announce (f, uv) called to announce
        fraction and coordinate as computed.
        
        :param (output):
        errorBound estimated bound on error.
        
        :param (output):
        minInterval smallest number of intervals allowed
        
        :param (output):
        maxStrokeLength maximum allowed stroke length
        
        :returns:
        false if point integration failed
        """
        ...
    
    def SymmetricLineSpiralSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, length: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralToSpiral: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        compute spirals and arc to make a line-to-line
        transition.
        
        :param (input):
        lineAPoint point on line A.
        
        :param (input):
        lineBPoint point on line B.
        
        :param (input):
        lineLineIntersection intersection of lines.
        
        :param (input):
        length length of spiral from line A to junction
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        lineToSpiralA tangency point from line to spiral
        
        :param (output):
        lineToSpiralB tangency point from line to spiral
        
        :param (output):
        spiralToSpiral tangency point from spiral to to spiral
        
        :param (output):
        junctionRadius radius at transition between the spirals.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def SymmetricPointShoulderTargetTransition(startPoint: MSPyBentleyGeom.DPoint2d, shoulderPoint: MSPyBentleyGeom.DPoint2d, targetPoint: MSPyBentleyGeom.DPoint2d, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, junctionPoint: MSPyBentleyGeom.DPoint2d, endPoint: MSPyBentleyGeom.DPoint2d) -> bool:
        """
        compute 2 spirals.
        
        :param (input):
        startPoint start point
        
        :param (input):
        shoulderPoint target point for first and last tangents
        
        :param (input):
        targetPoint target point for last tangent
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        junctionPoint transition between spirals. This is the max
        curvature point.
        
        :param (output):
        endPoint end of second spiral.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def TransitionTypeToString(type: int) -> str:
        """
        return the string name of the type
        """
        ...
    
    TransitionType_Arema: int
    
    TransitionType_AustralianRailCorp: int
    
    TransitionType_Biquadratic: int
    
    TransitionType_Bloss: int
    
    TransitionType_ChineseCubic: int
    
    TransitionType_Clothoid: int
    
    TransitionType_Cosine: int
    
    TransitionType_Czech: int
    
    TransitionType_CzechAlongTangent: int
    
    TransitionType_DirectHalfCosine: int
    
    TransitionType_FirstDirectEvaluate: int
    
    TransitionType_Italian: int
    
    TransitionType_JapaneseCubic: int
    
    TransitionType_MXCubicAlongArc: int
    
    TransitionType_MXCubicAlongTangent: int
    
    TransitionType_PolishCubic: int
    
    TransitionType_Sine: int
    
    TransitionType_Unknown: int
    
    TransitionType_Viennese: int
    
    TransitionType_WeightedViennese: int
    
    TransitionType_WesternAustralian: int
    
    def VectorIntegrandCount(self: MSPyBentleyGeom.BSIVectorIntegrand) -> int:
        ...
    
    def __init__(self: MSPyBentleyGeom.DSpiral2dArema, nominalLength: float) -> None:
        ...
    
    @property
    def mLength(arg0: MSPyBentleyGeom.DSpiral2dBase) -> float:
        ...
    
class DSpiral2dAustralianRailCorp:
    """
    None
    """

    class ASLSACollector:
        """
        None
        """
    
        def Collect(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector, centerA: MSPyBentleyGeom.DPoint3d, arcToSpiralA: MSPyBentleyGeom.DPoint3d, sprialA: MSPyBentleyGeom.DSpiral2dBase, sprialToLineA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, arcToSpiralB: MSPyBentleyGeom.DPoint3d, spiralB: MSPyBentleyGeom.DSpiral2dBase, spiralToLibeB: MSPyBentleyGeom.DPoint3d) -> None:
            ...
        
        def __init__(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> None:
            ...
        
    def ApplyCCWRotation(radians: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: DVec2d, d2XYZ: DVec2d, d3XYZ: DVec2d) -> None:
        """
        rotate xy and optional derivatives by radians. (To be called by
        derived class EvaluateAtDistance when to rotate EvaluateAtDistance
        results from standard position)
        """
        ...
    
    def ArcSpiralLineSpiralArcTransition(centerA: MSPyBentleyGeom.DPoint3d, radiusA: float, lengthA: float, centerB: MSPyBentleyGeom.DPoint3d, radiusB: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, collector: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> int:
        ...
    
    def Clone(self: MSPyBentleyGeom.DSpiral2dBase) -> MSPyBentleyGeom.DSpiral2dBase:
        ...
    
    def ClosestPoint(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, spiralToWorld: Transform, spacePoint: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        Compute the closest spiral point for a given space point.
        
        :param (input):
        spiral spiral to evaluate.
        
        :param (input):
        startFraction start fraction of search range
        
        :param (input):
        endFraction endFraction of search range
        
        :param (input):
        spiralToWorld transform placing the spiral local coordinates into
        the world coordinate system
        
        :param (input):
        spacePoint world coordinates of space point.
        
        :param (output):
        spiralPoint world coordinates of closest point on spiral
        
        :param (output):
        spiralFraction fractional coordinates of closest point on spiral
        
        :param (output):
        minDistance distance from space point to spiralPoint.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def CopyBaseParameters(self: MSPyBentleyGeom.DSpiral2dBase, pSource: MSPyBentleyGeom.DSpiral2dBase) -> None:
        ...
    
    def CreateBearingCurvatureBearingCurvature(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float, extraData: MSPyBentleyGeom.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def CreateBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float, extraData: MSPyBentleyGeom.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def DefaultStrokeAngle() -> float:
        ...
    
    def DistanceToCurvature(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToCurvatureDerivative(self: MSPyBentleyGeom.DSpiral2dBase, arg0: float) -> float:
        """
        distance
        """
        ...
    
    def DistanceToFraction(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToGlobalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToLocalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def EvaluateAtFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: DVec2d, d2XYZ: DVec2d, d3XYZ: DVec2d) -> bool:
        """
        Evaluate the spiral and derivatives at specified fractional position
        return true if valid evaluation. DSpiral2dDirectEvaluation default
        implementation returns false.
        """
        ...
    
    def EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(s: float, length: float, curvature1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: DVec2d, d2XY: DVec2d, d3XY: DVec2d) -> bool:
        """
        (input) distance for evaluation (input) nominal length. ASSUMED NONZERO (input)
        exit curvature. ASSUMED NONZERO (output) coordinates on spiral (output)
        first derivative wrt distance (output) second derivative wrt distance
        (output) third derivative wrt distance
        """
        ...
    
    def EvaluateVectorIntegrand(self: MSPyBentleyGeom.DSpiral2dBase, distance: float, pF: float) -> None:
        ...
    
    def FractionToCurvature(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float:
        """
        Return the true curvature at fractional position. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDCurvatureDFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> tuple:
        """
        Return the true curvature derivative wrt fraction. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDerivatives(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float, dXdf: DVec2d, ddXdfdf: DVec2d, dddXdfdfdf: DVec2d) -> bool:
        ...
    
    def FractionToDistance(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float) -> float:
        ...
    
    def FractionToLocalAngle(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float:
        """
        Return the tangent angle (in radians) in local coordinates
        """
        ...
    
    def FractionToVelocity(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float:
        """
        Return the magnitude of the true derivative of position wrt fraction.
        Implemented in DSpiral2dDirectEvaluation, not individual classes.
        Assume EvaluateAtFraction.
        """
        ...
    
    def GetExtraData(self: MSPyBentleyGeom.DSpiral2dBase, extraData: MSPyBentleyGeom.DoubleArray) -> None:
        """
        Get the extra data for this spiral. REMARK:This should be a virtual,
        but is implemented as special cases because of API change restriction
        """
        ...
    
    def GetIntervalCount(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, minInterval: int = 0, maxStrokeLength: float = 10000.0) -> int:
        """
        Return an interval count for stroking or integration. Except for
        degenerate single interval cases, the interval count is always even.
        That is the possible values are
        
        :param (input):
        spiral spiral being queried.
        
        :param (input):
        startFraction start of interval to stroke.
        
        :param (input):
        endFraction end of interval to stroke.
        
        :param (input):
        maxRadians max turn between strokes.
        
        :param (input):
        minInterval smallest number of intervals.
        
        :param (input):
        maxStrokeLength largest stroke size. Recommended 10 meters
        """
        ...
    
    def GetTransitionTypeCode(self: MSPyBentleyGeom.DSpiral2dBase) -> int:
        ...
    
    def GetVectorIntegrandCount(self: MSPyBentleyGeom.DSpiral2dBase) -> int:
        ...
    
    def IsValidRLCombination(lengthFromInflection: float, radius: float, spiralType: int = 0) -> bool:
        """
        test if a length-from-inflection and final radius
        combination is " small enough " for reasonable use. Test depends on
        spiral type:
        
        * DSpiral2dBase.TransitionType_None indicates apply the strictest
        test (same as Czech and Italian)
        
        * DSpiral2dBase.TransitionType_Czech and
        DSpiral2dBase.TransitionType_Italian indicate a strict test L<2*R
        
        * other types have no restrictions.
        
        :param (input):
        lengthFromInflection (input) distance along spiral starting at
        inflection and ending at finalRadius.
        
        :param (input):
        finalRadius (input) final radius
        
        :param (input):
        spiralType (input) spiral type.
        
        :param (input):
        lengthFactor expansion or reduction factor to apply to the allowed
        length. +---------------+---------------+---------------+---------
        ------+------
        """
        ...
    
    def LineSpiralArcSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, radius: float, lengthA: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralAToArc: MSPyBentleyGeom.DPoint3d, spiralBToArc: MSPyBentleyGeom.DPoint3d, arc: MSPyBentleyGeom.DEllipse3d) -> bool:
        """
        compute spirals and arc to make a line-to-line
        transition.
        
        :param (input):
        lineAPoint point on line A.
        
        :param (input):
        lineBPoint point on line B.
        
        :param (input):
        lineLineIntersection intersection of lines.
        
        :param (input):
        radius radius for circular part of transition.
        
        :param (input):
        lengthA length of spiral from line A to circle.
        
        :param (input):
        lengthB length of spiral from line B to circle.
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        lineToSpiralA tangency point from line to spiral
        
        :param (output):
        spiralAToArc tangency point from spiral to arc
        
        :param (output):
        lineToSpiralB tangency point from line to spiral
        
        :param (output):
        spiralBToArc tangency point from spiral to arc
        
        :param (output):
        arc arc between spirals.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def ScaleInPlace(self: MSPyBentleyGeom.DSpiral2dBase, s: float) -> bool:
        ...
    
    def SetBearingAndCurvatureLimits(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, theta1: float, curvature1: float) -> bool:
        ...
    
    def SetBearingCurvatureLengthBearing(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, theta1: float) -> bool:
        """
        Set start bearing, start curvature, length, and end
        curvature. (Compute end bearing)
        
        :param (input):
        theta0 start bearing
        
        :param (input):
        curvature0 start curvature
        
        :param (input):
        length arc length
        
        :param (input):
        theta1 end bearing
        """
        ...
    
    def SetBearingCurvatureLengthCurvature(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, curvature1: float) -> bool:
        ...
    
    def StringToTransitionType(name: str) -> int:
        """
        return the integer code for the string name.
        """
        ...
    
    def Stroke(*args, **kwargs):
        """
        Overloaded function.
        
        1. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, pDXY: DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        2. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, xyz0: MSPyBentleyGeom.DPoint3d, pXYZ: MSPyBentleyGeom.DPoint3d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        3. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: DVec2d) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        4. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        5. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: DVec2d, pFraction: float, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        6. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: DVec2d, maxStrokeLength: float) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        7. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, uvPoints: List[DVec2d], fractions: MSPyBentleyGeom.DoubleArray, maxStrokeLength: float = 10000.0) -> tuple
        """
        ...
    
    def StrokeToAnnouncer(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, F: MSPyBentleyGeom.AnnounceDoubleDPoint2d, minIndex: int = 0, maxStrokeLength: float = 10000.0) -> tuple:
        """
        Integrate the vector displacements of a clothoid over a
        fractional interval. This uses the angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        startFraction start fraction for integral.
        
        :param (input):
        endFraction end fraction for integral.
        
        :param (input):
        maxRadians maximum bearing change between computed points. A
        default is used if 0.0 is passed.
        
        :param (input):
        F object with a method F->Announce (f, uv) called to announce
        fraction and coordinate as computed.
        
        :param (output):
        errorBound estimated bound on error.
        
        :param (output):
        minInterval smallest number of intervals allowed
        
        :param (output):
        maxStrokeLength maximum allowed stroke length
        
        :returns:
        false if point integration failed
        """
        ...
    
    def SymmetricLineSpiralSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, length: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralToSpiral: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        compute spirals and arc to make a line-to-line
        transition.
        
        :param (input):
        lineAPoint point on line A.
        
        :param (input):
        lineBPoint point on line B.
        
        :param (input):
        lineLineIntersection intersection of lines.
        
        :param (input):
        length length of spiral from line A to junction
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        lineToSpiralA tangency point from line to spiral
        
        :param (output):
        lineToSpiralB tangency point from line to spiral
        
        :param (output):
        spiralToSpiral tangency point from spiral to to spiral
        
        :param (output):
        junctionRadius radius at transition between the spirals.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def SymmetricPointShoulderTargetTransition(startPoint: MSPyBentleyGeom.DPoint2d, shoulderPoint: MSPyBentleyGeom.DPoint2d, targetPoint: MSPyBentleyGeom.DPoint2d, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, junctionPoint: MSPyBentleyGeom.DPoint2d, endPoint: MSPyBentleyGeom.DPoint2d) -> bool:
        """
        compute 2 spirals.
        
        :param (input):
        startPoint start point
        
        :param (input):
        shoulderPoint target point for first and last tangents
        
        :param (input):
        targetPoint target point for last tangent
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        junctionPoint transition between spirals. This is the max
        curvature point.
        
        :param (output):
        endPoint end of second spiral.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def TransitionTypeToString(type: int) -> str:
        """
        return the string name of the type
        """
        ...
    
    TransitionType_Arema: int
    
    TransitionType_AustralianRailCorp: int
    
    TransitionType_Biquadratic: int
    
    TransitionType_Bloss: int
    
    TransitionType_ChineseCubic: int
    
    TransitionType_Clothoid: int
    
    TransitionType_Cosine: int
    
    TransitionType_Czech: int
    
    TransitionType_CzechAlongTangent: int
    
    TransitionType_DirectHalfCosine: int
    
    TransitionType_FirstDirectEvaluate: int
    
    TransitionType_Italian: int
    
    TransitionType_JapaneseCubic: int
    
    TransitionType_MXCubicAlongArc: int
    
    TransitionType_MXCubicAlongTangent: int
    
    TransitionType_PolishCubic: int
    
    TransitionType_Sine: int
    
    TransitionType_Unknown: int
    
    TransitionType_Viennese: int
    
    TransitionType_WeightedViennese: int
    
    TransitionType_WesternAustralian: int
    
    def VectorIntegrandCount(self: MSPyBentleyGeom.BSIVectorIntegrand) -> int:
        ...
    
    def __init__(self: MSPyBentleyGeom.DSpiral2dAustralianRailCorp, nominalLength: float) -> None:
        ...
    
    @property
    def mLength(arg0: MSPyBentleyGeom.DSpiral2dBase) -> float:
        ...
    
class DSpiral2dBase:
    """
    None
    """

    class ASLSACollector:
        """
        None
        """
    
        def Collect(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector, centerA: MSPyBentleyGeom.DPoint3d, arcToSpiralA: MSPyBentleyGeom.DPoint3d, sprialA: MSPyBentleyGeom.DSpiral2dBase, sprialToLineA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, arcToSpiralB: MSPyBentleyGeom.DPoint3d, spiralB: MSPyBentleyGeom.DSpiral2dBase, spiralToLibeB: MSPyBentleyGeom.DPoint3d) -> None:
            ...
        
        def __init__(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> None:
            ...
        
    @staticmethod
    def ArcSpiralLineSpiralArcTransition(centerA: MSPyBentleyGeom.DPoint3d, radiusA: float, lengthA: float, centerB: MSPyBentleyGeom.DPoint3d, radiusB: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, collector: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> int:
        ...
    
    def Clone(self: MSPyBentleyGeom.DSpiral2dBase) -> MSPyBentleyGeom.DSpiral2dBase:
        ...
    
    @staticmethod
    def ClosestPoint(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, spiralToWorld: Transform, spacePoint: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        Compute the closest spiral point for a given space point.
        
        :param (input):
        spiral spiral to evaluate.
        
        :param (input):
        startFraction start fraction of search range
        
        :param (input):
        endFraction endFraction of search range
        
        :param (input):
        spiralToWorld transform placing the spiral local coordinates into
        the world coordinate system
        
        :param (input):
        spacePoint world coordinates of space point.
        
        :param (output):
        spiralPoint world coordinates of closest point on spiral
        
        :param (output):
        spiralFraction fractional coordinates of closest point on spiral
        
        :param (output):
        minDistance distance from space point to spiralPoint.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def CopyBaseParameters(self: MSPyBentleyGeom.DSpiral2dBase, pSource: MSPyBentleyGeom.DSpiral2dBase) -> None:
        ...
    
    @staticmethod
    def CreateBearingCurvatureBearingCurvature(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float, extraData: MSPyBentleyGeom.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    @staticmethod
    def CreateBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float, extraData: MSPyBentleyGeom.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    @staticmethod
    def DefaultStrokeAngle() -> float:
        ...
    
    def DistanceToCurvature(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToCurvatureDerivative(self: MSPyBentleyGeom.DSpiral2dBase, arg0: float) -> float:
        """
        distance
        """
        ...
    
    def DistanceToFraction(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToGlobalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToLocalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    @staticmethod
    def EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(s: float, length: float, curvature1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: DVec2d, d2XY: DVec2d, d3XY: DVec2d) -> bool:
        """
        (input) distance for evaluation (input) nominal length. ASSUMED NONZERO (input)
        exit curvature. ASSUMED NONZERO (output) coordinates on spiral (output)
        first derivative wrt distance (output) second derivative wrt distance
        (output) third derivative wrt distance
        """
        ...
    
    def EvaluateVectorIntegrand(self: MSPyBentleyGeom.DSpiral2dBase, distance: float, pF: float) -> None:
        ...
    
    def FractionToDerivatives(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float, dXdf: DVec2d, ddXdfdf: DVec2d, dddXdfdfdf: DVec2d) -> bool:
        ...
    
    def FractionToDistance(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float) -> float:
        ...
    
    def GetExtraData(self: MSPyBentleyGeom.DSpiral2dBase, extraData: MSPyBentleyGeom.DoubleArray) -> None:
        """
        Get the extra data for this spiral. REMARK:This should be a virtual,
        but is implemented as special cases because of API change restriction
        """
        ...
    
    @staticmethod
    def GetIntervalCount(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, minInterval: int = 0, maxStrokeLength: float = 10000.0) -> int:
        """
        Return an interval count for stroking or integration. Except for
        degenerate single interval cases, the interval count is always even.
        That is the possible values are
        
        :param (input):
        spiral spiral being queried.
        
        :param (input):
        startFraction start of interval to stroke.
        
        :param (input):
        endFraction end of interval to stroke.
        
        :param (input):
        maxRadians max turn between strokes.
        
        :param (input):
        minInterval smallest number of intervals.
        
        :param (input):
        maxStrokeLength largest stroke size. Recommended 10 meters
        """
        ...
    
    def GetTransitionTypeCode(self: MSPyBentleyGeom.DSpiral2dBase) -> int:
        ...
    
    def GetVectorIntegrandCount(self: MSPyBentleyGeom.DSpiral2dBase) -> int:
        ...
    
    @staticmethod
    def IsValidRLCombination(lengthFromInflection: float, radius: float, spiralType: int = 0) -> bool:
        """
        test if a length-from-inflection and final radius
        combination is " small enough " for reasonable use. Test depends on
        spiral type:
        
        * DSpiral2dBase.TransitionType_None indicates apply the strictest
        test (same as Czech and Italian)
        
        * DSpiral2dBase.TransitionType_Czech and
        DSpiral2dBase.TransitionType_Italian indicate a strict test L<2*R
        
        * other types have no restrictions.
        
        :param (input):
        lengthFromInflection (input) distance along spiral starting at
        inflection and ending at finalRadius.
        
        :param (input):
        finalRadius (input) final radius
        
        :param (input):
        spiralType (input) spiral type.
        
        :param (input):
        lengthFactor expansion or reduction factor to apply to the allowed
        length. +---------------+---------------+---------------+---------
        ------+------
        """
        ...
    
    @staticmethod
    def LineSpiralArcSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, radius: float, lengthA: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralAToArc: MSPyBentleyGeom.DPoint3d, spiralBToArc: MSPyBentleyGeom.DPoint3d, arc: MSPyBentleyGeom.DEllipse3d) -> bool:
        """
        compute spirals and arc to make a line-to-line
        transition.
        
        :param (input):
        lineAPoint point on line A.
        
        :param (input):
        lineBPoint point on line B.
        
        :param (input):
        lineLineIntersection intersection of lines.
        
        :param (input):
        radius radius for circular part of transition.
        
        :param (input):
        lengthA length of spiral from line A to circle.
        
        :param (input):
        lengthB length of spiral from line B to circle.
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        lineToSpiralA tangency point from line to spiral
        
        :param (output):
        spiralAToArc tangency point from spiral to arc
        
        :param (output):
        lineToSpiralB tangency point from line to spiral
        
        :param (output):
        spiralBToArc tangency point from spiral to arc
        
        :param (output):
        arc arc between spirals.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def ScaleInPlace(self: MSPyBentleyGeom.DSpiral2dBase, s: float) -> bool:
        ...
    
    def SetBearingAndCurvatureLimits(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, theta1: float, curvature1: float) -> bool:
        ...
    
    def SetBearingCurvatureLengthBearing(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, theta1: float) -> bool:
        """
        Set start bearing, start curvature, length, and end
        curvature. (Compute end bearing)
        
        :param (input):
        theta0 start bearing
        
        :param (input):
        curvature0 start curvature
        
        :param (input):
        length arc length
        
        :param (input):
        theta1 end bearing
        """
        ...
    
    def SetBearingCurvatureLengthCurvature(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, curvature1: float) -> bool:
        ...
    
    @staticmethod
    def StringToTransitionType(name: str) -> int:
        """
        return the integer code for the string name.
        """
        ...
    
    @staticmethod
    def Stroke(*args, **kwargs):
        """
        Overloaded function.
        
        1. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, pDXY: DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        2. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, xyz0: MSPyBentleyGeom.DPoint3d, pXYZ: MSPyBentleyGeom.DPoint3d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        3. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: DVec2d) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        4. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        5. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: DVec2d, pFraction: float, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        6. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: DVec2d, maxStrokeLength: float) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        7. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, uvPoints: List[DVec2d], fractions: MSPyBentleyGeom.DoubleArray, maxStrokeLength: float = 10000.0) -> tuple
        """
        ...
    
    @staticmethod
    def StrokeToAnnouncer(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, F: MSPyBentleyGeom.AnnounceDoubleDPoint2d, minIndex: int = 0, maxStrokeLength: float = 10000.0) -> tuple:
        """
        Integrate the vector displacements of a clothoid over a
        fractional interval. This uses the angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        startFraction start fraction for integral.
        
        :param (input):
        endFraction end fraction for integral.
        
        :param (input):
        maxRadians maximum bearing change between computed points. A
        default is used if 0.0 is passed.
        
        :param (input):
        F object with a method F->Announce (f, uv) called to announce
        fraction and coordinate as computed.
        
        :param (output):
        errorBound estimated bound on error.
        
        :param (output):
        minInterval smallest number of intervals allowed
        
        :param (output):
        maxStrokeLength maximum allowed stroke length
        
        :returns:
        false if point integration failed
        """
        ...
    
    @staticmethod
    def SymmetricLineSpiralSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, length: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralToSpiral: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        compute spirals and arc to make a line-to-line
        transition.
        
        :param (input):
        lineAPoint point on line A.
        
        :param (input):
        lineBPoint point on line B.
        
        :param (input):
        lineLineIntersection intersection of lines.
        
        :param (input):
        length length of spiral from line A to junction
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        lineToSpiralA tangency point from line to spiral
        
        :param (output):
        lineToSpiralB tangency point from line to spiral
        
        :param (output):
        spiralToSpiral tangency point from spiral to to spiral
        
        :param (output):
        junctionRadius radius at transition between the spirals.
        
        :returns:
        false if unable to construct
        """
        ...
    
    @staticmethod
    def SymmetricPointShoulderTargetTransition(startPoint: MSPyBentleyGeom.DPoint2d, shoulderPoint: MSPyBentleyGeom.DPoint2d, targetPoint: MSPyBentleyGeom.DPoint2d, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, junctionPoint: MSPyBentleyGeom.DPoint2d, endPoint: MSPyBentleyGeom.DPoint2d) -> bool:
        """
        compute 2 spirals.
        
        :param (input):
        startPoint start point
        
        :param (input):
        shoulderPoint target point for first and last tangents
        
        :param (input):
        targetPoint target point for last tangent
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        junctionPoint transition between spirals. This is the max
        curvature point.
        
        :param (output):
        endPoint end of second spiral.
        
        :returns:
        false if unable to construct
        """
        ...
    
    @staticmethod
    def TransitionTypeToString(type: int) -> str:
        """
        return the string name of the type
        """
        ...
    
    TransitionType_Arema: int
    
    TransitionType_AustralianRailCorp: int
    
    TransitionType_Biquadratic: int
    
    TransitionType_Bloss: int
    
    TransitionType_ChineseCubic: int
    
    TransitionType_Clothoid: int
    
    TransitionType_Cosine: int
    
    TransitionType_Czech: int
    
    TransitionType_CzechAlongTangent: int
    
    TransitionType_DirectHalfCosine: int
    
    TransitionType_FirstDirectEvaluate: int
    
    TransitionType_Italian: int
    
    TransitionType_JapaneseCubic: int
    
    TransitionType_MXCubicAlongArc: int
    
    TransitionType_MXCubicAlongTangent: int
    
    TransitionType_PolishCubic: int
    
    TransitionType_Sine: int
    
    TransitionType_Unknown: int
    
    TransitionType_Viennese: int
    
    TransitionType_WeightedViennese: int
    
    TransitionType_WesternAustralian: int
    
    def VectorIntegrandCount(self: MSPyBentleyGeom.BSIVectorIntegrand) -> int:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DSpiral2dBase) -> None
        
        2. __init__(self: MSPyBentleyGeom.DSpiral2dBase, transitionType: int) -> None
        
        3. __init__(self: MSPyBentleyGeom.DSpiral2dBase, transitionType: int, extraData: MSPyBentleyGeom.DoubleArray) -> None
        
        4. __init__(self: MSPyBentleyGeom.DSpiral2dBase, transitionType: int, parameter: float) -> None
        """
        ...
    
    @property
    def mLength(arg0: MSPyBentleyGeom.DSpiral2dBase) -> float:
        ...
    
class DSpiral2dBiQuadratic:
    """
    None
    """

    class ASLSACollector:
        """
        None
        """
    
        def Collect(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector, centerA: MSPyBentleyGeom.DPoint3d, arcToSpiralA: MSPyBentleyGeom.DPoint3d, sprialA: MSPyBentleyGeom.DSpiral2dBase, sprialToLineA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, arcToSpiralB: MSPyBentleyGeom.DPoint3d, spiralB: MSPyBentleyGeom.DSpiral2dBase, spiralToLibeB: MSPyBentleyGeom.DPoint3d) -> None:
            ...
        
        def __init__(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> None:
            ...
        
    def ArcSpiralLineSpiralArcTransition(centerA: MSPyBentleyGeom.DPoint3d, radiusA: float, lengthA: float, centerB: MSPyBentleyGeom.DPoint3d, radiusB: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, collector: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> int:
        ...
    
    def Clone(self: MSPyBentleyGeom.DSpiral2dBase) -> MSPyBentleyGeom.DSpiral2dBase:
        ...
    
    def ClosestPoint(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, spiralToWorld: Transform, spacePoint: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        Compute the closest spiral point for a given space point.
        
        :param (input):
        spiral spiral to evaluate.
        
        :param (input):
        startFraction start fraction of search range
        
        :param (input):
        endFraction endFraction of search range
        
        :param (input):
        spiralToWorld transform placing the spiral local coordinates into
        the world coordinate system
        
        :param (input):
        spacePoint world coordinates of space point.
        
        :param (output):
        spiralPoint world coordinates of closest point on spiral
        
        :param (output):
        spiralFraction fractional coordinates of closest point on spiral
        
        :param (output):
        minDistance distance from space point to spiralPoint.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def CopyBaseParameters(self: MSPyBentleyGeom.DSpiral2dBase, pSource: MSPyBentleyGeom.DSpiral2dBase) -> None:
        ...
    
    def CreateBearingCurvatureBearingCurvature(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float, extraData: MSPyBentleyGeom.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def CreateBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float, extraData: MSPyBentleyGeom.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def DefaultStrokeAngle() -> float:
        ...
    
    def DistanceToCurvature(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToCurvatureDerivative(self: MSPyBentleyGeom.DSpiral2dBase, arg0: float) -> float:
        """
        distance
        """
        ...
    
    def DistanceToFraction(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToGlobalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToLocalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(s: float, length: float, curvature1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: DVec2d, d2XY: DVec2d, d3XY: DVec2d) -> bool:
        """
        (input) distance for evaluation (input) nominal length. ASSUMED NONZERO (input)
        exit curvature. ASSUMED NONZERO (output) coordinates on spiral (output)
        first derivative wrt distance (output) second derivative wrt distance
        (output) third derivative wrt distance
        """
        ...
    
    def EvaluateVectorIntegrand(self: MSPyBentleyGeom.DSpiral2dBase, distance: float, pF: float) -> None:
        ...
    
    def FractionToDerivatives(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float, dXdf: DVec2d, ddXdfdf: DVec2d, dddXdfdfdf: DVec2d) -> bool:
        ...
    
    def FractionToDistance(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float) -> float:
        ...
    
    def GetExtraData(self: MSPyBentleyGeom.DSpiral2dBase, extraData: MSPyBentleyGeom.DoubleArray) -> None:
        """
        Get the extra data for this spiral. REMARK:This should be a virtual,
        but is implemented as special cases because of API change restriction
        """
        ...
    
    def GetIntervalCount(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, minInterval: int = 0, maxStrokeLength: float = 10000.0) -> int:
        """
        Return an interval count for stroking or integration. Except for
        degenerate single interval cases, the interval count is always even.
        That is the possible values are
        
        :param (input):
        spiral spiral being queried.
        
        :param (input):
        startFraction start of interval to stroke.
        
        :param (input):
        endFraction end of interval to stroke.
        
        :param (input):
        maxRadians max turn between strokes.
        
        :param (input):
        minInterval smallest number of intervals.
        
        :param (input):
        maxStrokeLength largest stroke size. Recommended 10 meters
        """
        ...
    
    def GetTransitionTypeCode(self: MSPyBentleyGeom.DSpiral2dBase) -> int:
        ...
    
    def GetVectorIntegrandCount(self: MSPyBentleyGeom.DSpiral2dBase) -> int:
        ...
    
    def IsValidRLCombination(lengthFromInflection: float, radius: float, spiralType: int = 0) -> bool:
        """
        test if a length-from-inflection and final radius
        combination is " small enough " for reasonable use. Test depends on
        spiral type:
        
        * DSpiral2dBase.TransitionType_None indicates apply the strictest
        test (same as Czech and Italian)
        
        * DSpiral2dBase.TransitionType_Czech and
        DSpiral2dBase.TransitionType_Italian indicate a strict test L<2*R
        
        * other types have no restrictions.
        
        :param (input):
        lengthFromInflection (input) distance along spiral starting at
        inflection and ending at finalRadius.
        
        :param (input):
        finalRadius (input) final radius
        
        :param (input):
        spiralType (input) spiral type.
        
        :param (input):
        lengthFactor expansion or reduction factor to apply to the allowed
        length. +---------------+---------------+---------------+---------
        ------+------
        """
        ...
    
    def LineSpiralArcSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, radius: float, lengthA: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralAToArc: MSPyBentleyGeom.DPoint3d, spiralBToArc: MSPyBentleyGeom.DPoint3d, arc: MSPyBentleyGeom.DEllipse3d) -> bool:
        """
        compute spirals and arc to make a line-to-line
        transition.
        
        :param (input):
        lineAPoint point on line A.
        
        :param (input):
        lineBPoint point on line B.
        
        :param (input):
        lineLineIntersection intersection of lines.
        
        :param (input):
        radius radius for circular part of transition.
        
        :param (input):
        lengthA length of spiral from line A to circle.
        
        :param (input):
        lengthB length of spiral from line B to circle.
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        lineToSpiralA tangency point from line to spiral
        
        :param (output):
        spiralAToArc tangency point from spiral to arc
        
        :param (output):
        lineToSpiralB tangency point from line to spiral
        
        :param (output):
        spiralBToArc tangency point from spiral to arc
        
        :param (output):
        arc arc between spirals.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def ScaleInPlace(self: MSPyBentleyGeom.DSpiral2dBase, s: float) -> bool:
        ...
    
    def SetBearingAndCurvatureLimits(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, theta1: float, curvature1: float) -> bool:
        ...
    
    def SetBearingCurvatureLengthBearing(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, theta1: float) -> bool:
        """
        Set start bearing, start curvature, length, and end
        curvature. (Compute end bearing)
        
        :param (input):
        theta0 start bearing
        
        :param (input):
        curvature0 start curvature
        
        :param (input):
        length arc length
        
        :param (input):
        theta1 end bearing
        """
        ...
    
    def SetBearingCurvatureLengthCurvature(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, curvature1: float) -> bool:
        ...
    
    def StringToTransitionType(name: str) -> int:
        """
        return the integer code for the string name.
        """
        ...
    
    def Stroke(*args, **kwargs):
        """
        Overloaded function.
        
        1. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, pDXY: DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        2. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, xyz0: MSPyBentleyGeom.DPoint3d, pXYZ: MSPyBentleyGeom.DPoint3d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        3. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: DVec2d) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        4. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        5. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: DVec2d, pFraction: float, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        6. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: DVec2d, maxStrokeLength: float) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        7. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, uvPoints: List[DVec2d], fractions: MSPyBentleyGeom.DoubleArray, maxStrokeLength: float = 10000.0) -> tuple
        """
        ...
    
    def StrokeToAnnouncer(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, F: MSPyBentleyGeom.AnnounceDoubleDPoint2d, minIndex: int = 0, maxStrokeLength: float = 10000.0) -> tuple:
        """
        Integrate the vector displacements of a clothoid over a
        fractional interval. This uses the angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        startFraction start fraction for integral.
        
        :param (input):
        endFraction end fraction for integral.
        
        :param (input):
        maxRadians maximum bearing change between computed points. A
        default is used if 0.0 is passed.
        
        :param (input):
        F object with a method F->Announce (f, uv) called to announce
        fraction and coordinate as computed.
        
        :param (output):
        errorBound estimated bound on error.
        
        :param (output):
        minInterval smallest number of intervals allowed
        
        :param (output):
        maxStrokeLength maximum allowed stroke length
        
        :returns:
        false if point integration failed
        """
        ...
    
    def SymmetricLineSpiralSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, length: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralToSpiral: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        compute spirals and arc to make a line-to-line
        transition.
        
        :param (input):
        lineAPoint point on line A.
        
        :param (input):
        lineBPoint point on line B.
        
        :param (input):
        lineLineIntersection intersection of lines.
        
        :param (input):
        length length of spiral from line A to junction
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        lineToSpiralA tangency point from line to spiral
        
        :param (output):
        lineToSpiralB tangency point from line to spiral
        
        :param (output):
        spiralToSpiral tangency point from spiral to to spiral
        
        :param (output):
        junctionRadius radius at transition between the spirals.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def SymmetricPointShoulderTargetTransition(startPoint: MSPyBentleyGeom.DPoint2d, shoulderPoint: MSPyBentleyGeom.DPoint2d, targetPoint: MSPyBentleyGeom.DPoint2d, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, junctionPoint: MSPyBentleyGeom.DPoint2d, endPoint: MSPyBentleyGeom.DPoint2d) -> bool:
        """
        compute 2 spirals.
        
        :param (input):
        startPoint start point
        
        :param (input):
        shoulderPoint target point for first and last tangents
        
        :param (input):
        targetPoint target point for last tangent
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        junctionPoint transition between spirals. This is the max
        curvature point.
        
        :param (output):
        endPoint end of second spiral.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def TransitionTypeToString(type: int) -> str:
        """
        return the string name of the type
        """
        ...
    
    TransitionType_Arema: int
    
    TransitionType_AustralianRailCorp: int
    
    TransitionType_Biquadratic: int
    
    TransitionType_Bloss: int
    
    TransitionType_ChineseCubic: int
    
    TransitionType_Clothoid: int
    
    TransitionType_Cosine: int
    
    TransitionType_Czech: int
    
    TransitionType_CzechAlongTangent: int
    
    TransitionType_DirectHalfCosine: int
    
    TransitionType_FirstDirectEvaluate: int
    
    TransitionType_Italian: int
    
    TransitionType_JapaneseCubic: int
    
    TransitionType_MXCubicAlongArc: int
    
    TransitionType_MXCubicAlongTangent: int
    
    TransitionType_PolishCubic: int
    
    TransitionType_Sine: int
    
    TransitionType_Unknown: int
    
    TransitionType_Viennese: int
    
    TransitionType_WeightedViennese: int
    
    TransitionType_WesternAustralian: int
    
    def VectorIntegrandCount(self: MSPyBentleyGeom.BSIVectorIntegrand) -> int:
        ...
    
    def __init__(self: MSPyBentleyGeom.DSpiral2dBiQuadratic) -> None:
        ...
    
    @property
    def mLength(arg0: MSPyBentleyGeom.DSpiral2dBase) -> float:
        ...
    
class DSpiral2dBloss:
    """
    None
    """

    class ASLSACollector:
        """
        None
        """
    
        def Collect(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector, centerA: MSPyBentleyGeom.DPoint3d, arcToSpiralA: MSPyBentleyGeom.DPoint3d, sprialA: MSPyBentleyGeom.DSpiral2dBase, sprialToLineA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, arcToSpiralB: MSPyBentleyGeom.DPoint3d, spiralB: MSPyBentleyGeom.DSpiral2dBase, spiralToLibeB: MSPyBentleyGeom.DPoint3d) -> None:
            ...
        
        def __init__(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> None:
            ...
        
    def ArcSpiralLineSpiralArcTransition(centerA: MSPyBentleyGeom.DPoint3d, radiusA: float, lengthA: float, centerB: MSPyBentleyGeom.DPoint3d, radiusB: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, collector: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> int:
        ...
    
    def Clone(self: MSPyBentleyGeom.DSpiral2dBase) -> MSPyBentleyGeom.DSpiral2dBase:
        ...
    
    def ClosestPoint(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, spiralToWorld: Transform, spacePoint: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        Compute the closest spiral point for a given space point.
        
        :param (input):
        spiral spiral to evaluate.
        
        :param (input):
        startFraction start fraction of search range
        
        :param (input):
        endFraction endFraction of search range
        
        :param (input):
        spiralToWorld transform placing the spiral local coordinates into
        the world coordinate system
        
        :param (input):
        spacePoint world coordinates of space point.
        
        :param (output):
        spiralPoint world coordinates of closest point on spiral
        
        :param (output):
        spiralFraction fractional coordinates of closest point on spiral
        
        :param (output):
        minDistance distance from space point to spiralPoint.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def CopyBaseParameters(self: MSPyBentleyGeom.DSpiral2dBase, pSource: MSPyBentleyGeom.DSpiral2dBase) -> None:
        ...
    
    def CreateBearingCurvatureBearingCurvature(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float, extraData: MSPyBentleyGeom.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def CreateBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float, extraData: MSPyBentleyGeom.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def DefaultStrokeAngle() -> float:
        ...
    
    def DistanceToCurvature(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToCurvatureDerivative(self: MSPyBentleyGeom.DSpiral2dBase, arg0: float) -> float:
        """
        distance
        """
        ...
    
    def DistanceToFraction(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToGlobalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToLocalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(s: float, length: float, curvature1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: DVec2d, d2XY: DVec2d, d3XY: DVec2d) -> bool:
        """
        (input) distance for evaluation (input) nominal length. ASSUMED NONZERO (input)
        exit curvature. ASSUMED NONZERO (output) coordinates on spiral (output)
        first derivative wrt distance (output) second derivative wrt distance
        (output) third derivative wrt distance
        """
        ...
    
    def EvaluateVectorIntegrand(self: MSPyBentleyGeom.DSpiral2dBase, distance: float, pF: float) -> None:
        ...
    
    def FractionToDerivatives(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float, dXdf: DVec2d, ddXdfdf: DVec2d, dddXdfdfdf: DVec2d) -> bool:
        ...
    
    def FractionToDistance(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float) -> float:
        ...
    
    def GetExtraData(self: MSPyBentleyGeom.DSpiral2dBase, extraData: MSPyBentleyGeom.DoubleArray) -> None:
        """
        Get the extra data for this spiral. REMARK:This should be a virtual,
        but is implemented as special cases because of API change restriction
        """
        ...
    
    def GetIntervalCount(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, minInterval: int = 0, maxStrokeLength: float = 10000.0) -> int:
        """
        Return an interval count for stroking or integration. Except for
        degenerate single interval cases, the interval count is always even.
        That is the possible values are
        
        :param (input):
        spiral spiral being queried.
        
        :param (input):
        startFraction start of interval to stroke.
        
        :param (input):
        endFraction end of interval to stroke.
        
        :param (input):
        maxRadians max turn between strokes.
        
        :param (input):
        minInterval smallest number of intervals.
        
        :param (input):
        maxStrokeLength largest stroke size. Recommended 10 meters
        """
        ...
    
    def GetTransitionTypeCode(self: MSPyBentleyGeom.DSpiral2dBase) -> int:
        ...
    
    def GetVectorIntegrandCount(self: MSPyBentleyGeom.DSpiral2dBase) -> int:
        ...
    
    def IsValidRLCombination(lengthFromInflection: float, radius: float, spiralType: int = 0) -> bool:
        """
        test if a length-from-inflection and final radius
        combination is " small enough " for reasonable use. Test depends on
        spiral type:
        
        * DSpiral2dBase.TransitionType_None indicates apply the strictest
        test (same as Czech and Italian)
        
        * DSpiral2dBase.TransitionType_Czech and
        DSpiral2dBase.TransitionType_Italian indicate a strict test L<2*R
        
        * other types have no restrictions.
        
        :param (input):
        lengthFromInflection (input) distance along spiral starting at
        inflection and ending at finalRadius.
        
        :param (input):
        finalRadius (input) final radius
        
        :param (input):
        spiralType (input) spiral type.
        
        :param (input):
        lengthFactor expansion or reduction factor to apply to the allowed
        length. +---------------+---------------+---------------+---------
        ------+------
        """
        ...
    
    def LineSpiralArcSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, radius: float, lengthA: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralAToArc: MSPyBentleyGeom.DPoint3d, spiralBToArc: MSPyBentleyGeom.DPoint3d, arc: MSPyBentleyGeom.DEllipse3d) -> bool:
        """
        compute spirals and arc to make a line-to-line
        transition.
        
        :param (input):
        lineAPoint point on line A.
        
        :param (input):
        lineBPoint point on line B.
        
        :param (input):
        lineLineIntersection intersection of lines.
        
        :param (input):
        radius radius for circular part of transition.
        
        :param (input):
        lengthA length of spiral from line A to circle.
        
        :param (input):
        lengthB length of spiral from line B to circle.
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        lineToSpiralA tangency point from line to spiral
        
        :param (output):
        spiralAToArc tangency point from spiral to arc
        
        :param (output):
        lineToSpiralB tangency point from line to spiral
        
        :param (output):
        spiralBToArc tangency point from spiral to arc
        
        :param (output):
        arc arc between spirals.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def ScaleInPlace(self: MSPyBentleyGeom.DSpiral2dBase, s: float) -> bool:
        ...
    
    def SetBearingAndCurvatureLimits(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, theta1: float, curvature1: float) -> bool:
        ...
    
    def SetBearingCurvatureLengthBearing(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, theta1: float) -> bool:
        """
        Set start bearing, start curvature, length, and end
        curvature. (Compute end bearing)
        
        :param (input):
        theta0 start bearing
        
        :param (input):
        curvature0 start curvature
        
        :param (input):
        length arc length
        
        :param (input):
        theta1 end bearing
        """
        ...
    
    def SetBearingCurvatureLengthCurvature(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, curvature1: float) -> bool:
        ...
    
    def StringToTransitionType(name: str) -> int:
        """
        return the integer code for the string name.
        """
        ...
    
    def Stroke(*args, **kwargs):
        """
        Overloaded function.
        
        1. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, pDXY: DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        2. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, xyz0: MSPyBentleyGeom.DPoint3d, pXYZ: MSPyBentleyGeom.DPoint3d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        3. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: DVec2d) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        4. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        5. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: DVec2d, pFraction: float, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        6. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: DVec2d, maxStrokeLength: float) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        7. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, uvPoints: List[DVec2d], fractions: MSPyBentleyGeom.DoubleArray, maxStrokeLength: float = 10000.0) -> tuple
        """
        ...
    
    def StrokeToAnnouncer(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, F: MSPyBentleyGeom.AnnounceDoubleDPoint2d, minIndex: int = 0, maxStrokeLength: float = 10000.0) -> tuple:
        """
        Integrate the vector displacements of a clothoid over a
        fractional interval. This uses the angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        startFraction start fraction for integral.
        
        :param (input):
        endFraction end fraction for integral.
        
        :param (input):
        maxRadians maximum bearing change between computed points. A
        default is used if 0.0 is passed.
        
        :param (input):
        F object with a method F->Announce (f, uv) called to announce
        fraction and coordinate as computed.
        
        :param (output):
        errorBound estimated bound on error.
        
        :param (output):
        minInterval smallest number of intervals allowed
        
        :param (output):
        maxStrokeLength maximum allowed stroke length
        
        :returns:
        false if point integration failed
        """
        ...
    
    def SymmetricLineSpiralSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, length: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralToSpiral: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        compute spirals and arc to make a line-to-line
        transition.
        
        :param (input):
        lineAPoint point on line A.
        
        :param (input):
        lineBPoint point on line B.
        
        :param (input):
        lineLineIntersection intersection of lines.
        
        :param (input):
        length length of spiral from line A to junction
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        lineToSpiralA tangency point from line to spiral
        
        :param (output):
        lineToSpiralB tangency point from line to spiral
        
        :param (output):
        spiralToSpiral tangency point from spiral to to spiral
        
        :param (output):
        junctionRadius radius at transition between the spirals.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def SymmetricPointShoulderTargetTransition(startPoint: MSPyBentleyGeom.DPoint2d, shoulderPoint: MSPyBentleyGeom.DPoint2d, targetPoint: MSPyBentleyGeom.DPoint2d, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, junctionPoint: MSPyBentleyGeom.DPoint2d, endPoint: MSPyBentleyGeom.DPoint2d) -> bool:
        """
        compute 2 spirals.
        
        :param (input):
        startPoint start point
        
        :param (input):
        shoulderPoint target point for first and last tangents
        
        :param (input):
        targetPoint target point for last tangent
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        junctionPoint transition between spirals. This is the max
        curvature point.
        
        :param (output):
        endPoint end of second spiral.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def TransitionTypeToString(type: int) -> str:
        """
        return the string name of the type
        """
        ...
    
    TransitionType_Arema: int
    
    TransitionType_AustralianRailCorp: int
    
    TransitionType_Biquadratic: int
    
    TransitionType_Bloss: int
    
    TransitionType_ChineseCubic: int
    
    TransitionType_Clothoid: int
    
    TransitionType_Cosine: int
    
    TransitionType_Czech: int
    
    TransitionType_CzechAlongTangent: int
    
    TransitionType_DirectHalfCosine: int
    
    TransitionType_FirstDirectEvaluate: int
    
    TransitionType_Italian: int
    
    TransitionType_JapaneseCubic: int
    
    TransitionType_MXCubicAlongArc: int
    
    TransitionType_MXCubicAlongTangent: int
    
    TransitionType_PolishCubic: int
    
    TransitionType_Sine: int
    
    TransitionType_Unknown: int
    
    TransitionType_Viennese: int
    
    TransitionType_WeightedViennese: int
    
    TransitionType_WesternAustralian: int
    
    def VectorIntegrandCount(self: MSPyBentleyGeom.BSIVectorIntegrand) -> int:
        ...
    
    def __init__(self: MSPyBentleyGeom.DSpiral2dBloss) -> None:
        ...
    
    @property
    def mLength(arg0: MSPyBentleyGeom.DSpiral2dBase) -> float:
        ...
    
class DSpiral2dChinese:
    """
    None
    """

    class ASLSACollector:
        """
        None
        """
    
        def Collect(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector, centerA: MSPyBentleyGeom.DPoint3d, arcToSpiralA: MSPyBentleyGeom.DPoint3d, sprialA: MSPyBentleyGeom.DSpiral2dBase, sprialToLineA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, arcToSpiralB: MSPyBentleyGeom.DPoint3d, spiralB: MSPyBentleyGeom.DSpiral2dBase, spiralToLibeB: MSPyBentleyGeom.DPoint3d) -> None:
            ...
        
        def __init__(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> None:
            ...
        
    def ApplyCCWRotation(radians: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: DVec2d, d2XYZ: DVec2d, d3XYZ: DVec2d) -> None:
        """
        rotate xy and optional derivatives by radians. (To be called by
        derived class EvaluateAtDistance when to rotate EvaluateAtDistance
        results from standard position)
        """
        ...
    
    def ArcSpiralLineSpiralArcTransition(centerA: MSPyBentleyGeom.DPoint3d, radiusA: float, lengthA: float, centerB: MSPyBentleyGeom.DPoint3d, radiusB: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, collector: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> int:
        ...
    
    def Clone(self: MSPyBentleyGeom.DSpiral2dBase) -> MSPyBentleyGeom.DSpiral2dBase:
        ...
    
    def ClosestPoint(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, spiralToWorld: Transform, spacePoint: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        Compute the closest spiral point for a given space point.
        
        :param (input):
        spiral spiral to evaluate.
        
        :param (input):
        startFraction start fraction of search range
        
        :param (input):
        endFraction endFraction of search range
        
        :param (input):
        spiralToWorld transform placing the spiral local coordinates into
        the world coordinate system
        
        :param (input):
        spacePoint world coordinates of space point.
        
        :param (output):
        spiralPoint world coordinates of closest point on spiral
        
        :param (output):
        spiralFraction fractional coordinates of closest point on spiral
        
        :param (output):
        minDistance distance from space point to spiralPoint.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def CopyBaseParameters(self: MSPyBentleyGeom.DSpiral2dBase, pSource: MSPyBentleyGeom.DSpiral2dBase) -> None:
        ...
    
    def CreateBearingCurvatureBearingCurvature(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float, extraData: MSPyBentleyGeom.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def CreateBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float, extraData: MSPyBentleyGeom.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def DefaultStrokeAngle() -> float:
        ...
    
    def DistanceToCurvature(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToCurvatureDerivative(self: MSPyBentleyGeom.DSpiral2dBase, arg0: float) -> float:
        """
        distance
        """
        ...
    
    def DistanceToFraction(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToGlobalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToLocalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def EvaluateAtFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: DVec2d, d2XYZ: DVec2d, d3XYZ: DVec2d) -> bool:
        """
        Evaluate the spiral and derivatives at specified fractional position
        return true if valid evaluation. DSpiral2dDirectEvaluation default
        implementation returns false.
        """
        ...
    
    def EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(s: float, length: float, curvature1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: DVec2d, d2XY: DVec2d, d3XY: DVec2d) -> bool:
        """
        (input) distance for evaluation (input) nominal length. ASSUMED NONZERO (input)
        exit curvature. ASSUMED NONZERO (output) coordinates on spiral (output)
        first derivative wrt distance (output) second derivative wrt distance
        (output) third derivative wrt distance
        """
        ...
    
    def EvaluateVectorIntegrand(self: MSPyBentleyGeom.DSpiral2dBase, distance: float, pF: float) -> None:
        ...
    
    def FractionToCurvature(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float:
        """
        Return the true curvature at fractional position. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDCurvatureDFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> tuple:
        """
        Return the true curvature derivative wrt fraction. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDerivatives(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float, dXdf: DVec2d, ddXdfdf: DVec2d, dddXdfdfdf: DVec2d) -> bool:
        ...
    
    def FractionToDistance(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float) -> float:
        ...
    
    def FractionToLocalAngle(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float:
        """
        Return the tangent angle (in radians) in local coordinates
        """
        ...
    
    def FractionToVelocity(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float:
        """
        Return the magnitude of the true derivative of position wrt fraction.
        Implemented in DSpiral2dDirectEvaluation, not individual classes.
        Assume EvaluateAtFraction.
        """
        ...
    
    def GetExtraData(self: MSPyBentleyGeom.DSpiral2dBase, extraData: MSPyBentleyGeom.DoubleArray) -> None:
        """
        Get the extra data for this spiral. REMARK:This should be a virtual,
        but is implemented as special cases because of API change restriction
        """
        ...
    
    def GetIntervalCount(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, minInterval: int = 0, maxStrokeLength: float = 10000.0) -> int:
        """
        Return an interval count for stroking or integration. Except for
        degenerate single interval cases, the interval count is always even.
        That is the possible values are
        
        :param (input):
        spiral spiral being queried.
        
        :param (input):
        startFraction start of interval to stroke.
        
        :param (input):
        endFraction end of interval to stroke.
        
        :param (input):
        maxRadians max turn between strokes.
        
        :param (input):
        minInterval smallest number of intervals.
        
        :param (input):
        maxStrokeLength largest stroke size. Recommended 10 meters
        """
        ...
    
    def GetTransitionTypeCode(self: MSPyBentleyGeom.DSpiral2dBase) -> int:
        ...
    
    def GetVectorIntegrandCount(self: MSPyBentleyGeom.DSpiral2dBase) -> int:
        ...
    
    def IsValidRLCombination(lengthFromInflection: float, radius: float, spiralType: int = 0) -> bool:
        """
        test if a length-from-inflection and final radius
        combination is " small enough " for reasonable use. Test depends on
        spiral type:
        
        * DSpiral2dBase.TransitionType_None indicates apply the strictest
        test (same as Czech and Italian)
        
        * DSpiral2dBase.TransitionType_Czech and
        DSpiral2dBase.TransitionType_Italian indicate a strict test L<2*R
        
        * other types have no restrictions.
        
        :param (input):
        lengthFromInflection (input) distance along spiral starting at
        inflection and ending at finalRadius.
        
        :param (input):
        finalRadius (input) final radius
        
        :param (input):
        spiralType (input) spiral type.
        
        :param (input):
        lengthFactor expansion or reduction factor to apply to the allowed
        length. +---------------+---------------+---------------+---------
        ------+------
        """
        ...
    
    def LineSpiralArcSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, radius: float, lengthA: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralAToArc: MSPyBentleyGeom.DPoint3d, spiralBToArc: MSPyBentleyGeom.DPoint3d, arc: MSPyBentleyGeom.DEllipse3d) -> bool:
        """
        compute spirals and arc to make a line-to-line
        transition.
        
        :param (input):
        lineAPoint point on line A.
        
        :param (input):
        lineBPoint point on line B.
        
        :param (input):
        lineLineIntersection intersection of lines.
        
        :param (input):
        radius radius for circular part of transition.
        
        :param (input):
        lengthA length of spiral from line A to circle.
        
        :param (input):
        lengthB length of spiral from line B to circle.
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        lineToSpiralA tangency point from line to spiral
        
        :param (output):
        spiralAToArc tangency point from spiral to arc
        
        :param (output):
        lineToSpiralB tangency point from line to spiral
        
        :param (output):
        spiralBToArc tangency point from spiral to arc
        
        :param (output):
        arc arc between spirals.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def ScaleInPlace(self: MSPyBentleyGeom.DSpiral2dBase, s: float) -> bool:
        ...
    
    def SetBearingAndCurvatureLimits(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, theta1: float, curvature1: float) -> bool:
        ...
    
    def SetBearingCurvatureLengthBearing(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, theta1: float) -> bool:
        """
        Set start bearing, start curvature, length, and end
        curvature. (Compute end bearing)
        
        :param (input):
        theta0 start bearing
        
        :param (input):
        curvature0 start curvature
        
        :param (input):
        length arc length
        
        :param (input):
        theta1 end bearing
        """
        ...
    
    def SetBearingCurvatureLengthCurvature(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, curvature1: float) -> bool:
        ...
    
    def StringToTransitionType(name: str) -> int:
        """
        return the integer code for the string name.
        """
        ...
    
    def Stroke(*args, **kwargs):
        """
        Overloaded function.
        
        1. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, pDXY: DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        2. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, xyz0: MSPyBentleyGeom.DPoint3d, pXYZ: MSPyBentleyGeom.DPoint3d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        3. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: DVec2d) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        4. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        5. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: DVec2d, pFraction: float, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        6. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: DVec2d, maxStrokeLength: float) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        7. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, uvPoints: List[DVec2d], fractions: MSPyBentleyGeom.DoubleArray, maxStrokeLength: float = 10000.0) -> tuple
        """
        ...
    
    def StrokeToAnnouncer(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, F: MSPyBentleyGeom.AnnounceDoubleDPoint2d, minIndex: int = 0, maxStrokeLength: float = 10000.0) -> tuple:
        """
        Integrate the vector displacements of a clothoid over a
        fractional interval. This uses the angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        startFraction start fraction for integral.
        
        :param (input):
        endFraction end fraction for integral.
        
        :param (input):
        maxRadians maximum bearing change between computed points. A
        default is used if 0.0 is passed.
        
        :param (input):
        F object with a method F->Announce (f, uv) called to announce
        fraction and coordinate as computed.
        
        :param (output):
        errorBound estimated bound on error.
        
        :param (output):
        minInterval smallest number of intervals allowed
        
        :param (output):
        maxStrokeLength maximum allowed stroke length
        
        :returns:
        false if point integration failed
        """
        ...
    
    def SymmetricLineSpiralSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, length: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralToSpiral: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        compute spirals and arc to make a line-to-line
        transition.
        
        :param (input):
        lineAPoint point on line A.
        
        :param (input):
        lineBPoint point on line B.
        
        :param (input):
        lineLineIntersection intersection of lines.
        
        :param (input):
        length length of spiral from line A to junction
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        lineToSpiralA tangency point from line to spiral
        
        :param (output):
        lineToSpiralB tangency point from line to spiral
        
        :param (output):
        spiralToSpiral tangency point from spiral to to spiral
        
        :param (output):
        junctionRadius radius at transition between the spirals.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def SymmetricPointShoulderTargetTransition(startPoint: MSPyBentleyGeom.DPoint2d, shoulderPoint: MSPyBentleyGeom.DPoint2d, targetPoint: MSPyBentleyGeom.DPoint2d, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, junctionPoint: MSPyBentleyGeom.DPoint2d, endPoint: MSPyBentleyGeom.DPoint2d) -> bool:
        """
        compute 2 spirals.
        
        :param (input):
        startPoint start point
        
        :param (input):
        shoulderPoint target point for first and last tangents
        
        :param (input):
        targetPoint target point for last tangent
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        junctionPoint transition between spirals. This is the max
        curvature point.
        
        :param (output):
        endPoint end of second spiral.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def TransitionTypeToString(type: int) -> str:
        """
        return the string name of the type
        """
        ...
    
    TransitionType_Arema: int
    
    TransitionType_AustralianRailCorp: int
    
    TransitionType_Biquadratic: int
    
    TransitionType_Bloss: int
    
    TransitionType_ChineseCubic: int
    
    TransitionType_Clothoid: int
    
    TransitionType_Cosine: int
    
    TransitionType_Czech: int
    
    TransitionType_CzechAlongTangent: int
    
    TransitionType_DirectHalfCosine: int
    
    TransitionType_FirstDirectEvaluate: int
    
    TransitionType_Italian: int
    
    TransitionType_JapaneseCubic: int
    
    TransitionType_MXCubicAlongArc: int
    
    TransitionType_MXCubicAlongTangent: int
    
    TransitionType_PolishCubic: int
    
    TransitionType_Sine: int
    
    TransitionType_Unknown: int
    
    TransitionType_Viennese: int
    
    TransitionType_WeightedViennese: int
    
    TransitionType_WesternAustralian: int
    
    def VectorIntegrandCount(self: MSPyBentleyGeom.BSIVectorIntegrand) -> int:
        ...
    
    def __init__(self: MSPyBentleyGeom.DSpiral2dChinese, nominalLength: float) -> None:
        ...
    
    @property
    def mLength(arg0: MSPyBentleyGeom.DSpiral2dBase) -> float:
        ...
    
class DSpiral2dClothoid:
    """
    None
    """

    class ASLSACollector:
        """
        None
        """
    
        def Collect(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector, centerA: MSPyBentleyGeom.DPoint3d, arcToSpiralA: MSPyBentleyGeom.DPoint3d, sprialA: MSPyBentleyGeom.DSpiral2dBase, sprialToLineA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, arcToSpiralB: MSPyBentleyGeom.DPoint3d, spiralB: MSPyBentleyGeom.DSpiral2dBase, spiralToLibeB: MSPyBentleyGeom.DPoint3d) -> None:
            ...
        
        def __init__(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> None:
            ...
        
    def ArcSpiralLineSpiralArcTransition(centerA: MSPyBentleyGeom.DPoint3d, radiusA: float, lengthA: float, centerB: MSPyBentleyGeom.DPoint3d, radiusB: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, collector: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> int:
        ...
    
    def Clone(self: MSPyBentleyGeom.DSpiral2dBase) -> MSPyBentleyGeom.DSpiral2dBase:
        ...
    
    def ClosestPoint(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, spiralToWorld: Transform, spacePoint: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        Compute the closest spiral point for a given space point.
        
        :param (input):
        spiral spiral to evaluate.
        
        :param (input):
        startFraction start fraction of search range
        
        :param (input):
        endFraction endFraction of search range
        
        :param (input):
        spiralToWorld transform placing the spiral local coordinates into
        the world coordinate system
        
        :param (input):
        spacePoint world coordinates of space point.
        
        :param (output):
        spiralPoint world coordinates of closest point on spiral
        
        :param (output):
        spiralFraction fractional coordinates of closest point on spiral
        
        :param (output):
        minDistance distance from space point to spiralPoint.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def CopyBaseParameters(self: MSPyBentleyGeom.DSpiral2dBase, pSource: MSPyBentleyGeom.DSpiral2dBase) -> None:
        ...
    
    def CreateBearingCurvatureBearingCurvature(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float, extraData: MSPyBentleyGeom.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def CreateBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float, extraData: MSPyBentleyGeom.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def DefaultStrokeAngle() -> float:
        ...
    
    def DistanceToCurvature(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToCurvatureDerivative(self: MSPyBentleyGeom.DSpiral2dBase, arg0: float) -> float:
        """
        distance
        """
        ...
    
    def DistanceToFraction(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToGlobalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToLocalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(s: float, length: float, curvature1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: DVec2d, d2XY: DVec2d, d3XY: DVec2d) -> bool:
        """
        (input) distance for evaluation (input) nominal length. ASSUMED NONZERO (input)
        exit curvature. ASSUMED NONZERO (output) coordinates on spiral (output)
        first derivative wrt distance (output) second derivative wrt distance
        (output) third derivative wrt distance
        """
        ...
    
    def EvaluateVectorIntegrand(self: MSPyBentleyGeom.DSpiral2dBase, distance: float, pF: float) -> None:
        ...
    
    def FractionToDerivatives(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float, dXdf: DVec2d, ddXdfdf: DVec2d, dddXdfdfdf: DVec2d) -> bool:
        ...
    
    def FractionToDistance(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float) -> float:
        ...
    
    def GetExtraData(self: MSPyBentleyGeom.DSpiral2dBase, extraData: MSPyBentleyGeom.DoubleArray) -> None:
        """
        Get the extra data for this spiral. REMARK:This should be a virtual,
        but is implemented as special cases because of API change restriction
        """
        ...
    
    def GetIntervalCount(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, minInterval: int = 0, maxStrokeLength: float = 10000.0) -> int:
        """
        Return an interval count for stroking or integration. Except for
        degenerate single interval cases, the interval count is always even.
        That is the possible values are
        
        :param (input):
        spiral spiral being queried.
        
        :param (input):
        startFraction start of interval to stroke.
        
        :param (input):
        endFraction end of interval to stroke.
        
        :param (input):
        maxRadians max turn between strokes.
        
        :param (input):
        minInterval smallest number of intervals.
        
        :param (input):
        maxStrokeLength largest stroke size. Recommended 10 meters
        """
        ...
    
    def GetTransitionTypeCode(self: MSPyBentleyGeom.DSpiral2dBase) -> int:
        ...
    
    def GetVectorIntegrandCount(self: MSPyBentleyGeom.DSpiral2dBase) -> int:
        ...
    
    def IsValidRLCombination(lengthFromInflection: float, radius: float, spiralType: int = 0) -> bool:
        """
        test if a length-from-inflection and final radius
        combination is " small enough " for reasonable use. Test depends on
        spiral type:
        
        * DSpiral2dBase.TransitionType_None indicates apply the strictest
        test (same as Czech and Italian)
        
        * DSpiral2dBase.TransitionType_Czech and
        DSpiral2dBase.TransitionType_Italian indicate a strict test L<2*R
        
        * other types have no restrictions.
        
        :param (input):
        lengthFromInflection (input) distance along spiral starting at
        inflection and ending at finalRadius.
        
        :param (input):
        finalRadius (input) final radius
        
        :param (input):
        spiralType (input) spiral type.
        
        :param (input):
        lengthFactor expansion or reduction factor to apply to the allowed
        length. +---------------+---------------+---------------+---------
        ------+------
        """
        ...
    
    def LineSpiralArcSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, radius: float, lengthA: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralAToArc: MSPyBentleyGeom.DPoint3d, spiralBToArc: MSPyBentleyGeom.DPoint3d, arc: MSPyBentleyGeom.DEllipse3d) -> bool:
        """
        compute spirals and arc to make a line-to-line
        transition.
        
        :param (input):
        lineAPoint point on line A.
        
        :param (input):
        lineBPoint point on line B.
        
        :param (input):
        lineLineIntersection intersection of lines.
        
        :param (input):
        radius radius for circular part of transition.
        
        :param (input):
        lengthA length of spiral from line A to circle.
        
        :param (input):
        lengthB length of spiral from line B to circle.
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        lineToSpiralA tangency point from line to spiral
        
        :param (output):
        spiralAToArc tangency point from spiral to arc
        
        :param (output):
        lineToSpiralB tangency point from line to spiral
        
        :param (output):
        spiralBToArc tangency point from spiral to arc
        
        :param (output):
        arc arc between spirals.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def ScaleInPlace(self: MSPyBentleyGeom.DSpiral2dBase, s: float) -> bool:
        ...
    
    def SetBearingAndCurvatureLimits(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, theta1: float, curvature1: float) -> bool:
        ...
    
    def SetBearingCurvatureLengthBearing(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, theta1: float) -> bool:
        """
        Set start bearing, start curvature, length, and end
        curvature. (Compute end bearing)
        
        :param (input):
        theta0 start bearing
        
        :param (input):
        curvature0 start curvature
        
        :param (input):
        length arc length
        
        :param (input):
        theta1 end bearing
        """
        ...
    
    def SetBearingCurvatureLengthCurvature(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, curvature1: float) -> bool:
        ...
    
    def StringToTransitionType(name: str) -> int:
        """
        return the integer code for the string name.
        """
        ...
    
    def Stroke(*args, **kwargs):
        """
        Overloaded function.
        
        1. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, pDXY: DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        2. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, xyz0: MSPyBentleyGeom.DPoint3d, pXYZ: MSPyBentleyGeom.DPoint3d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        3. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: DVec2d) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        4. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        5. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: DVec2d, pFraction: float, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        6. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: DVec2d, maxStrokeLength: float) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        7. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, uvPoints: List[DVec2d], fractions: MSPyBentleyGeom.DoubleArray, maxStrokeLength: float = 10000.0) -> tuple
        """
        ...
    
    def StrokeToAnnouncer(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, F: MSPyBentleyGeom.AnnounceDoubleDPoint2d, minIndex: int = 0, maxStrokeLength: float = 10000.0) -> tuple:
        """
        Integrate the vector displacements of a clothoid over a
        fractional interval. This uses the angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        startFraction start fraction for integral.
        
        :param (input):
        endFraction end fraction for integral.
        
        :param (input):
        maxRadians maximum bearing change between computed points. A
        default is used if 0.0 is passed.
        
        :param (input):
        F object with a method F->Announce (f, uv) called to announce
        fraction and coordinate as computed.
        
        :param (output):
        errorBound estimated bound on error.
        
        :param (output):
        minInterval smallest number of intervals allowed
        
        :param (output):
        maxStrokeLength maximum allowed stroke length
        
        :returns:
        false if point integration failed
        """
        ...
    
    def SymmetricLineSpiralSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, length: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralToSpiral: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        compute spirals and arc to make a line-to-line
        transition.
        
        :param (input):
        lineAPoint point on line A.
        
        :param (input):
        lineBPoint point on line B.
        
        :param (input):
        lineLineIntersection intersection of lines.
        
        :param (input):
        length length of spiral from line A to junction
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        lineToSpiralA tangency point from line to spiral
        
        :param (output):
        lineToSpiralB tangency point from line to spiral
        
        :param (output):
        spiralToSpiral tangency point from spiral to to spiral
        
        :param (output):
        junctionRadius radius at transition between the spirals.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def SymmetricPointShoulderTargetTransition(startPoint: MSPyBentleyGeom.DPoint2d, shoulderPoint: MSPyBentleyGeom.DPoint2d, targetPoint: MSPyBentleyGeom.DPoint2d, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, junctionPoint: MSPyBentleyGeom.DPoint2d, endPoint: MSPyBentleyGeom.DPoint2d) -> bool:
        """
        compute 2 spirals.
        
        :param (input):
        startPoint start point
        
        :param (input):
        shoulderPoint target point for first and last tangents
        
        :param (input):
        targetPoint target point for last tangent
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        junctionPoint transition between spirals. This is the max
        curvature point.
        
        :param (output):
        endPoint end of second spiral.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def TransitionTypeToString(type: int) -> str:
        """
        return the string name of the type
        """
        ...
    
    TransitionType_Arema: int
    
    TransitionType_AustralianRailCorp: int
    
    TransitionType_Biquadratic: int
    
    TransitionType_Bloss: int
    
    TransitionType_ChineseCubic: int
    
    TransitionType_Clothoid: int
    
    TransitionType_Cosine: int
    
    TransitionType_Czech: int
    
    TransitionType_CzechAlongTangent: int
    
    TransitionType_DirectHalfCosine: int
    
    TransitionType_FirstDirectEvaluate: int
    
    TransitionType_Italian: int
    
    TransitionType_JapaneseCubic: int
    
    TransitionType_MXCubicAlongArc: int
    
    TransitionType_MXCubicAlongTangent: int
    
    TransitionType_PolishCubic: int
    
    TransitionType_Sine: int
    
    TransitionType_Unknown: int
    
    TransitionType_Viennese: int
    
    TransitionType_WeightedViennese: int
    
    TransitionType_WesternAustralian: int
    
    def VectorIntegrandCount(self: MSPyBentleyGeom.BSIVectorIntegrand) -> int:
        ...
    
    def __init__(self: MSPyBentleyGeom.DSpiral2dClothoid) -> None:
        ...
    
    @property
    def mLength(arg0: MSPyBentleyGeom.DSpiral2dBase) -> float:
        ...
    
class DSpiral2dCosine:
    """
    None
    """

    class ASLSACollector:
        """
        None
        """
    
        def Collect(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector, centerA: MSPyBentleyGeom.DPoint3d, arcToSpiralA: MSPyBentleyGeom.DPoint3d, sprialA: MSPyBentleyGeom.DSpiral2dBase, sprialToLineA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, arcToSpiralB: MSPyBentleyGeom.DPoint3d, spiralB: MSPyBentleyGeom.DSpiral2dBase, spiralToLibeB: MSPyBentleyGeom.DPoint3d) -> None:
            ...
        
        def __init__(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> None:
            ...
        
    def ArcSpiralLineSpiralArcTransition(centerA: MSPyBentleyGeom.DPoint3d, radiusA: float, lengthA: float, centerB: MSPyBentleyGeom.DPoint3d, radiusB: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, collector: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> int:
        ...
    
    def Clone(self: MSPyBentleyGeom.DSpiral2dBase) -> MSPyBentleyGeom.DSpiral2dBase:
        ...
    
    def ClosestPoint(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, spiralToWorld: Transform, spacePoint: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        Compute the closest spiral point for a given space point.
        
        :param (input):
        spiral spiral to evaluate.
        
        :param (input):
        startFraction start fraction of search range
        
        :param (input):
        endFraction endFraction of search range
        
        :param (input):
        spiralToWorld transform placing the spiral local coordinates into
        the world coordinate system
        
        :param (input):
        spacePoint world coordinates of space point.
        
        :param (output):
        spiralPoint world coordinates of closest point on spiral
        
        :param (output):
        spiralFraction fractional coordinates of closest point on spiral
        
        :param (output):
        minDistance distance from space point to spiralPoint.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def CopyBaseParameters(self: MSPyBentleyGeom.DSpiral2dBase, pSource: MSPyBentleyGeom.DSpiral2dBase) -> None:
        ...
    
    def CreateBearingCurvatureBearingCurvature(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float, extraData: MSPyBentleyGeom.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def CreateBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float, extraData: MSPyBentleyGeom.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def DefaultStrokeAngle() -> float:
        ...
    
    def DistanceToCurvature(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToCurvatureDerivative(self: MSPyBentleyGeom.DSpiral2dBase, arg0: float) -> float:
        """
        distance
        """
        ...
    
    def DistanceToFraction(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToGlobalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToLocalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(s: float, length: float, curvature1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: DVec2d, d2XY: DVec2d, d3XY: DVec2d) -> bool:
        """
        (input) distance for evaluation (input) nominal length. ASSUMED NONZERO (input)
        exit curvature. ASSUMED NONZERO (output) coordinates on spiral (output)
        first derivative wrt distance (output) second derivative wrt distance
        (output) third derivative wrt distance
        """
        ...
    
    def EvaluateVectorIntegrand(self: MSPyBentleyGeom.DSpiral2dBase, distance: float, pF: float) -> None:
        ...
    
    def FractionToDerivatives(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float, dXdf: DVec2d, ddXdfdf: DVec2d, dddXdfdfdf: DVec2d) -> bool:
        ...
    
    def FractionToDistance(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float) -> float:
        ...
    
    def GetExtraData(self: MSPyBentleyGeom.DSpiral2dBase, extraData: MSPyBentleyGeom.DoubleArray) -> None:
        """
        Get the extra data for this spiral. REMARK:This should be a virtual,
        but is implemented as special cases because of API change restriction
        """
        ...
    
    def GetIntervalCount(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, minInterval: int = 0, maxStrokeLength: float = 10000.0) -> int:
        """
        Return an interval count for stroking or integration. Except for
        degenerate single interval cases, the interval count is always even.
        That is the possible values are
        
        :param (input):
        spiral spiral being queried.
        
        :param (input):
        startFraction start of interval to stroke.
        
        :param (input):
        endFraction end of interval to stroke.
        
        :param (input):
        maxRadians max turn between strokes.
        
        :param (input):
        minInterval smallest number of intervals.
        
        :param (input):
        maxStrokeLength largest stroke size. Recommended 10 meters
        """
        ...
    
    def GetTransitionTypeCode(self: MSPyBentleyGeom.DSpiral2dBase) -> int:
        ...
    
    def GetVectorIntegrandCount(self: MSPyBentleyGeom.DSpiral2dBase) -> int:
        ...
    
    def IsValidRLCombination(lengthFromInflection: float, radius: float, spiralType: int = 0) -> bool:
        """
        test if a length-from-inflection and final radius
        combination is " small enough " for reasonable use. Test depends on
        spiral type:
        
        * DSpiral2dBase.TransitionType_None indicates apply the strictest
        test (same as Czech and Italian)
        
        * DSpiral2dBase.TransitionType_Czech and
        DSpiral2dBase.TransitionType_Italian indicate a strict test L<2*R
        
        * other types have no restrictions.
        
        :param (input):
        lengthFromInflection (input) distance along spiral starting at
        inflection and ending at finalRadius.
        
        :param (input):
        finalRadius (input) final radius
        
        :param (input):
        spiralType (input) spiral type.
        
        :param (input):
        lengthFactor expansion or reduction factor to apply to the allowed
        length. +---------------+---------------+---------------+---------
        ------+------
        """
        ...
    
    def LineSpiralArcSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, radius: float, lengthA: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralAToArc: MSPyBentleyGeom.DPoint3d, spiralBToArc: MSPyBentleyGeom.DPoint3d, arc: MSPyBentleyGeom.DEllipse3d) -> bool:
        """
        compute spirals and arc to make a line-to-line
        transition.
        
        :param (input):
        lineAPoint point on line A.
        
        :param (input):
        lineBPoint point on line B.
        
        :param (input):
        lineLineIntersection intersection of lines.
        
        :param (input):
        radius radius for circular part of transition.
        
        :param (input):
        lengthA length of spiral from line A to circle.
        
        :param (input):
        lengthB length of spiral from line B to circle.
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        lineToSpiralA tangency point from line to spiral
        
        :param (output):
        spiralAToArc tangency point from spiral to arc
        
        :param (output):
        lineToSpiralB tangency point from line to spiral
        
        :param (output):
        spiralBToArc tangency point from spiral to arc
        
        :param (output):
        arc arc between spirals.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def ScaleInPlace(self: MSPyBentleyGeom.DSpiral2dBase, s: float) -> bool:
        ...
    
    def SetBearingAndCurvatureLimits(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, theta1: float, curvature1: float) -> bool:
        ...
    
    def SetBearingCurvatureLengthBearing(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, theta1: float) -> bool:
        """
        Set start bearing, start curvature, length, and end
        curvature. (Compute end bearing)
        
        :param (input):
        theta0 start bearing
        
        :param (input):
        curvature0 start curvature
        
        :param (input):
        length arc length
        
        :param (input):
        theta1 end bearing
        """
        ...
    
    def SetBearingCurvatureLengthCurvature(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, curvature1: float) -> bool:
        ...
    
    def StringToTransitionType(name: str) -> int:
        """
        return the integer code for the string name.
        """
        ...
    
    def Stroke(*args, **kwargs):
        """
        Overloaded function.
        
        1. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, pDXY: DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        2. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, xyz0: MSPyBentleyGeom.DPoint3d, pXYZ: MSPyBentleyGeom.DPoint3d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        3. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: DVec2d) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        4. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        5. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: DVec2d, pFraction: float, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        6. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: DVec2d, maxStrokeLength: float) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        7. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, uvPoints: List[DVec2d], fractions: MSPyBentleyGeom.DoubleArray, maxStrokeLength: float = 10000.0) -> tuple
        """
        ...
    
    def StrokeToAnnouncer(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, F: MSPyBentleyGeom.AnnounceDoubleDPoint2d, minIndex: int = 0, maxStrokeLength: float = 10000.0) -> tuple:
        """
        Integrate the vector displacements of a clothoid over a
        fractional interval. This uses the angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        startFraction start fraction for integral.
        
        :param (input):
        endFraction end fraction for integral.
        
        :param (input):
        maxRadians maximum bearing change between computed points. A
        default is used if 0.0 is passed.
        
        :param (input):
        F object with a method F->Announce (f, uv) called to announce
        fraction and coordinate as computed.
        
        :param (output):
        errorBound estimated bound on error.
        
        :param (output):
        minInterval smallest number of intervals allowed
        
        :param (output):
        maxStrokeLength maximum allowed stroke length
        
        :returns:
        false if point integration failed
        """
        ...
    
    def SymmetricLineSpiralSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, length: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralToSpiral: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        compute spirals and arc to make a line-to-line
        transition.
        
        :param (input):
        lineAPoint point on line A.
        
        :param (input):
        lineBPoint point on line B.
        
        :param (input):
        lineLineIntersection intersection of lines.
        
        :param (input):
        length length of spiral from line A to junction
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        lineToSpiralA tangency point from line to spiral
        
        :param (output):
        lineToSpiralB tangency point from line to spiral
        
        :param (output):
        spiralToSpiral tangency point from spiral to to spiral
        
        :param (output):
        junctionRadius radius at transition between the spirals.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def SymmetricPointShoulderTargetTransition(startPoint: MSPyBentleyGeom.DPoint2d, shoulderPoint: MSPyBentleyGeom.DPoint2d, targetPoint: MSPyBentleyGeom.DPoint2d, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, junctionPoint: MSPyBentleyGeom.DPoint2d, endPoint: MSPyBentleyGeom.DPoint2d) -> bool:
        """
        compute 2 spirals.
        
        :param (input):
        startPoint start point
        
        :param (input):
        shoulderPoint target point for first and last tangents
        
        :param (input):
        targetPoint target point for last tangent
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        junctionPoint transition between spirals. This is the max
        curvature point.
        
        :param (output):
        endPoint end of second spiral.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def TransitionTypeToString(type: int) -> str:
        """
        return the string name of the type
        """
        ...
    
    TransitionType_Arema: int
    
    TransitionType_AustralianRailCorp: int
    
    TransitionType_Biquadratic: int
    
    TransitionType_Bloss: int
    
    TransitionType_ChineseCubic: int
    
    TransitionType_Clothoid: int
    
    TransitionType_Cosine: int
    
    TransitionType_Czech: int
    
    TransitionType_CzechAlongTangent: int
    
    TransitionType_DirectHalfCosine: int
    
    TransitionType_FirstDirectEvaluate: int
    
    TransitionType_Italian: int
    
    TransitionType_JapaneseCubic: int
    
    TransitionType_MXCubicAlongArc: int
    
    TransitionType_MXCubicAlongTangent: int
    
    TransitionType_PolishCubic: int
    
    TransitionType_Sine: int
    
    TransitionType_Unknown: int
    
    TransitionType_Viennese: int
    
    TransitionType_WeightedViennese: int
    
    TransitionType_WesternAustralian: int
    
    def VectorIntegrandCount(self: MSPyBentleyGeom.BSIVectorIntegrand) -> int:
        ...
    
    def __init__(self: MSPyBentleyGeom.DSpiral2dCosine) -> None:
        ...
    
    @property
    def mLength(arg0: MSPyBentleyGeom.DSpiral2dBase) -> float:
        ...
    
class DSpiral2dCzech:
    """
    None
    """

    class ASLSACollector:
        """
        None
        """
    
        def Collect(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector, centerA: MSPyBentleyGeom.DPoint3d, arcToSpiralA: MSPyBentleyGeom.DPoint3d, sprialA: MSPyBentleyGeom.DSpiral2dBase, sprialToLineA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, arcToSpiralB: MSPyBentleyGeom.DPoint3d, spiralB: MSPyBentleyGeom.DSpiral2dBase, spiralToLibeB: MSPyBentleyGeom.DPoint3d) -> None:
            ...
        
        def __init__(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> None:
            ...
        
    def ApplyCCWRotation(radians: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: DVec2d, d2XYZ: DVec2d, d3XYZ: DVec2d) -> None:
        """
        rotate xy and optional derivatives by radians. (To be called by
        derived class EvaluateAtDistance when to rotate EvaluateAtDistance
        results from standard position)
        """
        ...
    
    def ArcSpiralLineSpiralArcTransition(centerA: MSPyBentleyGeom.DPoint3d, radiusA: float, lengthA: float, centerB: MSPyBentleyGeom.DPoint3d, radiusB: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, collector: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> int:
        ...
    
    def Clone(self: MSPyBentleyGeom.DSpiral2dBase) -> MSPyBentleyGeom.DSpiral2dBase:
        ...
    
    def ClosestPoint(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, spiralToWorld: Transform, spacePoint: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        Compute the closest spiral point for a given space point.
        
        :param (input):
        spiral spiral to evaluate.
        
        :param (input):
        startFraction start fraction of search range
        
        :param (input):
        endFraction endFraction of search range
        
        :param (input):
        spiralToWorld transform placing the spiral local coordinates into
        the world coordinate system
        
        :param (input):
        spacePoint world coordinates of space point.
        
        :param (output):
        spiralPoint world coordinates of closest point on spiral
        
        :param (output):
        spiralFraction fractional coordinates of closest point on spiral
        
        :param (output):
        minDistance distance from space point to spiralPoint.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def CopyBaseParameters(self: MSPyBentleyGeom.DSpiral2dBase, pSource: MSPyBentleyGeom.DSpiral2dBase) -> None:
        ...
    
    def CreateBearingCurvatureBearingCurvature(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float, extraData: MSPyBentleyGeom.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def CreateBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float, extraData: MSPyBentleyGeom.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def DefaultStrokeAngle() -> float:
        ...
    
    def DistanceToCurvature(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToCurvatureDerivative(self: MSPyBentleyGeom.DSpiral2dBase, arg0: float) -> float:
        """
        distance
        """
        ...
    
    def DistanceToFraction(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToGlobalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToLocalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def EvaluateAtFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: DVec2d, d2XYZ: DVec2d, d3XYZ: DVec2d) -> bool:
        """
        Evaluate the spiral and derivatives at specified fractional position
        return true if valid evaluation. DSpiral2dDirectEvaluation default
        implementation returns false.
        """
        ...
    
    @staticmethod
    def EvaluateAtFractionOfNominalLengthInStandardOrientation(fraction: float, Lx: float, Ls: float, radius1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: DVec2d, d2XY: DVec2d, d3XY: DVec2d) -> bool:
        """
        Evaluate at distance a spiral in standard orientation -- zero
        curvature at origin.
        """
        ...
    
    def EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(s: float, length: float, curvature1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: DVec2d, d2XY: DVec2d, d3XY: DVec2d) -> bool:
        """
        (input) distance for evaluation (input) nominal length. ASSUMED NONZERO (input)
        exit curvature. ASSUMED NONZERO (output) coordinates on spiral (output)
        first derivative wrt distance (output) second derivative wrt distance
        (output) third derivative wrt distance
        """
        ...
    
    def EvaluateVectorIntegrand(self: MSPyBentleyGeom.DSpiral2dBase, distance: float, pF: float) -> None:
        ...
    
    def FractionToCurvature(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float:
        """
        Return the true curvature at fractional position. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDCurvatureDFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> tuple:
        """
        Return the true curvature derivative wrt fraction. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDerivatives(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float, dXdf: DVec2d, ddXdfdf: DVec2d, dddXdfdfdf: DVec2d) -> bool:
        ...
    
    def FractionToDistance(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float) -> float:
        ...
    
    def FractionToLocalAngle(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float:
        """
        Return the tangent angle (in radians) in local coordinates
        """
        ...
    
    def FractionToVelocity(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float:
        """
        Return the magnitude of the true derivative of position wrt fraction.
        Implemented in DSpiral2dDirectEvaluation, not individual classes.
        Assume EvaluateAtFraction.
        """
        ...
    
    def GetExtraData(self: MSPyBentleyGeom.DSpiral2dBase, extraData: MSPyBentleyGeom.DoubleArray) -> None:
        """
        Get the extra data for this spiral. REMARK:This should be a virtual,
        but is implemented as special cases because of API change restriction
        """
        ...
    
    def GetIntervalCount(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, minInterval: int = 0, maxStrokeLength: float = 10000.0) -> int:
        """
        Return an interval count for stroking or integration. Except for
        degenerate single interval cases, the interval count is always even.
        That is the possible values are
        
        :param (input):
        spiral spiral being queried.
        
        :param (input):
        startFraction start of interval to stroke.
        
        :param (input):
        endFraction end of interval to stroke.
        
        :param (input):
        maxRadians max turn between strokes.
        
        :param (input):
        minInterval smallest number of intervals.
        
        :param (input):
        maxStrokeLength largest stroke size. Recommended 10 meters
        """
        ...
    
    def GetTransitionTypeCode(self: MSPyBentleyGeom.DSpiral2dBase) -> int:
        ...
    
    def GetVectorIntegrandCount(self: MSPyBentleyGeom.DSpiral2dBase) -> int:
        ...
    
    def IsValidRLCombination(lengthFromInflection: float, radius: float, spiralType: int = 0) -> bool:
        """
        test if a length-from-inflection and final radius
        combination is " small enough " for reasonable use. Test depends on
        spiral type:
        
        * DSpiral2dBase.TransitionType_None indicates apply the strictest
        test (same as Czech and Italian)
        
        * DSpiral2dBase.TransitionType_Czech and
        DSpiral2dBase.TransitionType_Italian indicate a strict test L<2*R
        
        * other types have no restrictions.
        
        :param (input):
        lengthFromInflection (input) distance along spiral starting at
        inflection and ending at finalRadius.
        
        :param (input):
        finalRadius (input) final radius
        
        :param (input):
        spiralType (input) spiral type.
        
        :param (input):
        lengthFactor expansion or reduction factor to apply to the allowed
        length. +---------------+---------------+---------------+---------
        ------+------
        """
        ...
    
    def LineSpiralArcSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, radius: float, lengthA: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralAToArc: MSPyBentleyGeom.DPoint3d, spiralBToArc: MSPyBentleyGeom.DPoint3d, arc: MSPyBentleyGeom.DEllipse3d) -> bool:
        """
        compute spirals and arc to make a line-to-line
        transition.
        
        :param (input):
        lineAPoint point on line A.
        
        :param (input):
        lineBPoint point on line B.
        
        :param (input):
        lineLineIntersection intersection of lines.
        
        :param (input):
        radius radius for circular part of transition.
        
        :param (input):
        lengthA length of spiral from line A to circle.
        
        :param (input):
        lengthB length of spiral from line B to circle.
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        lineToSpiralA tangency point from line to spiral
        
        :param (output):
        spiralAToArc tangency point from spiral to arc
        
        :param (output):
        lineToSpiralB tangency point from line to spiral
        
        :param (output):
        spiralBToArc tangency point from spiral to arc
        
        :param (output):
        arc arc between spirals.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def ScaleInPlace(self: MSPyBentleyGeom.DSpiral2dBase, s: float) -> bool:
        ...
    
    def SetBearingAndCurvatureLimits(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, theta1: float, curvature1: float) -> bool:
        ...
    
    def SetBearingCurvatureLengthBearing(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, theta1: float) -> bool:
        """
        Set start bearing, start curvature, length, and end
        curvature. (Compute end bearing)
        
        :param (input):
        theta0 start bearing
        
        :param (input):
        curvature0 start curvature
        
        :param (input):
        length arc length
        
        :param (input):
        theta1 end bearing
        """
        ...
    
    def SetBearingCurvatureLengthCurvature(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, curvature1: float) -> bool:
        ...
    
    def StringToTransitionType(name: str) -> int:
        """
        return the integer code for the string name.
        """
        ...
    
    def Stroke(*args, **kwargs):
        """
        Overloaded function.
        
        1. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, pDXY: DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        2. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, xyz0: MSPyBentleyGeom.DPoint3d, pXYZ: MSPyBentleyGeom.DPoint3d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        3. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: DVec2d) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        4. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        5. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: DVec2d, pFraction: float, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        6. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: DVec2d, maxStrokeLength: float) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        7. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, uvPoints: List[DVec2d], fractions: MSPyBentleyGeom.DoubleArray, maxStrokeLength: float = 10000.0) -> tuple
        """
        ...
    
    def StrokeToAnnouncer(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, F: MSPyBentleyGeom.AnnounceDoubleDPoint2d, minIndex: int = 0, maxStrokeLength: float = 10000.0) -> tuple:
        """
        Integrate the vector displacements of a clothoid over a
        fractional interval. This uses the angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        startFraction start fraction for integral.
        
        :param (input):
        endFraction end fraction for integral.
        
        :param (input):
        maxRadians maximum bearing change between computed points. A
        default is used if 0.0 is passed.
        
        :param (input):
        F object with a method F->Announce (f, uv) called to announce
        fraction and coordinate as computed.
        
        :param (output):
        errorBound estimated bound on error.
        
        :param (output):
        minInterval smallest number of intervals allowed
        
        :param (output):
        maxStrokeLength maximum allowed stroke length
        
        :returns:
        false if point integration failed
        """
        ...
    
    def SymmetricLineSpiralSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, length: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralToSpiral: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        compute spirals and arc to make a line-to-line
        transition.
        
        :param (input):
        lineAPoint point on line A.
        
        :param (input):
        lineBPoint point on line B.
        
        :param (input):
        lineLineIntersection intersection of lines.
        
        :param (input):
        length length of spiral from line A to junction
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        lineToSpiralA tangency point from line to spiral
        
        :param (output):
        lineToSpiralB tangency point from line to spiral
        
        :param (output):
        spiralToSpiral tangency point from spiral to to spiral
        
        :param (output):
        junctionRadius radius at transition between the spirals.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def SymmetricPointShoulderTargetTransition(startPoint: MSPyBentleyGeom.DPoint2d, shoulderPoint: MSPyBentleyGeom.DPoint2d, targetPoint: MSPyBentleyGeom.DPoint2d, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, junctionPoint: MSPyBentleyGeom.DPoint2d, endPoint: MSPyBentleyGeom.DPoint2d) -> bool:
        """
        compute 2 spirals.
        
        :param (input):
        startPoint start point
        
        :param (input):
        shoulderPoint target point for first and last tangents
        
        :param (input):
        targetPoint target point for last tangent
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        junctionPoint transition between spirals. This is the max
        curvature point.
        
        :param (output):
        endPoint end of second spiral.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def TransitionTypeToString(type: int) -> str:
        """
        return the string name of the type
        """
        ...
    
    TransitionType_Arema: int
    
    TransitionType_AustralianRailCorp: int
    
    TransitionType_Biquadratic: int
    
    TransitionType_Bloss: int
    
    TransitionType_ChineseCubic: int
    
    TransitionType_Clothoid: int
    
    TransitionType_Cosine: int
    
    TransitionType_Czech: int
    
    TransitionType_CzechAlongTangent: int
    
    TransitionType_DirectHalfCosine: int
    
    TransitionType_FirstDirectEvaluate: int
    
    TransitionType_Italian: int
    
    TransitionType_JapaneseCubic: int
    
    TransitionType_MXCubicAlongArc: int
    
    TransitionType_MXCubicAlongTangent: int
    
    TransitionType_PolishCubic: int
    
    TransitionType_Sine: int
    
    TransitionType_Unknown: int
    
    TransitionType_Viennese: int
    
    TransitionType_WeightedViennese: int
    
    TransitionType_WesternAustralian: int
    
    def VectorIntegrandCount(self: MSPyBentleyGeom.BSIVectorIntegrand) -> int:
        ...
    
    def __init__(self: MSPyBentleyGeom.DSpiral2dCzech, nominalLength: float) -> None:
        ...
    
    @property
    def mLength(arg0: MSPyBentleyGeom.DSpiral2dBase) -> float:
        ...
    
class DSpiral2dCzechAlongTangent:
    """
    None
    """

    class ASLSACollector:
        """
        None
        """
    
        def Collect(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector, centerA: MSPyBentleyGeom.DPoint3d, arcToSpiralA: MSPyBentleyGeom.DPoint3d, sprialA: MSPyBentleyGeom.DSpiral2dBase, sprialToLineA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, arcToSpiralB: MSPyBentleyGeom.DPoint3d, spiralB: MSPyBentleyGeom.DSpiral2dBase, spiralToLibeB: MSPyBentleyGeom.DPoint3d) -> None:
            ...
        
        def __init__(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> None:
            ...
        
    def ApplyCCWRotation(radians: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: DVec2d, d2XYZ: DVec2d, d3XYZ: DVec2d) -> None:
        """
        rotate xy and optional derivatives by radians. (To be called by
        derived class EvaluateAtDistance when to rotate EvaluateAtDistance
        results from standard position)
        """
        ...
    
    def ArcSpiralLineSpiralArcTransition(centerA: MSPyBentleyGeom.DPoint3d, radiusA: float, lengthA: float, centerB: MSPyBentleyGeom.DPoint3d, radiusB: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, collector: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> int:
        ...
    
    def Clone(self: MSPyBentleyGeom.DSpiral2dBase) -> MSPyBentleyGeom.DSpiral2dBase:
        ...
    
    def ClosestPoint(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, spiralToWorld: Transform, spacePoint: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        Compute the closest spiral point for a given space point.
        
        :param (input):
        spiral spiral to evaluate.
        
        :param (input):
        startFraction start fraction of search range
        
        :param (input):
        endFraction endFraction of search range
        
        :param (input):
        spiralToWorld transform placing the spiral local coordinates into
        the world coordinate system
        
        :param (input):
        spacePoint world coordinates of space point.
        
        :param (output):
        spiralPoint world coordinates of closest point on spiral
        
        :param (output):
        spiralFraction fractional coordinates of closest point on spiral
        
        :param (output):
        minDistance distance from space point to spiralPoint.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def CopyBaseParameters(self: MSPyBentleyGeom.DSpiral2dBase, pSource: MSPyBentleyGeom.DSpiral2dBase) -> None:
        ...
    
    def CreateBearingCurvatureBearingCurvature(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float, extraData: MSPyBentleyGeom.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def CreateBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float, extraData: MSPyBentleyGeom.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def DefaultStrokeAngle() -> float:
        ...
    
    def DistanceToCurvature(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToCurvatureDerivative(self: MSPyBentleyGeom.DSpiral2dBase, arg0: float) -> float:
        """
        distance
        """
        ...
    
    def DistanceToFraction(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToGlobalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToLocalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def EvaluateAtFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: DVec2d, d2XYZ: DVec2d, d3XYZ: DVec2d) -> bool:
        """
        Evaluate the spiral and derivatives at specified fractional position
        return true if valid evaluation. DSpiral2dDirectEvaluation default
        implementation returns false.
        """
        ...
    
    @staticmethod
    def EvaluateAtFractionAlongTangentInStandardOrientation(fraction: float, axisLength: float, radius1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: DVec2d, d2XY: DVec2d, d3XY: DVec2d) -> bool:
        """
        Evaluate at distance a spiral in standard orientation -- zero
        curvature at origin.
        """
        ...
    
    def EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(s: float, length: float, curvature1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: DVec2d, d2XY: DVec2d, d3XY: DVec2d) -> bool:
        """
        (input) distance for evaluation (input) nominal length. ASSUMED NONZERO (input)
        exit curvature. ASSUMED NONZERO (output) coordinates on spiral (output)
        first derivative wrt distance (output) second derivative wrt distance
        (output) third derivative wrt distance
        """
        ...
    
    def EvaluateVectorIntegrand(self: MSPyBentleyGeom.DSpiral2dBase, distance: float, pF: float) -> None:
        ...
    
    def FractionToCurvature(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float:
        """
        Return the true curvature at fractional position. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDCurvatureDFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> tuple:
        """
        Return the true curvature derivative wrt fraction. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDerivatives(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float, dXdf: DVec2d, ddXdfdf: DVec2d, dddXdfdfdf: DVec2d) -> bool:
        ...
    
    def FractionToDistance(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float) -> float:
        ...
    
    def FractionToLocalAngle(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float:
        """
        Return the tangent angle (in radians) in local coordinates
        """
        ...
    
    def FractionToVelocity(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float:
        """
        Return the magnitude of the true derivative of position wrt fraction.
        Implemented in DSpiral2dDirectEvaluation, not individual classes.
        Assume EvaluateAtFraction.
        """
        ...
    
    def GetBezierPoles(self: MSPyBentleyGeom.DSpiral2dCzechAlongTangent, poles: MSPyBentleyGeom.DPoint3dArray, startFraction: float, endFraction: float) -> bool:
        """
        Return poles for preferred representation as a bezier curve These are
        in the local coordinates of the standard orientation
        """
        ...
    
    def GetExtraData(self: MSPyBentleyGeom.DSpiral2dBase, extraData: MSPyBentleyGeom.DoubleArray) -> None:
        """
        Get the extra data for this spiral. REMARK:This should be a virtual,
        but is implemented as special cases because of API change restriction
        """
        ...
    
    def GetIntervalCount(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, minInterval: int = 0, maxStrokeLength: float = 10000.0) -> int:
        """
        Return an interval count for stroking or integration. Except for
        degenerate single interval cases, the interval count is always even.
        That is the possible values are
        
        :param (input):
        spiral spiral being queried.
        
        :param (input):
        startFraction start of interval to stroke.
        
        :param (input):
        endFraction end of interval to stroke.
        
        :param (input):
        maxRadians max turn between strokes.
        
        :param (input):
        minInterval smallest number of intervals.
        
        :param (input):
        maxStrokeLength largest stroke size. Recommended 10 meters
        """
        ...
    
    def GetTransitionTypeCode(self: MSPyBentleyGeom.DSpiral2dBase) -> int:
        ...
    
    def GetVectorIntegrandCount(self: MSPyBentleyGeom.DSpiral2dBase) -> int:
        ...
    
    def IsValidRLCombination(lengthFromInflection: float, radius: float, spiralType: int = 0) -> bool:
        """
        test if a length-from-inflection and final radius
        combination is " small enough " for reasonable use. Test depends on
        spiral type:
        
        * DSpiral2dBase.TransitionType_None indicates apply the strictest
        test (same as Czech and Italian)
        
        * DSpiral2dBase.TransitionType_Czech and
        DSpiral2dBase.TransitionType_Italian indicate a strict test L<2*R
        
        * other types have no restrictions.
        
        :param (input):
        lengthFromInflection (input) distance along spiral starting at
        inflection and ending at finalRadius.
        
        :param (input):
        finalRadius (input) final radius
        
        :param (input):
        spiralType (input) spiral type.
        
        :param (input):
        lengthFactor expansion or reduction factor to apply to the allowed
        length. +---------------+---------------+---------------+---------
        ------+------
        """
        ...
    
    def LineSpiralArcSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, radius: float, lengthA: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralAToArc: MSPyBentleyGeom.DPoint3d, spiralBToArc: MSPyBentleyGeom.DPoint3d, arc: MSPyBentleyGeom.DEllipse3d) -> bool:
        """
        compute spirals and arc to make a line-to-line
        transition.
        
        :param (input):
        lineAPoint point on line A.
        
        :param (input):
        lineBPoint point on line B.
        
        :param (input):
        lineLineIntersection intersection of lines.
        
        :param (input):
        radius radius for circular part of transition.
        
        :param (input):
        lengthA length of spiral from line A to circle.
        
        :param (input):
        lengthB length of spiral from line B to circle.
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        lineToSpiralA tangency point from line to spiral
        
        :param (output):
        spiralAToArc tangency point from spiral to arc
        
        :param (output):
        lineToSpiralB tangency point from line to spiral
        
        :param (output):
        spiralBToArc tangency point from spiral to arc
        
        :param (output):
        arc arc between spirals.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def ScaleInPlace(self: MSPyBentleyGeom.DSpiral2dBase, s: float) -> bool:
        ...
    
    def SetBearingAndCurvatureLimits(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, theta1: float, curvature1: float) -> bool:
        ...
    
    def SetBearingCurvatureLengthBearing(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, theta1: float) -> bool:
        """
        Set start bearing, start curvature, length, and end
        curvature. (Compute end bearing)
        
        :param (input):
        theta0 start bearing
        
        :param (input):
        curvature0 start curvature
        
        :param (input):
        length arc length
        
        :param (input):
        theta1 end bearing
        """
        ...
    
    def SetBearingCurvatureLengthCurvature(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, curvature1: float) -> bool:
        ...
    
    def StringToTransitionType(name: str) -> int:
        """
        return the integer code for the string name.
        """
        ...
    
    def Stroke(*args, **kwargs):
        """
        Overloaded function.
        
        1. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, pDXY: DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        2. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, xyz0: MSPyBentleyGeom.DPoint3d, pXYZ: MSPyBentleyGeom.DPoint3d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        3. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: DVec2d) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        4. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        5. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: DVec2d, pFraction: float, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        6. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: DVec2d, maxStrokeLength: float) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        7. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, uvPoints: List[DVec2d], fractions: MSPyBentleyGeom.DoubleArray, maxStrokeLength: float = 10000.0) -> tuple
        """
        ...
    
    def StrokeToAnnouncer(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, F: MSPyBentleyGeom.AnnounceDoubleDPoint2d, minIndex: int = 0, maxStrokeLength: float = 10000.0) -> tuple:
        """
        Integrate the vector displacements of a clothoid over a
        fractional interval. This uses the angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        startFraction start fraction for integral.
        
        :param (input):
        endFraction end fraction for integral.
        
        :param (input):
        maxRadians maximum bearing change between computed points. A
        default is used if 0.0 is passed.
        
        :param (input):
        F object with a method F->Announce (f, uv) called to announce
        fraction and coordinate as computed.
        
        :param (output):
        errorBound estimated bound on error.
        
        :param (output):
        minInterval smallest number of intervals allowed
        
        :param (output):
        maxStrokeLength maximum allowed stroke length
        
        :returns:
        false if point integration failed
        """
        ...
    
    def SymmetricLineSpiralSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, length: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralToSpiral: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        compute spirals and arc to make a line-to-line
        transition.
        
        :param (input):
        lineAPoint point on line A.
        
        :param (input):
        lineBPoint point on line B.
        
        :param (input):
        lineLineIntersection intersection of lines.
        
        :param (input):
        length length of spiral from line A to junction
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        lineToSpiralA tangency point from line to spiral
        
        :param (output):
        lineToSpiralB tangency point from line to spiral
        
        :param (output):
        spiralToSpiral tangency point from spiral to to spiral
        
        :param (output):
        junctionRadius radius at transition between the spirals.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def SymmetricPointShoulderTargetTransition(startPoint: MSPyBentleyGeom.DPoint2d, shoulderPoint: MSPyBentleyGeom.DPoint2d, targetPoint: MSPyBentleyGeom.DPoint2d, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, junctionPoint: MSPyBentleyGeom.DPoint2d, endPoint: MSPyBentleyGeom.DPoint2d) -> bool:
        """
        compute 2 spirals.
        
        :param (input):
        startPoint start point
        
        :param (input):
        shoulderPoint target point for first and last tangents
        
        :param (input):
        targetPoint target point for last tangent
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        junctionPoint transition between spirals. This is the max
        curvature point.
        
        :param (output):
        endPoint end of second spiral.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def TransitionTypeToString(type: int) -> str:
        """
        return the string name of the type
        """
        ...
    
    TransitionType_Arema: int
    
    TransitionType_AustralianRailCorp: int
    
    TransitionType_Biquadratic: int
    
    TransitionType_Bloss: int
    
    TransitionType_ChineseCubic: int
    
    TransitionType_Clothoid: int
    
    TransitionType_Cosine: int
    
    TransitionType_Czech: int
    
    TransitionType_CzechAlongTangent: int
    
    TransitionType_DirectHalfCosine: int
    
    TransitionType_FirstDirectEvaluate: int
    
    TransitionType_Italian: int
    
    TransitionType_JapaneseCubic: int
    
    TransitionType_MXCubicAlongArc: int
    
    TransitionType_MXCubicAlongTangent: int
    
    TransitionType_PolishCubic: int
    
    TransitionType_Sine: int
    
    TransitionType_Unknown: int
    
    TransitionType_Viennese: int
    
    TransitionType_WeightedViennese: int
    
    TransitionType_WesternAustralian: int
    
    def VectorIntegrandCount(self: MSPyBentleyGeom.BSIVectorIntegrand) -> int:
        ...
    
    def __init__(self: MSPyBentleyGeom.DSpiral2dCzechAlongTangent, nominalLength: float) -> None:
        ...
    
    @property
    def mLength(arg0: MSPyBentleyGeom.DSpiral2dBase) -> float:
        ...
    
class DSpiral2dDirectEvaluation:
    """
    None
    """

    class ASLSACollector:
        """
        None
        """
    
        def Collect(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector, centerA: MSPyBentleyGeom.DPoint3d, arcToSpiralA: MSPyBentleyGeom.DPoint3d, sprialA: MSPyBentleyGeom.DSpiral2dBase, sprialToLineA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, arcToSpiralB: MSPyBentleyGeom.DPoint3d, spiralB: MSPyBentleyGeom.DSpiral2dBase, spiralToLibeB: MSPyBentleyGeom.DPoint3d) -> None:
            ...
        
        def __init__(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> None:
            ...
        
    @staticmethod
    def ApplyCCWRotation(radians: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: DVec2d, d2XYZ: DVec2d, d3XYZ: DVec2d) -> None:
        """
        rotate xy and optional derivatives by radians. (To be called by
        derived class EvaluateAtDistance when to rotate EvaluateAtDistance
        results from standard position)
        """
        ...
    
    def ArcSpiralLineSpiralArcTransition(centerA: MSPyBentleyGeom.DPoint3d, radiusA: float, lengthA: float, centerB: MSPyBentleyGeom.DPoint3d, radiusB: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, collector: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> int:
        ...
    
    def Clone(self: MSPyBentleyGeom.DSpiral2dBase) -> MSPyBentleyGeom.DSpiral2dBase:
        ...
    
    def ClosestPoint(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, spiralToWorld: Transform, spacePoint: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        Compute the closest spiral point for a given space point.
        
        :param (input):
        spiral spiral to evaluate.
        
        :param (input):
        startFraction start fraction of search range
        
        :param (input):
        endFraction endFraction of search range
        
        :param (input):
        spiralToWorld transform placing the spiral local coordinates into
        the world coordinate system
        
        :param (input):
        spacePoint world coordinates of space point.
        
        :param (output):
        spiralPoint world coordinates of closest point on spiral
        
        :param (output):
        spiralFraction fractional coordinates of closest point on spiral
        
        :param (output):
        minDistance distance from space point to spiralPoint.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def CopyBaseParameters(self: MSPyBentleyGeom.DSpiral2dBase, pSource: MSPyBentleyGeom.DSpiral2dBase) -> None:
        ...
    
    def CreateBearingCurvatureBearingCurvature(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float, extraData: MSPyBentleyGeom.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def CreateBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float, extraData: MSPyBentleyGeom.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def DefaultStrokeAngle() -> float:
        ...
    
    def DistanceToCurvature(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToCurvatureDerivative(self: MSPyBentleyGeom.DSpiral2dBase, arg0: float) -> float:
        """
        distance
        """
        ...
    
    def DistanceToFraction(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToGlobalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToLocalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def EvaluateAtFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: DVec2d, d2XYZ: DVec2d, d3XYZ: DVec2d) -> bool:
        """
        Evaluate the spiral and derivatives at specified fractional position
        return true if valid evaluation. DSpiral2dDirectEvaluation default
        implementation returns false.
        """
        ...
    
    def EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(s: float, length: float, curvature1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: DVec2d, d2XY: DVec2d, d3XY: DVec2d) -> bool:
        """
        (input) distance for evaluation (input) nominal length. ASSUMED NONZERO (input)
        exit curvature. ASSUMED NONZERO (output) coordinates on spiral (output)
        first derivative wrt distance (output) second derivative wrt distance
        (output) third derivative wrt distance
        """
        ...
    
    def EvaluateVectorIntegrand(self: MSPyBentleyGeom.DSpiral2dBase, distance: float, pF: float) -> None:
        ...
    
    def FractionToCurvature(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float:
        """
        Return the true curvature at fractional position. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDCurvatureDFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> tuple:
        """
        Return the true curvature derivative wrt fraction. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDerivatives(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float, dXdf: DVec2d, ddXdfdf: DVec2d, dddXdfdfdf: DVec2d) -> bool:
        ...
    
    def FractionToDistance(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float) -> float:
        ...
    
    def FractionToLocalAngle(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float:
        """
        Return the tangent angle (in radians) in local coordinates
        """
        ...
    
    def FractionToVelocity(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float:
        """
        Return the magnitude of the true derivative of position wrt fraction.
        Implemented in DSpiral2dDirectEvaluation, not individual classes.
        Assume EvaluateAtFraction.
        """
        ...
    
    def GetExtraData(self: MSPyBentleyGeom.DSpiral2dBase, extraData: MSPyBentleyGeom.DoubleArray) -> None:
        """
        Get the extra data for this spiral. REMARK:This should be a virtual,
        but is implemented as special cases because of API change restriction
        """
        ...
    
    def GetIntervalCount(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, minInterval: int = 0, maxStrokeLength: float = 10000.0) -> int:
        """
        Return an interval count for stroking or integration. Except for
        degenerate single interval cases, the interval count is always even.
        That is the possible values are
        
        :param (input):
        spiral spiral being queried.
        
        :param (input):
        startFraction start of interval to stroke.
        
        :param (input):
        endFraction end of interval to stroke.
        
        :param (input):
        maxRadians max turn between strokes.
        
        :param (input):
        minInterval smallest number of intervals.
        
        :param (input):
        maxStrokeLength largest stroke size. Recommended 10 meters
        """
        ...
    
    def GetTransitionTypeCode(self: MSPyBentleyGeom.DSpiral2dBase) -> int:
        ...
    
    def GetVectorIntegrandCount(self: MSPyBentleyGeom.DSpiral2dBase) -> int:
        ...
    
    def IsValidRLCombination(lengthFromInflection: float, radius: float, spiralType: int = 0) -> bool:
        """
        test if a length-from-inflection and final radius
        combination is " small enough " for reasonable use. Test depends on
        spiral type:
        
        * DSpiral2dBase.TransitionType_None indicates apply the strictest
        test (same as Czech and Italian)
        
        * DSpiral2dBase.TransitionType_Czech and
        DSpiral2dBase.TransitionType_Italian indicate a strict test L<2*R
        
        * other types have no restrictions.
        
        :param (input):
        lengthFromInflection (input) distance along spiral starting at
        inflection and ending at finalRadius.
        
        :param (input):
        finalRadius (input) final radius
        
        :param (input):
        spiralType (input) spiral type.
        
        :param (input):
        lengthFactor expansion or reduction factor to apply to the allowed
        length. +---------------+---------------+---------------+---------
        ------+------
        """
        ...
    
    def LineSpiralArcSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, radius: float, lengthA: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralAToArc: MSPyBentleyGeom.DPoint3d, spiralBToArc: MSPyBentleyGeom.DPoint3d, arc: MSPyBentleyGeom.DEllipse3d) -> bool:
        """
        compute spirals and arc to make a line-to-line
        transition.
        
        :param (input):
        lineAPoint point on line A.
        
        :param (input):
        lineBPoint point on line B.
        
        :param (input):
        lineLineIntersection intersection of lines.
        
        :param (input):
        radius radius for circular part of transition.
        
        :param (input):
        lengthA length of spiral from line A to circle.
        
        :param (input):
        lengthB length of spiral from line B to circle.
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        lineToSpiralA tangency point from line to spiral
        
        :param (output):
        spiralAToArc tangency point from spiral to arc
        
        :param (output):
        lineToSpiralB tangency point from line to spiral
        
        :param (output):
        spiralBToArc tangency point from spiral to arc
        
        :param (output):
        arc arc between spirals.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def ScaleInPlace(self: MSPyBentleyGeom.DSpiral2dBase, s: float) -> bool:
        ...
    
    def SetBearingAndCurvatureLimits(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, theta1: float, curvature1: float) -> bool:
        ...
    
    def SetBearingCurvatureLengthBearing(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, theta1: float) -> bool:
        """
        Set start bearing, start curvature, length, and end
        curvature. (Compute end bearing)
        
        :param (input):
        theta0 start bearing
        
        :param (input):
        curvature0 start curvature
        
        :param (input):
        length arc length
        
        :param (input):
        theta1 end bearing
        """
        ...
    
    def SetBearingCurvatureLengthCurvature(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, curvature1: float) -> bool:
        ...
    
    def StringToTransitionType(name: str) -> int:
        """
        return the integer code for the string name.
        """
        ...
    
    def Stroke(*args, **kwargs):
        """
        Overloaded function.
        
        1. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, pDXY: DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        2. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, xyz0: MSPyBentleyGeom.DPoint3d, pXYZ: MSPyBentleyGeom.DPoint3d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        3. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: DVec2d) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        4. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        5. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: DVec2d, pFraction: float, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        6. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: DVec2d, maxStrokeLength: float) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        7. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, uvPoints: List[DVec2d], fractions: MSPyBentleyGeom.DoubleArray, maxStrokeLength: float = 10000.0) -> tuple
        """
        ...
    
    def StrokeToAnnouncer(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, F: MSPyBentleyGeom.AnnounceDoubleDPoint2d, minIndex: int = 0, maxStrokeLength: float = 10000.0) -> tuple:
        """
        Integrate the vector displacements of a clothoid over a
        fractional interval. This uses the angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        startFraction start fraction for integral.
        
        :param (input):
        endFraction end fraction for integral.
        
        :param (input):
        maxRadians maximum bearing change between computed points. A
        default is used if 0.0 is passed.
        
        :param (input):
        F object with a method F->Announce (f, uv) called to announce
        fraction and coordinate as computed.
        
        :param (output):
        errorBound estimated bound on error.
        
        :param (output):
        minInterval smallest number of intervals allowed
        
        :param (output):
        maxStrokeLength maximum allowed stroke length
        
        :returns:
        false if point integration failed
        """
        ...
    
    def SymmetricLineSpiralSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, length: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralToSpiral: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        compute spirals and arc to make a line-to-line
        transition.
        
        :param (input):
        lineAPoint point on line A.
        
        :param (input):
        lineBPoint point on line B.
        
        :param (input):
        lineLineIntersection intersection of lines.
        
        :param (input):
        length length of spiral from line A to junction
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        lineToSpiralA tangency point from line to spiral
        
        :param (output):
        lineToSpiralB tangency point from line to spiral
        
        :param (output):
        spiralToSpiral tangency point from spiral to to spiral
        
        :param (output):
        junctionRadius radius at transition between the spirals.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def SymmetricPointShoulderTargetTransition(startPoint: MSPyBentleyGeom.DPoint2d, shoulderPoint: MSPyBentleyGeom.DPoint2d, targetPoint: MSPyBentleyGeom.DPoint2d, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, junctionPoint: MSPyBentleyGeom.DPoint2d, endPoint: MSPyBentleyGeom.DPoint2d) -> bool:
        """
        compute 2 spirals.
        
        :param (input):
        startPoint start point
        
        :param (input):
        shoulderPoint target point for first and last tangents
        
        :param (input):
        targetPoint target point for last tangent
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        junctionPoint transition between spirals. This is the max
        curvature point.
        
        :param (output):
        endPoint end of second spiral.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def TransitionTypeToString(type: int) -> str:
        """
        return the string name of the type
        """
        ...
    
    TransitionType_Arema: int
    
    TransitionType_AustralianRailCorp: int
    
    TransitionType_Biquadratic: int
    
    TransitionType_Bloss: int
    
    TransitionType_ChineseCubic: int
    
    TransitionType_Clothoid: int
    
    TransitionType_Cosine: int
    
    TransitionType_Czech: int
    
    TransitionType_CzechAlongTangent: int
    
    TransitionType_DirectHalfCosine: int
    
    TransitionType_FirstDirectEvaluate: int
    
    TransitionType_Italian: int
    
    TransitionType_JapaneseCubic: int
    
    TransitionType_MXCubicAlongArc: int
    
    TransitionType_MXCubicAlongTangent: int
    
    TransitionType_PolishCubic: int
    
    TransitionType_Sine: int
    
    TransitionType_Unknown: int
    
    TransitionType_Viennese: int
    
    TransitionType_WeightedViennese: int
    
    TransitionType_WesternAustralian: int
    
    def VectorIntegrandCount(self: MSPyBentleyGeom.BSIVectorIntegrand) -> int:
        ...
    
    def __init__(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, nominalLength: float) -> None:
        ...
    
    @property
    def mLength(arg0: MSPyBentleyGeom.DSpiral2dBase) -> float:
        ...
    
class DSpiral2dDirectHalfCosine:
    """
    None
    """

    class ASLSACollector:
        """
        None
        """
    
        def Collect(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector, centerA: MSPyBentleyGeom.DPoint3d, arcToSpiralA: MSPyBentleyGeom.DPoint3d, sprialA: MSPyBentleyGeom.DSpiral2dBase, sprialToLineA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, arcToSpiralB: MSPyBentleyGeom.DPoint3d, spiralB: MSPyBentleyGeom.DSpiral2dBase, spiralToLibeB: MSPyBentleyGeom.DPoint3d) -> None:
            ...
        
        def __init__(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> None:
            ...
        
    def ApplyCCWRotation(radians: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: DVec2d, d2XYZ: DVec2d, d3XYZ: DVec2d) -> None:
        """
        rotate xy and optional derivatives by radians. (To be called by
        derived class EvaluateAtDistance when to rotate EvaluateAtDistance
        results from standard position)
        """
        ...
    
    def ArcSpiralLineSpiralArcTransition(centerA: MSPyBentleyGeom.DPoint3d, radiusA: float, lengthA: float, centerB: MSPyBentleyGeom.DPoint3d, radiusB: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, collector: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> int:
        ...
    
    def Clone(self: MSPyBentleyGeom.DSpiral2dBase) -> MSPyBentleyGeom.DSpiral2dBase:
        ...
    
    def ClosestPoint(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, spiralToWorld: Transform, spacePoint: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        Compute the closest spiral point for a given space point.
        
        :param (input):
        spiral spiral to evaluate.
        
        :param (input):
        startFraction start fraction of search range
        
        :param (input):
        endFraction endFraction of search range
        
        :param (input):
        spiralToWorld transform placing the spiral local coordinates into
        the world coordinate system
        
        :param (input):
        spacePoint world coordinates of space point.
        
        :param (output):
        spiralPoint world coordinates of closest point on spiral
        
        :param (output):
        spiralFraction fractional coordinates of closest point on spiral
        
        :param (output):
        minDistance distance from space point to spiralPoint.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def CopyBaseParameters(self: MSPyBentleyGeom.DSpiral2dBase, pSource: MSPyBentleyGeom.DSpiral2dBase) -> None:
        ...
    
    def CreateBearingCurvatureBearingCurvature(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float, extraData: MSPyBentleyGeom.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def CreateBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float, extraData: MSPyBentleyGeom.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def DefaultStrokeAngle() -> float:
        ...
    
    def DistanceToCurvature(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToCurvatureDerivative(self: MSPyBentleyGeom.DSpiral2dBase, arg0: float) -> float:
        """
        distance
        """
        ...
    
    def DistanceToFraction(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToGlobalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToLocalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def EvaluateAtFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: DVec2d, d2XYZ: DVec2d, d3XYZ: DVec2d) -> bool:
        """
        Evaluate the spiral and derivatives at specified fractional position
        return true if valid evaluation. DSpiral2dDirectEvaluation default
        implementation returns false.
        """
        ...
    
    @staticmethod
    def EvaluateAtFractionInStandardOrientation(s: float, axisLength: float, radius1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: DVec2d, d2XY: DVec2d, d3XY: DVec2d) -> bool:
        """
        Evaluate at distance a spiral in standard orientation -- zero
        curvature at origin.
        """
        ...
    
    def EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(s: float, length: float, curvature1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: DVec2d, d2XY: DVec2d, d3XY: DVec2d) -> bool:
        """
        (input) distance for evaluation (input) nominal length. ASSUMED NONZERO (input)
        exit curvature. ASSUMED NONZERO (output) coordinates on spiral (output)
        first derivative wrt distance (output) second derivative wrt distance
        (output) third derivative wrt distance
        """
        ...
    
    def EvaluateVectorIntegrand(self: MSPyBentleyGeom.DSpiral2dBase, distance: float, pF: float) -> None:
        ...
    
    def FractionToCurvature(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float:
        """
        Return the true curvature at fractional position. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDCurvatureDFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> tuple:
        """
        Return the true curvature derivative wrt fraction. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDerivatives(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float, dXdf: DVec2d, ddXdfdf: DVec2d, dddXdfdfdf: DVec2d) -> bool:
        ...
    
    def FractionToDistance(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float) -> float:
        ...
    
    def FractionToLocalAngle(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float:
        """
        Return the tangent angle (in radians) in local coordinates
        """
        ...
    
    def FractionToVelocity(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float:
        """
        Return the magnitude of the true derivative of position wrt fraction.
        Implemented in DSpiral2dDirectEvaluation, not individual classes.
        Assume EvaluateAtFraction.
        """
        ...
    
    def GetExtraData(self: MSPyBentleyGeom.DSpiral2dBase, extraData: MSPyBentleyGeom.DoubleArray) -> None:
        """
        Get the extra data for this spiral. REMARK:This should be a virtual,
        but is implemented as special cases because of API change restriction
        """
        ...
    
    def GetIntervalCount(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, minInterval: int = 0, maxStrokeLength: float = 10000.0) -> int:
        """
        Return an interval count for stroking or integration. Except for
        degenerate single interval cases, the interval count is always even.
        That is the possible values are
        
        :param (input):
        spiral spiral being queried.
        
        :param (input):
        startFraction start of interval to stroke.
        
        :param (input):
        endFraction end of interval to stroke.
        
        :param (input):
        maxRadians max turn between strokes.
        
        :param (input):
        minInterval smallest number of intervals.
        
        :param (input):
        maxStrokeLength largest stroke size. Recommended 10 meters
        """
        ...
    
    def GetTransitionTypeCode(self: MSPyBentleyGeom.DSpiral2dBase) -> int:
        ...
    
    def GetVectorIntegrandCount(self: MSPyBentleyGeom.DSpiral2dBase) -> int:
        ...
    
    def IsValidRLCombination(lengthFromInflection: float, radius: float, spiralType: int = 0) -> bool:
        """
        test if a length-from-inflection and final radius
        combination is " small enough " for reasonable use. Test depends on
        spiral type:
        
        * DSpiral2dBase.TransitionType_None indicates apply the strictest
        test (same as Czech and Italian)
        
        * DSpiral2dBase.TransitionType_Czech and
        DSpiral2dBase.TransitionType_Italian indicate a strict test L<2*R
        
        * other types have no restrictions.
        
        :param (input):
        lengthFromInflection (input) distance along spiral starting at
        inflection and ending at finalRadius.
        
        :param (input):
        finalRadius (input) final radius
        
        :param (input):
        spiralType (input) spiral type.
        
        :param (input):
        lengthFactor expansion or reduction factor to apply to the allowed
        length. +---------------+---------------+---------------+---------
        ------+------
        """
        ...
    
    def LineSpiralArcSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, radius: float, lengthA: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralAToArc: MSPyBentleyGeom.DPoint3d, spiralBToArc: MSPyBentleyGeom.DPoint3d, arc: MSPyBentleyGeom.DEllipse3d) -> bool:
        """
        compute spirals and arc to make a line-to-line
        transition.
        
        :param (input):
        lineAPoint point on line A.
        
        :param (input):
        lineBPoint point on line B.
        
        :param (input):
        lineLineIntersection intersection of lines.
        
        :param (input):
        radius radius for circular part of transition.
        
        :param (input):
        lengthA length of spiral from line A to circle.
        
        :param (input):
        lengthB length of spiral from line B to circle.
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        lineToSpiralA tangency point from line to spiral
        
        :param (output):
        spiralAToArc tangency point from spiral to arc
        
        :param (output):
        lineToSpiralB tangency point from line to spiral
        
        :param (output):
        spiralBToArc tangency point from spiral to arc
        
        :param (output):
        arc arc between spirals.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def ScaleInPlace(self: MSPyBentleyGeom.DSpiral2dBase, s: float) -> bool:
        ...
    
    def SetBearingAndCurvatureLimits(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, theta1: float, curvature1: float) -> bool:
        ...
    
    def SetBearingCurvatureLengthBearing(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, theta1: float) -> bool:
        """
        Set start bearing, start curvature, length, and end
        curvature. (Compute end bearing)
        
        :param (input):
        theta0 start bearing
        
        :param (input):
        curvature0 start curvature
        
        :param (input):
        length arc length
        
        :param (input):
        theta1 end bearing
        """
        ...
    
    def SetBearingCurvatureLengthCurvature(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, curvature1: float) -> bool:
        ...
    
    def StringToTransitionType(name: str) -> int:
        """
        return the integer code for the string name.
        """
        ...
    
    def Stroke(*args, **kwargs):
        """
        Overloaded function.
        
        1. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, pDXY: DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        2. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, xyz0: MSPyBentleyGeom.DPoint3d, pXYZ: MSPyBentleyGeom.DPoint3d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        3. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: DVec2d) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        4. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        5. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: DVec2d, pFraction: float, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        6. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: DVec2d, maxStrokeLength: float) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        7. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, uvPoints: List[DVec2d], fractions: MSPyBentleyGeom.DoubleArray, maxStrokeLength: float = 10000.0) -> tuple
        """
        ...
    
    def StrokeToAnnouncer(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, F: MSPyBentleyGeom.AnnounceDoubleDPoint2d, minIndex: int = 0, maxStrokeLength: float = 10000.0) -> tuple:
        """
        Integrate the vector displacements of a clothoid over a
        fractional interval. This uses the angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        startFraction start fraction for integral.
        
        :param (input):
        endFraction end fraction for integral.
        
        :param (input):
        maxRadians maximum bearing change between computed points. A
        default is used if 0.0 is passed.
        
        :param (input):
        F object with a method F->Announce (f, uv) called to announce
        fraction and coordinate as computed.
        
        :param (output):
        errorBound estimated bound on error.
        
        :param (output):
        minInterval smallest number of intervals allowed
        
        :param (output):
        maxStrokeLength maximum allowed stroke length
        
        :returns:
        false if point integration failed
        """
        ...
    
    def SymmetricLineSpiralSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, length: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralToSpiral: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        compute spirals and arc to make a line-to-line
        transition.
        
        :param (input):
        lineAPoint point on line A.
        
        :param (input):
        lineBPoint point on line B.
        
        :param (input):
        lineLineIntersection intersection of lines.
        
        :param (input):
        length length of spiral from line A to junction
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        lineToSpiralA tangency point from line to spiral
        
        :param (output):
        lineToSpiralB tangency point from line to spiral
        
        :param (output):
        spiralToSpiral tangency point from spiral to to spiral
        
        :param (output):
        junctionRadius radius at transition between the spirals.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def SymmetricPointShoulderTargetTransition(startPoint: MSPyBentleyGeom.DPoint2d, shoulderPoint: MSPyBentleyGeom.DPoint2d, targetPoint: MSPyBentleyGeom.DPoint2d, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, junctionPoint: MSPyBentleyGeom.DPoint2d, endPoint: MSPyBentleyGeom.DPoint2d) -> bool:
        """
        compute 2 spirals.
        
        :param (input):
        startPoint start point
        
        :param (input):
        shoulderPoint target point for first and last tangents
        
        :param (input):
        targetPoint target point for last tangent
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        junctionPoint transition between spirals. This is the max
        curvature point.
        
        :param (output):
        endPoint end of second spiral.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def TransitionTypeToString(type: int) -> str:
        """
        return the string name of the type
        """
        ...
    
    TransitionType_Arema: int
    
    TransitionType_AustralianRailCorp: int
    
    TransitionType_Biquadratic: int
    
    TransitionType_Bloss: int
    
    TransitionType_ChineseCubic: int
    
    TransitionType_Clothoid: int
    
    TransitionType_Cosine: int
    
    TransitionType_Czech: int
    
    TransitionType_CzechAlongTangent: int
    
    TransitionType_DirectHalfCosine: int
    
    TransitionType_FirstDirectEvaluate: int
    
    TransitionType_Italian: int
    
    TransitionType_JapaneseCubic: int
    
    TransitionType_MXCubicAlongArc: int
    
    TransitionType_MXCubicAlongTangent: int
    
    TransitionType_PolishCubic: int
    
    TransitionType_Sine: int
    
    TransitionType_Unknown: int
    
    TransitionType_Viennese: int
    
    TransitionType_WeightedViennese: int
    
    TransitionType_WesternAustralian: int
    
    def VectorIntegrandCount(self: MSPyBentleyGeom.BSIVectorIntegrand) -> int:
        ...
    
    def __init__(self: MSPyBentleyGeom.DSpiral2dDirectHalfCosine, axisLength: float) -> None:
        ...
    
    @property
    def mLength(arg0: MSPyBentleyGeom.DSpiral2dBase) -> float:
        ...
    
class DSpiral2dItalian:
    """
    None
    """

    class ASLSACollector:
        """
        None
        """
    
        def Collect(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector, centerA: MSPyBentleyGeom.DPoint3d, arcToSpiralA: MSPyBentleyGeom.DPoint3d, sprialA: MSPyBentleyGeom.DSpiral2dBase, sprialToLineA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, arcToSpiralB: MSPyBentleyGeom.DPoint3d, spiralB: MSPyBentleyGeom.DSpiral2dBase, spiralToLibeB: MSPyBentleyGeom.DPoint3d) -> None:
            ...
        
        def __init__(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> None:
            ...
        
    def ApplyCCWRotation(radians: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: DVec2d, d2XYZ: DVec2d, d3XYZ: DVec2d) -> None:
        """
        rotate xy and optional derivatives by radians. (To be called by
        derived class EvaluateAtDistance when to rotate EvaluateAtDistance
        results from standard position)
        """
        ...
    
    def ArcSpiralLineSpiralArcTransition(centerA: MSPyBentleyGeom.DPoint3d, radiusA: float, lengthA: float, centerB: MSPyBentleyGeom.DPoint3d, radiusB: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, collector: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> int:
        ...
    
    def Clone(self: MSPyBentleyGeom.DSpiral2dBase) -> MSPyBentleyGeom.DSpiral2dBase:
        ...
    
    def ClosestPoint(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, spiralToWorld: Transform, spacePoint: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        Compute the closest spiral point for a given space point.
        
        :param (input):
        spiral spiral to evaluate.
        
        :param (input):
        startFraction start fraction of search range
        
        :param (input):
        endFraction endFraction of search range
        
        :param (input):
        spiralToWorld transform placing the spiral local coordinates into
        the world coordinate system
        
        :param (input):
        spacePoint world coordinates of space point.
        
        :param (output):
        spiralPoint world coordinates of closest point on spiral
        
        :param (output):
        spiralFraction fractional coordinates of closest point on spiral
        
        :param (output):
        minDistance distance from space point to spiralPoint.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def CopyBaseParameters(self: MSPyBentleyGeom.DSpiral2dBase, pSource: MSPyBentleyGeom.DSpiral2dBase) -> None:
        ...
    
    def CreateBearingCurvatureBearingCurvature(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float, extraData: MSPyBentleyGeom.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def CreateBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float, extraData: MSPyBentleyGeom.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def DefaultStrokeAngle() -> float:
        ...
    
    def DistanceToCurvature(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToCurvatureDerivative(self: MSPyBentleyGeom.DSpiral2dBase, arg0: float) -> float:
        """
        distance
        """
        ...
    
    def DistanceToFraction(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToGlobalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToLocalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def EvaluateAtFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: DVec2d, d2XYZ: DVec2d, d3XYZ: DVec2d) -> bool:
        """
        Evaluate the spiral and derivatives at specified fractional position
        return true if valid evaluation. DSpiral2dDirectEvaluation default
        implementation returns false.
        """
        ...
    
    def EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(s: float, length: float, curvature1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: DVec2d, d2XY: DVec2d, d3XY: DVec2d) -> bool:
        """
        (input) distance for evaluation (input) nominal length. ASSUMED NONZERO (input)
        exit curvature. ASSUMED NONZERO (output) coordinates on spiral (output)
        first derivative wrt distance (output) second derivative wrt distance
        (output) third derivative wrt distance
        """
        ...
    
    def EvaluateVectorIntegrand(self: MSPyBentleyGeom.DSpiral2dBase, distance: float, pF: float) -> None:
        ...
    
    def FractionToCurvature(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float:
        """
        Return the true curvature at fractional position. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDCurvatureDFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> tuple:
        """
        Return the true curvature derivative wrt fraction. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDerivatives(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float, dXdf: DVec2d, ddXdfdf: DVec2d, dddXdfdfdf: DVec2d) -> bool:
        ...
    
    def FractionToDistance(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float) -> float:
        ...
    
    def FractionToLocalAngle(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float:
        """
        Return the tangent angle (in radians) in local coordinates
        """
        ...
    
    def FractionToVelocity(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float:
        """
        Return the magnitude of the true derivative of position wrt fraction.
        Implemented in DSpiral2dDirectEvaluation, not individual classes.
        Assume EvaluateAtFraction.
        """
        ...
    
    def GetExtraData(self: MSPyBentleyGeom.DSpiral2dBase, extraData: MSPyBentleyGeom.DoubleArray) -> None:
        """
        Get the extra data for this spiral. REMARK:This should be a virtual,
        but is implemented as special cases because of API change restriction
        """
        ...
    
    def GetIntervalCount(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, minInterval: int = 0, maxStrokeLength: float = 10000.0) -> int:
        """
        Return an interval count for stroking or integration. Except for
        degenerate single interval cases, the interval count is always even.
        That is the possible values are
        
        :param (input):
        spiral spiral being queried.
        
        :param (input):
        startFraction start of interval to stroke.
        
        :param (input):
        endFraction end of interval to stroke.
        
        :param (input):
        maxRadians max turn between strokes.
        
        :param (input):
        minInterval smallest number of intervals.
        
        :param (input):
        maxStrokeLength largest stroke size. Recommended 10 meters
        """
        ...
    
    def GetTransitionTypeCode(self: MSPyBentleyGeom.DSpiral2dBase) -> int:
        ...
    
    def GetVectorIntegrandCount(self: MSPyBentleyGeom.DSpiral2dBase) -> int:
        ...
    
    def IsValidRLCombination(lengthFromInflection: float, radius: float, spiralType: int = 0) -> bool:
        """
        test if a length-from-inflection and final radius
        combination is " small enough " for reasonable use. Test depends on
        spiral type:
        
        * DSpiral2dBase.TransitionType_None indicates apply the strictest
        test (same as Czech and Italian)
        
        * DSpiral2dBase.TransitionType_Czech and
        DSpiral2dBase.TransitionType_Italian indicate a strict test L<2*R
        
        * other types have no restrictions.
        
        :param (input):
        lengthFromInflection (input) distance along spiral starting at
        inflection and ending at finalRadius.
        
        :param (input):
        finalRadius (input) final radius
        
        :param (input):
        spiralType (input) spiral type.
        
        :param (input):
        lengthFactor expansion or reduction factor to apply to the allowed
        length. +---------------+---------------+---------------+---------
        ------+------
        """
        ...
    
    def LineSpiralArcSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, radius: float, lengthA: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralAToArc: MSPyBentleyGeom.DPoint3d, spiralBToArc: MSPyBentleyGeom.DPoint3d, arc: MSPyBentleyGeom.DEllipse3d) -> bool:
        """
        compute spirals and arc to make a line-to-line
        transition.
        
        :param (input):
        lineAPoint point on line A.
        
        :param (input):
        lineBPoint point on line B.
        
        :param (input):
        lineLineIntersection intersection of lines.
        
        :param (input):
        radius radius for circular part of transition.
        
        :param (input):
        lengthA length of spiral from line A to circle.
        
        :param (input):
        lengthB length of spiral from line B to circle.
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        lineToSpiralA tangency point from line to spiral
        
        :param (output):
        spiralAToArc tangency point from spiral to arc
        
        :param (output):
        lineToSpiralB tangency point from line to spiral
        
        :param (output):
        spiralBToArc tangency point from spiral to arc
        
        :param (output):
        arc arc between spirals.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def ScaleInPlace(self: MSPyBentleyGeom.DSpiral2dBase, s: float) -> bool:
        ...
    
    def SetBearingAndCurvatureLimits(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, theta1: float, curvature1: float) -> bool:
        ...
    
    def SetBearingCurvatureLengthBearing(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, theta1: float) -> bool:
        """
        Set start bearing, start curvature, length, and end
        curvature. (Compute end bearing)
        
        :param (input):
        theta0 start bearing
        
        :param (input):
        curvature0 start curvature
        
        :param (input):
        length arc length
        
        :param (input):
        theta1 end bearing
        """
        ...
    
    def SetBearingCurvatureLengthCurvature(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, curvature1: float) -> bool:
        ...
    
    def StringToTransitionType(name: str) -> int:
        """
        return the integer code for the string name.
        """
        ...
    
    def Stroke(*args, **kwargs):
        """
        Overloaded function.
        
        1. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, pDXY: DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        2. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, xyz0: MSPyBentleyGeom.DPoint3d, pXYZ: MSPyBentleyGeom.DPoint3d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        3. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: DVec2d) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        4. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        5. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: DVec2d, pFraction: float, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        6. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: DVec2d, maxStrokeLength: float) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        7. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, uvPoints: List[DVec2d], fractions: MSPyBentleyGeom.DoubleArray, maxStrokeLength: float = 10000.0) -> tuple
        """
        ...
    
    def StrokeToAnnouncer(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, F: MSPyBentleyGeom.AnnounceDoubleDPoint2d, minIndex: int = 0, maxStrokeLength: float = 10000.0) -> tuple:
        """
        Integrate the vector displacements of a clothoid over a
        fractional interval. This uses the angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        startFraction start fraction for integral.
        
        :param (input):
        endFraction end fraction for integral.
        
        :param (input):
        maxRadians maximum bearing change between computed points. A
        default is used if 0.0 is passed.
        
        :param (input):
        F object with a method F->Announce (f, uv) called to announce
        fraction and coordinate as computed.
        
        :param (output):
        errorBound estimated bound on error.
        
        :param (output):
        minInterval smallest number of intervals allowed
        
        :param (output):
        maxStrokeLength maximum allowed stroke length
        
        :returns:
        false if point integration failed
        """
        ...
    
    def SymmetricLineSpiralSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, length: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralToSpiral: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        compute spirals and arc to make a line-to-line
        transition.
        
        :param (input):
        lineAPoint point on line A.
        
        :param (input):
        lineBPoint point on line B.
        
        :param (input):
        lineLineIntersection intersection of lines.
        
        :param (input):
        length length of spiral from line A to junction
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        lineToSpiralA tangency point from line to spiral
        
        :param (output):
        lineToSpiralB tangency point from line to spiral
        
        :param (output):
        spiralToSpiral tangency point from spiral to to spiral
        
        :param (output):
        junctionRadius radius at transition between the spirals.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def SymmetricPointShoulderTargetTransition(startPoint: MSPyBentleyGeom.DPoint2d, shoulderPoint: MSPyBentleyGeom.DPoint2d, targetPoint: MSPyBentleyGeom.DPoint2d, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, junctionPoint: MSPyBentleyGeom.DPoint2d, endPoint: MSPyBentleyGeom.DPoint2d) -> bool:
        """
        compute 2 spirals.
        
        :param (input):
        startPoint start point
        
        :param (input):
        shoulderPoint target point for first and last tangents
        
        :param (input):
        targetPoint target point for last tangent
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        junctionPoint transition between spirals. This is the max
        curvature point.
        
        :param (output):
        endPoint end of second spiral.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def TransitionTypeToString(type: int) -> str:
        """
        return the string name of the type
        """
        ...
    
    TransitionType_Arema: int
    
    TransitionType_AustralianRailCorp: int
    
    TransitionType_Biquadratic: int
    
    TransitionType_Bloss: int
    
    TransitionType_ChineseCubic: int
    
    TransitionType_Clothoid: int
    
    TransitionType_Cosine: int
    
    TransitionType_Czech: int
    
    TransitionType_CzechAlongTangent: int
    
    TransitionType_DirectHalfCosine: int
    
    TransitionType_FirstDirectEvaluate: int
    
    TransitionType_Italian: int
    
    TransitionType_JapaneseCubic: int
    
    TransitionType_MXCubicAlongArc: int
    
    TransitionType_MXCubicAlongTangent: int
    
    TransitionType_PolishCubic: int
    
    TransitionType_Sine: int
    
    TransitionType_Unknown: int
    
    TransitionType_Viennese: int
    
    TransitionType_WeightedViennese: int
    
    TransitionType_WesternAustralian: int
    
    def VectorIntegrandCount(self: MSPyBentleyGeom.BSIVectorIntegrand) -> int:
        ...
    
    def __init__(self: MSPyBentleyGeom.DSpiral2dItalian, pseudoLength: float) -> None:
        ...
    
    @property
    def mLength(arg0: MSPyBentleyGeom.DSpiral2dBase) -> float:
        ...
    
class DSpiral2dJapaneseCubic:
    """
    None
    """

    class ASLSACollector:
        """
        None
        """
    
        def Collect(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector, centerA: MSPyBentleyGeom.DPoint3d, arcToSpiralA: MSPyBentleyGeom.DPoint3d, sprialA: MSPyBentleyGeom.DSpiral2dBase, sprialToLineA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, arcToSpiralB: MSPyBentleyGeom.DPoint3d, spiralB: MSPyBentleyGeom.DSpiral2dBase, spiralToLibeB: MSPyBentleyGeom.DPoint3d) -> None:
            ...
        
        def __init__(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> None:
            ...
        
    def ApplyCCWRotation(radians: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: DVec2d, d2XYZ: DVec2d, d3XYZ: DVec2d) -> None:
        """
        rotate xy and optional derivatives by radians. (To be called by
        derived class EvaluateAtDistance when to rotate EvaluateAtDistance
        results from standard position)
        """
        ...
    
    def ArcSpiralLineSpiralArcTransition(centerA: MSPyBentleyGeom.DPoint3d, radiusA: float, lengthA: float, centerB: MSPyBentleyGeom.DPoint3d, radiusB: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, collector: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> int:
        ...
    
    def Clone(self: MSPyBentleyGeom.DSpiral2dBase) -> MSPyBentleyGeom.DSpiral2dBase:
        ...
    
    def ClosestPoint(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, spiralToWorld: Transform, spacePoint: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        Compute the closest spiral point for a given space point.
        
        :param (input):
        spiral spiral to evaluate.
        
        :param (input):
        startFraction start fraction of search range
        
        :param (input):
        endFraction endFraction of search range
        
        :param (input):
        spiralToWorld transform placing the spiral local coordinates into
        the world coordinate system
        
        :param (input):
        spacePoint world coordinates of space point.
        
        :param (output):
        spiralPoint world coordinates of closest point on spiral
        
        :param (output):
        spiralFraction fractional coordinates of closest point on spiral
        
        :param (output):
        minDistance distance from space point to spiralPoint.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def CopyBaseParameters(self: MSPyBentleyGeom.DSpiral2dBase, pSource: MSPyBentleyGeom.DSpiral2dBase) -> None:
        ...
    
    def CreateBearingCurvatureBearingCurvature(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float, extraData: MSPyBentleyGeom.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def CreateBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float, extraData: MSPyBentleyGeom.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def DefaultStrokeAngle() -> float:
        ...
    
    def DistanceToCurvature(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToCurvatureDerivative(self: MSPyBentleyGeom.DSpiral2dBase, arg0: float) -> float:
        """
        distance
        """
        ...
    
    def DistanceToFraction(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToGlobalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToLocalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def EvaluateAtFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: DVec2d, d2XYZ: DVec2d, d3XYZ: DVec2d) -> bool:
        """
        Evaluate the spiral and derivatives at specified fractional position
        return true if valid evaluation. DSpiral2dDirectEvaluation default
        implementation returns false.
        """
        ...
    
    @staticmethod
    def EvaluateAtFractionInStandardOrientation(s: float, axisLength: float, radius1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: DVec2d, d2XY: DVec2d, d3XY: DVec2d) -> bool:
        """
        Evaluate at distance a spiral in standard orientation -- zero
        curvature at origin.
        """
        ...
    
    def EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(s: float, length: float, curvature1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: DVec2d, d2XY: DVec2d, d3XY: DVec2d) -> bool:
        """
        (input) distance for evaluation (input) nominal length. ASSUMED NONZERO (input)
        exit curvature. ASSUMED NONZERO (output) coordinates on spiral (output)
        first derivative wrt distance (output) second derivative wrt distance
        (output) third derivative wrt distance
        """
        ...
    
    def EvaluateVectorIntegrand(self: MSPyBentleyGeom.DSpiral2dBase, distance: float, pF: float) -> None:
        ...
    
    def FractionToCurvature(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float:
        """
        Return the true curvature at fractional position. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDCurvatureDFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> tuple:
        """
        Return the true curvature derivative wrt fraction. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDerivatives(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float, dXdf: DVec2d, ddXdfdf: DVec2d, dddXdfdfdf: DVec2d) -> bool:
        ...
    
    def FractionToDistance(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float) -> float:
        ...
    
    def FractionToLocalAngle(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float:
        """
        Return the tangent angle (in radians) in local coordinates
        """
        ...
    
    def FractionToVelocity(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float:
        """
        Return the magnitude of the true derivative of position wrt fraction.
        Implemented in DSpiral2dDirectEvaluation, not individual classes.
        Assume EvaluateAtFraction.
        """
        ...
    
    def GetExtraData(self: MSPyBentleyGeom.DSpiral2dBase, extraData: MSPyBentleyGeom.DoubleArray) -> None:
        """
        Get the extra data for this spiral. REMARK:This should be a virtual,
        but is implemented as special cases because of API change restriction
        """
        ...
    
    def GetIntervalCount(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, minInterval: int = 0, maxStrokeLength: float = 10000.0) -> int:
        """
        Return an interval count for stroking or integration. Except for
        degenerate single interval cases, the interval count is always even.
        That is the possible values are
        
        :param (input):
        spiral spiral being queried.
        
        :param (input):
        startFraction start of interval to stroke.
        
        :param (input):
        endFraction end of interval to stroke.
        
        :param (input):
        maxRadians max turn between strokes.
        
        :param (input):
        minInterval smallest number of intervals.
        
        :param (input):
        maxStrokeLength largest stroke size. Recommended 10 meters
        """
        ...
    
    def GetTransitionTypeCode(self: MSPyBentleyGeom.DSpiral2dBase) -> int:
        ...
    
    def GetVectorIntegrandCount(self: MSPyBentleyGeom.DSpiral2dBase) -> int:
        ...
    
    def IsValidRLCombination(lengthFromInflection: float, radius: float, spiralType: int = 0) -> bool:
        """
        test if a length-from-inflection and final radius
        combination is " small enough " for reasonable use. Test depends on
        spiral type:
        
        * DSpiral2dBase.TransitionType_None indicates apply the strictest
        test (same as Czech and Italian)
        
        * DSpiral2dBase.TransitionType_Czech and
        DSpiral2dBase.TransitionType_Italian indicate a strict test L<2*R
        
        * other types have no restrictions.
        
        :param (input):
        lengthFromInflection (input) distance along spiral starting at
        inflection and ending at finalRadius.
        
        :param (input):
        finalRadius (input) final radius
        
        :param (input):
        spiralType (input) spiral type.
        
        :param (input):
        lengthFactor expansion or reduction factor to apply to the allowed
        length. +---------------+---------------+---------------+---------
        ------+------
        """
        ...
    
    def LineSpiralArcSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, radius: float, lengthA: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralAToArc: MSPyBentleyGeom.DPoint3d, spiralBToArc: MSPyBentleyGeom.DPoint3d, arc: MSPyBentleyGeom.DEllipse3d) -> bool:
        """
        compute spirals and arc to make a line-to-line
        transition.
        
        :param (input):
        lineAPoint point on line A.
        
        :param (input):
        lineBPoint point on line B.
        
        :param (input):
        lineLineIntersection intersection of lines.
        
        :param (input):
        radius radius for circular part of transition.
        
        :param (input):
        lengthA length of spiral from line A to circle.
        
        :param (input):
        lengthB length of spiral from line B to circle.
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        lineToSpiralA tangency point from line to spiral
        
        :param (output):
        spiralAToArc tangency point from spiral to arc
        
        :param (output):
        lineToSpiralB tangency point from line to spiral
        
        :param (output):
        spiralBToArc tangency point from spiral to arc
        
        :param (output):
        arc arc between spirals.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def ScaleInPlace(self: MSPyBentleyGeom.DSpiral2dBase, s: float) -> bool:
        ...
    
    def SetBearingAndCurvatureLimits(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, theta1: float, curvature1: float) -> bool:
        ...
    
    def SetBearingCurvatureLengthBearing(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, theta1: float) -> bool:
        """
        Set start bearing, start curvature, length, and end
        curvature. (Compute end bearing)
        
        :param (input):
        theta0 start bearing
        
        :param (input):
        curvature0 start curvature
        
        :param (input):
        length arc length
        
        :param (input):
        theta1 end bearing
        """
        ...
    
    def SetBearingCurvatureLengthCurvature(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, curvature1: float) -> bool:
        ...
    
    def StringToTransitionType(name: str) -> int:
        """
        return the integer code for the string name.
        """
        ...
    
    def Stroke(*args, **kwargs):
        """
        Overloaded function.
        
        1. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, pDXY: DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        2. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, xyz0: MSPyBentleyGeom.DPoint3d, pXYZ: MSPyBentleyGeom.DPoint3d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        3. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: DVec2d) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        4. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        5. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: DVec2d, pFraction: float, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        6. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: DVec2d, maxStrokeLength: float) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        7. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, uvPoints: List[DVec2d], fractions: MSPyBentleyGeom.DoubleArray, maxStrokeLength: float = 10000.0) -> tuple
        """
        ...
    
    def StrokeToAnnouncer(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, F: MSPyBentleyGeom.AnnounceDoubleDPoint2d, minIndex: int = 0, maxStrokeLength: float = 10000.0) -> tuple:
        """
        Integrate the vector displacements of a clothoid over a
        fractional interval. This uses the angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        startFraction start fraction for integral.
        
        :param (input):
        endFraction end fraction for integral.
        
        :param (input):
        maxRadians maximum bearing change between computed points. A
        default is used if 0.0 is passed.
        
        :param (input):
        F object with a method F->Announce (f, uv) called to announce
        fraction and coordinate as computed.
        
        :param (output):
        errorBound estimated bound on error.
        
        :param (output):
        minInterval smallest number of intervals allowed
        
        :param (output):
        maxStrokeLength maximum allowed stroke length
        
        :returns:
        false if point integration failed
        """
        ...
    
    def SymmetricLineSpiralSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, length: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralToSpiral: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        compute spirals and arc to make a line-to-line
        transition.
        
        :param (input):
        lineAPoint point on line A.
        
        :param (input):
        lineBPoint point on line B.
        
        :param (input):
        lineLineIntersection intersection of lines.
        
        :param (input):
        length length of spiral from line A to junction
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        lineToSpiralA tangency point from line to spiral
        
        :param (output):
        lineToSpiralB tangency point from line to spiral
        
        :param (output):
        spiralToSpiral tangency point from spiral to to spiral
        
        :param (output):
        junctionRadius radius at transition between the spirals.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def SymmetricPointShoulderTargetTransition(startPoint: MSPyBentleyGeom.DPoint2d, shoulderPoint: MSPyBentleyGeom.DPoint2d, targetPoint: MSPyBentleyGeom.DPoint2d, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, junctionPoint: MSPyBentleyGeom.DPoint2d, endPoint: MSPyBentleyGeom.DPoint2d) -> bool:
        """
        compute 2 spirals.
        
        :param (input):
        startPoint start point
        
        :param (input):
        shoulderPoint target point for first and last tangents
        
        :param (input):
        targetPoint target point for last tangent
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        junctionPoint transition between spirals. This is the max
        curvature point.
        
        :param (output):
        endPoint end of second spiral.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def TransitionTypeToString(type: int) -> str:
        """
        return the string name of the type
        """
        ...
    
    TransitionType_Arema: int
    
    TransitionType_AustralianRailCorp: int
    
    TransitionType_Biquadratic: int
    
    TransitionType_Bloss: int
    
    TransitionType_ChineseCubic: int
    
    TransitionType_Clothoid: int
    
    TransitionType_Cosine: int
    
    TransitionType_Czech: int
    
    TransitionType_CzechAlongTangent: int
    
    TransitionType_DirectHalfCosine: int
    
    TransitionType_FirstDirectEvaluate: int
    
    TransitionType_Italian: int
    
    TransitionType_JapaneseCubic: int
    
    TransitionType_MXCubicAlongArc: int
    
    TransitionType_MXCubicAlongTangent: int
    
    TransitionType_PolishCubic: int
    
    TransitionType_Sine: int
    
    TransitionType_Unknown: int
    
    TransitionType_Viennese: int
    
    TransitionType_WeightedViennese: int
    
    TransitionType_WesternAustralian: int
    
    def VectorIntegrandCount(self: MSPyBentleyGeom.BSIVectorIntegrand) -> int:
        ...
    
    def __init__(self: MSPyBentleyGeom.DSpiral2dJapaneseCubic, axisLength: float) -> None:
        ...
    
    @property
    def mLength(arg0: MSPyBentleyGeom.DSpiral2dBase) -> float:
        ...
    
class DSpiral2dMXCubicAlongArc:
    """
    None
    """

    class ASLSACollector:
        """
        None
        """
    
        def Collect(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector, centerA: MSPyBentleyGeom.DPoint3d, arcToSpiralA: MSPyBentleyGeom.DPoint3d, sprialA: MSPyBentleyGeom.DSpiral2dBase, sprialToLineA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, arcToSpiralB: MSPyBentleyGeom.DPoint3d, spiralB: MSPyBentleyGeom.DSpiral2dBase, spiralToLibeB: MSPyBentleyGeom.DPoint3d) -> None:
            ...
        
        def __init__(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> None:
            ...
        
    def ApplyCCWRotation(radians: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: DVec2d, d2XYZ: DVec2d, d3XYZ: DVec2d) -> None:
        """
        rotate xy and optional derivatives by radians. (To be called by
        derived class EvaluateAtDistance when to rotate EvaluateAtDistance
        results from standard position)
        """
        ...
    
    def ArcSpiralLineSpiralArcTransition(centerA: MSPyBentleyGeom.DPoint3d, radiusA: float, lengthA: float, centerB: MSPyBentleyGeom.DPoint3d, radiusB: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, collector: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> int:
        ...
    
    def Clone(self: MSPyBentleyGeom.DSpiral2dBase) -> MSPyBentleyGeom.DSpiral2dBase:
        ...
    
    def ClosestPoint(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, spiralToWorld: Transform, spacePoint: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        Compute the closest spiral point for a given space point.
        
        :param (input):
        spiral spiral to evaluate.
        
        :param (input):
        startFraction start fraction of search range
        
        :param (input):
        endFraction endFraction of search range
        
        :param (input):
        spiralToWorld transform placing the spiral local coordinates into
        the world coordinate system
        
        :param (input):
        spacePoint world coordinates of space point.
        
        :param (output):
        spiralPoint world coordinates of closest point on spiral
        
        :param (output):
        spiralFraction fractional coordinates of closest point on spiral
        
        :param (output):
        minDistance distance from space point to spiralPoint.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def CopyBaseParameters(self: MSPyBentleyGeom.DSpiral2dBase, pSource: MSPyBentleyGeom.DSpiral2dBase) -> None:
        ...
    
    def CreateBearingCurvatureBearingCurvature(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float, extraData: MSPyBentleyGeom.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def CreateBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float, extraData: MSPyBentleyGeom.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def DefaultStrokeAngle() -> float:
        ...
    
    def DistanceToCurvature(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToCurvatureDerivative(self: MSPyBentleyGeom.DSpiral2dBase, arg0: float) -> float:
        """
        distance
        """
        ...
    
    def DistanceToFraction(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToGlobalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToLocalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def EvaluateAtFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: DVec2d, d2XYZ: DVec2d, d3XYZ: DVec2d) -> bool:
        """
        Evaluate the spiral and derivatives at specified fractional position
        return true if valid evaluation. DSpiral2dDirectEvaluation default
        implementation returns false.
        """
        ...
    
    @staticmethod
    def EvaluateAtFractionInStandardOrientation(fraction: float, length: float, curvature1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: DVec2d, d2XY: DVec2d, d3XY: DVec2d) -> bool:
        """
        Evaluate at fraction standard orientation -- zero curvature at origin.
        """
        ...
    
    def EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(s: float, length: float, curvature1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: DVec2d, d2XY: DVec2d, d3XY: DVec2d) -> bool:
        """
        (input) distance for evaluation (input) nominal length. ASSUMED NONZERO (input)
        exit curvature. ASSUMED NONZERO (output) coordinates on spiral (output)
        first derivative wrt distance (output) second derivative wrt distance
        (output) third derivative wrt distance
        """
        ...
    
    def EvaluateVectorIntegrand(self: MSPyBentleyGeom.DSpiral2dBase, distance: float, pF: float) -> None:
        ...
    
    def FractionToCurvature(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float:
        """
        Return the true curvature at fractional position. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDCurvatureDFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> tuple:
        """
        Return the true curvature derivative wrt fraction. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDerivatives(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float, dXdf: DVec2d, ddXdfdf: DVec2d, dddXdfdfdf: DVec2d) -> bool:
        ...
    
    def FractionToDistance(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float) -> float:
        ...
    
    def FractionToLocalAngle(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float:
        """
        Return the tangent angle (in radians) in local coordinates
        """
        ...
    
    def FractionToVelocity(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float:
        """
        Return the magnitude of the true derivative of position wrt fraction.
        Implemented in DSpiral2dDirectEvaluation, not individual classes.
        Assume EvaluateAtFraction.
        """
        ...
    
    def GetExtraData(self: MSPyBentleyGeom.DSpiral2dBase, extraData: MSPyBentleyGeom.DoubleArray) -> None:
        """
        Get the extra data for this spiral. REMARK:This should be a virtual,
        but is implemented as special cases because of API change restriction
        """
        ...
    
    def GetIntervalCount(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, minInterval: int = 0, maxStrokeLength: float = 10000.0) -> int:
        """
        Return an interval count for stroking or integration. Except for
        degenerate single interval cases, the interval count is always even.
        That is the possible values are
        
        :param (input):
        spiral spiral being queried.
        
        :param (input):
        startFraction start of interval to stroke.
        
        :param (input):
        endFraction end of interval to stroke.
        
        :param (input):
        maxRadians max turn between strokes.
        
        :param (input):
        minInterval smallest number of intervals.
        
        :param (input):
        maxStrokeLength largest stroke size. Recommended 10 meters
        """
        ...
    
    def GetTransitionTypeCode(self: MSPyBentleyGeom.DSpiral2dBase) -> int:
        ...
    
    def GetVectorIntegrandCount(self: MSPyBentleyGeom.DSpiral2dBase) -> int:
        ...
    
    def IsValidRLCombination(lengthFromInflection: float, radius: float, spiralType: int = 0) -> bool:
        """
        test if a length-from-inflection and final radius
        combination is " small enough " for reasonable use. Test depends on
        spiral type:
        
        * DSpiral2dBase.TransitionType_None indicates apply the strictest
        test (same as Czech and Italian)
        
        * DSpiral2dBase.TransitionType_Czech and
        DSpiral2dBase.TransitionType_Italian indicate a strict test L<2*R
        
        * other types have no restrictions.
        
        :param (input):
        lengthFromInflection (input) distance along spiral starting at
        inflection and ending at finalRadius.
        
        :param (input):
        finalRadius (input) final radius
        
        :param (input):
        spiralType (input) spiral type.
        
        :param (input):
        lengthFactor expansion or reduction factor to apply to the allowed
        length. +---------------+---------------+---------------+---------
        ------+------
        """
        ...
    
    def LineSpiralArcSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, radius: float, lengthA: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralAToArc: MSPyBentleyGeom.DPoint3d, spiralBToArc: MSPyBentleyGeom.DPoint3d, arc: MSPyBentleyGeom.DEllipse3d) -> bool:
        """
        compute spirals and arc to make a line-to-line
        transition.
        
        :param (input):
        lineAPoint point on line A.
        
        :param (input):
        lineBPoint point on line B.
        
        :param (input):
        lineLineIntersection intersection of lines.
        
        :param (input):
        radius radius for circular part of transition.
        
        :param (input):
        lengthA length of spiral from line A to circle.
        
        :param (input):
        lengthB length of spiral from line B to circle.
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        lineToSpiralA tangency point from line to spiral
        
        :param (output):
        spiralAToArc tangency point from spiral to arc
        
        :param (output):
        lineToSpiralB tangency point from line to spiral
        
        :param (output):
        spiralBToArc tangency point from spiral to arc
        
        :param (output):
        arc arc between spirals.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def ScaleInPlace(self: MSPyBentleyGeom.DSpiral2dBase, s: float) -> bool:
        ...
    
    def SetBearingAndCurvatureLimits(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, theta1: float, curvature1: float) -> bool:
        ...
    
    def SetBearingCurvatureLengthBearing(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, theta1: float) -> bool:
        """
        Set start bearing, start curvature, length, and end
        curvature. (Compute end bearing)
        
        :param (input):
        theta0 start bearing
        
        :param (input):
        curvature0 start curvature
        
        :param (input):
        length arc length
        
        :param (input):
        theta1 end bearing
        """
        ...
    
    def SetBearingCurvatureLengthCurvature(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, curvature1: float) -> bool:
        ...
    
    def StringToTransitionType(name: str) -> int:
        """
        return the integer code for the string name.
        """
        ...
    
    def Stroke(*args, **kwargs):
        """
        Overloaded function.
        
        1. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, pDXY: DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        2. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, xyz0: MSPyBentleyGeom.DPoint3d, pXYZ: MSPyBentleyGeom.DPoint3d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        3. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: DVec2d) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        4. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        5. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: DVec2d, pFraction: float, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        6. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: DVec2d, maxStrokeLength: float) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        7. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, uvPoints: List[DVec2d], fractions: MSPyBentleyGeom.DoubleArray, maxStrokeLength: float = 10000.0) -> tuple
        """
        ...
    
    def StrokeToAnnouncer(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, F: MSPyBentleyGeom.AnnounceDoubleDPoint2d, minIndex: int = 0, maxStrokeLength: float = 10000.0) -> tuple:
        """
        Integrate the vector displacements of a clothoid over a
        fractional interval. This uses the angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        startFraction start fraction for integral.
        
        :param (input):
        endFraction end fraction for integral.
        
        :param (input):
        maxRadians maximum bearing change between computed points. A
        default is used if 0.0 is passed.
        
        :param (input):
        F object with a method F->Announce (f, uv) called to announce
        fraction and coordinate as computed.
        
        :param (output):
        errorBound estimated bound on error.
        
        :param (output):
        minInterval smallest number of intervals allowed
        
        :param (output):
        maxStrokeLength maximum allowed stroke length
        
        :returns:
        false if point integration failed
        """
        ...
    
    def SymmetricLineSpiralSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, length: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralToSpiral: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        compute spirals and arc to make a line-to-line
        transition.
        
        :param (input):
        lineAPoint point on line A.
        
        :param (input):
        lineBPoint point on line B.
        
        :param (input):
        lineLineIntersection intersection of lines.
        
        :param (input):
        length length of spiral from line A to junction
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        lineToSpiralA tangency point from line to spiral
        
        :param (output):
        lineToSpiralB tangency point from line to spiral
        
        :param (output):
        spiralToSpiral tangency point from spiral to to spiral
        
        :param (output):
        junctionRadius radius at transition between the spirals.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def SymmetricPointShoulderTargetTransition(startPoint: MSPyBentleyGeom.DPoint2d, shoulderPoint: MSPyBentleyGeom.DPoint2d, targetPoint: MSPyBentleyGeom.DPoint2d, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, junctionPoint: MSPyBentleyGeom.DPoint2d, endPoint: MSPyBentleyGeom.DPoint2d) -> bool:
        """
        compute 2 spirals.
        
        :param (input):
        startPoint start point
        
        :param (input):
        shoulderPoint target point for first and last tangents
        
        :param (input):
        targetPoint target point for last tangent
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        junctionPoint transition between spirals. This is the max
        curvature point.
        
        :param (output):
        endPoint end of second spiral.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def TransitionTypeToString(type: int) -> str:
        """
        return the string name of the type
        """
        ...
    
    TransitionType_Arema: int
    
    TransitionType_AustralianRailCorp: int
    
    TransitionType_Biquadratic: int
    
    TransitionType_Bloss: int
    
    TransitionType_ChineseCubic: int
    
    TransitionType_Clothoid: int
    
    TransitionType_Cosine: int
    
    TransitionType_Czech: int
    
    TransitionType_CzechAlongTangent: int
    
    TransitionType_DirectHalfCosine: int
    
    TransitionType_FirstDirectEvaluate: int
    
    TransitionType_Italian: int
    
    TransitionType_JapaneseCubic: int
    
    TransitionType_MXCubicAlongArc: int
    
    TransitionType_MXCubicAlongTangent: int
    
    TransitionType_PolishCubic: int
    
    TransitionType_Sine: int
    
    TransitionType_Unknown: int
    
    TransitionType_Viennese: int
    
    TransitionType_WeightedViennese: int
    
    TransitionType_WesternAustralian: int
    
    def VectorIntegrandCount(self: MSPyBentleyGeom.BSIVectorIntegrand) -> int:
        ...
    
    def __init__(self: MSPyBentleyGeom.DSpiral2dMXCubicAlongArc, nominalLength: float) -> None:
        ...
    
    @property
    def mLength(arg0: MSPyBentleyGeom.DSpiral2dBase) -> float:
        ...
    
class DSpiral2dPlacement:
    """
    None
    """

    def ActiveFractionToDerivatives(self: MSPyBentleyGeom.DSpiral2dPlacement, fraction: float) -> RotMatrix:
        """
        return xyz first, second, third derivatives as columns, scaled for
        active interval.
        """
        ...
    
    def ActiveFractionToFrenetFrame(self: MSPyBentleyGeom.DSpiral2dPlacement, fraction: float) -> Transform:
        ...
    
    def ActiveFractionToGlobalFraction(self: MSPyBentleyGeom.DSpiral2dPlacement, activeFraction: float) -> float:
        ...
    
    def ActiveFractionToPoint(self: MSPyBentleyGeom.DSpiral2dPlacement, fraction: float) -> MSPyBentleyGeom.DPoint3d:
        ...
    
    def AlmostEqual(self: MSPyBentleyGeom.DSpiral2dPlacement, other: MSPyBentleyGeom.DSpiral2dPlacement, tolerance: float = 0.0) -> bool:
        """
        Apply AlmostEqual to all components
        """
        ...
    
    def AlmostEqual01(self: MSPyBentleyGeom.DSpiral2dPlacement, other: MSPyBentleyGeom.DSpiral2dPlacement, tolerance: float = 0.0) -> bool:
        """
        Apply AlmostEqual to all components except fractions
        """
        ...
    
    def Clone(self: MSPyBentleyGeom.DSpiral2dPlacement, source: MSPyBentleyGeom.DSpiral2dPlacement) -> MSPyBentleyGeom.DSpiral2dPlacement:
        """
        Return a clone.
        """
        ...
    
    def DisplacementBetweenActiveFractions(self: MSPyBentleyGeom.DSpiral2dPlacement, g0: float, g1: float) -> DVec3d:
        ...
    
    def DisplacementBetweenFractions(self: MSPyBentleyGeom.DSpiral2dPlacement, f0: float, f1: float) -> DVec3d:
        """
        return the displacement between fractions. Having a close f0 is much
        faster than FractionToPoint with no starter fraction.
        """
        ...
    
    def FractionInterval(self: MSPyBentleyGeom.DSpiral2dPlacement) -> MSPyBentleyGeom.DSegment1d:
        ...
    
    def FractionToDerivatives(self: MSPyBentleyGeom.DSpiral2dPlacement, fraction: float) -> RotMatrix:
        """
        return xyz first, second, third derivatives as columns.
        """
        ...
    
    def FractionToFrenetFrame(self: MSPyBentleyGeom.DSpiral2dPlacement, fraction: float) -> Transform:
        ...
    
    def FractionToPoint(self: MSPyBentleyGeom.DSpiral2dPlacement, fraction: float) -> MSPyBentleyGeom.DPoint3d:
        ...
    
    def FractionToPointAndDerivative(self: MSPyBentleyGeom.DSpiral2dPlacement, fraction: float) -> MSPyBentleyGeom.DRay3d:
        ...
    
    def FractionToPointAndUnitTangent(self: MSPyBentleyGeom.DSpiral2dPlacement, fraction: float) -> MSPyBentleyGeom.DRay3d:
        ...
    
    def GlobalFractionToActiveFraction(self: MSPyBentleyGeom.DSpiral2dPlacement, globalFraction: float) -> float:
        ...
    
    def MappedSpiralLengthActiveInterval(self: MSPyBentleyGeom.DSpiral2dPlacement, matrix: RotMatrix) -> float:
        """
        Length of the spiral after mapping by matrix*frame.matrix
        """
        ...
    
    def ReplaceSpiral(self: MSPyBentleyGeom.DSpiral2dPlacement, callerSpiral: MSPyBentleyGeom.DSpiral2dBase) -> None:
        """
        Free the current spiral pointer and replace by (possibly NULL) arg.
        """
        ...
    
    def ReverseInPlace(self: MSPyBentleyGeom.DSpiral2dPlacement) -> bool:
        """
        Reverse the fractions !!
        """
        ...
    
    def SpiralLength01(self: MSPyBentleyGeom.DSpiral2dPlacement) -> float:
        """
        absolute length of the reference spiral (between 0 and 1)
        """
        ...
    
    def SpiralLengthActiveInterval(self: MSPyBentleyGeom.DSpiral2dPlacement) -> float:
        """
        absolute length of the partial spiral (between start and end
        fractions)
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DSpiral2dPlacement) -> None
        
        2. __init__(self: MSPyBentleyGeom.DSpiral2dPlacement, source: MSPyBentleyGeom.DSpiral2dBase, frame: Transform, fractionA: float, fractionB: float) -> None
        """
        ...
    
    @property
    def fractionA(self: MSPyBentleyGeom.DSpiral2dPlacement) -> float:
        ...
    @fractionA.setter
    def fractionA(self: MSPyBentleyGeom.DSpiral2dPlacement, arg0: float) -> None:
        ...
    
    @property
    def fractionB(self: MSPyBentleyGeom.DSpiral2dPlacement) -> float:
        ...
    @fractionB.setter
    def fractionB(self: MSPyBentleyGeom.DSpiral2dPlacement, arg0: float) -> None:
        ...
    
    @property
    def frame(self: MSPyBentleyGeom.DSpiral2dPlacement) -> Transform:
        ...
    @frame.setter
    def frame(self: MSPyBentleyGeom.DSpiral2dPlacement, arg0: Transform) -> None:
        ...
    
    @property
    def spiral(self: MSPyBentleyGeom.DSpiral2dPlacement) -> MSPyBentleyGeom.DSpiral2dBase:
        ...
    @spiral.setter
    def spiral(self: MSPyBentleyGeom.DSpiral2dPlacement, arg0: MSPyBentleyGeom.DSpiral2dBase) -> None:
        ...
    
class DSpiral2dPolish:
    """
    None
    """

    class ASLSACollector:
        """
        None
        """
    
        def Collect(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector, centerA: MSPyBentleyGeom.DPoint3d, arcToSpiralA: MSPyBentleyGeom.DPoint3d, sprialA: MSPyBentleyGeom.DSpiral2dBase, sprialToLineA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, arcToSpiralB: MSPyBentleyGeom.DPoint3d, spiralB: MSPyBentleyGeom.DSpiral2dBase, spiralToLibeB: MSPyBentleyGeom.DPoint3d) -> None:
            ...
        
        def __init__(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> None:
            ...
        
    def ApplyCCWRotation(radians: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: DVec2d, d2XYZ: DVec2d, d3XYZ: DVec2d) -> None:
        """
        rotate xy and optional derivatives by radians. (To be called by
        derived class EvaluateAtDistance when to rotate EvaluateAtDistance
        results from standard position)
        """
        ...
    
    def ArcSpiralLineSpiralArcTransition(centerA: MSPyBentleyGeom.DPoint3d, radiusA: float, lengthA: float, centerB: MSPyBentleyGeom.DPoint3d, radiusB: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, collector: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> int:
        ...
    
    def Clone(self: MSPyBentleyGeom.DSpiral2dBase) -> MSPyBentleyGeom.DSpiral2dBase:
        ...
    
    def ClosestPoint(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, spiralToWorld: Transform, spacePoint: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        Compute the closest spiral point for a given space point.
        
        :param (input):
        spiral spiral to evaluate.
        
        :param (input):
        startFraction start fraction of search range
        
        :param (input):
        endFraction endFraction of search range
        
        :param (input):
        spiralToWorld transform placing the spiral local coordinates into
        the world coordinate system
        
        :param (input):
        spacePoint world coordinates of space point.
        
        :param (output):
        spiralPoint world coordinates of closest point on spiral
        
        :param (output):
        spiralFraction fractional coordinates of closest point on spiral
        
        :param (output):
        minDistance distance from space point to spiralPoint.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def CopyBaseParameters(self: MSPyBentleyGeom.DSpiral2dBase, pSource: MSPyBentleyGeom.DSpiral2dBase) -> None:
        ...
    
    def CreateBearingCurvatureBearingCurvature(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float, extraData: MSPyBentleyGeom.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def CreateBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float, extraData: MSPyBentleyGeom.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def DefaultStrokeAngle() -> float:
        ...
    
    def DistanceToCurvature(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToCurvatureDerivative(self: MSPyBentleyGeom.DSpiral2dBase, arg0: float) -> float:
        """
        distance
        """
        ...
    
    def DistanceToFraction(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToGlobalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToLocalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def EvaluateAtFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: DVec2d, d2XYZ: DVec2d, d3XYZ: DVec2d) -> bool:
        """
        Evaluate the spiral and derivatives at specified fractional position
        return true if valid evaluation. DSpiral2dDirectEvaluation default
        implementation returns false.
        """
        ...
    
    @staticmethod
    def EvaluateAtFractionOfAxisLengthInStandardOrientation(fraction: float, Ls: float, radius1: float, mapDerivativesWRTSeriesDistance: bool, xy: MSPyBentleyGeom.DPoint2d, d1XY: DVec2d, d2XY: DVec2d, d3XY: DVec2d) -> Tuple[bool, float]:
        """
        Evaluate at distance a spiral in standard orientation -- zero
        curvature at origin.
        """
        ...
    
    def EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(s: float, length: float, curvature1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: DVec2d, d2XY: DVec2d, d3XY: DVec2d) -> bool:
        """
        (input) distance for evaluation (input) nominal length. ASSUMED NONZERO (input)
        exit curvature. ASSUMED NONZERO (output) coordinates on spiral (output)
        first derivative wrt distance (output) second derivative wrt distance
        (output) third derivative wrt distance
        """
        ...
    
    def EvaluateVectorIntegrand(self: MSPyBentleyGeom.DSpiral2dBase, distance: float, pF: float) -> None:
        ...
    
    def FractionToCurvature(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float:
        """
        Return the true curvature at fractional position. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDCurvatureDFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> tuple:
        """
        Return the true curvature derivative wrt fraction. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDerivatives(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float, dXdf: DVec2d, ddXdfdf: DVec2d, dddXdfdfdf: DVec2d) -> bool:
        ...
    
    def FractionToDistance(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float) -> float:
        ...
    
    def FractionToLocalAngle(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float:
        """
        Return the tangent angle (in radians) in local coordinates
        """
        ...
    
    def FractionToVelocity(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float:
        """
        Return the magnitude of the true derivative of position wrt fraction.
        Implemented in DSpiral2dDirectEvaluation, not individual classes.
        Assume EvaluateAtFraction.
        """
        ...
    
    def GetBezierPoles(self: MSPyBentleyGeom.DSpiral2dPolish, poles: MSPyBentleyGeom.DPoint3dArray, startFraction: float, endFraction: float) -> bool:
        """
        Return poles for preferred representation as a bezier curve These are
        in the local coordinates of the standard orientation
        """
        ...
    
    def GetExtraData(self: MSPyBentleyGeom.DSpiral2dBase, extraData: MSPyBentleyGeom.DoubleArray) -> None:
        """
        Get the extra data for this spiral. REMARK:This should be a virtual,
        but is implemented as special cases because of API change restriction
        """
        ...
    
    def GetIntervalCount(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, minInterval: int = 0, maxStrokeLength: float = 10000.0) -> int:
        """
        Return an interval count for stroking or integration. Except for
        degenerate single interval cases, the interval count is always even.
        That is the possible values are
        
        :param (input):
        spiral spiral being queried.
        
        :param (input):
        startFraction start of interval to stroke.
        
        :param (input):
        endFraction end of interval to stroke.
        
        :param (input):
        maxRadians max turn between strokes.
        
        :param (input):
        minInterval smallest number of intervals.
        
        :param (input):
        maxStrokeLength largest stroke size. Recommended 10 meters
        """
        ...
    
    def GetTransitionTypeCode(self: MSPyBentleyGeom.DSpiral2dBase) -> int:
        ...
    
    def GetVectorIntegrandCount(self: MSPyBentleyGeom.DSpiral2dBase) -> int:
        ...
    
    def IsValidRLCombination(lengthFromInflection: float, radius: float, spiralType: int = 0) -> bool:
        """
        test if a length-from-inflection and final radius
        combination is " small enough " for reasonable use. Test depends on
        spiral type:
        
        * DSpiral2dBase.TransitionType_None indicates apply the strictest
        test (same as Czech and Italian)
        
        * DSpiral2dBase.TransitionType_Czech and
        DSpiral2dBase.TransitionType_Italian indicate a strict test L<2*R
        
        * other types have no restrictions.
        
        :param (input):
        lengthFromInflection (input) distance along spiral starting at
        inflection and ending at finalRadius.
        
        :param (input):
        finalRadius (input) final radius
        
        :param (input):
        spiralType (input) spiral type.
        
        :param (input):
        lengthFactor expansion or reduction factor to apply to the allowed
        length. +---------------+---------------+---------------+---------
        ------+------
        """
        ...
    
    def LineSpiralArcSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, radius: float, lengthA: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralAToArc: MSPyBentleyGeom.DPoint3d, spiralBToArc: MSPyBentleyGeom.DPoint3d, arc: MSPyBentleyGeom.DEllipse3d) -> bool:
        """
        compute spirals and arc to make a line-to-line
        transition.
        
        :param (input):
        lineAPoint point on line A.
        
        :param (input):
        lineBPoint point on line B.
        
        :param (input):
        lineLineIntersection intersection of lines.
        
        :param (input):
        radius radius for circular part of transition.
        
        :param (input):
        lengthA length of spiral from line A to circle.
        
        :param (input):
        lengthB length of spiral from line B to circle.
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        lineToSpiralA tangency point from line to spiral
        
        :param (output):
        spiralAToArc tangency point from spiral to arc
        
        :param (output):
        lineToSpiralB tangency point from line to spiral
        
        :param (output):
        spiralBToArc tangency point from spiral to arc
        
        :param (output):
        arc arc between spirals.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def ScaleInPlace(self: MSPyBentleyGeom.DSpiral2dBase, s: float) -> bool:
        ...
    
    def SetBearingAndCurvatureLimits(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, theta1: float, curvature1: float) -> bool:
        ...
    
    def SetBearingCurvatureLengthBearing(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, theta1: float) -> bool:
        """
        Set start bearing, start curvature, length, and end
        curvature. (Compute end bearing)
        
        :param (input):
        theta0 start bearing
        
        :param (input):
        curvature0 start curvature
        
        :param (input):
        length arc length
        
        :param (input):
        theta1 end bearing
        """
        ...
    
    def SetBearingCurvatureLengthCurvature(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, curvature1: float) -> bool:
        ...
    
    def StringToTransitionType(name: str) -> int:
        """
        return the integer code for the string name.
        """
        ...
    
    def Stroke(*args, **kwargs):
        """
        Overloaded function.
        
        1. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, pDXY: DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        2. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, xyz0: MSPyBentleyGeom.DPoint3d, pXYZ: MSPyBentleyGeom.DPoint3d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        3. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: DVec2d) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        4. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        5. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: DVec2d, pFraction: float, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        6. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: DVec2d, maxStrokeLength: float) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        7. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, uvPoints: List[DVec2d], fractions: MSPyBentleyGeom.DoubleArray, maxStrokeLength: float = 10000.0) -> tuple
        """
        ...
    
    def StrokeToAnnouncer(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, F: MSPyBentleyGeom.AnnounceDoubleDPoint2d, minIndex: int = 0, maxStrokeLength: float = 10000.0) -> tuple:
        """
        Integrate the vector displacements of a clothoid over a
        fractional interval. This uses the angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        startFraction start fraction for integral.
        
        :param (input):
        endFraction end fraction for integral.
        
        :param (input):
        maxRadians maximum bearing change between computed points. A
        default is used if 0.0 is passed.
        
        :param (input):
        F object with a method F->Announce (f, uv) called to announce
        fraction and coordinate as computed.
        
        :param (output):
        errorBound estimated bound on error.
        
        :param (output):
        minInterval smallest number of intervals allowed
        
        :param (output):
        maxStrokeLength maximum allowed stroke length
        
        :returns:
        false if point integration failed
        """
        ...
    
    def SymmetricLineSpiralSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, length: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralToSpiral: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        compute spirals and arc to make a line-to-line
        transition.
        
        :param (input):
        lineAPoint point on line A.
        
        :param (input):
        lineBPoint point on line B.
        
        :param (input):
        lineLineIntersection intersection of lines.
        
        :param (input):
        length length of spiral from line A to junction
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        lineToSpiralA tangency point from line to spiral
        
        :param (output):
        lineToSpiralB tangency point from line to spiral
        
        :param (output):
        spiralToSpiral tangency point from spiral to to spiral
        
        :param (output):
        junctionRadius radius at transition between the spirals.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def SymmetricPointShoulderTargetTransition(startPoint: MSPyBentleyGeom.DPoint2d, shoulderPoint: MSPyBentleyGeom.DPoint2d, targetPoint: MSPyBentleyGeom.DPoint2d, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, junctionPoint: MSPyBentleyGeom.DPoint2d, endPoint: MSPyBentleyGeom.DPoint2d) -> bool:
        """
        compute 2 spirals.
        
        :param (input):
        startPoint start point
        
        :param (input):
        shoulderPoint target point for first and last tangents
        
        :param (input):
        targetPoint target point for last tangent
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        junctionPoint transition between spirals. This is the max
        curvature point.
        
        :param (output):
        endPoint end of second spiral.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def TransitionTypeToString(type: int) -> str:
        """
        return the string name of the type
        """
        ...
    
    TransitionType_Arema: int
    
    TransitionType_AustralianRailCorp: int
    
    TransitionType_Biquadratic: int
    
    TransitionType_Bloss: int
    
    TransitionType_ChineseCubic: int
    
    TransitionType_Clothoid: int
    
    TransitionType_Cosine: int
    
    TransitionType_Czech: int
    
    TransitionType_CzechAlongTangent: int
    
    TransitionType_DirectHalfCosine: int
    
    TransitionType_FirstDirectEvaluate: int
    
    TransitionType_Italian: int
    
    TransitionType_JapaneseCubic: int
    
    TransitionType_MXCubicAlongArc: int
    
    TransitionType_MXCubicAlongTangent: int
    
    TransitionType_PolishCubic: int
    
    TransitionType_Sine: int
    
    TransitionType_Unknown: int
    
    TransitionType_Viennese: int
    
    TransitionType_WeightedViennese: int
    
    TransitionType_WesternAustralian: int
    
    def ValidateSeriesInversion() -> float:
        """
        Execute unit test of the series inversion logic.
        """
        ...
    
    def VectorIntegrandCount(self: MSPyBentleyGeom.BSIVectorIntegrand) -> int:
        ...
    
    def __init__(self: MSPyBentleyGeom.DSpiral2dPolish, nominalLength: float) -> None:
        ...
    
    @property
    def mLength(arg0: MSPyBentleyGeom.DSpiral2dBase) -> float:
        ...
    
class DSpiral2dSine:
    """
    None
    """

    class ASLSACollector:
        """
        None
        """
    
        def Collect(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector, centerA: MSPyBentleyGeom.DPoint3d, arcToSpiralA: MSPyBentleyGeom.DPoint3d, sprialA: MSPyBentleyGeom.DSpiral2dBase, sprialToLineA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, arcToSpiralB: MSPyBentleyGeom.DPoint3d, spiralB: MSPyBentleyGeom.DSpiral2dBase, spiralToLibeB: MSPyBentleyGeom.DPoint3d) -> None:
            ...
        
        def __init__(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> None:
            ...
        
    def ArcSpiralLineSpiralArcTransition(centerA: MSPyBentleyGeom.DPoint3d, radiusA: float, lengthA: float, centerB: MSPyBentleyGeom.DPoint3d, radiusB: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, collector: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> int:
        ...
    
    def Clone(self: MSPyBentleyGeom.DSpiral2dBase) -> MSPyBentleyGeom.DSpiral2dBase:
        ...
    
    def ClosestPoint(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, spiralToWorld: Transform, spacePoint: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        Compute the closest spiral point for a given space point.
        
        :param (input):
        spiral spiral to evaluate.
        
        :param (input):
        startFraction start fraction of search range
        
        :param (input):
        endFraction endFraction of search range
        
        :param (input):
        spiralToWorld transform placing the spiral local coordinates into
        the world coordinate system
        
        :param (input):
        spacePoint world coordinates of space point.
        
        :param (output):
        spiralPoint world coordinates of closest point on spiral
        
        :param (output):
        spiralFraction fractional coordinates of closest point on spiral
        
        :param (output):
        minDistance distance from space point to spiralPoint.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def CopyBaseParameters(self: MSPyBentleyGeom.DSpiral2dBase, pSource: MSPyBentleyGeom.DSpiral2dBase) -> None:
        ...
    
    def CreateBearingCurvatureBearingCurvature(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float, extraData: MSPyBentleyGeom.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def CreateBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float, extraData: MSPyBentleyGeom.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def DefaultStrokeAngle() -> float:
        ...
    
    def DistanceToCurvature(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToCurvatureDerivative(self: MSPyBentleyGeom.DSpiral2dBase, arg0: float) -> float:
        """
        distance
        """
        ...
    
    def DistanceToFraction(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToGlobalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToLocalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(s: float, length: float, curvature1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: DVec2d, d2XY: DVec2d, d3XY: DVec2d) -> bool:
        """
        (input) distance for evaluation (input) nominal length. ASSUMED NONZERO (input)
        exit curvature. ASSUMED NONZERO (output) coordinates on spiral (output)
        first derivative wrt distance (output) second derivative wrt distance
        (output) third derivative wrt distance
        """
        ...
    
    def EvaluateVectorIntegrand(self: MSPyBentleyGeom.DSpiral2dBase, distance: float, pF: float) -> None:
        ...
    
    def FractionToDerivatives(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float, dXdf: DVec2d, ddXdfdf: DVec2d, dddXdfdfdf: DVec2d) -> bool:
        ...
    
    def FractionToDistance(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float) -> float:
        ...
    
    def GetExtraData(self: MSPyBentleyGeom.DSpiral2dBase, extraData: MSPyBentleyGeom.DoubleArray) -> None:
        """
        Get the extra data for this spiral. REMARK:This should be a virtual,
        but is implemented as special cases because of API change restriction
        """
        ...
    
    def GetIntervalCount(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, minInterval: int = 0, maxStrokeLength: float = 10000.0) -> int:
        """
        Return an interval count for stroking or integration. Except for
        degenerate single interval cases, the interval count is always even.
        That is the possible values are
        
        :param (input):
        spiral spiral being queried.
        
        :param (input):
        startFraction start of interval to stroke.
        
        :param (input):
        endFraction end of interval to stroke.
        
        :param (input):
        maxRadians max turn between strokes.
        
        :param (input):
        minInterval smallest number of intervals.
        
        :param (input):
        maxStrokeLength largest stroke size. Recommended 10 meters
        """
        ...
    
    def GetTransitionTypeCode(self: MSPyBentleyGeom.DSpiral2dBase) -> int:
        ...
    
    def GetVectorIntegrandCount(self: MSPyBentleyGeom.DSpiral2dBase) -> int:
        ...
    
    def IsValidRLCombination(lengthFromInflection: float, radius: float, spiralType: int = 0) -> bool:
        """
        test if a length-from-inflection and final radius
        combination is " small enough " for reasonable use. Test depends on
        spiral type:
        
        * DSpiral2dBase.TransitionType_None indicates apply the strictest
        test (same as Czech and Italian)
        
        * DSpiral2dBase.TransitionType_Czech and
        DSpiral2dBase.TransitionType_Italian indicate a strict test L<2*R
        
        * other types have no restrictions.
        
        :param (input):
        lengthFromInflection (input) distance along spiral starting at
        inflection and ending at finalRadius.
        
        :param (input):
        finalRadius (input) final radius
        
        :param (input):
        spiralType (input) spiral type.
        
        :param (input):
        lengthFactor expansion or reduction factor to apply to the allowed
        length. +---------------+---------------+---------------+---------
        ------+------
        """
        ...
    
    def LineSpiralArcSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, radius: float, lengthA: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralAToArc: MSPyBentleyGeom.DPoint3d, spiralBToArc: MSPyBentleyGeom.DPoint3d, arc: MSPyBentleyGeom.DEllipse3d) -> bool:
        """
        compute spirals and arc to make a line-to-line
        transition.
        
        :param (input):
        lineAPoint point on line A.
        
        :param (input):
        lineBPoint point on line B.
        
        :param (input):
        lineLineIntersection intersection of lines.
        
        :param (input):
        radius radius for circular part of transition.
        
        :param (input):
        lengthA length of spiral from line A to circle.
        
        :param (input):
        lengthB length of spiral from line B to circle.
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        lineToSpiralA tangency point from line to spiral
        
        :param (output):
        spiralAToArc tangency point from spiral to arc
        
        :param (output):
        lineToSpiralB tangency point from line to spiral
        
        :param (output):
        spiralBToArc tangency point from spiral to arc
        
        :param (output):
        arc arc between spirals.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def ScaleInPlace(self: MSPyBentleyGeom.DSpiral2dBase, s: float) -> bool:
        ...
    
    def SetBearingAndCurvatureLimits(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, theta1: float, curvature1: float) -> bool:
        ...
    
    def SetBearingCurvatureLengthBearing(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, theta1: float) -> bool:
        """
        Set start bearing, start curvature, length, and end
        curvature. (Compute end bearing)
        
        :param (input):
        theta0 start bearing
        
        :param (input):
        curvature0 start curvature
        
        :param (input):
        length arc length
        
        :param (input):
        theta1 end bearing
        """
        ...
    
    def SetBearingCurvatureLengthCurvature(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, curvature1: float) -> bool:
        ...
    
    def StringToTransitionType(name: str) -> int:
        """
        return the integer code for the string name.
        """
        ...
    
    def Stroke(*args, **kwargs):
        """
        Overloaded function.
        
        1. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, pDXY: DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        2. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, xyz0: MSPyBentleyGeom.DPoint3d, pXYZ: MSPyBentleyGeom.DPoint3d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        3. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: DVec2d) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        4. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        5. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: DVec2d, pFraction: float, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        6. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: DVec2d, maxStrokeLength: float) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        7. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, uvPoints: List[DVec2d], fractions: MSPyBentleyGeom.DoubleArray, maxStrokeLength: float = 10000.0) -> tuple
        """
        ...
    
    def StrokeToAnnouncer(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, F: MSPyBentleyGeom.AnnounceDoubleDPoint2d, minIndex: int = 0, maxStrokeLength: float = 10000.0) -> tuple:
        """
        Integrate the vector displacements of a clothoid over a
        fractional interval. This uses the angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        startFraction start fraction for integral.
        
        :param (input):
        endFraction end fraction for integral.
        
        :param (input):
        maxRadians maximum bearing change between computed points. A
        default is used if 0.0 is passed.
        
        :param (input):
        F object with a method F->Announce (f, uv) called to announce
        fraction and coordinate as computed.
        
        :param (output):
        errorBound estimated bound on error.
        
        :param (output):
        minInterval smallest number of intervals allowed
        
        :param (output):
        maxStrokeLength maximum allowed stroke length
        
        :returns:
        false if point integration failed
        """
        ...
    
    def SymmetricLineSpiralSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, length: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralToSpiral: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        compute spirals and arc to make a line-to-line
        transition.
        
        :param (input):
        lineAPoint point on line A.
        
        :param (input):
        lineBPoint point on line B.
        
        :param (input):
        lineLineIntersection intersection of lines.
        
        :param (input):
        length length of spiral from line A to junction
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        lineToSpiralA tangency point from line to spiral
        
        :param (output):
        lineToSpiralB tangency point from line to spiral
        
        :param (output):
        spiralToSpiral tangency point from spiral to to spiral
        
        :param (output):
        junctionRadius radius at transition between the spirals.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def SymmetricPointShoulderTargetTransition(startPoint: MSPyBentleyGeom.DPoint2d, shoulderPoint: MSPyBentleyGeom.DPoint2d, targetPoint: MSPyBentleyGeom.DPoint2d, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, junctionPoint: MSPyBentleyGeom.DPoint2d, endPoint: MSPyBentleyGeom.DPoint2d) -> bool:
        """
        compute 2 spirals.
        
        :param (input):
        startPoint start point
        
        :param (input):
        shoulderPoint target point for first and last tangents
        
        :param (input):
        targetPoint target point for last tangent
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        junctionPoint transition between spirals. This is the max
        curvature point.
        
        :param (output):
        endPoint end of second spiral.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def TransitionTypeToString(type: int) -> str:
        """
        return the string name of the type
        """
        ...
    
    TransitionType_Arema: int
    
    TransitionType_AustralianRailCorp: int
    
    TransitionType_Biquadratic: int
    
    TransitionType_Bloss: int
    
    TransitionType_ChineseCubic: int
    
    TransitionType_Clothoid: int
    
    TransitionType_Cosine: int
    
    TransitionType_Czech: int
    
    TransitionType_CzechAlongTangent: int
    
    TransitionType_DirectHalfCosine: int
    
    TransitionType_FirstDirectEvaluate: int
    
    TransitionType_Italian: int
    
    TransitionType_JapaneseCubic: int
    
    TransitionType_MXCubicAlongArc: int
    
    TransitionType_MXCubicAlongTangent: int
    
    TransitionType_PolishCubic: int
    
    TransitionType_Sine: int
    
    TransitionType_Unknown: int
    
    TransitionType_Viennese: int
    
    TransitionType_WeightedViennese: int
    
    TransitionType_WesternAustralian: int
    
    def VectorIntegrandCount(self: MSPyBentleyGeom.BSIVectorIntegrand) -> int:
        ...
    
    def __init__(self: MSPyBentleyGeom.DSpiral2dSine) -> None:
        ...
    
    @property
    def mLength(arg0: MSPyBentleyGeom.DSpiral2dBase) -> float:
        ...
    
class DSpiral2dWesternAustralian:
    """
    None
    """

    class ASLSACollector:
        """
        None
        """
    
        def Collect(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector, centerA: MSPyBentleyGeom.DPoint3d, arcToSpiralA: MSPyBentleyGeom.DPoint3d, sprialA: MSPyBentleyGeom.DSpiral2dBase, sprialToLineA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, arcToSpiralB: MSPyBentleyGeom.DPoint3d, spiralB: MSPyBentleyGeom.DSpiral2dBase, spiralToLibeB: MSPyBentleyGeom.DPoint3d) -> None:
            ...
        
        def __init__(self: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> None:
            ...
        
    def ApplyCCWRotation(radians: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: DVec2d, d2XYZ: DVec2d, d3XYZ: DVec2d) -> None:
        """
        rotate xy and optional derivatives by radians. (To be called by
        derived class EvaluateAtDistance when to rotate EvaluateAtDistance
        results from standard position)
        """
        ...
    
    def ArcSpiralLineSpiralArcTransition(centerA: MSPyBentleyGeom.DPoint3d, radiusA: float, lengthA: float, centerB: MSPyBentleyGeom.DPoint3d, radiusB: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, collector: MSPyBentleyGeom.DSpiral2dBase.ASLSACollector) -> int:
        ...
    
    def Clone(self: MSPyBentleyGeom.DSpiral2dBase) -> MSPyBentleyGeom.DSpiral2dBase:
        ...
    
    def ClosestPoint(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, spiralToWorld: Transform, spacePoint: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        Compute the closest spiral point for a given space point.
        
        :param (input):
        spiral spiral to evaluate.
        
        :param (input):
        startFraction start fraction of search range
        
        :param (input):
        endFraction endFraction of search range
        
        :param (input):
        spiralToWorld transform placing the spiral local coordinates into
        the world coordinate system
        
        :param (input):
        spacePoint world coordinates of space point.
        
        :param (output):
        spiralPoint world coordinates of closest point on spiral
        
        :param (output):
        spiralFraction fractional coordinates of closest point on spiral
        
        :param (output):
        minDistance distance from space point to spiralPoint.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def CopyBaseParameters(self: MSPyBentleyGeom.DSpiral2dBase, pSource: MSPyBentleyGeom.DSpiral2dBase) -> None:
        ...
    
    def CreateBearingCurvatureBearingCurvature(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float, extraData: MSPyBentleyGeom.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def CreateBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        
        2. CreateBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float, extraData: MSPyBentleyGeom.DoubleArray) -> MSPyBentleyGeom.DSpiral2dBase
        
        invoke appropriate concrete class constructor ...
        """
        ...
    
    def DefaultStrokeAngle() -> float:
        ...
    
    def DistanceToCurvature(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToCurvatureDerivative(self: MSPyBentleyGeom.DSpiral2dBase, arg0: float) -> float:
        """
        distance
        """
        ...
    
    def DistanceToFraction(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToGlobalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def DistanceToLocalAngle(self: MSPyBentleyGeom.DSpiral2dBase, distance: float) -> float:
        ...
    
    def EvaluateAtFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float, xyz: MSPyBentleyGeom.DPoint2d, d1XYZ: DVec2d, d2XYZ: DVec2d, d3XYZ: DVec2d) -> bool:
        """
        Evaluate the spiral and derivatives at specified fractional position
        return true if valid evaluation. DSpiral2dDirectEvaluation default
        implementation returns false.
        """
        ...
    
    def EvaluateTwoTermClothoidSeriesAtDistanceInStandardOrientation(s: float, length: float, curvature1: float, xy: MSPyBentleyGeom.DPoint2d, d1XY: DVec2d, d2XY: DVec2d, d3XY: DVec2d) -> bool:
        """
        (input) distance for evaluation (input) nominal length. ASSUMED NONZERO (input)
        exit curvature. ASSUMED NONZERO (output) coordinates on spiral (output)
        first derivative wrt distance (output) second derivative wrt distance
        (output) third derivative wrt distance
        """
        ...
    
    def EvaluateVectorIntegrand(self: MSPyBentleyGeom.DSpiral2dBase, distance: float, pF: float) -> None:
        ...
    
    def FractionToCurvature(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float:
        """
        Return the true curvature at fractional position. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDCurvatureDFraction(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> tuple:
        """
        Return the true curvature derivative wrt fraction. Implemented in
        DSpiral2dDirectEvaluation, not individual classes. Assume
        EvaluateAtFraction.
        """
        ...
    
    def FractionToDerivatives(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float, dXdf: DVec2d, ddXdfdf: DVec2d, dddXdfdfdf: DVec2d) -> bool:
        ...
    
    def FractionToDistance(self: MSPyBentleyGeom.DSpiral2dBase, fraction: float) -> float:
        ...
    
    def FractionToLocalAngle(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float:
        """
        Return the tangent angle (in radians) in local coordinates
        """
        ...
    
    def FractionToVelocity(self: MSPyBentleyGeom.DSpiral2dDirectEvaluation, fraction: float) -> float:
        """
        Return the magnitude of the true derivative of position wrt fraction.
        Implemented in DSpiral2dDirectEvaluation, not individual classes.
        Assume EvaluateAtFraction.
        """
        ...
    
    def GetExtraData(self: MSPyBentleyGeom.DSpiral2dBase, extraData: MSPyBentleyGeom.DoubleArray) -> None:
        """
        Get the extra data for this spiral. REMARK:This should be a virtual,
        but is implemented as special cases because of API change restriction
        """
        ...
    
    def GetIntervalCount(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, minInterval: int = 0, maxStrokeLength: float = 10000.0) -> int:
        """
        Return an interval count for stroking or integration. Except for
        degenerate single interval cases, the interval count is always even.
        That is the possible values are
        
        :param (input):
        spiral spiral being queried.
        
        :param (input):
        startFraction start of interval to stroke.
        
        :param (input):
        endFraction end of interval to stroke.
        
        :param (input):
        maxRadians max turn between strokes.
        
        :param (input):
        minInterval smallest number of intervals.
        
        :param (input):
        maxStrokeLength largest stroke size. Recommended 10 meters
        """
        ...
    
    def GetTransitionTypeCode(self: MSPyBentleyGeom.DSpiral2dBase) -> int:
        ...
    
    def GetVectorIntegrandCount(self: MSPyBentleyGeom.DSpiral2dBase) -> int:
        ...
    
    def IsValidRLCombination(lengthFromInflection: float, radius: float, spiralType: int = 0) -> bool:
        """
        test if a length-from-inflection and final radius
        combination is " small enough " for reasonable use. Test depends on
        spiral type:
        
        * DSpiral2dBase.TransitionType_None indicates apply the strictest
        test (same as Czech and Italian)
        
        * DSpiral2dBase.TransitionType_Czech and
        DSpiral2dBase.TransitionType_Italian indicate a strict test L<2*R
        
        * other types have no restrictions.
        
        :param (input):
        lengthFromInflection (input) distance along spiral starting at
        inflection and ending at finalRadius.
        
        :param (input):
        finalRadius (input) final radius
        
        :param (input):
        spiralType (input) spiral type.
        
        :param (input):
        lengthFactor expansion or reduction factor to apply to the allowed
        length. +---------------+---------------+---------------+---------
        ------+------
        """
        ...
    
    def LineSpiralArcSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, radius: float, lengthA: float, lengthB: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralAToArc: MSPyBentleyGeom.DPoint3d, spiralBToArc: MSPyBentleyGeom.DPoint3d, arc: MSPyBentleyGeom.DEllipse3d) -> bool:
        """
        compute spirals and arc to make a line-to-line
        transition.
        
        :param (input):
        lineAPoint point on line A.
        
        :param (input):
        lineBPoint point on line B.
        
        :param (input):
        lineLineIntersection intersection of lines.
        
        :param (input):
        radius radius for circular part of transition.
        
        :param (input):
        lengthA length of spiral from line A to circle.
        
        :param (input):
        lengthB length of spiral from line B to circle.
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        lineToSpiralA tangency point from line to spiral
        
        :param (output):
        spiralAToArc tangency point from spiral to arc
        
        :param (output):
        lineToSpiralB tangency point from line to spiral
        
        :param (output):
        spiralBToArc tangency point from spiral to arc
        
        :param (output):
        arc arc between spirals.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def ScaleInPlace(self: MSPyBentleyGeom.DSpiral2dBase, s: float) -> bool:
        ...
    
    def SetBearingAndCurvatureLimits(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, theta1: float, curvature1: float) -> bool:
        ...
    
    def SetBearingCurvatureLengthBearing(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, theta1: float) -> bool:
        """
        Set start bearing, start curvature, length, and end
        curvature. (Compute end bearing)
        
        :param (input):
        theta0 start bearing
        
        :param (input):
        curvature0 start curvature
        
        :param (input):
        length arc length
        
        :param (input):
        theta1 end bearing
        """
        ...
    
    def SetBearingCurvatureLengthCurvature(self: MSPyBentleyGeom.DSpiral2dBase, theta0: float, curvature0: float, length: float, curvature1: float) -> bool:
        ...
    
    def StringToTransitionType(name: str) -> int:
        """
        return the integer code for the string name.
        """
        ...
    
    def Stroke(*args, **kwargs):
        """
        Overloaded function.
        
        1. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, pDXY: DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        2. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, maxRadians: float, xyz0: MSPyBentleyGeom.DPoint3d, pXYZ: MSPyBentleyGeom.DPoint3d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        3. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: DVec2d) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        4. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: DVec2d, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        5. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, pDXY: DVec2d, pFraction: float, maxDXY: int) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        6. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, delta: DVec2d, maxStrokeLength: float) -> tuple
        
        Integrate the vector displacements of a clothoid from its
        start point to multiple points up to its end point. This uses the
        angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        maxRadians maximum bearing change between computed points.
        Recommended value is 0.08.
        
        :param [in,out]:
        pDXY buffer to receive points.
        
        :param (output):
        numDXY number of points computed.
        
        :param (input):
        maxDXY maximum number of points to compute. If zero or negative,
        only the final vector is stored (and pDXY is assumed to be valid
        for one vector).
        
        :param (output):
        errorBound estimated bound on error.
        
        :returns:
        false if point buffer exceeded.
        
        7. Stroke(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, uvPoints: List[DVec2d], fractions: MSPyBentleyGeom.DoubleArray, maxStrokeLength: float = 10000.0) -> tuple
        """
        ...
    
    def StrokeToAnnouncer(spiral: MSPyBentleyGeom.DSpiral2dBase, startFraction: float, endFraction: float, maxRadians: float, F: MSPyBentleyGeom.AnnounceDoubleDPoint2d, minIndex: int = 0, maxStrokeLength: float = 10000.0) -> tuple:
        """
        Integrate the vector displacements of a clothoid over a
        fractional interval. This uses the angles, curvatures, and length.
        
        :param (input):
        spiral spiral to stroke
        
        :param (input):
        startFraction start fraction for integral.
        
        :param (input):
        endFraction end fraction for integral.
        
        :param (input):
        maxRadians maximum bearing change between computed points. A
        default is used if 0.0 is passed.
        
        :param (input):
        F object with a method F->Announce (f, uv) called to announce
        fraction and coordinate as computed.
        
        :param (output):
        errorBound estimated bound on error.
        
        :param (output):
        minInterval smallest number of intervals allowed
        
        :param (output):
        maxStrokeLength maximum allowed stroke length
        
        :returns:
        false if point integration failed
        """
        ...
    
    def SymmetricLineSpiralSpiralLineTransition(lineAPoint: MSPyBentleyGeom.DPoint3d, lineBPoint: MSPyBentleyGeom.DPoint3d, lineLineIntersection: MSPyBentleyGeom.DPoint3d, length: float, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, lineToSpiralA: MSPyBentleyGeom.DPoint3d, lineToSpiralB: MSPyBentleyGeom.DPoint3d, spiralToSpiral: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        compute spirals and arc to make a line-to-line
        transition.
        
        :param (input):
        lineAPoint point on line A.
        
        :param (input):
        lineBPoint point on line B.
        
        :param (input):
        lineLineIntersection intersection of lines.
        
        :param (input):
        length length of spiral from line A to junction
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        lineToSpiralA tangency point from line to spiral
        
        :param (output):
        lineToSpiralB tangency point from line to spiral
        
        :param (output):
        spiralToSpiral tangency point from spiral to to spiral
        
        :param (output):
        junctionRadius radius at transition between the spirals.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def SymmetricPointShoulderTargetTransition(startPoint: MSPyBentleyGeom.DPoint2d, shoulderPoint: MSPyBentleyGeom.DPoint2d, targetPoint: MSPyBentleyGeom.DPoint2d, spiralA: MSPyBentleyGeom.DSpiral2dBase, spiralB: MSPyBentleyGeom.DSpiral2dBase, junctionPoint: MSPyBentleyGeom.DPoint2d, endPoint: MSPyBentleyGeom.DPoint2d) -> bool:
        """
        compute 2 spirals.
        
        :param (input):
        startPoint start point
        
        :param (input):
        shoulderPoint target point for first and last tangents
        
        :param (input):
        targetPoint target point for last tangent
        
        :param [in,out]:
        spiralA On input, a spiral of the desired type. On output all
        fields are set.
        
        :param [in,out]:
        spiralB On input, a spiral of the desired type. On output all
        fields are set.
        
        :param (output):
        junctionPoint transition between spirals. This is the max
        curvature point.
        
        :param (output):
        endPoint end of second spiral.
        
        :returns:
        false if unable to construct
        """
        ...
    
    def TransitionTypeToString(type: int) -> str:
        """
        return the string name of the type
        """
        ...
    
    TransitionType_Arema: int
    
    TransitionType_AustralianRailCorp: int
    
    TransitionType_Biquadratic: int
    
    TransitionType_Bloss: int
    
    TransitionType_ChineseCubic: int
    
    TransitionType_Clothoid: int
    
    TransitionType_Cosine: int
    
    TransitionType_Czech: int
    
    TransitionType_CzechAlongTangent: int
    
    TransitionType_DirectHalfCosine: int
    
    TransitionType_FirstDirectEvaluate: int
    
    TransitionType_Italian: int
    
    TransitionType_JapaneseCubic: int
    
    TransitionType_MXCubicAlongArc: int
    
    TransitionType_MXCubicAlongTangent: int
    
    TransitionType_PolishCubic: int
    
    TransitionType_Sine: int
    
    TransitionType_Unknown: int
    
    TransitionType_Viennese: int
    
    TransitionType_WeightedViennese: int
    
    TransitionType_WesternAustralian: int
    
    def VectorIntegrandCount(self: MSPyBentleyGeom.BSIVectorIntegrand) -> int:
        ...
    
    def __init__(self: MSPyBentleyGeom.DSpiral2dWesternAustralian, arg0: float) -> None:
        ...
    
    @property
    def mLength(arg0: MSPyBentleyGeom.DSpiral2dBase) -> float:
        ...
    
class DTriangle3d:
    """
    None
    """

    def AspectRatio(self: MSPyBentleyGeom.DTriangle3d) -> float:
        """
        Return a measure of triangle quality. The value is 0 for a 0 area
        triangle, increases as aspect angles become more equal.
        """
        ...
    
    def ClosestPointUnbounded(*args, **kwargs):
        """
        Overloaded function.
        
        1. ClosestPointUnbounded(self: MSPyBentleyGeom.DTriangle3d, spacePoint: MSPyBentleyGeom.DPoint3d, uv: MSPyBentleyGeom.DPoint2d, xyz: MSPyBentleyGeom.DPoint3d) -> bool
        
        return uv and xyz coordinates of the projection to the unbounded plane
        of the triangle.
        
        :returns:
        false if axes are not independent.
        
        2. ClosestPointUnbounded(self: MSPyBentleyGeom.DTriangle3d, spacePoint: MSPyBentleyGeom.DPoint3d, uv: MSPyBentleyGeom.DPoint2d) -> bool
        
        return uv and xyz coordinates of the projection to the unbounded plane
        of the triangle.
        
        :returns:
        false if axes are not independent.
        """
        ...
    
    def CrossVectorsFromOrigin(self: MSPyBentleyGeom.DTriangle3d) -> DVec3d:
        """
        Return the cross product of VectorsFromOrigin
        """
        ...
    
    def Evaluate(*args, **kwargs):
        """
        Overloaded function.
        
        1. Evaluate(self: MSPyBentleyGeom.DTriangle3d, u: float, v: float) -> MSPyBentleyGeom.DPoint3d
        
        Return surface coordinates at u,v parameters
        
        2. Evaluate(self: MSPyBentleyGeom.DTriangle3d, u: float, v: float, xyz: MSPyBentleyGeom.DPoint3d, dXdu: DVec3d, dXdv: DVec3d) -> None
        
        Return surface coordinates at u,v parameters
        """
        ...
    
    def EvaluateNormal(self: MSPyBentleyGeom.DTriangle3d, u: float, v: float, xyz: MSPyBentleyGeom.DPoint3d, unitNormal: DVec3d) -> None:
        """
        Return surface coordinates and unit normal at u,v parameters
        """
        ...
    
    def GetCCWEdgeDRay3d(self: MSPyBentleyGeom.DTriangle3d, i: int) -> MSPyBentleyGeom.DRay3d:
        """
        Return specified edge as a ray. Edge order is:bottom, diagonal, left
        with CCW loop direction.
        """
        ...
    
    def GetCCWEdgeDSegment3d(self: MSPyBentleyGeom.DTriangle3d, i: int) -> MSPyBentleyGeom.DSegment3d:
        """
        Return specified edge as a line segment. Edge order is:bottom,
        diagonal, left with CCW loop direction.
        """
        ...
    
    def GetCCWEdgeDVec3d(self: MSPyBentleyGeom.DTriangle3d, i: int) -> DVec3d:
        """
        Return specified edge as a vector Edge order is:bottom, diagonal,
        left with CCW loop direction.
        """
        ...
    
    def GetVectorsFromOrigin(self: MSPyBentleyGeom.DTriangle3d, vectorU: DVec3d, vectorV: DVec3d) -> None:
        """
        Return the two edge vectors outward from the origin.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DTriangle3d) -> None
        
        2. __init__(self: MSPyBentleyGeom.DTriangle3d, xyz0: MSPyBentleyGeom.DPoint3d, xyz10: MSPyBentleyGeom.DPoint3d, xyz01: MSPyBentleyGeom.DPoint3d) -> None
        
        3. __init__(self: MSPyBentleyGeom.DTriangle3d, xyz0: MSPyBentleyGeom.DPoint2d, xyz10: MSPyBentleyGeom.DPoint2d, xyz01: MSPyBentleyGeom.DPoint2d) -> None
        """
        ...
    
class DTriangle3dArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DTriangle3dArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.DTriangle3dArray, arg0: MSPyBentleyGeom.DTriangle3dArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.DTriangle3dArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.DTriangle3dArray, x: MSPyBentleyGeom.DTriangle3d) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.DTriangle3dArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.DTriangle3dArray, L: MSPyBentleyGeom.DTriangle3dArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.DTriangle3dArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.DTriangle3dArray, i: int, x: MSPyBentleyGeom.DTriangle3d) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.DTriangle3dArray) -> MSPyBentleyGeom.DTriangle3d
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.DTriangle3dArray, i: int) -> MSPyBentleyGeom.DTriangle3d
        
        Remove and return the item at index ``i``
        """
        ...
    
class DVec2d:
    """
    None
    """

    def Add(self: MSPyBentleyGeom.DVec2d, vector: MSPyBentleyGeom.DVec2d) -> None:
        """
        Adds a vector to a pointer or vector, returns the result
        in place.
        
        :param (input):
        vector The vector to add.
        """
        ...
    
    def AlmostEqual(self: MSPyBentleyGeom.DVec2d, vector2: MSPyBentleyGeom.DVec2d) -> bool:
        """
        test if two points are equal. Uses library " small angle " as both
        absolute and relative tolerance. points are equal if squared distance
        between is less than (squared abstol) plus (squared relTol) * sum of
        cmponent squares
        
        :param (input):
        dataB second DVec2d
        
        :returns:
        true if within tolerance.
        """
        ...
    
    def AngleTo(self: MSPyBentleyGeom.DVec2d, vector2: MSPyBentleyGeom.DVec2d) -> float:
        """
        Returns the angle between two vectors. This angle is
        between 0 and pi. Rotating the first vector by this angle around the
        cross product between the vectors aligns it with the second vector.
        
        :param (input):
        vector2 The second vector
        
        :returns:
        The angle between the vectors.
        """
        ...
    
    def CrossProduct(self: MSPyBentleyGeom.DVec2d, vector2: MSPyBentleyGeom.DVec2d) -> float:
        """
        Returns the (vector) cross product of two vectors.
        
        :param (input):
        vector2 The second vector
        """
        ...
    
    def CrossProductSquared(self: MSPyBentleyGeom.DVec2d, vector2: MSPyBentleyGeom.DVec2d) -> float:
        """
        Returns the (vector) cross product of two vectors.
        
        :param (input):
        vector2 The second vector
        """
        ...
    
    def CrossProductToPoints(self: MSPyBentleyGeom.DPoint2d, target1: MSPyBentleyGeom.DPoint2d, target2: MSPyBentleyGeom.DPoint2d) -> float:
        """
        Returns the (scalar) cross product of two vectors. The
        vectors are computed from the Origin to Target1 and Target2.
        
        :param (input):
        target1 target of first vector
        
        :param (input):
        target2 target of second vector
        """
        ...
    
    def DifferenceOf(*args, **kwargs):
        """
        Overloaded function.
        
        1. DifferenceOf(self: MSPyBentleyGeom.DVec2d, vector1: MSPyBentleyGeom.DVec2d, vector2: MSPyBentleyGeom.DVec2d) -> None
        
        Subtract coordinates of two vectors. (Compute Vector1 -
        Vector2)
        
        :param (input):
        vector1 The first vector
        
        :param (input):
        vector2 The second (subtracted) vector
        
        2. DifferenceOf(self: MSPyBentleyGeom.DVec2d, target: MSPyBentleyGeom.DPoint2d, base: MSPyBentleyGeom.DPoint2d) -> None
        
        Subtract coordinates of two vectors. (Compute Vector1 -
        Vector2)
        
        :param (input):
        vector1 The first vector
        
        :param (input):
        vector2 The second (subtracted) vector
        """
        ...
    
    def Distance(self: MSPyBentleyGeom.DVec2d, vector2: MSPyBentleyGeom.DVec2d) -> float:
        """
        Computes the (cartesian) distance between two vectors
        
        :param (input):
        vector2 The second vector
        
        :returns:
        The distance between vector.
        """
        ...
    
    def DistanceSquared(self: MSPyBentleyGeom.DVec2d, vector2: MSPyBentleyGeom.DVec2d) -> float:
        """
        Computes the squared distance between two vectors.
        
        :param (input):
        vector2 The second vector.
        
        :returns:
        The squared distance between the vectors.
        """
        ...
    
    def DotProduct(*args, **kwargs):
        """
        Overloaded function.
        
        1. DotProduct(self: MSPyBentleyGeom.DVec2d, vector2: MSPyBentleyGeom.DVec2d) -> float
        
        Returns the (scalar) dot product of two vectors.
        
        :param (input):
        vector2 The second vector
        
        :returns:
        The dot product of the two vectors
        
        2. DotProduct(self: MSPyBentleyGeom.DVec2d, ax: float, ay: float) -> float
        
        Returns the (scalar) dot product of two vectors.
        
        :param (input):
        vector2 The second vector
        
        :returns:
        The dot product of the two vectors
        
        3. DotProduct(self: MSPyBentleyGeom.DVec2d, point2: MSPyBentleyGeom.DPoint2d) -> float
        
        Returns the (scalar) dot product of two vectors.
        
        :param (input):
        vector2 The second vector
        
        :returns:
        The dot product of the two vectors
        """
        ...
    
    def DotProductToPoints(self: MSPyBentleyGeom.DPoint2d, target1: MSPyBentleyGeom.DPoint2d, target2: MSPyBentleyGeom.DPoint2d) -> float:
        """
        Returns the (scalar) dot product of two vectors. The
        vectors are computed from the Origin to Target1 and Target2.
        
        :param (input):
        target1 target of first vector
        
        :param (input):
        target2 target of second vector
        """
        ...
    
    @staticmethod
    def From(ax: float, ay: float) -> MSPyBentleyGeom.DVec2d:
        ...
    
    def FromInterpolate(point0: MSPyBentleyGeom.DPoint2d, fraction: float, point1: MSPyBentleyGeom.DPoint2d) -> MSPyBentleyGeom.DPoint2d:
        """
        Returns an interpolated point.
        
        :param (input):
        point0 point at fraction 0
        
        :param (input):
        fraction fraction from interpolation.
        
        :param (input):
        point1 point at fraction 1
        """
        ...
    
    def FromInterpolateBilinear(point00: MSPyBentleyGeom.DPoint2d, point10: MSPyBentleyGeom.DPoint2d, point01: MSPyBentleyGeom.DPoint2d, point11: MSPyBentleyGeom.DPoint2d, u: float, v: float) -> MSPyBentleyGeom.DPoint2d:
        """
        Returns a bilinear interpolation from corners
        (00)(10)(01)(11)
        
        :param (input):
        point00 point at (0,0)
        
        :param (input):
        point10 point at (1,0)
        
        :param (input):
        point01 point at (0,1)
        
        :param (input):
        point11 point at (1,1)
        
        :param (input):
        u interpolation fraction for edges (point00,point10) and
        (point01,point11)
        
        :param (input):
        v interpolation fraction for edges (point00,point10) and
        (point10,point11)
        """
        ...
    
    def FromOne() -> MSPyBentleyGeom.DPoint2d:
        """
        Return a DPoint2d with xy = 1.
        """
        ...
    
    def FromScale(point: MSPyBentleyGeom.DPoint2d, scale: float) -> MSPyBentleyGeom.DPoint2d:
        """
        Returns a scalar multiple of a DPoint2d
        
        :param (input):
        point input point
        
        :param (input):
        scale scale factor
        """
        ...
    
    @staticmethod
    def FromSumOf(*args, **kwargs):
        """
        Overloaded function.
        
        1. FromSumOf(vector0: MSPyBentleyGeom.DVec2d, scale0: float, vector1: MSPyBentleyGeom.DVec2d, scale1: float) -> MSPyBentleyGeom.DVec2d
        
        Returns a linear combination of vectors
        
        :param (input):
        vector0 first vector
        
        :param (input):
        scale0 first scale
        
        :param (input):
        vector1 second vector
        
        :param (input):
        scale1 second scale
        
        2. FromSumOf(vector0: MSPyBentleyGeom.DVec2d, scale0: float, vector1: MSPyBentleyGeom.DVec2d, scale1: float, vector2: MSPyBentleyGeom.DVec2d, scale2: float) -> MSPyBentleyGeom.DVec2d
        
        Returns a linear combination of vectors
        
        :param (input):
        vector0 first vector
        
        :param (input):
        scale0 first scale
        
        :param (input):
        vector1 second vector
        
        :param (input):
        scale1 second scale
        """
        ...
    
    def FromZero() -> MSPyBentleyGeom.DPoint2d:
        """
        Return a DPoint2d with xy = 0.
        """
        ...
    
    def GetComponent(self: MSPyBentleyGeom.DVec2d, index: int) -> float:
        """
        Gets a single component of a vector. If the index is out
        of range 0,1 it is interpretted cyclically.
        
        :param (input):
        index Indicates which component is accessed. The values are 0=x,
        1=y Other values are treated cyclically.
        
        :returns:
        The specified component of the vector.
        """
        ...
    
    def GetComponents(self: MSPyBentleyGeom.DVec2d) -> tuple:
        ...
    
    def Init(*args, **kwargs):
        """
        Overloaded function.
        
        1. Init(self: MSPyBentleyGeom.DVec2d, point: MSPyBentleyGeom.DPoint2d) -> None
        
        2. Init(self: MSPyBentleyGeom.DVec2d, x: float, y: float) -> None
        """
        ...
    
    def InitDisconnect(self: MSPyBentleyGeom.DPoint2d) -> None:
        """
        Initialize a point with all coordinates as the disconnect value.
        """
        ...
    
    def Interpolate(self: MSPyBentleyGeom.DVec2d, vector0: MSPyBentleyGeom.DVec2d, fractionParameter: float, vector1: MSPyBentleyGeom.DVec2d) -> None:
        """
        Computes a vector whose position is given by a fractional
        argument and two vectors.
        
        :param (input):
        vector0 The vector corresponding to fractionParameter of 0.
        
        :param (input):
        fractionParameter The fractional parametric coordinate. 0.0 is the
        start of the segment, 1.0 is the end, 0.5 is middle
        
        :param (input):
        vector1 The vector corresponding to fractionParameter of 1.
        """
        ...
    
    def IsConvexPair(self: MSPyBentleyGeom.DPoint2d) -> bool:
        """
        return true if the point has x, y, and x+1 all between 0 and 1
        (inclusive).
        """
        ...
    
    def IsDisconnect(self: MSPyBentleyGeom.DPoint2d) -> bool:
        """
        :returns:
        true if the point has coordinates which indicate it is a
        disconnect (separator) ponit.
        """
        ...
    
    def IsEqual(*args, **kwargs):
        """
        Overloaded function.
        
        1. IsEqual(self: MSPyBentleyGeom.DVec2d, vector2: MSPyBentleyGeom.DVec2d) -> bool
        
        Test for exact equality between all components of two
        vectors.
        
        :param (input):
        vector2 The second vector
        
        :returns:
        true if the vectors are identical.
        
        2. IsEqual(self: MSPyBentleyGeom.DVec2d, vector2: MSPyBentleyGeom.DVec2d, tolerance: float) -> bool
        
        Test for exact equality between all components of two
        vectors.
        
        :param (input):
        vector2 The second vector
        
        :returns:
        true if the vectors are identical.
        """
        ...
    
    def IsParallelTo(self: MSPyBentleyGeom.DVec2d, vector2: MSPyBentleyGeom.DVec2d) -> bool:
        """
        Tests if two vectors are parallel.
        
        :param (input):
        vector2 The second vector
        
        :returns:
        true if the vectors are parallel within tolerance
        """
        ...
    
    def IsPerpendicularTo(self: MSPyBentleyGeom.DVec2d, vector2: MSPyBentleyGeom.DVec2d) -> bool:
        """
        Tests if two vectors are perpendicular.
        
        :param (input):
        vector2 The second vector
        
        :returns:
        true if vectors are perpendicular within tolerance
        """
        ...
    
    def IsVectorInCCWSector(self: MSPyBentleyGeom.DVec2d, vector0: MSPyBentleyGeom.DVec2d, vector1: MSPyBentleyGeom.DVec2d) -> bool:
        """
        test if the instance is " between " vector0 and vector1
        when vector0 is rotated counterclockwise towards vector1.
        
        :param (input):
        vector0 start vector for CCW sweep.
        
        :param (input):
        vector1 end vector for CCW sweep.
        """
        ...
    
    def IsVectorInSmallerSector(self: MSPyBentleyGeom.DVec2d, vector0: MSPyBentleyGeom.DVec2d, vector1: MSPyBentleyGeom.DVec2d) -> bool:
        """
        Test a vector is " between " vector0 and vector1. If the
        vectors are coplanar and vector0 is neither parallel nor antiparallel
        to vector1, betweenness has the expected meaning:there are two angles
        between vector0 and vector1; one is less than 180; the test vector is
        tested to see if it is in the smaller angle. If the vectors are not
        coplanar, the test is based on the projection of the test vector into
        the plane of the other two vectors.
        
        Zero testing is untoleranced, and is biased to all parallel conditions
        " false ". That is, if any pair of the input vectors is parallel or
        antiparallel, the mathematical answer is false. Floating point
        tolerances will cause " nearby " cases to be unpredictable. It is
        assumed that if the caller considers the " parallel " cases important
        they will be checked explicitly.
        
        :param (input):
        vector0 The first boundary vector.
        
        :param (input):
        vector1 The second boundary vector.
        
        :returns:
        true if the test vector is within the angle.
        """
        ...
    
    def Magnitude(self: MSPyBentleyGeom.DVec2d) -> float:
        """
        Computes the magnitude of a vector.
        
        :returns:
        The length of the vector
        """
        ...
    
    def MagnitudeSquared(self: MSPyBentleyGeom.DVec2d) -> float:
        """
        Computes the squared magnitude of a vector.
        
        :returns:
        The squared magnitude of the vector.
        """
        ...
    
    def MaxAbs(self: MSPyBentleyGeom.DVec2d) -> float:
        """
        Finds the largest absolute value among the components of
        a vector.
        
        :returns:
        The largest absolute value among vector coordinates.
        """
        ...
    
    def Negate(*args, **kwargs):
        """
        Overloaded function.
        
        1. Negate(self: MSPyBentleyGeom.DVec2d, vector: MSPyBentleyGeom.DVec2d) -> None
        
        Computes a negated (opposite) vector.
        
        :param (input):
        vector The vector to be negated.
        
        2. Negate(self: MSPyBentleyGeom.DVec2d) -> None
        
        Computes a negated (opposite) vector.
        
        :param (input):
        vector The vector to be negated.
        """
        ...
    
    def Normalize(*args, **kwargs):
        """
        Overloaded function.
        
        1. Normalize(self: MSPyBentleyGeom.DVec2d, vector: MSPyBentleyGeom.DVec2d) -> float
        
        Normalizes (scales) a vector to length 1.
        
        Remark:
        In the 0-length error case, the vector is set to (1,0) in the
        legacy microstation style.
        
        :param (input):
        vector The vector to be normalized.
        
        :returns:
        The length prior to normalization
        
        2. Normalize(self: MSPyBentleyGeom.DVec2d) -> float
        
        Normalizes (scales) a vector to length 1.
        
        Remark:
        In the 0-length error case, the vector is set to (1,0) in the
        legacy microstation style.
        
        :param (input):
        vector The vector to be normalized.
        
        :returns:
        The length prior to normalization
        """
        ...
    
    def NormalizedDifference(self: MSPyBentleyGeom.DVec2d, target: MSPyBentleyGeom.DPoint2d, origin: MSPyBentleyGeom.DPoint2d) -> float:
        """
        Computes a unit vector in the direction of the difference
        of the vectors or vectors (Second parameter vector is subtracted from
        the first parameter vector, exactly as in the subtract function.)
        
        Remark:
        In the 0-length error case, the vector is set to (1,0) in the
        legacy microstation style.
        
        :param (input):
        target The target point.
        
        :param (input):
        origin The origin point.
        
        :returns:
        The length of original difference vector.
        """
        ...
    
    def NormalizedDifferenceOf(self: MSPyBentleyGeom.DPoint2d, point1: MSPyBentleyGeom.DPoint2d, point2: MSPyBentleyGeom.DPoint2d) -> float:
        """
        Sets pNormal to the unit vector in the direction of point1 point2
        
        :param (input):
        point1 point 1
        
        :param (input):
        point2 point 2
        
        :returns:
        double distance between input points
        """
        ...
    
    def One(self: MSPyBentleyGeom.DVec2d) -> None:
        """
        Returns a vector with all components 1.0.
        """
        ...
    
    def Rotate90(self: MSPyBentleyGeom.DPoint2d, vec: MSPyBentleyGeom.DPoint2d) -> None:
        """
        :param (input):
        vec original vector
        """
        ...
    
    def RotateCCW(*args, **kwargs):
        """
        Overloaded function.
        
        1. RotateCCW(self: MSPyBentleyGeom.DVec2d, vector: MSPyBentleyGeom.DVec2d, theta: float) -> None
        
        Rotate a vector COUNTERCLOCKWISE around the z axis.
        
        :param (input):
        vector vector to rotate.
        
        :param (input):
        theta The rotation angle.
        
        2. RotateCCW(self: MSPyBentleyGeom.DVec2d, theta: float) -> None
        
        Rotate a vector COUNTERCLOCKWISE around the z axis.
        
        :param (input):
        vector vector to rotate.
        
        :param (input):
        theta The rotation angle.
        """
        ...
    
    def SafeDivide(self: MSPyBentleyGeom.DVec2d, vector: MSPyBentleyGeom.DVec2d, denominator: float) -> bool:
        """
        Try to divide each component of a vector by a scalar. If
        the denominator near zero compared to any numerator component, return
        the original vector.
        
        :param (input):
        vector The initial vector.
        
        :param (input):
        denominator The divisor.
        
        :returns:
        true if division is numerically safe.
        """
        ...
    
    def Scale(*args, **kwargs):
        """
        Overloaded function.
        
        1. Scale(self: MSPyBentleyGeom.DVec2d, vector: MSPyBentleyGeom.DVec2d, scale: float) -> None
        
        Multiplies a vector by a scale factor.
        
        :param (input):
        vector The vector to be scaled.
        
        :param (input):
        scale The scale factor.
        
        2. Scale(self: MSPyBentleyGeom.DVec2d, scale: float) -> None
        
        Multiplies a vector by a scale factor.
        
        :param (input):
        vector The vector to be scaled.
        
        :param (input):
        scale The scale factor.
        """
        ...
    
    def ScaleToLength(*args, **kwargs):
        """
        Overloaded function.
        
        1. ScaleToLength(self: MSPyBentleyGeom.DVec2d, vector: MSPyBentleyGeom.DVec2d, length: float) -> float
        
        Scales a vector to specified length.
        
        Remark:
        In the 0-length error case, the vector is set to (1,0) in the
        legacy microstation style.
        
        :param (input):
        vector The original vector.
        
        :param (input):
        length The requested length.
        
        :returns:
        The length prior to scaling.
        
        2. ScaleToLength(self: MSPyBentleyGeom.DVec2d, length: float) -> float
        
        Scales a vector to specified length.
        
        Remark:
        In the 0-length error case, the vector is set to (1,0) in the
        legacy microstation style.
        
        :param (input):
        vector The original vector.
        
        :param (input):
        length The requested length.
        
        :returns:
        The length prior to scaling.
        """
        ...
    
    def SetComponent(self: MSPyBentleyGeom.DVec2d, a: float, index: int) -> None:
        """
        Set one of three components (x,y) of the vector.
        
        :param (input):
        a The component value.
        
        :param (input):
        index Selects the the axis:0=x, 1=y
        """
        ...
    
    def SmallerUnorientedAngleTo(self: MSPyBentleyGeom.DVec2d, vector2: MSPyBentleyGeom.DVec2d) -> float:
        """
        Returns the angle between two vectors, choosing the
        smaller of the two possible angles when both the vectors and their
        negations are considered. This angle is between 0 and pi/2.
        
        :param (input):
        vector2 The second vector
        
        :returns:
        The angle between the vectors.
        """
        ...
    
    def Subtract(self: MSPyBentleyGeom.DVec2d, vector2: MSPyBentleyGeom.DVec2d) -> None:
        """
        Subtract two vectors, and return the result in place of
        the first.
        
        :param (input):
        vector2 The vector to subtract.
        """
        ...
    
    def SumOf(*args, **kwargs):
        """
        Overloaded function.
        
        1. SumOf(self: MSPyBentleyGeom.DVec2d, vector1: MSPyBentleyGeom.DVec2d, vector2: MSPyBentleyGeom.DVec2d) -> None
        
        Compute the sum of two vectors or vectors.
        
        :param (input):
        vector1 The the first vector
        
        :param (input):
        vector2 The second vector
        
        2. SumOf(self: MSPyBentleyGeom.DVec2d, vector1: MSPyBentleyGeom.DVec2d, vector2: MSPyBentleyGeom.DVec2d, scale: float) -> None
        
        Compute the sum of two vectors or vectors.
        
        :param (input):
        vector1 The the first vector
        
        :param (input):
        vector2 The second vector
        
        3. SumOf(self: MSPyBentleyGeom.DVec2d, origin: MSPyBentleyGeom.DVec2d, vector1: MSPyBentleyGeom.DVec2d, scale1: float, vector2: MSPyBentleyGeom.DVec2d, scale2: float) -> None
        
        Compute the sum of two vectors or vectors.
        
        :param (input):
        vector1 The the first vector
        
        :param (input):
        vector2 The second vector
        
        4. SumOf(self: MSPyBentleyGeom.DVec2d, origin: MSPyBentleyGeom.DVec2d, vector1: MSPyBentleyGeom.DVec2d, scale1: float, vector2: MSPyBentleyGeom.DVec2d, scale2: float, vector3: MSPyBentleyGeom.DVec2d, scale3: float) -> None
        
        Compute the sum of two vectors or vectors.
        
        :param (input):
        vector1 The the first vector
        
        :param (input):
        vector2 The second vector
        """
        ...
    
    def Swap(self: MSPyBentleyGeom.DPoint2d, other: MSPyBentleyGeom.DPoint2d) -> None:
        """
        Swap contents of instance, other.
        
        :param [in,out]:
        other second point.
        """
        ...
    
    def UnitPerpendicular(self: MSPyBentleyGeom.DVec2d, vector: MSPyBentleyGeom.DVec2d) -> bool:
        """
        Compute a unit vector perpendicular given vector.
        
        Remark:
        s Input may equal output.
        
        :param (input):
        vector The source vector
        
        :returns:
        true if the input vector has nonzero length
        """
        ...
    
    @property
    def X(self: MSPyBentleyGeom.DPoint2d) -> float:
        ...
    @X.setter
    def X(self: MSPyBentleyGeom.DPoint2d, arg0: float) -> None:
        ...
    
    def XyOf(self: MSPyBentleyGeom.DVec2d, hPoint: MSPyBentleyGeom.DPoint4d) -> None:
        """
        Sets the x,y, and z components of a DVec2d structure from
        the corresponding parts of a DPoint4d. Weight part of DPoint4d is not
        used.
        
        :param (input):
        hPoint The homogeneous point
        """
        ...
    
    @property
    def Y(self: MSPyBentleyGeom.DPoint2d) -> float:
        ...
    @Y.setter
    def Y(self: MSPyBentleyGeom.DPoint2d, arg0: float) -> None:
        ...
    
    def Zero(self: MSPyBentleyGeom.DVec2d) -> None:
        """
        Sets all components of a vector to zero.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DVec2d) -> None
        
        2. __init__(self: MSPyBentleyGeom.DVec2d, x: float, y: float) -> None
        
        3. __init__(self: MSPyBentleyGeom.DVec2d, point: MSPyBentleyGeom.DPoint2d) -> None
        
        4. __init__(self: MSPyBentleyGeom.DVec2d, start: MSPyBentleyGeom.DPoint2d, end: MSPyBentleyGeom.DPoint2d) -> None
        
        5. __init__(self: MSPyBentleyGeom.DVec2d, vector: MSPyBentleyGeom.DVec2d, scale: float) -> None
        """
        ...
    
    @property
    def x(self: MSPyBentleyGeom.DPoint2d) -> float:
        ...
    @x.setter
    def x(self: MSPyBentleyGeom.DPoint2d, arg0: float) -> None:
        ...
    
    @property
    def y(self: MSPyBentleyGeom.DPoint2d) -> float:
        ...
    @y.setter
    def y(self: MSPyBentleyGeom.DPoint2d, arg0: float) -> None:
        ...
    
class DVec2dArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DVec2dArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.DVec2dArray, arg0: MSPyBentleyGeom.DVec2dArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.DVec2dArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.DVec2dArray, x: MSPyBentleyGeom.DVec2d) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.DVec2dArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def count(self: MSPyBentleyGeom.DVec2dArray, x: MSPyBentleyGeom.DVec2d) -> int:
        """
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.DVec2dArray, L: MSPyBentleyGeom.DVec2dArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.DVec2dArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.DVec2dArray, i: int, x: MSPyBentleyGeom.DVec2d) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.DVec2dArray) -> MSPyBentleyGeom.DVec2d
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.DVec2dArray, i: int) -> MSPyBentleyGeom.DVec2d
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(self: MSPyBentleyGeom.DVec2dArray, x: MSPyBentleyGeom.DVec2d) -> None:
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class DVec3d:
    """
    None
    """

    def Add(self: MSPyBentleyGeom.DVec3d, vector: MSPyBentleyGeom.DVec3d) -> None:
        """
        Adds a vector to a pointer or vector, returns the result
        in place.
        
        :param (input):
        vector The vector to add.
        """
        ...
    
    def AddToArray(*args, **kwargs):
        """
        Overloaded function.
        
        1. AddToArray(points: MSPyBentleyGeom.DPoint3dArray, delta: MSPyBentleyGeom.DPoint3d) -> None
        
        Add translation to all points.
        
        2. AddToArray(points: list, delta: MSPyBentleyGeom.DPoint3d) -> None
        
        Add translation to all points.
        """
        ...
    
    def AlmostEqual(self: MSPyBentleyGeom.DVec3d, dataB: MSPyBentleyGeom.DVec3d) -> bool:
        """
        test if two points are equal. Uses library " small angle " as both
        absolute and relative tolerance. points are equal if squared distance
        between is less than (squared abstol) plus (squared relTol) * sum of
        cmponent squares
        
        :param (input):
        dataB second DVec3d
        
        :returns:
        true if within tolerance.
        """
        ...
    
    def AlmostEqualXY(*args, **kwargs):
        """
        Overloaded function.
        
        1. AlmostEqualXY(self: MSPyBentleyGeom.DPoint3d, dataB: MSPyBentleyGeom.DPoint3d) -> bool
        
        test if two points are equal. Uses library " small angle " as both
        absolute and relative tolerance. points are equal if squared distance
        between is less than (squared abstol) plus (squared relTol) * sum of
        cmponent squares
        
        :param (input):
        dataB second DPoint3d
        
        :returns:
        true if within tolerance.
        
        2. AlmostEqualXY(self: MSPyBentleyGeom.DPoint3d, dataB: MSPyBentleyGeom.DPoint3d, abstol: float) -> bool
        
        test if two points are equal. Uses library " small angle " as both
        absolute and relative tolerance. points are equal if squared distance
        between is less than (squared abstol) plus (squared relTol) * sum of
        cmponent squares
        
        :param (input):
        dataB second DPoint3d
        
        :returns:
        true if within tolerance.
        """
        ...
    
    def AngleAndAxisOfRotationFromVectorToVector(self: MSPyBentleyGeom.DVec3d, target: MSPyBentleyGeom.DVec3d, axis: MSPyBentleyGeom.DVec3d) -> tuple:
        """
        Compute an axis and angle to rotate from the instance vector to a
        target.
        
        :param (output):
        target direction that the instance is to rotate towards.
        
        :param (output):
        axis returned axis of rotation
        
        :param (output):
        radians returned rotation angle
        
        :returns:
        true if both vectors are nonzero.
        """
        ...
    
    def AngleFromPerpendicular(self: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d) -> float:
        """
        Returns the angle that two vectors deviate from being
        perpendicular.
        """
        ...
    
    def AngleTo(self: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d) -> float:
        """
        Returns the angle between two vectors. This angle is
        between 0 and pi. Rotating the first vector by this angle around the
        cross product between the vectors aligns it with the second vector.
        
        :param (input):
        vector2 The second vector
        
        :returns:
        The angle between the vectors.
        """
        ...
    
    def AngleToXY(self: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d) -> float:
        """
        Returns the angle from Vector1 to Vector2 using only xy
        parts. This angle is between -pi and +pi.
        
        :param (input):
        vector2 The second vector
        
        :returns:
        The angle between vectors.
        """
        ...
    
    def AngleXY(self: MSPyBentleyGeom.DPoint3d) -> float:
        """
        @description Computes the (signed) angle from xy axis to the vector,
        using only xy parts.
        """
        ...
    
    def ComponentRange(self: MSPyBentleyGeom.DPoint3d) -> DRange1d:
        """
        :returns:
        min and max of componetns.
        """
        ...
    
    def CrossProduct(*args, **kwargs):
        """
        Overloaded function.
        
        1. CrossProduct(self: MSPyBentleyGeom.DVec3d, vector1: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d) -> None
        
        Returns the (vector) cross product of two vectors.
        
        :param (input):
        vector1 The first vector
        
        :param (input):
        vector2 The second vector
        
        2. CrossProduct(self: MSPyBentleyGeom.DVec3d, vector1: MSPyBentleyGeom.DVec3d, point2: MSPyBentleyGeom.DPoint3d) -> None
        
        Returns the (vector) cross product of two vectors.
        
        :param (input):
        vector1 The first vector
        
        :param (input):
        vector2 The second vector
        
        3. CrossProduct(self: MSPyBentleyGeom.DVec3d, point1: MSPyBentleyGeom.DPoint3d, vector2: MSPyBentleyGeom.DVec3d) -> None
        
        Returns the (vector) cross product of two vectors.
        
        :param (input):
        vector1 The first vector
        
        :param (input):
        vector2 The second vector
        """
        ...
    
    def CrossProductMagnitude(self: MSPyBentleyGeom.DVec3d, other: MSPyBentleyGeom.DVec3d) -> float:
        """
        Compute the cross product with other and return is magnitude (but the
        cross product is not returned)
        
        :param (input):
        other second vector of cross product
        """
        ...
    
    def CrossProductToPoints(self: MSPyBentleyGeom.DVec3d, origin: MSPyBentleyGeom.DPoint3d, target1: MSPyBentleyGeom.DPoint3d, arget2: MSPyBentleyGeom.DPoint3d) -> None:
        """
        Sets the instance to the (vector) cross product of two
        vectors. The vectors are computed from the Origin to Target1 and
        Target2.
        
        :param (input):
        origin The base point for computing vectors.
        
        :param (input):
        target1 The target point for the first vector.
        
        :param (input):
        target2 The target point for the second vector.
        """
        ...
    
    def CrossProductToPointsXY(self: MSPyBentleyGeom.DPoint3d, target1: MSPyBentleyGeom.DPoint3d, target2: MSPyBentleyGeom.DPoint3d) -> float:
        """
        @description Returns the (scalar) cross product of the xy parts of two
        vectors. The vectors are computed from the Origin to target1 and
        target2.
        
        :param (input):
        target1 The target point for the first vector.
        
        :param (input):
        target2 The target point for the second vector.
        """
        ...
    
    def CrossProductXY(self: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d) -> float:
        """
        Return the (scalar) cross product of the xy parts of two
        vectors.
        
        :param (input):
        vector2 The second vector
        
        :returns:
        The 2d cross product.
        """
        ...
    
    def DifferenceOf(*args, **kwargs):
        """
        Overloaded function.
        
        1. DifferenceOf(self: MSPyBentleyGeom.DVec3d, vector1: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d) -> None
        
        Subtract coordinates of two vectors. (Compute Vector1 -
        Vector2)
        
        :param (input):
        vector1 The first vector
        
        :param (input):
        vector2 The second (subtracted) vector
        
        2. DifferenceOf(self: MSPyBentleyGeom.DVec3d, target: MSPyBentleyGeom.DPoint3d, base: MSPyBentleyGeom.DPoint3d) -> None
        
        Subtract coordinates of two vectors. (Compute Vector1 -
        Vector2)
        
        :param (input):
        vector1 The first vector
        
        :param (input):
        vector2 The second (subtracted) vector
        """
        ...
    
    def Distance(self: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d) -> float:
        """
        Computes the (cartesian) distance between two vectors
        
        :param (input):
        vector2 The second vector
        
        :returns:
        The distance between vector.
        """
        ...
    
    def DistanceSquared(self: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d) -> float:
        """
        Computes the squared distance between two vectors.
        
        :param (input):
        vector2 The second vector.
        
        :returns:
        The squared distance between the vectors.
        """
        ...
    
    def DistanceSquaredXY(self: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d) -> float:
        """
        Computes the squared distance between two vectors, using
        only the xy parts.
        
        :param (input):
        vector2 The second vector
        
        :returns:
        The squared distance between the XY projections of the two
        vectors. (i.e. any z difference is ignored)
        """
        ...
    
    def DistanceXY(self: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d) -> float:
        """
        Computes the distance between two vectors, using only x
        and y components.
        
        :param (input):
        vector2 The second vector
        
        :returns:
        The distance between the XY projections of the two vectors. (i.e.
        any z difference is ignored)
        """
        ...
    
    def DivideArrayByScales(*args, **kwargs):
        """
        Overloaded function.
        
        1. DivideArrayByScales(outPoints: MSPyBentleyGeom.DPoint3dArray, inPoints: MSPyBentleyGeom.DPoint3dArray, scales: MSPyBentleyGeom.DoubleArray) -> None
        
        @description Divide each point in an array by its corresponding scale
        factor. Leave any point with near zero weight unchanged.
        
        :param (output):
        pDest destination array.
        
        :param (input):
        pSource source array.
        
        :param (input):
        pScales scale factors
        
        :param (input):
        n number of points.
        
        2. DivideArrayByScales(outPoints: list, inPoints: list, scales: MSPyBentleyGeom.DoubleArray) -> None
        
        @description Divide each point in an array by its corresponding scale
        factor. Leave any point with near zero weight unchanged.
        
        :param (output):
        pDest destination array.
        
        :param (input):
        pSource source array.
        
        :param (input):
        pScales scale factors
        
        :param (input):
        n number of points.
        """
        ...
    
    def DotDifference(self: MSPyBentleyGeom.DPoint3d, origin: MSPyBentleyGeom.DPoint3d, vector: DVec3d) -> float:
        """
        @description Returns the (scalar) dot product of a two vectors. One
        vector is computed internally as the difference of the TargetPoint and
        Origin. (TargetPoint-Origin) The other is given directly as a single
        argument.
        
        :param (input):
        origin The start (orign) point of the first vector of the cross
        product.
        
        :param (input):
        vector The second
        """
        ...
    
    def DotProduct(*args, **kwargs):
        """
        Overloaded function.
        
        1. DotProduct(self: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d) -> float
        
        Returns the (scalar) dot product of two vectors.
        
        :param (input):
        vector2 The second vector
        
        :returns:
        The dot product of the two vectors
        
        2. DotProduct(self: MSPyBentleyGeom.DVec3d, az: float, ay: float, az: float) -> float
        
        Returns the (scalar) dot product of two vectors.
        
        :param (input):
        vector2 The second vector
        
        :returns:
        The dot product of the two vectors
        
        3. DotProduct(self: MSPyBentleyGeom.DVec3d, point2: MSPyBentleyGeom.DPoint3d) -> float
        
        Returns the (scalar) dot product of two vectors.
        
        :param (input):
        vector2 The second vector
        
        :returns:
        The dot product of the two vectors
        """
        ...
    
    def DotProductColumn(self: MSPyBentleyGeom.DVec3d, matrix: RotMatrix, index: int) -> float:
        """
        Returns the (scalar) dot product of this vector and a
        column of a matrix.
        
        :param (input):
        matrix
        
        :param (input):
        index column index.
        
        :returns:
        The dot product of the two vectors
        """
        ...
    
    def DotProductMatrixColumn(self: MSPyBentleyGeom.DVec3d, matrix: Transform, index: int) -> float:
        """
        Returns the (scalar) dot product of this vector and a column of the
        matrix part of the transform.
        
        :param (input):
        matrix
        
        :param (input):
        index column index.
        
        :returns:
        The dot product of the two vectors
        """
        ...
    
    def DotProductMatrixRow(self: MSPyBentleyGeom.DVec3d, matrix: Transform, index: int) -> float:
        """
        Returns the (scalar) dot product of this vector and a row of the
        matrix part of the transform.
        
        :param (input):
        matrix
        
        :param (input):
        index row index.
        
        :returns:
        The dot product of the two vectors
        """
        ...
    
    def DotProductRow(self: MSPyBentleyGeom.DVec3d, matrix: RotMatrix, index: int) -> float:
        """
        Returns the (scalar) dot product of this vector and a row of a matrix.
        
        :param (input):
        matrix
        
        :param (input):
        index row index.
        
        :returns:
        The dot product of the two vectors
        """
        ...
    
    def DotProductToPoints(self: MSPyBentleyGeom.DPoint3d, target1: MSPyBentleyGeom.DPoint3d, target2: MSPyBentleyGeom.DPoint3d) -> float:
        """
        @description Returns the (scalar) dot product of two vectors. The
        vectors are computed from the Origin to target1 and target2.
        
        :param (input):
        target1 The target point for the first vector.
        
        :param (input):
        target2 The target point for the second vector.
        """
        ...
    
    def DotProductToPointsXY(self: MSPyBentleyGeom.DPoint3d, target1: MSPyBentleyGeom.DPoint3d, target2: MSPyBentleyGeom.DPoint3d) -> float:
        """
        @description Returns the (scalar) dot product of xy parts of two
        vectors. The vectors are computed from the BasePoint to target1 and
        target2.
        
        :param (input):
        target1 The target point for the first vector.
        
        :param (input):
        target2 The target point for the second vector.
        """
        ...
    
    def DotProductXY(self: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d) -> float:
        """
        Returns the (scalar) dot product of xy parts of two
        vectors.
        
        :param (input):
        vector2 The second vector
        
        :returns:
        The dot product of the xy parts of the two vectors
        """
        ...
    
    @staticmethod
    def From(*args, **kwargs):
        """
        Overloaded function.
        
        1. From(point: MSPyBentleyGeom.DPoint3d) -> MSPyBentleyGeom.DVec3d
        
        2. From(vector: MSPyBentleyGeom.DVec2d) -> MSPyBentleyGeom.DVec3d
        
        3. From(az: float, ay: float, az: float = 0.0) -> MSPyBentleyGeom.DVec3d
        """
        ...
    
    @staticmethod
    def FromCCWPerpendicularXY(source: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.DVec3d:
        """
        return a vector same length as source but rotate 90
        degrees CCW
        """
        ...
    
    @staticmethod
    def FromColumn(matrix: RotMatrix, i: int) -> MSPyBentleyGeom.DVec3d:
        """
        return a (cyclically indexed) column of the matrix.
        
        :param (input):
        matrix source
        
        :param (input):
        i column index
        """
        ...
    
    @staticmethod
    def FromColumnCrossProduct(matrix: RotMatrix, i: int, j: int) -> MSPyBentleyGeom.DVec3d:
        """
        return the cross product of vectors found in columns a
        matrix
        
        :param (input):
        matrix source transform
        
        :param (input):
        i first column index
        
        :param (input):
        j second column index
        """
        ...
    
    @staticmethod
    def FromCrossProduct(*args, **kwargs):
        """
        Overloaded function.
        
        1. FromCrossProduct(vector0: MSPyBentleyGeom.DVec3d, vector1: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.DVec3d
        
        return the cross product of vectors
        
        :param (input):
        vector0 first vector
        
        :param (input):
        vector1 second vector
        
        2. FromCrossProduct(x0: float, y0: float, z0: float, x1: float, y1: float, z1: float) -> MSPyBentleyGeom.DVec3d
        
        return the cross product of vectors
        
        :param (input):
        vector0 first vector
        
        :param (input):
        vector1 second vector
        """
        ...
    
    @staticmethod
    def FromCrossProductToPoints(origin: MSPyBentleyGeom.DPoint3d, target1: MSPyBentleyGeom.DPoint3d, arget2: MSPyBentleyGeom.DPoint3d) -> MSPyBentleyGeom.DVec3d:
        """
        Returns the (vector) cross product of two vectors. The
        vectors are computed from the Origin to Target1 and Target2.
        
        :param (input):
        origin The base point for computing vectors.
        
        :param (input):
        target1 The target point for the first vector.
        
        :param (input):
        target2 The target point for the second vector.
        """
        ...
    
    @staticmethod
    def FromInterpolate(vector0: MSPyBentleyGeom.DVec3d, fraction: float, vector1: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.DVec3d:
        """
        Returns an interpolated vector.
        
        :param (input):
        vector0 vector at fraction 0
        
        :param (input):
        fraction fraction from interpolation.
        
        :param (input):
        vector1 vector at fraction 1
        """
        ...
    
    def FromInterpolateAndPerpendicularXY(pointA: MSPyBentleyGeom.DPoint3d, fraction: float, pointB: MSPyBentleyGeom.DPoint3d, fractionXYPerp: float) -> MSPyBentleyGeom.DPoint3d:
        """
        interpolate between points. Then add a shift in the xy plane by a
        fraction of the XY projection perpendicular
        
        :param (input):
        pointA start point
        
        :param (input):
        fraction fractional parameter along the line from A to B
        
        :param (input):
        pointB end point
        
        :param (input):
        fractionXYPerp fractional parameter applied to vector that is the
        XY parts of (B-A), rotated CCW in plane.
        """
        ...
    
    @staticmethod
    def FromInterpolateBilinear(vector00: MSPyBentleyGeom.DVec3d, vector10: MSPyBentleyGeom.DVec3d, vector01: MSPyBentleyGeom.DVec3d, vector11: MSPyBentleyGeom.DVec3d, u: float, v: float) -> MSPyBentleyGeom.DVec3d:
        """
        Returns a bilinear interpolation from corners
        (00)(10)(01)(11)
        
        :param (input):
        vector00 vector at (0,0)
        
        :param (input):
        vector10 vector at (1,0)
        
        :param (input):
        vector01 vector at (0,1)
        
        :param (input):
        vector11 vector at (1,1)
        
        :param (input):
        u interpolation fraction for edges (vector00,vector10) and
        (vector01,vector11)
        
        :param (input):
        v interpolation fraction for edges (vector00,vector10) and
        (vector10,vector11)
        """
        ...
    
    @staticmethod
    def FromMatrixColumn(transform: Transform, i: int) -> MSPyBentleyGeom.DVec3d:
        """
        return a (cyclically indexed) column of the matrix part
        of a transform.
        
        :param (input):
        transform source transform
        
        :param (input):
        i column index
        """
        ...
    
    @staticmethod
    def FromMatrixColumnCrossProduct(transform: Transform, i: int, j: int) -> MSPyBentleyGeom.DVec3d:
        """
        return the cross product of vectors found in columns of
        (the matrix part of) a transform.
        
        :param (input):
        transform source transform
        
        :param (input):
        i first column index
        
        :param (input):
        j second column index
        """
        ...
    
    @staticmethod
    def FromMatrixRow(transform: Transform, i: int) -> MSPyBentleyGeom.DVec3d:
        """
        return a (cyclically indexed) row of the matrix part of a
        transform.
        
        :param (input):
        transform source transform
        
        :param (input):
        i row index
        """
        ...
    
    @staticmethod
    def FromNormalizedCrossProduct(vector0: MSPyBentleyGeom.DVec3d, vector1: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.DVec3d:
        """
        return the normalized cross product of vectors
        
        :param (input):
        vector0 first vector
        
        :param (input):
        vector1 second vector
        """
        ...
    
    @staticmethod
    def FromNormalizedCrossProductToPoints(origin: MSPyBentleyGeom.DPoint3d, target1: MSPyBentleyGeom.DPoint3d, arget2: MSPyBentleyGeom.DPoint3d) -> MSPyBentleyGeom.DVec3d:
        """
        Returns the (normalized vector) cross product of two
        vectors. The vectors are computed from the Origin to Target1 and
        Target2. If the cross product is zero, a zero vector is returned.
        
        :param (input):
        origin The base point for computing vectors.
        
        :param (input):
        target1 The target point for the first vector.
        
        :param (input):
        target2 The target point for the second vector.
        """
        ...
    
    def FromOne() -> MSPyBentleyGeom.DPoint3d:
        """
        Return a DPoint3d with xyz = 1.
        """
        ...
    
    def FromProduct(*args, **kwargs):
        """
        Overloaded function.
        
        1. FromProduct(transform: Transform, x: float, y: float, z: float) -> MSPyBentleyGeom.DPoint3d
        
        return product of transform times point given as components.
        
        :param (input):
        transform affine transform.
        
        :param (input):
        x x component
        
        :param (input):
        y y component
        
        :param (input):
        z z component
        
        2. FromProduct(transform: Transform, point: MSPyBentleyGeom.DPoint3d) -> MSPyBentleyGeom.DPoint3d
        
        return product of transform times point given as components.
        
        :param (input):
        transform affine transform.
        
        :param (input):
        x x component
        
        :param (input):
        y y component
        
        :param (input):
        z z component
        
        3. FromProduct(point: MSPyBentleyGeom.DPoint3d, matrix: RotMatrix, x: float, y: float, z: float) -> MSPyBentleyGeom.DPoint3d
        
        return product of transform times point given as components.
        
        :param (input):
        transform affine transform.
        
        :param (input):
        x x component
        
        :param (input):
        y y component
        
        :param (input):
        z z component
        
        4. FromProduct(point: MSPyBentleyGeom.DPoint3d, matrix: RotMatrix, vector: DVec3d) -> MSPyBentleyGeom.DPoint3d
        
        return product of transform times point given as components.
        
        :param (input):
        transform affine transform.
        
        :param (input):
        x x component
        
        :param (input):
        y y component
        
        :param (input):
        z z component
        """
        ...
    
    @staticmethod
    def FromRotate90Around(source: MSPyBentleyGeom.DVec3d, target: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.DVec3d:
        """
        return a vector same length as source but rotate 90
        degrees around axis
        """
        ...
    
    @staticmethod
    def FromRotate90Towards(source: MSPyBentleyGeom.DVec3d, target: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.DVec3d:
        """
        return a vector same length as source but rotate 90
        degrees towards target
        """
        ...
    
    @staticmethod
    def FromRotateVectorAroundVector(source: MSPyBentleyGeom.DVec3d, axis: MSPyBentleyGeom.DVec3d, angle: MSPyBentleyGeom.Angle) -> MSPyBentleyGeom.ValidatedDVec3d:
        """
        return a vector same length as source but rotated by
        angle around axis. (Rodriguez formula)
        """
        ...
    
    @staticmethod
    def FromRow(matrix: RotMatrix, i: int) -> MSPyBentleyGeom.DVec3d:
        """
        return a (cyclically indexed) row of the matrix.
        
        :param (input):
        matrix source
        
        :param (input):
        i row index
        """
        ...
    
    @staticmethod
    def FromScale(vector: MSPyBentleyGeom.DVec3d, scale: float) -> MSPyBentleyGeom.DVec3d:
        """
        Returns a scalar multiple of a DVec3d
        
        :param (input):
        vector input vector
        
        :param (input):
        scale scale factor
        """
        ...
    
    @staticmethod
    def FromStartEnd(start: MSPyBentleyGeom.DPoint3d, end: MSPyBentleyGeom.DPoint3d) -> MSPyBentleyGeom.DVec3d:
        ...
    
    @staticmethod
    def FromStartEndNormalize(start: MSPyBentleyGeom.DPoint3d, end: MSPyBentleyGeom.DPoint3d) -> MSPyBentleyGeom.DVec3d:
        """
        Returns a vector from start towards end, normalized if
        nonzero.
        
        :param (input):
        start start point
        
        :param (input):
        end end point
        """
        ...
    
    def FromSumOf(*args, **kwargs):
        """
        Overloaded function.
        
        1. FromSumOf(origin: MSPyBentleyGeom.DPoint3d, vector: MSPyBentleyGeom.DPoint3d) -> MSPyBentleyGeom.DPoint3d
        
        Add a point and a vector.
        
        :param (input):
        origin start point
        
        :param (input):
        vector vector add
        
        2. FromSumOf(origin: MSPyBentleyGeom.DPoint3d, vector: MSPyBentleyGeom.DPoint3d, scaleFactor: float) -> MSPyBentleyGeom.DPoint3d
        
        Add a point and a vector.
        
        :param (input):
        origin start point
        
        :param (input):
        vector vector add
        
        3. FromSumOf(origin: MSPyBentleyGeom.DPoint3d, point0: MSPyBentleyGeom.DPoint3d, scaleFactor0: float, point1: MSPyBentleyGeom.DPoint3d, scaleFactor1: float) -> MSPyBentleyGeom.DPoint3d
        
        Add a point and a vector.
        
        :param (input):
        origin start point
        
        :param (input):
        vector vector add
        
        4. FromSumOf(origin: MSPyBentleyGeom.DPoint3d, point0: MSPyBentleyGeom.DPoint3d, scaleFactor0: float, point1: MSPyBentleyGeom.DPoint3d, scaleFactor1: float, point2: MSPyBentleyGeom.DPoint3d, scaleFactor2: float) -> MSPyBentleyGeom.DPoint3d
        
        Add a point and a vector.
        
        :param (input):
        origin start point
        
        :param (input):
        vector vector add
        
        5. FromSumOf(point0: MSPyBentleyGeom.DPoint3d, scale0: float, point1: MSPyBentleyGeom.DPoint3d, scale1: float) -> MSPyBentleyGeom.DPoint3d
        
        Add a point and a vector.
        
        :param (input):
        origin start point
        
        :param (input):
        vector vector add
        
        6. FromSumOf(point0: MSPyBentleyGeom.DPoint3d, scale0: float, point1: MSPyBentleyGeom.DPoint3d, scale1: float, point2: MSPyBentleyGeom.DPoint3d, scale2: float) -> MSPyBentleyGeom.DPoint3d
        
        Add a point and a vector.
        
        :param (input):
        origin start point
        
        :param (input):
        vector vector add
        """
        ...
    
    @staticmethod
    def FromTranslation(source: Transform) -> MSPyBentleyGeom.DVec3d:
        """
        return the translation xyz as a DVec3d (which you can
        pass as a DPoint3d where needed.)
        
        :param (input):
        source source transform
        """
        ...
    
    @staticmethod
    def FromUnitPerpendicularXY(vector: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.ValidatedDVec3d:
        """
        Compute a unit vector perpendicular to the xy parts of
        given vector.
        
        :param (input):
        vector The source vector
        
        :returns:
        perpendicular vector, marked invalid if unable to divide.
        """
        ...
    
    def FromWeightedAverage(*args, **kwargs):
        """
        Overloaded function.
        
        1. FromWeightedAverage(pointA: MSPyBentleyGeom.DPoint3d, weightA: float, pointB: MSPyBentleyGeom.DPoint3d, weightB: float) -> MSPyBentleyGeom.DPoint3d
        
        return the centroid for points with specified weights
        
        2. FromWeightedAverage(pointA: MSPyBentleyGeom.DPoint3d, weightA: float, pointB: MSPyBentleyGeom.DPoint3d, weightB: float, pointC: MSPyBentleyGeom.DPoint3d, weightC: float) -> MSPyBentleyGeom.DPoint3d
        
        return the centroid for points with specified weights
        """
        ...
    
    @staticmethod
    def FromXYAngleAndMagnitude(theta: float, magnitude: float) -> MSPyBentleyGeom.DVec3d:
        """
        Returns a DVec3d from given angle and distance in xy
        plane. Z part is set to zero.
        
        :param (input):
        theta Angle from X axis to the vector, in the xy plane.
        
        :param (input):
        magnitude Vector magnitude
        """
        ...
    
    def FromZero() -> MSPyBentleyGeom.DPoint3d:
        """
        Return a DPoint3d with xyz = 0.
        """
        ...
    
    def GeometricMeanCrossProduct(self: MSPyBentleyGeom.DVec3d, vector0: MSPyBentleyGeom.DVec3d, vector1: MSPyBentleyGeom.DVec3d) -> float:
        """
        Computes the cross product of two vectors and scales it
        to the geometric mean of the lengths of the two vectors. This is
        useful because it has the direction of the cross product (i.e. normal
        to the plane of the two vectors) and a size in between the two
        vectors.
        
        :param (input):
        vector1 The first vector
        
        :param (input):
        vector2 The second vector
        
        :returns:
        The The length of unscaled cross product.
        """
        ...
    
    def GetComponent(self: MSPyBentleyGeom.DVec3d, index: int) -> float:
        """
        Gets a single component of a vector. If the index is out
        of range 0,1,2, it is interpreted cyclically.
        
        :param (input):
        index Indicates which component is accessed. The values are 0=x,
        1=y, 2=z. Other values are treated cyclically.
        
        :returns:
        The specified component of the vector.
        """
        ...
    
    def GetComponents(self: MSPyBentleyGeom.DVec3d) -> tuple:
        ...
    
    def GetNormalizedTriad(self: MSPyBentleyGeom.DVec3d, xAxis: MSPyBentleyGeom.DVec3d, yAxis: MSPyBentleyGeom.DVec3d, zAxis: MSPyBentleyGeom.DVec3d) -> bool:
        """
        Sets three vectors so that they are mutually
        perpendicular unit vectors with the third (Z) vector in the direction
        of the given axis vector. If the given axis vector contains only
        zeros, a (0,0,1) vector is used instead.
        
        :param (output):
        xAxis unit x direction vector
        
        :param (output):
        yAxis unit y direction vector
        
        :param (output):
        zAxis unit z direction vector
        
        :returns:
        true unless given vector has zero length.
        """
        ...
    
    def GetPerpendicularParts(self: MSPyBentleyGeom.DVec3d, hypotenuse: MSPyBentleyGeom.DVec3d, parallelPart: MSPyBentleyGeom.DVec3d, perpendicularPart: MSPyBentleyGeom.DVec3d) -> tuple:
        """
        Decompose hypotenuse into a vector parallel to the instance and a
        vector perpendicular to the instance.
        
        :param (input):
        hypotenuse vector to decompose
        
        :param (output):
        fraction position where hypotenuse projects onto the instance.
        
        :param (output):
        parallelPart vector parallel to the instance
        
        :param (output):
        perpendicularPart vector perpendicular to the instance
        """
        ...
    
    def GetTriad(self: MSPyBentleyGeom.DVec3d, xAxis: MSPyBentleyGeom.DVec3d, yAxis: MSPyBentleyGeom.DVec3d, zAxis: MSPyBentleyGeom.DVec3d) -> bool:
        """
        Sets three vectors so that they are mutually
        perpendicular, the third (Z) vector is identical to the given axis
        vector, and all have the same length. If the given axis vector
        contains only zeros, a (0,0,1) vector is used instead.
        
        :param (output):
        xAxis x direction of the coordinate system
        
        :param (output):
        yAxis y direction of the coordinate system
        
        :param (output):
        zAxis z direction of the coordinate system
        
        :returns:
        true unless given vector is z zero vector.
        """
        ...
    
    def Init(*args, **kwargs):
        """
        Overloaded function.
        
        1. Init(self: MSPyBentleyGeom.DPoint3d, source: MSPyBentleyGeom.DPoint2d) -> None
        
        @description Copy from a 2d point setting z to zero.
        
        :param (input):
        source source point
        
        2. Init(self: MSPyBentleyGeom.DPoint3d, ax: float, ay: float, az: float) -> None
        
        @description Copy from a 2d point setting z to zero.
        
        :param (input):
        source source point
        
        3. Init(self: MSPyBentleyGeom.DPoint3d, ax: float, ay: float) -> None
        
        @description Copy from a 2d point setting z to zero.
        
        :param (input):
        source source point
        
        4. Init(self: MSPyBentleyGeom.DPoint3d, vector: DVec3d) -> None
        
        @description Copy from a 2d point setting z to zero.
        
        :param (input):
        source source point
        """
        ...
    
    def InitDisconnect(self: MSPyBentleyGeom.DPoint3d) -> None:
        """
        Initialize a point with all coordinates as the disconnect value.
        """
        ...
    
    def InitFromColumn(self: MSPyBentleyGeom.DVec3d, matrix: RotMatrix, col: int) -> None:
        ...
    
    def InitFromRow(self: MSPyBentleyGeom.DVec3d, matrix: RotMatrix, row: int) -> None:
        ...
    
    def InitFromXYAngleAndMagnitude(self: MSPyBentleyGeom.DVec3d, theta: float, magnitude: float) -> None:
        """
        Sets a vector from given angle and distance in xy plane. Z part is set to zero
        
        Parameter ``[in]``:
        theta Angle from X axis to the vector, in the xy plane
        
        Parameter ``[in]``:
        magnitude Vector magnitude
        """
        ...
    
    def Interpolate(self: MSPyBentleyGeom.DVec3d, vector0: MSPyBentleyGeom.DVec3d, fraction: float, vector1: MSPyBentleyGeom.DVec3d) -> None:
        """
        Computes a vector whose position is given by a fractional
        argument and two vectors.
        
        :param (input):
        vector0 The vector corresponding to fractionParameter of 0.
        
        :param (input):
        fractionParameter The fractional parametric coordinate. 0.0 is the
        start of the segment, 1.0 is the end, 0.5 is middle
        
        :param (input):
        vector1 The vector corresponding to fractionParameter of 1.
        """
        ...
    
    def IsDisconnect(self: MSPyBentleyGeom.DPoint3d) -> bool:
        """
        :returns:
        true if the point has coordinates which indicate it is a
        disconnect (separator) ponit.
        """
        ...
    
    def IsEqual(*args, **kwargs):
        """
        Overloaded function.
        
        1. IsEqual(self: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d) -> bool
        
        Test for exact equality between all components of two
        vectors.
        
        :param (input):
        vector2 The second vector
        
        :returns:
        true if the vectors are identical.
        
        2. IsEqual(self: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d, tolerance: float) -> bool
        
        Test for exact equality between all components of two
        vectors.
        
        :param (input):
        vector2 The second vector
        
        :returns:
        true if the vectors are identical.
        """
        ...
    
    def IsParallelTo(self: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d) -> bool:
        """
        Tests if two vectors are parallel (opposites are
        considered parallel!)
        
        :param (input):
        vector2 The second vector
        
        :returns:
        true if the vectors are parallel within tolerance
        """
        ...
    
    def IsPerpendicularTo(self: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d) -> bool:
        """
        Tests if two vectors are perpendicular.
        
        :param (input):
        vector2 The second vector
        
        :returns:
        true if vectors are perpendicular within tolerance
        """
        ...
    
    def IsPointInCCWector(self: MSPyBentleyGeom.DPoint3d, origin: MSPyBentleyGeom.DPoint3d, target0: MSPyBentleyGeom.DPoint3d, target1: MSPyBentleyGeom.DPoint3d, upVector: DVec3d) -> bool:
        """
        @description Test if a point is within the counter-clockwise sector
        defined by an origin and two boundary points, with an up vector to
        determine which direction is counter clockwise.
        
        :param (input):
        origin The point to test.
        
        :param (input):
        target0 The first target point.
        
        :param (input):
        target1 The second target point.
        
        :param (input):
        upVector vector towards eye to resolve direction.
        
        :returns:
        true if the test point is within the angle.
        """
        ...
    
    def IsPointInSmallerSector(self: MSPyBentleyGeom.DPoint3d, origin: MSPyBentleyGeom.DPoint3d, target1: MSPyBentleyGeom.DPoint3d, target2: MSPyBentleyGeom.DPoint3d) -> bool:
        """
        @description Form vectors from the origin to the test point and the
        two boundary vectors. Test if the test vector is within the smaller
        angle between the other two vectors.
        
        :param (input):
        origin The point to test.
        
        :param (input):
        target1 The first target point.
        
        :param (input):
        target2 The second target point.
        
        :returns:
        true if the test point is within the angle.
        """
        ...
    
    def IsPositiveParallelTo(self: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d) -> bool:
        """
        Tests if two vectors are parallel and have positive dot
        product (opposites are NOT considered parallel)
        
        :param (input):
        vector2 The second vector
        
        :returns:
        true if the vectors are parallel within tolerance
        """
        ...
    
    def IsVectorInCCWSector(self: MSPyBentleyGeom.DVec3d, vector0: MSPyBentleyGeom.DVec3d, vector1: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d) -> bool:
        """
        Test if the test vector vector is " between " vector0 and
        vector1, with CCW direction resolved by an up vector. The cross
        product of vector0 and vector1 is considered the positive plane normal
        if its dot product with the up vector is positive.
        
        :param (input):
        vector0 The boundary vector.
        
        :param (input):
        vector1 The boundary vector.
        
        :param (input):
        upVector The out of plane vector.
        
        :returns:
        true if test vector is within the angle.
        """
        ...
    
    def IsVectorInCCWXYSector(self: MSPyBentleyGeom.DVec3d, vector1: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d) -> bool:
        """
        Test if the instance vector vector is " between " vector0
        and vector1, with CCW direction using only xy parts.
        
        :param (input):
        vector0 The boundary vector.
        
        :param (input):
        vector1 The boundary vector.
        
        :returns:
        true if test vector is within the angle.
        """
        ...
    
    def IsVectorInSmallerSector(self: MSPyBentleyGeom.DVec3d, vector0: MSPyBentleyGeom.DVec3d, vector1: MSPyBentleyGeom.DVec3d) -> bool:
        """
        Test a vector is " between " vector0 and vector1. If the
        vectors are coplanar and vector0 is neither parallel nor antiparallel
        to vector1, betweenness has the expected meaning:there are two angles
        between vector0 and vector1; one is less than 180; the test vector is
        tested to see if it is in the smaller angle. If the vectors are not
        coplanar, the test is based on the projection of the test vector into
        the plane of the other two vectors.
        
        Zero testing is untoleranced, and is biased to all parallel conditions
        " false ". That is, if any pair of the input vectors is parallel or
        antiparallel, the mathematical answer is false. Floating point
        tolerances will cause " nearby " cases to be unpredictable. It is
        assumed that if the caller considers the " parallel " cases important
        they will be checked explicitly.
        
        :param (input):
        vector0 The first boundary vector.
        
        :param (input):
        vector1 The second boundary vector.
        
        :returns:
        true if the test vector is within the angle.
        """
        ...
    
    def IsZero(self: MSPyBentleyGeom.DVec3d) -> bool:
        """
        checks if the vector has all zeros
        """
        ...
    
    def Magnitude(self: MSPyBentleyGeom.DVec3d) -> float:
        """
        Computes the magnitude of a vector.
        
        :returns:
        The length of the vector
        """
        ...
    
    def MagnitudeSquared(self: MSPyBentleyGeom.DVec3d) -> float:
        """
        Computes the squared magnitude of a vector.
        
        :returns:
        The squared magnitude of the vector.
        """
        ...
    
    def MagnitudeSquaredXY(self: MSPyBentleyGeom.DVec3d) -> float:
        """
        Computes the squared magnitude of the xy part of a
        vector.
        
        :returns:
        The squared magnitude of the xy parts of the given vector.
        """
        ...
    
    def MagnitudeXY(self: MSPyBentleyGeom.DVec3d) -> float:
        """
        Computes the magnitude of the xy part of a vector.
        
        :returns:
        The magnitude of the xy parts of the given vector.
        """
        ...
    
    def MaxAbs(self: MSPyBentleyGeom.DVec3d) -> float:
        """
        Finds the largest absolute value among the components of
        a vector.
        
        :returns:
        The largest absolute value among vector coordinates.
        """
        ...
    
    def MaxAbsIndex(self: MSPyBentleyGeom.DPoint3d) -> int:
        """
        return in the index of the MaxAbs () value.
        """
        ...
    
    def MinAbs(self: MSPyBentleyGeom.DPoint3d) -> float:
        """
        @description Finds the smallest absolute value among the components of
        a point or vector.
        
        :returns:
        The smallest absolute value among point coordinates.
        """
        ...
    
    def MinAbsIndex(self: MSPyBentleyGeom.DPoint3d) -> int:
        """
        return in the index of the MinAbs () value
        """
        ...
    
    def Multiply(*args, **kwargs):
        """
        Overloaded function.
        
        1. Multiply(self: MSPyBentleyGeom.DVec3d, matrix: RotMatrix, vector: MSPyBentleyGeom.DVec3d) -> None
        
        Returns the product of a matrix times a vector.
        
        :param (input):
        matrix The matrix.
        
        :param (input):
        vector The known vector.
        
        2. Multiply(self: MSPyBentleyGeom.DVec3d, matrix: RotMatrix, x: float, y: float, z: float) -> None
        
        Returns the product of a matrix times a vector.
        
        :param (input):
        matrix The matrix.
        
        :param (input):
        vector The known vector.
        """
        ...
    
    def MultiplyArrayByScales(*args, **kwargs):
        """
        Overloaded function.
        
        1. MultiplyArrayByScales(outPoints: MSPyBentleyGeom.DPoint3dArray, inPoints: MSPyBentleyGeom.DPoint3dArray, scales: MSPyBentleyGeom.DoubleArray) -> None
        
        @description Multiply each point in an array by its corresponding
        scale factor.
        
        :param (output):
        pDest destination array.
        
        :param (input):
        pSource source array.
        
        :param (input):
        pScales scale factors
        
        :param (input):
        n number of points.
        
        2. MultiplyArrayByScales(outPoints: list, inPoints: list, scales: MSPyBentleyGeom.DoubleArray) -> None
        
        @description Multiply each point in an array by its corresponding
        scale factor.
        
        :param (output):
        pDest destination array.
        
        :param (input):
        pSource source array.
        
        :param (input):
        pScales scale factors
        
        :param (input):
        n number of points.
        """
        ...
    
    def MultiplyTranspose(*args, **kwargs):
        """
        Overloaded function.
        
        1. MultiplyTranspose(self: MSPyBentleyGeom.DVec3d, matrix: RotMatrix, vector: MSPyBentleyGeom.DVec3d) -> None
        
        Returns the product of a matrix transpose times a vector.
        
        :param (input):
        matrix The the matrix.
        
        :param (input):
        vector The known vector.
        
        2. MultiplyTranspose(self: MSPyBentleyGeom.DVec3d, matrix: RotMatrix, x: float, y: float, z: float) -> None
        
        Returns the product of a matrix transpose times a vector.
        
        :param (input):
        matrix The the matrix.
        
        :param (input):
        vector The known vector.
        """
        ...
    
    def Negate(*args, **kwargs):
        """
        Overloaded function.
        
        1. Negate(self: MSPyBentleyGeom.DVec3d, vector: MSPyBentleyGeom.DVec3d) -> None
        
        Computes a negated (opposite) vector.
        
        :param (input):
        vector The vector to be negated.
        
        2. Negate(self: MSPyBentleyGeom.DVec3d) -> None
        
        Computes a negated (opposite) vector.
        
        :param (input):
        vector The vector to be negated.
        """
        ...
    
    def Normalize(*args, **kwargs):
        """
        Overloaded function.
        
        1. Normalize(self: MSPyBentleyGeom.DVec3d, vector: MSPyBentleyGeom.DVec3d) -> float
        
        Normalizes (scales) a vector to length 1.
        
        Remark:
        In the 0-length error case, the vector is set to (1,0,0) in the
        legacy microstation style.
        
        :param (input):
        vector The vector to be normalized.
        
        :returns:
        The length prior to normalization
        
        2. Normalize(self: MSPyBentleyGeom.DVec3d) -> float
        
        Normalizes (scales) a vector to length 1.
        
        Remark:
        In the 0-length error case, the vector is set to (1,0,0) in the
        legacy microstation style.
        
        :param (input):
        vector The vector to be normalized.
        
        :returns:
        The length prior to normalization
        """
        ...
    
    def NormalizedCrossProduct(self: MSPyBentleyGeom.DVec3d, vector0: MSPyBentleyGeom.DVec3d, vector1: MSPyBentleyGeom.DVec3d) -> float:
        """
        Compute the normalized cross product of two vectors and
        return the length of the unnormalized cross product.
        
        :param (input):
        vector1 The first vector
        
        :param (input):
        vector2 The second vector
        
        :returns:
        The length of the original (prenormalization) cross product vector
        """
        ...
    
    def NormalizedDifference(self: MSPyBentleyGeom.DVec3d, target: MSPyBentleyGeom.DPoint3d, origin: MSPyBentleyGeom.DPoint3d) -> float:
        """
        Computes a unit vector in the direction of the difference
        of the vectors or vectors (Second parameter vector is subtracted from
        the first parameter vector, exactly as in the subtract function.)
        
        Remark:
        In the 0-length error case, the vector is set to (1,0,0) in the
        legacy microstation style.
        
        :param (input):
        target The target point.
        
        :param (input):
        origin The origin point.
        
        :returns:
        The length of original difference vector.
        """
        ...
    
    def NpcCoordinatesOf(self: MSPyBentleyGeom.DPoint3d, point: MSPyBentleyGeom.DPoint3d, cube: DRange3d) -> None:
        """
        @description Computes the coordinates of point under the translation
        and scaling that puts 000 at cube>low and 111 at cube>high.
        
        :param (input):
        point Point whose NPC coordinates are to be computed
        
        :param (input):
        cube Cube whose corners map to 000 and 111
        """
        ...
    
    def One(self: MSPyBentleyGeom.DPoint3d) -> None:
        """
        @description Returns a point or vector with all components 1.0.
        """
        ...
    
    def PlanarAngleTo(self: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d, planeNormal: MSPyBentleyGeom.DVec3d) -> float:
        """
        Computes the signed angle between the projection of two
        vectors onto a plane with given normal.
        
        :param (input):
        vector2 The second vector
        
        :param (input):
        planeNormal The plane normal vector
        
        :returns:
        The angle in plane
        """
        ...
    
    def ProjectToPlane(self: MSPyBentleyGeom.DVec3d, vectorU: MSPyBentleyGeom.DVec3d, vectorV: MSPyBentleyGeom.DVec3d, uv: MSPyBentleyGeom.DPoint2d) -> bool:
        """
        Find the projection of the instance vector to a plane defined by two
        vectors.
        
        :param (input):
        vectorU u-direction vector of the plane.
        
        :param (input):
        vectorV v-direction vector of the plane.
        
        :param (output):
        uv fractional coordinates on vectors.
        
        :returns:
        false if plane vectors are not independent. In this case the
        method attempts to project to the longer plane vector, and sets
        the other fraction to 0. If that fails uv is 00.
        """
        ...
    
    def ProjectToVector(self: MSPyBentleyGeom.DVec3d, targetVector: MSPyBentleyGeom.DVec3d) -> tuple:
        """
        Find the fraction at which the instance projects to a vector.
        
        :param (input):
        targetVector target vector.
        
        :param (output):
        fraction projection fraction
        
        :returns:
        false if targetVector has zero length. In this case the fraction
        is zero.
        """
        ...
    
    def RotateXY(*args, **kwargs):
        """
        Overloaded function.
        
        1. RotateXY(self: MSPyBentleyGeom.DVec3d, vector: MSPyBentleyGeom.DVec3d, theta: float) -> None
        
        Rotate a vector around the z axis.
        
        :param (input):
        vector vector to rotate.
        
        :param (input):
        theta The rotation angle.
        
        2. RotateXY(self: MSPyBentleyGeom.DVec3d, theta: float) -> None
        
        Rotate a vector around the z axis.
        
        :param (input):
        vector vector to rotate.
        
        :param (input):
        theta The rotation angle.
        """
        ...
    
    def SafeDivide(self: MSPyBentleyGeom.DVec3d, vector: MSPyBentleyGeom.DVec3d, denominator: float) -> bool:
        """
        Try to divide each component of a vector by a scalar. If
        the denominator near zero compared to any numerator component, return
        the original vector.
        
        :param (input):
        vector The initial vector.
        
        :param (input):
        denominator The divisor.
        
        :returns:
        true if division is numerically safe.
        """
        ...
    
    def SafeOneOverMagnitudeSquared(self: MSPyBentleyGeom.DVec3d, defaultValue: float) -> float:
        """
        Returns 1 over the squared magnitude, or caller supplied
        default if squared magnitude is too small.
        """
        ...
    
    def Scale(*args, **kwargs):
        """
        Overloaded function.
        
        1. Scale(self: MSPyBentleyGeom.DVec3d, vector: MSPyBentleyGeom.DVec3d, scale: float) -> None
        
        Multiplies a vector by a scale factor.
        
        :param (input):
        vector The vector to be scaled.
        
        :param (input):
        scale The scale factor.
        
        2. Scale(self: MSPyBentleyGeom.DVec3d, scale: float) -> None
        
        Multiplies a vector by a scale factor.
        
        :param (input):
        vector The vector to be scaled.
        
        :param (input):
        scale The scale factor.
        """
        ...
    
    def ScaleToLength(*args, **kwargs):
        """
        Overloaded function.
        
        1. ScaleToLength(self: MSPyBentleyGeom.DVec3d, vector: MSPyBentleyGeom.DVec3d, length: float) -> float
        
        Scales a vector to specified length.
        
        Remark:
        In the 0-length error case, the vector is set to (1,0,0) in the
        legacy microstation style.
        
        :param (input):
        vector The original vector.
        
        :param (input):
        length The requested length.
        
        :returns:
        The length prior to scaling.
        
        2. ScaleToLength(self: MSPyBentleyGeom.DVec3d, length: float) -> float
        
        Scales a vector to specified length.
        
        Remark:
        In the 0-length error case, the vector is set to (1,0,0) in the
        legacy microstation style.
        
        :param (input):
        vector The original vector.
        
        :param (input):
        length The requested length.
        
        :returns:
        The length prior to scaling.
        """
        ...
    
    def SetComponent(self: MSPyBentleyGeom.DVec3d, a: float, index: int) -> None:
        """
        Set one of three components (x,y,z) of the vector.
        
        :param (input):
        a The component value.
        
        :param (input):
        index Selects the the axis:0=x, 1=y, 2=z, others cyclic.
        """
        ...
    
    def SignedAngleTo(self: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d, orientationVector: MSPyBentleyGeom.DVec3d) -> float:
        """
        Computes the signed angle from one vector to another, in
        the plane of the two vectors. Initial computation using only the two
        vectors yields two possible angles depending on which side of the
        plane of the vectors is viewed. To choose which side to view, go on
        the side whose normal has a positive dot product with the orientation
        vector. This angle can be between -pi and +pi.
        
        :param (input):
        vector2 The second vector
        
        :param (input):
        orientationVector The vector used to determine orientation.
        
        :returns:
        The signed angle
        """
        ...
    
    def SizedCrossProduct(self: MSPyBentleyGeom.DVec3d, vector0: MSPyBentleyGeom.DVec3d, vector1: MSPyBentleyGeom.DVec3d, productLength: float) -> float:
        """
        Computes the cross product of the two parameter vectors
        and scales it to a given length. The scaled vector is stored as the
        product vector, and the length of the original cross product vector is
        returned.
        
        :param (input):
        vector1 The first vector
        
        :param (input):
        vector2 The second vector
        
        :param (input):
        productLength The Desired length
        
        :returns:
        The The length of unscaled cross product.
        """
        ...
    
    def SmallerUnorientedAngleTo(self: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d) -> float:
        """
        Returns the angle between two vectors, choosing the
        smaller of the two possible angles when both the vectors and their
        negations are considered. This angle is between 0 and pi/2.
        
        :param (input):
        vector2 The second vector
        
        :returns:
        The angle between the vectors.
        """
        ...
    
    def SmallerUnorientedAngleToXY(self: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d) -> float:
        """
        Returns the angle between two vectors, considering both
        the vectors and their negations and choosing the smaller. This angle
        is between 0 and pi/2.
        
        :param (input):
        vector2 The second vector
        
        :returns:
        The angle between vectors.
        """
        ...
    
    def Subtract(self: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d) -> None:
        """
        Subtract two vectors, and return the result in place of
        the first.
        
        :param (input):
        vector2 The vector to subtract.
        """
        ...
    
    def SumOf(*args, **kwargs):
        """
        Overloaded function.
        
        1. SumOf(self: MSPyBentleyGeom.DVec3d, vector1: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d) -> None
        
        Compute the sum of two vectors.
        
        :param (input):
        vector1 The the first vector
        
        :param (input):
        vector2 The second vector
        
        2. SumOf(self: MSPyBentleyGeom.DVec3d, vector1: MSPyBentleyGeom.DVec3d, scale1: float, vector2: MSPyBentleyGeom.DVec3d, scale2: float) -> None
        
        Compute the sum of two vectors.
        
        :param (input):
        vector1 The the first vector
        
        :param (input):
        vector2 The second vector
        
        3. SumOf(self: MSPyBentleyGeom.DVec3d, vector1: MSPyBentleyGeom.DVec3d, scale1: float, vector2: MSPyBentleyGeom.DVec3d, scale2: float, vector3: MSPyBentleyGeom.DVec3d, scale3: float) -> None
        
        Compute the sum of two vectors.
        
        :param (input):
        vector1 The the first vector
        
        :param (input):
        vector2 The second vector
        
        4. SumOf(self: MSPyBentleyGeom.DVec3d, origin: MSPyBentleyGeom.DVec3d, vector: MSPyBentleyGeom.DVec3d, scale: float) -> None
        
        Compute the sum of two vectors.
        
        :param (input):
        vector1 The the first vector
        
        :param (input):
        vector2 The second vector
        
        5. SumOf(self: MSPyBentleyGeom.DVec3d, origin: MSPyBentleyGeom.DVec3d, vector1: MSPyBentleyGeom.DVec3d, scale1: float, vector2: MSPyBentleyGeom.DVec3d, scale2: float) -> None
        
        Compute the sum of two vectors.
        
        :param (input):
        vector1 The the first vector
        
        :param (input):
        vector2 The second vector
        
        6. SumOf(self: MSPyBentleyGeom.DVec3d, origin: MSPyBentleyGeom.DVec3d, vector1: MSPyBentleyGeom.DVec3d, scale1: float, vector2: MSPyBentleyGeom.DVec3d, scale2: float, vector3: MSPyBentleyGeom.DVec3d, scale3: float) -> None
        
        Compute the sum of two vectors.
        
        :param (input):
        vector1 The the first vector
        
        :param (input):
        vector2 The second vector
        """
        ...
    
    def Swap(self: MSPyBentleyGeom.DPoint3d, other: MSPyBentleyGeom.DPoint3d) -> None:
        """
        Swap contents of instance, other.
        
        :param [in,out]:
        other second point.
        """
        ...
    
    def TripleProduct(self: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d, vector3: MSPyBentleyGeom.DVec3d) -> float:
        """
        Computes the triple product of three vectors. The
        following are equivalent definitions of the triple product of three
        vectors V1, V2, and V3:
        
        <UL> <LI> (V1 cross V2) dot V3 <LI> V1 dot (V2 cross V3) <LI>The
        determinant of the 3x3 matrix with the three vectors as its columns.
        <LI>The determinant of the 3x3 matrix with the three vectors as its
        rows. <LI>The (signed)volume of the parallelepiped whose 4 vertices
        are at the origin and at the ends of the 3 vectors placed at the
        origin. </UL>
        
        :param (input):
        vector2 The second vector.
        
        :param (input):
        vector3 The third vector.
        
        :returns:
        The triple product
        """
        ...
    
    def TripleProductToPoints(self: MSPyBentleyGeom.DPoint3d, target1: MSPyBentleyGeom.DPoint3d, target2: MSPyBentleyGeom.DPoint3d, target3: MSPyBentleyGeom.DPoint3d) -> float:
        """
        @description Computes the triple product of vectors from a base point
        three target points.
        
        :param (input):
        target1 The target point for the first vector.
        
        :param (input):
        target2 The target point for the second vector.
        
        :param (input):
        target3 The target point for the third vector.
        
        :returns:
        The triple product
        """
        ...
    
    def TryNormalize(self: MSPyBentleyGeom.DVec3d, source: MSPyBentleyGeom.DVec3d) -> tuple:
        """
        initialize this vector to unit vector in the direction of
        source.
        
        Remark:
        In the 0-length error case, the vector is set to (1,0,0) in the
        legacy microstation style.
        
        :param (input):
        source The vector to be normalized.
        
        :param (output):
        magnitude The orignal magnitude of the source vector;
        
        :returns:
        true if the other vector length is large enough for
        DoubleOps.SafeDivide to compute 1/length.
        """
        ...
    
    def UnitPerpendicularXY(self: MSPyBentleyGeom.DVec3d, vector: MSPyBentleyGeom.DVec3d) -> bool:
        """
        Compute a unit vector perpendicular to the xy parts of
        given vector.
        
        :param (input):
        vector The source vector
        
        :returns:
        true if the input vector has nonzero length
        """
        ...
    
    @staticmethod
    def UnitX() -> MSPyBentleyGeom.DVec3d:
        """
        unit X vector
        """
        ...
    
    @staticmethod
    def UnitY() -> MSPyBentleyGeom.DVec3d:
        """
        unit Y vector
        """
        ...
    
    @staticmethod
    def UnitZ() -> MSPyBentleyGeom.DVec3d:
        """
        unit Z vector
        """
        ...
    
    def ValidatedFractionOfProjection(self: MSPyBentleyGeom.DVec3d, vectorToProject: MSPyBentleyGeom.DVec3d, defaultValue: float = 0.0) -> MSPyBentleyGeom.ValidatedDouble:
        """
        Returns fraction at which other projects onto this, in
        ValidatedDouble which records if the division was safe.
        """
        ...
    
    def ValidatedNormalize(self: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.ValidatedDVec3d:
        """
        return a (possibly invalid) unit vector in the direction
        of the calling instance.
        """
        ...
    
    def WeightedDifferenceCrossProduct(self: MSPyBentleyGeom.DVec3d, basePoint: MSPyBentleyGeom.DPoint4d, target1: MSPyBentleyGeom.DPoint4d, target2: MSPyBentleyGeom.DPoint4d) -> None:
        """
        Form the cross product of the weighted differences from
        base poitn to two targets
        
        :param (input):
        basePoint The common base point (second point for differences)
        
        :param (input):
        target1 The first target point.
        
        :param (input):
        target2 The second target point.
        """
        ...
    
    def WeightedDifferenceOf(self: MSPyBentleyGeom.DVec3d, hPoint1: MSPyBentleyGeom.DPoint4d, hPoint2: MSPyBentleyGeom.DPoint4d) -> None:
        """
        Scale each (homogeneous) point by the other's weight and
        subtract, i.e. form (point1 * point2.w - point2 * point1.w). The
        weight term vanishes. Copy the xyz parts back as a vector.
        
        :param (input):
        hPoint1 The first homogeneous point
        
        :param (input):
        hPoint2 The second homogeneous point.
        """
        ...
    
    @property
    def X(self: MSPyBentleyGeom.DPoint3d) -> float:
        ...
    @X.setter
    def X(self: MSPyBentleyGeom.DPoint3d, arg0: float) -> None:
        ...
    
    def XyzOf(self: MSPyBentleyGeom.DVec3d, hPoint: MSPyBentleyGeom.DPoint4d) -> None:
        """
        Sets the x,y, and z components of a DVec3d structure from
        the corresponding parts of a DPoint4d. Weight part of DPoint4d is not
        used.
        
        :param (input):
        hPoint The homogeneous point
        """
        ...
    
    @property
    def Y(self: MSPyBentleyGeom.DPoint3d) -> float:
        ...
    @Y.setter
    def Y(self: MSPyBentleyGeom.DPoint3d, arg0: float) -> None:
        ...
    
    @property
    def Z(self: MSPyBentleyGeom.DPoint3d) -> float:
        ...
    @Z.setter
    def Z(self: MSPyBentleyGeom.DPoint3d, arg0: float) -> None:
        ...
    
    def Zero(self: MSPyBentleyGeom.DPoint3d) -> None:
        """
        @description Sets all components of a point or vector to zero.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DVec3d) -> None
        
        2. __init__(self: MSPyBentleyGeom.DVec3d, ax: float, ay: float, az: float = 0.0) -> None
        
        3. __init__(self: MSPyBentleyGeom.DVec3d, point: MSPyBentleyGeom.DPoint3d) -> None
        
        4. __init__(self: MSPyBentleyGeom.DVec3d, vector: MSPyBentleyGeom.DVec2d) -> None
        
        5. __init__(self: MSPyBentleyGeom.DVec3d, start: MSPyBentleyGeom.DPoint3d, end: MSPyBentleyGeom.DPoint3d) -> None
        
        6. __init__(self: MSPyBentleyGeom.DVec3d, start: MSPyBentleyGeom.DPoint4d, end: MSPyBentleyGeom.DPoint4d) -> None
        
        7. __init__(self: MSPyBentleyGeom.DVec3d, start: Transform, target: MSPyBentleyGeom.DPoint3d) -> None
        """
        ...
    
    @property
    def x(self: MSPyBentleyGeom.DPoint3d) -> float:
        ...
    @x.setter
    def x(self: MSPyBentleyGeom.DPoint3d, arg0: float) -> None:
        ...
    
    @property
    def y(self: MSPyBentleyGeom.DPoint3d) -> float:
        ...
    @y.setter
    def y(self: MSPyBentleyGeom.DPoint3d, arg0: float) -> None:
        ...
    
    @property
    def z(self: MSPyBentleyGeom.DPoint3d) -> float:
        ...
    @z.setter
    def z(self: MSPyBentleyGeom.DPoint3d, arg0: float) -> None:
        ...
    
class DVec3dArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DVec3dArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.DVec3dArray, arg0: MSPyBentleyGeom.DVec3dArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.DVec3dArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.DVec3dArray, x: MSPyBentleyGeom.DVec3d) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.DVec3dArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def count(self: MSPyBentleyGeom.DVec3dArray, x: MSPyBentleyGeom.DVec3d) -> int:
        """
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.DVec3dArray, L: MSPyBentleyGeom.DVec3dArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.DVec3dArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.DVec3dArray, i: int, x: MSPyBentleyGeom.DVec3d) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.DVec3dArray) -> MSPyBentleyGeom.DVec3d
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.DVec3dArray, i: int) -> MSPyBentleyGeom.DVec3d
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(self: MSPyBentleyGeom.DVec3dArray, x: MSPyBentleyGeom.DVec3d) -> None:
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class DVec3dVecArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DVec3dVecArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.DVec3dVecArray, arg0: MSPyBentleyGeom.DVec3dVecArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.DVec3dVecArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.DVec3dVecArray, x: MSPyBentleyGeom.DVec3dArray) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.DVec3dVecArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def count(self: MSPyBentleyGeom.DVec3dVecArray, x: MSPyBentleyGeom.DVec3dArray) -> int:
        """
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.DVec3dVecArray, L: MSPyBentleyGeom.DVec3dVecArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.DVec3dVecArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.DVec3dVecArray, i: int, x: MSPyBentleyGeom.DVec3dArray) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.DVec3dVecArray) -> MSPyBentleyGeom.DVec3dArray
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.DVec3dVecArray, i: int) -> MSPyBentleyGeom.DVec3dArray
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(self: MSPyBentleyGeom.DVec3dVecArray, x: MSPyBentleyGeom.DVec3dArray) -> None:
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class DgnBoxDetail:
    """
    None
    """

    def AddCurveIntersections(*args, **kwargs):
        """
        Overloaded function.
        
        1. AddCurveIntersections(self: MSPyBentleyGeom.DgnBoxDetail, curves: MSPyBentleyGeom.CurveVector, curvePoints: MSPyBentleyGeom.CurveLocationDetailArray, solidPoints: MSPyBentleyGeom.SolidLocationDetailArray, messages: MSPyBentleyGeom.MeshAnnotationVector) -> None
        
        Compute intersections with curves and add to the data array.
        
        :param (input):
        curves
        
        :param [in,out]:
        curvePoints growing array of curve points.
        
        :param [in,out]:
        solidPoints growing array of solid points.
        
        :param [in,out]:
        messages array of error messages
        
        2. AddCurveIntersections(self: MSPyBentleyGeom.DgnBoxDetail, curves: MSPyBentleyGeom.ICurvePrimitive, curvePoints: MSPyBentleyGeom.CurveLocationDetailArray, solidPoints: MSPyBentleyGeom.SolidLocationDetailArray, messages: MSPyBentleyGeom.MeshAnnotationVector) -> None
        
        Compute intersections with curves and add to the data array.
        
        :param (input):
        curves
        
        :param [in,out]:
        curvePoints growing array of curve points.
        
        :param [in,out]:
        solidPoints growing array of solid points.
        
        :param [in,out]:
        messages array of error messages
        """
        ...
    
    def AddRayIntersections(self: MSPyBentleyGeom.DgnBoxDetail, pickData: MSPyBentleyGeom.SolidLocationDetailArray, ray: MSPyBentleyGeom.DRay3d, parentId: int, minParameter: float) -> None:
        """
        Compute intersections with a ray and add to the pickData.
        
        :param (input):
        ray origin and direction
        
        :param (input):
        minParameter smallest parameter of pick. (e.g. 0 for picking along
        a positive ray from an eyepoint)
        
        :param [in,out]:
        pickData growing array of picks.
        
        :param (input):
        parentId caller's id for this solid. Will be placed in each
        pickData entry has parentId.
        """
        ...
    
    def Clone(self: MSPyBentleyGeom.DgnBoxDetail) -> ISolidPrimitive:
        """
        Copy to a new (allocated) solid primitive.
        """
        ...
    
    def ClosestPoint(self: MSPyBentleyGeom.DgnBoxDetail, spacePoint: MSPyBentleyGeom.DPoint3d, pickDetail: MSPyBentleyGeom.SolidLocationDetail) -> bool:
        """
        :param (input):
        spacePoint search for point close to here and on the solid surface
        
        :param (output):
        pickDetail closest point data.
        
        :returns:
        false if not supported.
        """
        ...
    
    def ComputeSecondMomentAreaProducts(self: MSPyBentleyGeom.DgnBoxDetail, localToWorld: MSPyBentleyGeom.Transform, localProducts: MSPyBentleyGeom.DMatrix4d) -> bool:
        """
        Return the various integrated products for area moment calculations.
        The primitive is treated as a thin shell.
        
        :param (output):
        localToWorld transform from preferred system where the products
        are most easily computed to world.
        
        :param (output):
        localProducts integrated [xx xy xz x; xy yy yz y; xz yz zz z; x y
        z 1] dA
        
        :returns:
        false if unable to compute.
        """
        ...
    
    def ComputeSecondMomentVolumeProducts(self: MSPyBentleyGeom.DgnBoxDetail, localToWorld: MSPyBentleyGeom.Transform, localProducts: MSPyBentleyGeom.DMatrix4d) -> bool:
        """
        Return the various integrated products for moment calculations. The
        primitive is treated as a volume
        
        :param (output):
        localToWorld transform from preferred system where the products
        are most easily computed to world.
        
        :param (output):
        localProducts integrated [xx xy xz x; xy yy yz y; xz yz zz z; x y
        z 1] dA
        
        :returns:
        false if unable to compute.
        """
        ...
    
    def GetConstantUSection(self: MSPyBentleyGeom.DgnBoxDetail, indices: SolidLocationDetail.FaceIndices, fraction: float) -> MSPyBentleyGeom.ICurvePrimitive:
        """
        Copy a section at constant u of a single face to a single
        ICurvePrimitive.
        
        :param (input):
        indices selects face
        
        :param (input):
        fraction u fraction for section curve
        """
        ...
    
    def GetConstantVSection(self: MSPyBentleyGeom.DgnBoxDetail, indices: SolidLocationDetail.FaceIndices, fraction: float) -> MSPyBentleyGeom.ICurvePrimitive:
        """
        Copy a section curve at constant v of a single face to a single
        ICurvePrimitive.
        
        :param (input):
        indices selects face
        
        :param (input):
        fraction v fraction for section curve
        """
        ...
    
    def GetCorners(*args, **kwargs):
        """
        Overloaded function.
        
        1. GetCorners(self: MSPyBentleyGeom.DgnBoxDetail, corners: MSPyBentleyGeom.DPoint3dArray) -> None
        
        Return 8 corners of the box. x varies fastest, then y then z.
        
        :param (output):
        corners 8 corner coordinates.
        
        2. GetCorners(self: MSPyBentleyGeom.DgnBoxDetail, corners: list) -> None
        
        Return 8 corners of the box. x varies fastest, then y then z.
        
        :param (output):
        corners 8 corner coordinates.
        
        3. GetCorners(self: MSPyBentleyGeom.DgnBoxDetail, corners: MSPyBentleyGeom.DPoint3d) -> None
        
        Return 8 corners of the box. x varies fastest, then y then z.
        
        :param (output):
        corners 8 corner coordinates.
        """
        ...
    
    def GetFace(self: MSPyBentleyGeom.DgnBoxDetail, indices: SolidLocationDetail.FaceIndices) -> MSPyBentleyGeom.IGeometry:
        """
        Return a single face of the solid primitive
        
        :param indices:
        integer selectors for the face.
        """
        ...
    
    def GetFaceIndices(self: MSPyBentleyGeom.DgnBoxDetail, indices: MSPyBentleyGeom.FaceIndicesArray) -> None:
        """
        Fill a list of all possible face indices.
        
        :param (output):
        indices array of selectors for the faces.
        """
        ...
    
    def GetNonUniformTransform(self: MSPyBentleyGeom.DgnBoxDetail, localToWorld: MSPyBentleyGeom.Transform) -> tuple:
        """
        Return (nonuniform) placement and rectangle sizes. (ax,ay) rectangle
        is on z=0. (bx,by) is on z=1;
        """
        ...
    
    def GetRange(*args, **kwargs):
        """
        Overloaded function.
        
        1. GetRange(self: MSPyBentleyGeom.DgnBoxDetail, range: MSPyBentleyGeom.DRange3d) -> bool
        
        Return range.
        
        2. GetRange(self: MSPyBentleyGeom.DgnBoxDetail, range: MSPyBentleyGeom.DRange3d, transform: MSPyBentleyGeom.Transform) -> bool
        
        Return range.
        """
        ...
    
    @staticmethod
    def InitFromCenterAndSize(center: MSPyBentleyGeom.DPoint3d, size: MSPyBentleyGeom.DPoint3d, capped: bool) -> MSPyBentleyGeom.DgnBoxDetail:
        """
        Initialize box detail fields from center and size.
        
        :param (input):
        center center of box in XYZ
        
        :param (input):
        size total range in XYZ
        
        :param (input):
        capped true if closed top and bottom.
        """
        ...
    
    @staticmethod
    def InitFromCenters(baseOrigin: MSPyBentleyGeom.DPoint3d, topOrigin: MSPyBentleyGeom.DPoint3d, vectorX: MSPyBentleyGeom.DVec3d, vectorY: MSPyBentleyGeom.DVec3d, baseX: float, baseY: float, topX: float, topY: float, capped: bool) -> MSPyBentleyGeom.DgnBoxDetail:
        """
        Initialize box detail fields specifying top/base centers instead of
        origins...
        
        :param (input):
        baseCenter center of base rectangle
        
        :param (input):
        topCenter center of Top rectangle
        
        :param (input):
        vectorX X vector of base plane
        
        :param (input):
        vectorY Y vector of base plane
        
        :param (input):
        baseX x size at base
        
        :param (input):
        baseY y size at base
        
        :param (input):
        topX X size at top
        
        :param (input):
        topY y size at top
        
        :param (input):
        capped true if closed top and bottom.
        """
        ...
    
    def IsBlock(self: MSPyBentleyGeom.DgnBoxDetail, origin: MSPyBentleyGeom.DPoint3d, unitAxes: MSPyBentleyGeom.RotMatrix, localDiagonal: MSPyBentleyGeom.DVec3d, originXFraction: float, originYFraction: float, originZFraction: float) -> bool:
        """
        Test if the DgnBox is really a box (aka slab). Return orientation and
        size data, using caller-specifed fractional coordinates to indicate
        position of origin in reference system.
        
        :param (output):
        origin local coordinates origin
        
        :param (output):
        unitAxes transform (with orthogonal axes)
        
        :param (output):
        localDiagonal the box edge lengths.
        
        :param (input):
        originXFraction fractional position of the unitAxes origin along
        the x edge.
        
        :param (input):
        originYFraction fractional position of the unitAxes origin along
        the y edge.
        
        :param (input):
        originZFraction fractional position of the unitAxes origin along
        the z edge.
        """
        ...
    
    def IsClosedVolume(self: MSPyBentleyGeom.DgnBoxDetail) -> bool:
        """
        Test if this is a closed volume.
        """
        ...
    
    def IsSameStructure(self: MSPyBentleyGeom.DgnBoxDetail, other: ISolidPrimitive) -> bool:
        """
        Test for same type and structure (but no coordinate comparison)
        """
        ...
    
    def IsSameStructureAndGeometry(self: MSPyBentleyGeom.DgnBoxDetail, other: ISolidPrimitive, tolerance: float) -> bool:
        """
        Test for same type, structure and coordinates.
        """
        ...
    
    def ParameterizationSign(self: MSPyBentleyGeom.DgnBoxDetail) -> float:
        """
        Return +1 or -1 that matches the volume sign after integration over
        the parameter space.
        """
        ...
    
    def SilhouetteCurves(self: MSPyBentleyGeom.DgnBoxDetail, eyePoint: MSPyBentleyGeom.DPoint4d, curves: MSPyBentleyGeom.CurveVector) -> bool:
        """
        Return curves which are silhoutte curves OTHER than hard edges
        
        :returns:
        return false if not implemented. return true if implemented -- but
        curves may still be empty.
        """
        ...
    
    def TransformInPlace(self: MSPyBentleyGeom.DgnBoxDetail, transform: MSPyBentleyGeom.Transform) -> bool:
        """
        Transform in place.
        """
        ...
    
    def TryGetConstructiveFrame(self: MSPyBentleyGeom.DgnBoxDetail, localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform) -> bool:
        """
        Return coordinate system with 1) XY in box base plane, origin at
        nominal lower left. 2) Z perpendicular
        """
        ...
    
    def TryGetMaxUVLength(self: MSPyBentleyGeom.DgnBoxDetail, indices: SolidLocationDetail.FaceIndices, uvLength: MSPyBentleyGeom.DVec2d) -> bool:
        """
        Compute the lengths of the longest u and v direction sections of a
        single face of a solid primitive.
        
        :param (input):
        indices selects face.
        
        :param (input):
        uvLength sizes in u, v directions.
        """
        ...
    
    def TryUVFractionToXYZ(self: MSPyBentleyGeom.DgnBoxDetail, faceIndices: SolidLocationDetail.FaceIndices, uFraction: float, vFraction: float, xyz: MSPyBentleyGeom.DPoint3d, dXdu: MSPyBentleyGeom.DVec3d, dXdv: MSPyBentleyGeom.DVec3d) -> bool:
        """
        convert u,v fraction on specified face to xyz and derivatives.
        
        :param (input):
        faceIndices face selection indices
        
        :param (input):
        uFraction fractional coordinate in u direction.
        
        :param (input):
        vFraction fractional coordinate in v direction.
        
        :param (output):
        xyz point on face.
        
        :param (output):
        dXdu derivative of face point wrt uFraction.
        
        :param (output):
        dXdv derivative of face point wrt vFraction.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DgnBoxDetail) -> None
        
        2. __init__(self: MSPyBentleyGeom.DgnBoxDetail, baseOrigin: MSPyBentleyGeom.DPoint3d, topOrigin: MSPyBentleyGeom.DPoint3d, vectorX: MSPyBentleyGeom.DVec3d, vectorY: MSPyBentleyGeom.DVec3d, baseX: float, baseY: float, topX: float, topY: float, capped: bool) -> None
        """
        ...
    
class DgnConeDetail:
    """
    None
    """

    def AddCurveIntersections(*args, **kwargs):
        """
        Overloaded function.
        
        1. AddCurveIntersections(self: MSPyBentleyGeom.DgnConeDetail, curves: MSPyBentleyGeom.CurveVector, curvePoints: MSPyBentleyGeom.CurveLocationDetailArray, solidPoints: MSPyBentleyGeom.SolidLocationDetailArray, messages: MSPyBentleyGeom.MeshAnnotationVector) -> None
        
        Compute intersections with curves and add to the data array.
        
        :param (input):
        curves
        
        :param [in,out]:
        curvePoints growing array of curve points.
        
        :param [in,out]:
        solidPoints growing array of solid points.
        
        :param [in,out]:
        messages array of error messages
        
        2. AddCurveIntersections(self: MSPyBentleyGeom.DgnConeDetail, curves: MSPyBentleyGeom.ICurvePrimitive, curvePoints: MSPyBentleyGeom.CurveLocationDetailArray, solidPoints: MSPyBentleyGeom.SolidLocationDetailArray, messages: MSPyBentleyGeom.MeshAnnotationVector) -> None
        
        Compute intersections with curves and add to the data array.
        
        :param (input):
        curves
        
        :param [in,out]:
        curvePoints growing array of curve points.
        
        :param [in,out]:
        solidPoints growing array of solid points.
        
        :param [in,out]:
        messages array of error messages
        """
        ...
    
    def AddRayIntersections(self: MSPyBentleyGeom.DgnConeDetail, pickData: MSPyBentleyGeom.SolidLocationDetailArray, ray: MSPyBentleyGeom.DRay3d, parentId: int, minParameter: float) -> None:
        """
        Compute intersections with a ray and add to the pickData.
        
        :param (input):
        ray origin and direction
        
        :param (input):
        minParameter smallest parameter of pick. (e.g. 0 for picking along
        a positive ray from an eyepoint)
        
        :param [in,out]:
        pickData growing array of picks.
        
        :param (input):
        parentId caller's id for this solid. Will be placed in each
        pickData entry has parentId.
        """
        ...
    
    def Clone(self: MSPyBentleyGeom.DgnConeDetail) -> ISolidPrimitive:
        """
        Copy to a new (allocated) solid primitive.
        """
        ...
    
    def ClosestPoint(self: MSPyBentleyGeom.DgnConeDetail, spacePoint: MSPyBentleyGeom.DPoint3d, pickDetail: MSPyBentleyGeom.SolidLocationDetail) -> bool:
        """
        :param (input):
        spacePoint search for point close to here and on the solid surface
        
        :param (output):
        pickDetail closest point data.
        
        :returns:
        false if not supported.
        """
        ...
    
    def ComputeSecondMomentAreaProducts(self: MSPyBentleyGeom.DgnConeDetail, localToWorld: MSPyBentleyGeom.Transform, localProducts: MSPyBentleyGeom.DMatrix4d) -> bool:
        """
        Return the various integrated products for area moment calculations.
        The primitive is treated as a thin shell.
        
        :param (output):
        localToWorld transform from preferred system where the products
        are most easily computed to world.
        
        :param (output):
        localProducts integrated [xx xy xz x; xy yy yz y; xz yz zz z; x y
        z 1] dA
        
        :returns:
        false if unable to compute.
        """
        ...
    
    def ComputeSecondMomentVolumeProducts(self: MSPyBentleyGeom.DgnConeDetail, localToWorld: MSPyBentleyGeom.Transform, localProducts: MSPyBentleyGeom.DMatrix4d) -> bool:
        """
        Return the various integrated products for moment calculations. The
        primitive is treated as a volume
        
        :param (output):
        localToWorld transform from preferred system where the products
        are most easily computed to world.
        
        :param (output):
        localProducts integrated [xx xy xz x; xy yy yz y; xz yz zz z; x y
        z 1] dA
        
        :returns:
        false if unable to compute.
        """
        ...
    
    def FractionToRule(self: MSPyBentleyGeom.DgnConeDetail, fraction: float, segment: MSPyBentleyGeom.DSegment3d) -> bool:
        """
        Return the rule line section at a fraction around the circular
        sections.
        
        :param (input):
        fraction fractional position around the cone.
        
        :param (output):
        segment rule line
        """
        ...
    
    def FractionToSection(self: MSPyBentleyGeom.DgnConeDetail, fraction: float, ellipse: MSPyBentleyGeom.DEllipse3d) -> bool:
        """
        Return the ellipse cross section at a fraction along the rotation
        axis.
        
        :param (input):
        fraction fractional position alont the z axis.
        
        :param (output):
        ellipse the section ellipse.
        """
        ...
    
    def GetConstantUSection(self: MSPyBentleyGeom.DgnConeDetail, indices: SolidLocationDetail.FaceIndices, fraction: float) -> MSPyBentleyGeom.ICurvePrimitive:
        """
        Copy a section at constant u of a single face to a single
        ICurvePrimitive.
        
        :param (input):
        indices selects face
        
        :param (input):
        fraction u fraction for section curve
        """
        ...
    
    def GetConstantVSection(self: MSPyBentleyGeom.DgnConeDetail, indices: SolidLocationDetail.FaceIndices, fraction: float) -> MSPyBentleyGeom.ICurvePrimitive:
        """
        Copy a section curve at constant v of a single face to a single
        ICurvePrimitive.
        
        :param (input):
        indices selects face
        
        :param (input):
        fraction v fraction for section curve
        """
        ...
    
    def GetFace(self: MSPyBentleyGeom.DgnConeDetail, indices: SolidLocationDetail.FaceIndices) -> MSPyBentleyGeom.IGeometry:
        """
        Return a single face of the solid primitive
        
        :param indices:
        integer selectors for the face.
        """
        ...
    
    def GetFaceIndices(self: MSPyBentleyGeom.DgnConeDetail, indices: MSPyBentleyGeom.FaceIndicesArray) -> None:
        """
        Fill a list of all possible face indices.
        
        :param (output):
        indices array of selectors for the faces.
        """
        ...
    
    def GetRange(*args, **kwargs):
        """
        Overloaded function.
        
        1. GetRange(self: MSPyBentleyGeom.DgnConeDetail, range: MSPyBentleyGeom.DRange3d) -> bool
        
        Return range.
        
        2. GetRange(self: MSPyBentleyGeom.DgnConeDetail, range: MSPyBentleyGeom.DRange3d, transform: MSPyBentleyGeom.Transform) -> bool
        
        Return range.
        """
        ...
    
    def GetSilhouettes(self: MSPyBentleyGeom.DgnConeDetail, segmentA: MSPyBentleyGeom.DSegment3d, segmentB: MSPyBentleyGeom.DSegment3d, viewToLocal: MSPyBentleyGeom.DMatrix4d) -> bool:
        """
        Return the rule lines which are silhouettes as viewed.
        
        :param (output):
        segmentA first silhouette line
        
        :param (output):
        segmentB second silhouette line
        
        :param (input):
        viewToLocal matrix that positions the cone for viewing along the z
        axis.
        """
        ...
    
    def GetTransforms(self: MSPyBentleyGeom.DgnConeDetail, localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform, fractionRadii: bool = False) -> tuple:
        """
        Try to set up a nonsingular coordinate frame. Returns false if centerB
        is in base plane !!!!
        """
        ...
    
    def IntersectBoundedArc(self: MSPyBentleyGeom.DgnConeDetail, arc: MSPyBentleyGeom.DEllipse3d, arcFractions: MSPyBentleyGeom.DoubleArray, normalizedConePoints: MSPyBentleyGeom.DPoint3dArray, localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform, boundedConeZ: bool) -> tuple:
        ...
    
    def IntersectCurveLocal(self: MSPyBentleyGeom.DgnConeDetail, curve: MSPyBentleyGeom.ICurvePrimitive, curveFractions: MSPyBentleyGeom.DoubleArray, normalizedConePoints: MSPyBentleyGeom.DPoint3dArray, localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform, boundedConeZ: bool) -> tuple:
        ...
    
    def IsCircular(self: MSPyBentleyGeom.DgnConeDetail, centerA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, rotMatrix: MSPyBentleyGeom.RotMatrix) -> tuple:
        """
        Return true (with supporting data) if the cone is circular.
        """
        ...
    
    def IsClosedVolume(self: MSPyBentleyGeom.DgnConeDetail) -> bool:
        """
        Test if this is a closed volume.
        """
        ...
    
    def IsCylinder(self: MSPyBentleyGeom.DgnConeDetail, centerA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        Return true (with supporting data) if the cone is a (constant radius)
        cylinder.
        """
        ...
    
    def IsRealCap(self: MSPyBentleyGeom.DgnConeDetail, select01: int) -> bool:
        """
        Test if caps are active and the indicated cap has nonzero radius.
        """
        ...
    
    def IsSameStructure(self: MSPyBentleyGeom.DgnConeDetail, other: ISolidPrimitive) -> bool:
        """
        Test for same type and structure (but no coordinate comparison)
        """
        ...
    
    def IsSameStructureAndGeometry(self: MSPyBentleyGeom.DgnConeDetail, other: ISolidPrimitive, tolerance: float) -> bool:
        """
        Test for same type, structure and coordinates.
        """
        ...
    
    def ParameterizationSign(self: MSPyBentleyGeom.DgnConeDetail) -> float:
        """
        Return +1 or -1 that matches the volume sign after integration over
        the parameter space.
        """
        ...
    
    @staticmethod
    def SetDetailCoordinatesFromFractionalizedConeCoordinates(detail: MSPyBentleyGeom.SolidLocationDetail, localuvw: MSPyBentleyGeom.DPoint3d, localToWorld: MSPyBentleyGeom.Transform, r0: float, r1: float) -> None:
        """
        set point, uv coordinates, and uv derivatives vectors
        """
        ...
    
    def SilhouetteCurves(self: MSPyBentleyGeom.DgnConeDetail, eyePoint: MSPyBentleyGeom.DPoint4d, curves: MSPyBentleyGeom.CurveVector) -> bool:
        """
        Return curves which are silhoutte curves OTHER than hard edges
        
        :returns:
        return false if not implemented. return true if implemented -- but
        curves may still be empty.
        """
        ...
    
    def TransformInPlace(self: MSPyBentleyGeom.DgnConeDetail, transform: MSPyBentleyGeom.Transform) -> bool:
        """
        Transform in place.
        """
        ...
    
    def TryGetConstructiveFrame(self: MSPyBentleyGeom.DgnConeDetail, localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform) -> bool:
        """
        Return coordinate system with 1) XY plane of base circle, origin at
        center. 2) Z perpendicular
        """
        ...
    
    def TryGetMaxUVLength(self: MSPyBentleyGeom.DgnConeDetail, indices: SolidLocationDetail.FaceIndices, uvLength: MSPyBentleyGeom.DVec2d) -> bool:
        """
        Compute the lengths of the longest u and v direction sections of a
        single face of a solid primitive.
        
        :param (input):
        indices selects face.
        
        :param (input):
        uvLength sizes in u, v directions.
        """
        ...
    
    def TryUVFractionToXYZ(self: MSPyBentleyGeom.DgnConeDetail, faceIndices: SolidLocationDetail.FaceIndices, uFraction: float, vFraction: float, xyz: MSPyBentleyGeom.DPoint3d, dXdu: MSPyBentleyGeom.DVec3d, dXdv: MSPyBentleyGeom.DVec3d) -> bool:
        """
        convert u,v fraction on specified face to xyz and derivatives.
        
        :param (input):
        faceIndices face selection indices
        
        :param (input):
        uFraction fractional coordinate in u direction.
        
        :param (input):
        vFraction fractional coordinate in v direction.
        
        :param (output):
        xyz point on face.
        
        :param (output):
        dXdu derivative of face point wrt uFraction.
        
        :param (output):
        dXdv derivative of face point wrt vFraction.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DgnConeDetail) -> None
        
        2. __init__(self: MSPyBentleyGeom.DgnConeDetail, centerA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, radiusA: float, radiusB: float, capped: bool) -> None
        
        3. __init__(self: MSPyBentleyGeom.DgnConeDetail, centerA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, axes: MSPyBentleyGeom.RotMatrix, radiusA: float, radiusB: float, capped: bool) -> None
        
        4. __init__(self: MSPyBentleyGeom.DgnConeDetail, centerA: MSPyBentleyGeom.DPoint3d, centerB: MSPyBentleyGeom.DPoint3d, vectorX: MSPyBentleyGeom.DVec3d, vectorY: MSPyBentleyGeom.DVec3d, radiusA: float, radiusB: float, capped: bool) -> None
        """
        ...
    
class DgnExtrusionDetail:
    """
    None
    """

    def AddCurveIntersections(*args, **kwargs):
        """
        Overloaded function.
        
        1. AddCurveIntersections(self: MSPyBentleyGeom.DgnExtrusionDetail, curves: MSPyBentleyGeom.CurveVector, curvePoints: MSPyBentleyGeom.CurveLocationDetailArray, solidPoints: MSPyBentleyGeom.SolidLocationDetailArray, messages: MSPyBentleyGeom.MeshAnnotationVector) -> None
        
        Compute intersections with curves and add to the data array.
        
        :param (input):
        curves
        
        :param [in,out]:
        curvePoints growing array of curve points.
        
        :param [in,out]:
        solidPoints growing array of solid points.
        
        :param [in,out]:
        messages array of error messages
        
        2. AddCurveIntersections(self: MSPyBentleyGeom.DgnExtrusionDetail, curves: MSPyBentleyGeom.ICurvePrimitive, curvePoints: MSPyBentleyGeom.CurveLocationDetailArray, solidPoints: MSPyBentleyGeom.SolidLocationDetailArray, messages: MSPyBentleyGeom.MeshAnnotationVector) -> None
        
        Compute intersections with curves and add to the data array.
        
        :param (input):
        curves
        
        :param [in,out]:
        curvePoints growing array of curve points.
        
        :param [in,out]:
        solidPoints growing array of solid points.
        
        :param [in,out]:
        messages array of error messages
        """
        ...
    
    def AddRayIntersections(self: MSPyBentleyGeom.DgnExtrusionDetail, pickData: MSPyBentleyGeom.SolidLocationDetailArray, ray: MSPyBentleyGeom.DRay3d, parentId: int, minParameter: float) -> None:
        """
        Compute intersections with a ray and add to the pickData.
        
        :param (input):
        ray origin and direction
        
        :param (input):
        minParameter smallest parameter of pick. (e.g. 0 for picking along
        a positive ray from an eyepoint)
        
        :param [in,out]:
        pickData growing array of picks.
        
        :param (input):
        parentId caller's id for this solid. Will be placed in each
        pickData entry has parentId.
        """
        ...
    
    def Clone(self: MSPyBentleyGeom.DgnExtrusionDetail) -> ISolidPrimitive:
        """
        Copy to a new (allocated) solid primitive.
        """
        ...
    
    def ClosestPoint(self: MSPyBentleyGeom.DgnExtrusionDetail, spacePoint: MSPyBentleyGeom.DPoint3d, pickDetail: MSPyBentleyGeom.SolidLocationDetail) -> bool:
        """
        :param (input):
        spacePoint search for point close to here and on the solid surface
        
        :param (output):
        pickDetail closest point data.
        
        :returns:
        false if not supported.
        """
        ...
    
    def ComputeSecondMomentAreaProducts(self: MSPyBentleyGeom.DgnExtrusionDetail, localToWorld: MSPyBentleyGeom.Transform, localProducts: MSPyBentleyGeom.DMatrix4d) -> bool:
        """
        Return the various integrated products for area moment calculations.
        The primitive is treated as a thin shell.
        
        :param (output):
        localToWorld transform from preferred system where the products
        are most easily computed to world.
        
        :param (output):
        localProducts integrated [xx xy xz x; xy yy yz y; xz yz zz z; x y
        z 1] dA
        
        :returns:
        false if unable to compute.
        """
        ...
    
    def ComputeSecondMomentVolumeProducts(self: MSPyBentleyGeom.DgnExtrusionDetail, localToWorld: MSPyBentleyGeom.Transform, localProducts: MSPyBentleyGeom.DMatrix4d) -> bool:
        """
        Return the various integrated products for moment calculations. The
        primitive is treated as a volume
        
        :param (output):
        localToWorld transform from preferred system where the products
        are most easily computed to world.
        
        :param (output):
        localProducts integrated [xx xy xz x; xy yy yz y; xz yz zz z; x y
        z 1] dA
        
        :returns:
        false if unable to compute.
        """
        ...
    
    def FractionToProfile(self: MSPyBentleyGeom.DgnExtrusionDetail, fraction: float) -> MSPyBentleyGeom.CurveVector:
        """
        Fractional profile curve
        """
        ...
    
    def GetConstantUSection(self: MSPyBentleyGeom.DgnExtrusionDetail, indices: SolidLocationDetail.FaceIndices, fraction: float) -> MSPyBentleyGeom.ICurvePrimitive:
        """
        Copy a section at constant u of a single face to a single
        ICurvePrimitive.
        
        :param (input):
        indices selects face
        
        :param (input):
        fraction u fraction for section curve
        """
        ...
    
    def GetConstantVSection(self: MSPyBentleyGeom.DgnExtrusionDetail, indices: SolidLocationDetail.FaceIndices, fraction: float) -> MSPyBentleyGeom.ICurvePrimitive:
        """
        Copy a section curve at constant v of a single face to a single
        ICurvePrimitive.
        
        :param (input):
        indices selects face
        
        :param (input):
        fraction v fraction for section curve
        """
        ...
    
    def GetFace(self: MSPyBentleyGeom.DgnExtrusionDetail, indices: SolidLocationDetail.FaceIndices) -> MSPyBentleyGeom.IGeometry:
        """
        Return a single face of the solid primitive
        
        :param indices:
        integer selectors for the face.
        """
        ...
    
    def GetFaceIndices(self: MSPyBentleyGeom.DgnExtrusionDetail, indices: MSPyBentleyGeom.FaceIndicesArray) -> None:
        """
        Fill a list of all possible face indices.
        
        :param (output):
        indices array of selectors for the faces.
        """
        ...
    
    def GetRange(*args, **kwargs):
        """
        Overloaded function.
        
        1. GetRange(self: MSPyBentleyGeom.DgnExtrusionDetail, range: MSPyBentleyGeom.DRange3d) -> bool
        
        Return range.
        
        2. GetRange(self: MSPyBentleyGeom.DgnExtrusionDetail, range: MSPyBentleyGeom.DRange3d, transform: MSPyBentleyGeom.Transform) -> bool
        
        Return range.
        """
        ...
    
    def IsClosedVolume(self: MSPyBentleyGeom.DgnExtrusionDetail) -> bool:
        """
        Test if this is a closed volume.
        """
        ...
    
    def IsSameStructure(self: MSPyBentleyGeom.DgnExtrusionDetail, other: ISolidPrimitive) -> bool:
        """
        Test for same type and structure (but no coordinate comparison)
        """
        ...
    
    def IsSameStructureAndGeometry(self: MSPyBentleyGeom.DgnExtrusionDetail, other: ISolidPrimitive, tolerance: float) -> bool:
        """
        Test for same type, structure and coordinates.
        """
        ...
    
    def SilhouetteCurves(self: MSPyBentleyGeom.DgnExtrusionDetail, eyePoint: MSPyBentleyGeom.DPoint4d, curves: MSPyBentleyGeom.CurveVector) -> bool:
        """
        Return curves which are silhoutte curves OTHER than hard edges
        
        :returns:
        return false if not implemented. return true if implemented -- but
        curves may still be empty.
        """
        ...
    
    def TransformInPlace(self: MSPyBentleyGeom.DgnExtrusionDetail, transform: MSPyBentleyGeom.Transform) -> bool:
        """
        Transform in place.
        """
        ...
    
    def TryGetConstructiveFrame(self: MSPyBentleyGeom.DgnExtrusionDetail, localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform) -> bool:
        """
        Return coordinate system based on any frenet frame for base curve
        vector, with yz reversed if necessary to make z sense match exgtusion
        vector.
        """
        ...
    
    def TryGetExtrusionFrame(self: MSPyBentleyGeom.DgnExtrusionDetail, localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform) -> bool:
        """
        Compute coordinate frames aligned with the extrusion vector.
        
        :param (output):
        localToWorld transform with orign at first point of base curve, z
        vector along extrusion direction, xy vectors arbitrary
        perpendiculars.
        
        :param (output):
        worldToLocal inverse of local to world
        """
        ...
    
    def TryGetMaxUVLength(self: MSPyBentleyGeom.DgnExtrusionDetail, indices: SolidLocationDetail.FaceIndices, uvLength: MSPyBentleyGeom.DVec2d) -> bool:
        """
        Compute the lengths of the longest u and v direction sections of a
        single face of a solid primitive.
        
        :param (input):
        indices selects face.
        
        :param (input):
        uvLength sizes in u, v directions.
        """
        ...
    
    def TryUVFractionToXYZ(self: MSPyBentleyGeom.DgnExtrusionDetail, faceIndices: SolidLocationDetail.FaceIndices, uFraction: float, vFraction: float, xyz: MSPyBentleyGeom.DPoint3d, dXdu: MSPyBentleyGeom.DVec3d, dXdv: MSPyBentleyGeom.DVec3d) -> bool:
        """
        convert u,v fraction on specified face to xyz and derivatives.
        
        :param (input):
        faceIndices face selection indices
        
        :param (input):
        uFraction fractional coordinate in u direction.
        
        :param (input):
        vFraction fractional coordinate in v direction.
        
        :param (output):
        xyz point on face.
        
        :param (output):
        dXdu derivative of face point wrt uFraction.
        
        :param (output):
        dXdv derivative of face point wrt vFraction.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DgnExtrusionDetail) -> None
        
        2. __init__(self: MSPyBentleyGeom.DgnExtrusionDetail, baseCurve: MSPyBentleyGeom.CurveVector, extrusionVector: MSPyBentleyGeom.DVec3d, capped: bool) -> None
        """
        ...
    
class DgnRotationalSweepDetail:
    """
    None
    """

    def AddCurveIntersections(*args, **kwargs):
        """
        Overloaded function.
        
        1. AddCurveIntersections(self: MSPyBentleyGeom.DgnRotationalSweepDetail, curves: MSPyBentleyGeom.CurveVector, curvePoints: MSPyBentleyGeom.CurveLocationDetailArray, solidPoints: MSPyBentleyGeom.SolidLocationDetailArray, messages: MSPyBentleyGeom.MeshAnnotationVector) -> None
        
        Compute intersections with curves and add to the data array.
        
        :param (input):
        curves
        
        :param [in,out]:
        curvePoints growing array of curve points.
        
        :param [in,out]:
        solidPoints growing array of solid points.
        
        :param [in,out]:
        messages array of error messages
        
        2. AddCurveIntersections(self: MSPyBentleyGeom.DgnRotationalSweepDetail, curves: MSPyBentleyGeom.ICurvePrimitive, curvePoints: MSPyBentleyGeom.CurveLocationDetailArray, solidPoints: MSPyBentleyGeom.SolidLocationDetailArray, messages: MSPyBentleyGeom.MeshAnnotationVector) -> None
        
        Compute intersections with curves and add to the data array.
        
        :param (input):
        curves
        
        :param [in,out]:
        curvePoints growing array of curve points.
        
        :param [in,out]:
        solidPoints growing array of solid points.
        
        :param [in,out]:
        messages array of error messages
        """
        ...
    
    def AddRayIntersections(self: MSPyBentleyGeom.DgnRotationalSweepDetail, pickData: MSPyBentleyGeom.SolidLocationDetailArray, ray: MSPyBentleyGeom.DRay3d, parentId: int, minParameter: float) -> None:
        """
        Compute intersections with a ray and add to the pickData.
        
        :param (input):
        ray origin and direction
        
        :param (input):
        minParameter smallest parameter of pick. (e.g. 0 for picking along
        a positive ray from an eyepoint)
        
        :param [in,out]:
        pickData growing array of picks.
        
        :param (input):
        parentId caller's id for this solid. Will be placed in each
        pickData entry has parentId.
        """
        ...
    
    def Clone(self: MSPyBentleyGeom.DgnRotationalSweepDetail) -> ISolidPrimitive:
        """
        Copy to a new (allocated) solid primitive.
        """
        ...
    
    def ClosestPoint(self: MSPyBentleyGeom.DgnRotationalSweepDetail, spacePoint: MSPyBentleyGeom.DPoint3d, pickDetail: MSPyBentleyGeom.SolidLocationDetail) -> bool:
        """
        :param (input):
        spacePoint search for point close to here and on the solid surface
        
        :param (output):
        pickDetail closest point data.
        
        :returns:
        false if not supported.
        """
        ...
    
    def ComputeSecondMomentAreaProducts(self: MSPyBentleyGeom.DgnRotationalSweepDetail, localToWorld: MSPyBentleyGeom.Transform, localProducts: MSPyBentleyGeom.DMatrix4d) -> bool:
        """
        Return the various integrated products for area moment calculations.
        The primitive is treated as a thin shell.
        
        :param (output):
        localToWorld transform from preferred system where the products
        are most easily computed to world.
        
        :param (output):
        localProducts integrated [xx xy xz x; xy yy yz y; xz yz zz z; x y
        z 1] dA
        
        :returns:
        false if unable to compute.
        """
        ...
    
    def ComputeSecondMomentVolumeProducts(self: MSPyBentleyGeom.DgnRotationalSweepDetail, localToWorld: MSPyBentleyGeom.Transform, localProducts: MSPyBentleyGeom.DMatrix4d) -> bool:
        """
        Return the various integrated products for moment calculations. The
        primitive is treated as a volume
        
        :param (output):
        localToWorld transform from preferred system where the products
        are most easily computed to world.
        
        :param (output):
        localProducts integrated [xx xy xz x; xy yy yz y; xz yz zz z; x y
        z 1] dA
        
        :returns:
        false if unable to compute.
        """
        ...
    
    @staticmethod
    def ComputeVRuleCount(sweepRadians: float, numVRulesFullSweep: int = 4) -> int:
        """
        Compute v rule count for a given sweep angle and desired number of v
        rules for a full sweep.
        """
        ...
    
    def GetConstantUSection(self: MSPyBentleyGeom.DgnRotationalSweepDetail, indices: SolidLocationDetail.FaceIndices, fraction: float) -> MSPyBentleyGeom.ICurvePrimitive:
        """
        Copy a section at constant u of a single face to a single
        ICurvePrimitive.
        
        :param (input):
        indices selects face
        
        :param (input):
        fraction u fraction for section curve
        """
        ...
    
    def GetConstantVSection(self: MSPyBentleyGeom.DgnRotationalSweepDetail, indices: SolidLocationDetail.FaceIndices, fraction: float) -> MSPyBentleyGeom.ICurvePrimitive:
        """
        Copy a section curve at constant v of a single face to a single
        ICurvePrimitive.
        
        :param (input):
        indices selects face
        
        :param (input):
        fraction v fraction for section curve
        """
        ...
    
    def GetFace(self: MSPyBentleyGeom.DgnRotationalSweepDetail, indices: SolidLocationDetail.FaceIndices) -> MSPyBentleyGeom.IGeometry:
        """
        Return a single face of the solid primitive
        
        :param indices:
        integer selectors for the face.
        """
        ...
    
    def GetFaceIndices(self: MSPyBentleyGeom.DgnRotationalSweepDetail, indices: MSPyBentleyGeom.FaceIndicesArray) -> None:
        """
        Fill a list of all possible face indices.
        
        :param (output):
        indices array of selectors for the faces.
        """
        ...
    
    def GetRadius(self: MSPyBentleyGeom.DgnRotationalSweepDetail, type: MSPyBentleyGeom.DgnRotationalSweepDetail.RadiusType) -> tuple:
        """
        Return the radius
        
        :param (output):
        radius
        
        :param (input):
        type of radius.
        """
        ...
    
    def GetRange(*args, **kwargs):
        """
        Overloaded function.
        
        1. GetRange(self: MSPyBentleyGeom.DgnRotationalSweepDetail, range: MSPyBentleyGeom.DRange3d) -> bool
        
        Return range.
        
        2. GetRange(self: MSPyBentleyGeom.DgnRotationalSweepDetail, range: MSPyBentleyGeom.DRange3d, transform: MSPyBentleyGeom.Transform) -> bool
        
        Return range.
        """
        ...
    
    def GetTransforms(self: MSPyBentleyGeom.DgnRotationalSweepDetail, localTransform: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform) -> bool:
        """
        return transforms for the coordinate frame with z axis on the line of
        rotation.
        
        :param (output):
        localToWorld translation part is is a point on the axis; z
        direction is the rotation axis.
        
        :param (output):
        worldToLocal inverse transform.
        """
        ...
    
    def GetVFractionTransform(self: MSPyBentleyGeom.DgnRotationalSweepDetail, vFraction: float, transform: MSPyBentleyGeom.Transform, derivativeTransform: MSPyBentleyGeom.Transform) -> bool:
        """
        Get transform from base cap to fractional v position.
        
        :param (output):
        transform transform to rotate a point.
        
        :param (output):
        derivativeTransform Derivative with respect to vFraction. The
        output of derivativeTransform * xyz is a vector, not a point !!!
        (If viewed as a 4x4 matrix, its ww entry is zero)
        
        :param (input):
        vFraction fraction of sweep angle.
        """
        ...
    
    def GetVRuledCount(self: MSPyBentleyGeom.DgnRotationalSweepDetail) -> int:
        ...
    
    def HasRealCaps(self: MSPyBentleyGeom.DgnRotationalSweepDetail) -> bool:
        """
        Return true if capped and incomplete sweep.
        """
        ...
    
    def IsClosedVolume(self: MSPyBentleyGeom.DgnRotationalSweepDetail) -> bool:
        """
        Test if this is a closed volume.
        """
        ...
    
    def IsSameStructure(self: MSPyBentleyGeom.DgnRotationalSweepDetail, other: ISolidPrimitive) -> bool:
        """
        Test for same type and structure (but no coordinate comparison)
        """
        ...
    
    def IsSameStructureAndGeometry(self: MSPyBentleyGeom.DgnRotationalSweepDetail, other: ISolidPrimitive, tolerance: float) -> bool:
        """
        Test for same type, structure and coordinates.
        """
        ...
    
    class RadiusType:
        """
        Members:
        
        eMinimum
        
        eMaximum
        
        eCentroidal
        """
    
        def __init__(self: MSPyBentleyGeom.DgnRotationalSweepDetail.RadiusType, value: int) -> None:
            ...
        
        eCentroidal: RadiusType
        
        eMaximum: RadiusType
        
        eMinimum: RadiusType
        
        @property
        def name(self: handle) -> str:
            ...
        
        @property
        def value(arg0: MSPyBentleyGeom.DgnRotationalSweepDetail.RadiusType) -> int:
            ...
        
    def SetRadius(self: MSPyBentleyGeom.DgnRotationalSweepDetail, radius: float, type: MSPyBentleyGeom.DgnRotationalSweepDetail.RadiusType) -> bool:
        """
        :param (input):
        radius
        
        :param (input):
        type of radius.
        """
        ...
    
    def SetVRuledCount(self: MSPyBentleyGeom.DgnRotationalSweepDetail, numVRules: int) -> None:
        ...
    
    def SilhouetteCurves(self: MSPyBentleyGeom.DgnRotationalSweepDetail, eyePoint: MSPyBentleyGeom.DPoint4d, curves: MSPyBentleyGeom.CurveVector) -> bool:
        """
        Return curves which are silhoutte curves OTHER than hard edges
        
        :returns:
        return false if not implemented. return true if implemented -- but
        curves may still be empty.
        """
        ...
    
    def TransformInPlace(self: MSPyBentleyGeom.DgnRotationalSweepDetail, transform: MSPyBentleyGeom.Transform) -> bool:
        """
        Transform in place.
        """
        ...
    
    def TryGetConstructiveFrame(self: MSPyBentleyGeom.DgnRotationalSweepDetail, localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform) -> bool:
        """
        Return coordinate system of 1) Z axis along rotation 2) X towards base
        curve extreme point.
        """
        ...
    
    def TryGetMaxUVLength(self: MSPyBentleyGeom.DgnRotationalSweepDetail, indices: SolidLocationDetail.FaceIndices, uvLength: MSPyBentleyGeom.DVec2d) -> bool:
        """
        Compute the lengths of the longest u and v direction sections of a
        single face of a solid primitive.
        
        :param (input):
        indices selects face.
        
        :param (input):
        uvLength sizes in u, v directions.
        """
        ...
    
    def TryGetRotationAxis(self: MSPyBentleyGeom.DgnRotationalSweepDetail, center: MSPyBentleyGeom.DPoint3d, axis: MSPyBentleyGeom.DVec3d) -> tuple:
        """
        Get the axis of rotation, negated if necessary to force a positive
        sweep angle.
        
        :param center:
        (output) center of rotation.
        
        :param axis:
        (output) axis of rotation.
        
        :param sweepRadians:
        (output) angle of rotation.
        """
        ...
    
    def TryUVFractionToXYZ(self: MSPyBentleyGeom.DgnRotationalSweepDetail, faceIndices: SolidLocationDetail.FaceIndices, uFraction: float, vFraction: float, xyz: MSPyBentleyGeom.DPoint3d, dXdu: MSPyBentleyGeom.DVec3d, dXdv: MSPyBentleyGeom.DVec3d) -> bool:
        """
        convert u,v fraction on specified face to xyz and derivatives.
        
        :param (input):
        faceIndices face selection indices
        
        :param (input):
        uFraction fractional coordinate in u direction.
        
        :param (input):
        vFraction fractional coordinate in v direction.
        
        :param (output):
        xyz point on face.
        
        :param (output):
        dXdu derivative of face point wrt uFraction.
        
        :param (output):
        dXdv derivative of face point wrt vFraction.
        """
        ...
    
    def VFractionToProfile(self: MSPyBentleyGeom.DgnRotationalSweepDetail, fraction: float) -> MSPyBentleyGeom.CurveVector:
        """
        Fractional profile curve
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DgnRotationalSweepDetail) -> None
        
        2. __init__(self: MSPyBentleyGeom.DgnRotationalSweepDetail, baseCurve: MSPyBentleyGeom.CurveVector, center: MSPyBentleyGeom.DPoint3d, axis: MSPyBentleyGeom.DVec3d, sweepAngle: float, capped: bool) -> None
        """
        ...
    
    eCentroidal: RadiusType
    
    eMaximum: RadiusType
    
    eMinimum: RadiusType
    
class DgnRuledSweepDetail:
    """
    None
    """

    def AddCurveIntersections(*args, **kwargs):
        """
        Overloaded function.
        
        1. AddCurveIntersections(self: MSPyBentleyGeom.DgnRuledSweepDetail, curves: MSPyBentleyGeom.CurveVector, curvePoints: MSPyBentleyGeom.CurveLocationDetailArray, solidPoints: MSPyBentleyGeom.SolidLocationDetailArray, messages: MSPyBentleyGeom.MeshAnnotationVector) -> None
        
        Compute intersections with curves and add to the data array.
        
        :param (input):
        curves
        
        :param [in,out]:
        curvePoints growing array of curve points.
        
        :param [in,out]:
        solidPoints growing array of solid points.
        
        :param [in,out]:
        messages array of error messages
        
        2. AddCurveIntersections(self: MSPyBentleyGeom.DgnRuledSweepDetail, curves: MSPyBentleyGeom.ICurvePrimitive, curvePoints: MSPyBentleyGeom.CurveLocationDetailArray, solidPoints: MSPyBentleyGeom.SolidLocationDetailArray, messages: MSPyBentleyGeom.MeshAnnotationVector) -> None
        
        Compute intersections with curves and add to the data array.
        
        :param (input):
        curves
        
        :param [in,out]:
        curvePoints growing array of curve points.
        
        :param [in,out]:
        solidPoints growing array of solid points.
        
        :param [in,out]:
        messages array of error messages
        """
        ...
    
    def AddRayIntersections(self: MSPyBentleyGeom.DgnRuledSweepDetail, pickData: MSPyBentleyGeom.SolidLocationDetailArray, ray: MSPyBentleyGeom.DRay3d, parentId: int, minParameter: float) -> None:
        """
        Compute intersections with a ray and add to the pickData.
        
        :param (input):
        ray origin and direction
        
        :param (input):
        minParameter smallest parameter of pick. (e.g. 0 for picking along
        a positive ray from an eyepoint)
        
        :param [in,out]:
        pickData growing array of picks.
        
        :param (input):
        parentId caller's id for this solid. Will be placed in each
        pickData entry has parentId.
        """
        ...
    
    def AddSection(self: MSPyBentleyGeom.DgnRuledSweepDetail, section: MSPyBentleyGeom.CurveVector) -> None:
        """
        Add (capture) a section.
        """
        ...
    
    def Clone(self: MSPyBentleyGeom.DgnRuledSweepDetail) -> ISolidPrimitive:
        """
        Copy to a new (allocated) solid primitive.
        """
        ...
    
    def ClosestPoint(self: MSPyBentleyGeom.DgnRuledSweepDetail, spacePoint: MSPyBentleyGeom.DPoint3d, pickDetail: MSPyBentleyGeom.SolidLocationDetail) -> bool:
        """
        :param (input):
        spacePoint search for point close to here and on the solid surface
        
        :param (output):
        pickDetail closest point data.
        
        :returns:
        false if not supported.
        """
        ...
    
    def ComputeSecondMomentAreaProducts(self: MSPyBentleyGeom.DgnRuledSweepDetail, localToWorld: MSPyBentleyGeom.Transform, localProducts: MSPyBentleyGeom.DMatrix4d) -> bool:
        """
        Return the various integrated products for area moment calculations.
        The primitive is treated as a thin shell.
        
        :param (output):
        localToWorld transform from preferred system where the products
        are most easily computed to world.
        
        :param (output):
        localProducts integrated [xx xy xz x; xy yy yz y; xz yz zz z; x y
        z 1] dA
        
        :returns:
        false if unable to compute.
        """
        ...
    
    def ComputeSecondMomentVolumeProducts(self: MSPyBentleyGeom.DgnRuledSweepDetail, localToWorld: MSPyBentleyGeom.Transform, localProducts: MSPyBentleyGeom.DMatrix4d) -> bool:
        """
        Return the various integrated products for moment calculations. The
        primitive is treated as a volume
        
        :param (output):
        localToWorld transform from preferred system where the products
        are most easily computed to world.
        
        :param (output):
        localProducts integrated [xx xy xz x; xy yy yz y; xz yz zz z; x y
        z 1] dA
        
        :returns:
        false if unable to compute.
        """
        ...
    
    def GetConstantUSection(self: MSPyBentleyGeom.DgnRuledSweepDetail, indices: SolidLocationDetail.FaceIndices, fraction: float) -> MSPyBentleyGeom.ICurvePrimitive:
        """
        Copy a section at constant u of a single face to a single
        ICurvePrimitive.
        
        :param (input):
        indices selects face
        
        :param (input):
        fraction u fraction for section curve
        """
        ...
    
    def GetConstantVSection(self: MSPyBentleyGeom.DgnRuledSweepDetail, indices: SolidLocationDetail.FaceIndices, fraction: float) -> MSPyBentleyGeom.ICurvePrimitive:
        """
        Copy a section curve at constant v of a single face to a single
        ICurvePrimitive.
        
        :param (input):
        indices selects face
        
        :param (input):
        fraction v fraction for section curve
        """
        ...
    
    def GetFace(self: MSPyBentleyGeom.DgnRuledSweepDetail, indices: SolidLocationDetail.FaceIndices) -> MSPyBentleyGeom.IGeometry:
        """
        Return a single face of the solid primitive
        
        :param indices:
        integer selectors for the face. <remarks>Face orientation
        convention pre> ul> li>There is a natural " forward " direction
        along section curves. li>There is a natural " direction " to the
        (swept) side faces. (e.g. extrusion vector, positive rotation,
        rule line direction) li>The cross product of the curve direction
        and sweep direction is the outward normal for side faces. li>Hence
        base section is REVERSED when used for the Cap0 face. li>Hence the
        base section is NOT reversed when used for the Cap1 face. ul> pre>
        remarks
        """
        ...
    
    def GetFaceIndices(self: MSPyBentleyGeom.DgnRuledSweepDetail, indices: MSPyBentleyGeom.FaceIndicesArray) -> None:
        """
        Fill a list of all possible face indices.
        
        :param (output):
        indices array of selectors for the faces.
        """
        ...
    
    def GetRange(*args, **kwargs):
        """
        Overloaded function.
        
        1. GetRange(self: MSPyBentleyGeom.DgnRuledSweepDetail, range: MSPyBentleyGeom.DRange3d) -> bool
        
        Return range.
        
        2. GetRange(self: MSPyBentleyGeom.DgnRuledSweepDetail, range: MSPyBentleyGeom.DRange3d, transform: MSPyBentleyGeom.Transform) -> bool
        
        Return range.
        """
        ...
    
    def IsClosedVolume(self: MSPyBentleyGeom.DgnRuledSweepDetail) -> bool:
        """
        Test if this is a closed volume.
        """
        ...
    
    def IsSameStructure(self: MSPyBentleyGeom.DgnRuledSweepDetail, other: ISolidPrimitive) -> bool:
        """
        Test for same type and structure (but no coordinate comparison)
        """
        ...
    
    def IsSameStructureAndGeometry(self: MSPyBentleyGeom.DgnRuledSweepDetail, other: ISolidPrimitive, tolerance: float) -> bool:
        """
        Test for same type, structure and coordinates.
        """
        ...
    
    def SilhouetteCurves(self: MSPyBentleyGeom.DgnRuledSweepDetail, eyePoint: MSPyBentleyGeom.DPoint4d, curves: MSPyBentleyGeom.CurveVector) -> bool:
        """
        Return curves which are silhoutte curves OTHER than hard edges
        
        :returns:
        return false if not implemented. return true if implemented -- but
        curves may still be empty.
        """
        ...
    
    def TransformInPlace(self: MSPyBentleyGeom.DgnRuledSweepDetail, transform: MSPyBentleyGeom.Transform) -> bool:
        """
        Transform in place.
        """
        ...
    
    def TryGetConstructiveFrame(self: MSPyBentleyGeom.DgnRuledSweepDetail, localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform) -> bool:
        """
        Return coordinate system (LOCAL_COORDINATES_UnitAxesAtStart) for base
        curve vector.
        """
        ...
    
    def TryGetCurvePair(self: MSPyBentleyGeom.DgnRuledSweepDetail, indices: SolidLocationDetail.FaceIndices, curveA: MSPyBentleyGeom.ICurvePrimitive, curveB: MSPyBentleyGeom.ICurvePrimitive) -> bool:
        """
        Get the lower and upper curves of a specified face.
        
        :param (input):
        indices face indices
        
        :param (output):
        curveA lower curve of face
        
        :param (output):
        curveB upper curve of face
        
        :returns:
        false if indices is not a valid ruled face. (Caps return false)
        """
        ...
    
    def TryGetMaxUVLength(self: MSPyBentleyGeom.DgnRuledSweepDetail, indices: SolidLocationDetail.FaceIndices, uvLength: MSPyBentleyGeom.DVec2d) -> bool:
        """
        Compute the lengths of the longest u and v direction sections of a
        single face of a solid primitive.
        
        :param (input):
        indices selects face.
        
        :param (input):
        uvLength sizes in u, v directions.
        """
        ...
    
    def TryUVFractionToXYZ(self: MSPyBentleyGeom.DgnRuledSweepDetail, faceIndices: SolidLocationDetail.FaceIndices, uFraction: float, vFraction: float, xyz: MSPyBentleyGeom.DPoint3d, dXdu: MSPyBentleyGeom.DVec3d, dXdv: MSPyBentleyGeom.DVec3d) -> bool:
        """
        convert u,v fraction on specified face to xyz and derivatives.
        
        :param (input):
        faceIndices face selection indices
        
        :param (input):
        uFraction fractional coordinate in u direction.
        
        :param (input):
        vFraction fractional coordinate in v direction.
        
        :param (output):
        xyz point on face.
        
        :param (output):
        dXdu derivative of face point wrt uFraction.
        
        :param (output):
        dXdv derivative of face point wrt vFraction.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DgnRuledSweepDetail, sectionCurves: MSPyBentleyGeom.CurveVectorPtrArray, capped: bool) -> None
        
        2. __init__(self: MSPyBentleyGeom.DgnRuledSweepDetail, sectionA: MSPyBentleyGeom.CurveVector, sectionB: MSPyBentleyGeom.CurveVector, capped: bool) -> None
        
        3. __init__(self: MSPyBentleyGeom.DgnRuledSweepDetail) -> None
        """
        ...
    
class DgnSphereDetail:
    """
    None
    """

    def AddCurveIntersections(*args, **kwargs):
        """
        Overloaded function.
        
        1. AddCurveIntersections(self: MSPyBentleyGeom.DgnSphereDetail, curves: MSPyBentleyGeom.CurveVector, curvePoints: MSPyBentleyGeom.CurveLocationDetailArray, solidPoints: MSPyBentleyGeom.SolidLocationDetailArray, messages: MSPyBentleyGeom.MeshAnnotationVector) -> None
        
        Compute intersections with curves and add to the data array.
        
        :param (input):
        curves
        
        :param [in,out]:
        curvePoints growing array of curve points.
        
        :param [in,out]:
        solidPoints growing array of solid points.
        
        :param [in,out]:
        messages array of error messages
        
        2. AddCurveIntersections(self: MSPyBentleyGeom.DgnSphereDetail, curves: MSPyBentleyGeom.ICurvePrimitive, curvePoints: MSPyBentleyGeom.CurveLocationDetailArray, solidPoints: MSPyBentleyGeom.SolidLocationDetailArray, messages: MSPyBentleyGeom.MeshAnnotationVector) -> None
        
        Compute intersections with curves and add to the data array.
        
        :param (input):
        curves
        
        :param [in,out]:
        curvePoints growing array of curve points.
        
        :param [in,out]:
        solidPoints growing array of solid points.
        
        :param [in,out]:
        messages array of error messages
        """
        ...
    
    def AddRayIntersections(self: MSPyBentleyGeom.DgnSphereDetail, pickData: MSPyBentleyGeom.SolidLocationDetailArray, ray: MSPyBentleyGeom.DRay3d, parentId: int, minParameter: float) -> None:
        """
        Compute intersections with a ray and add to the pickData.
        
        :param (input):
        ray origin and direction
        
        :param (input):
        minParameter smallest parameter of pick. (e.g. 0 for picking along
        a positive ray from an eyepoint)
        
        :param [in,out]:
        pickData growing array of picks.
        
        :param (input):
        parentId caller's id for this solid. Will be placed in each
        pickData entry has parentId.
        """
        ...
    
    def Clone(self: MSPyBentleyGeom.DgnSphereDetail) -> ISolidPrimitive:
        """
        Copy to a new (allocated) solid primitive.
        """
        ...
    
    def ClosestPoint(self: MSPyBentleyGeom.DgnSphereDetail, spacePoint: MSPyBentleyGeom.DPoint3d, pickDetail: MSPyBentleyGeom.SolidLocationDetail) -> bool:
        """
        :param (input):
        spacePoint search for point close to here and on the solid surface
        
        :param (output):
        pickDetail closest point data.
        
        :returns:
        false if not supported.
        """
        ...
    
    def ComputeSecondMomentAreaProducts(self: MSPyBentleyGeom.DgnSphereDetail, localToWorld: MSPyBentleyGeom.Transform, localProducts: MSPyBentleyGeom.DMatrix4d) -> bool:
        """
        Return the various integrated products for area moment calculations.
        The primitive is treated as a thin shell.
        
        :param (output):
        localToWorld transform from preferred system where the products
        are most easily computed to world.
        
        :param (output):
        localProducts integrated [xx xy xz x; xy yy yz y; xz yz zz z; x y
        z 1] dA
        
        :returns:
        false if unable to compute.
        """
        ...
    
    def ComputeSecondMomentVolumeProducts(self: MSPyBentleyGeom.DgnSphereDetail, localToWorld: MSPyBentleyGeom.Transform, localProducts: MSPyBentleyGeom.DMatrix4d) -> bool:
        """
        Return the various integrated products for moment calculations. The
        primitive is treated as a volume
        
        :param (output):
        localToWorld transform from preferred system where the products
        are most easily computed to world.
        
        :param (output):
        localProducts integrated [xx xy xz x; xy yy yz y; xz yz zz z; x y
        z 1] dA
        
        :returns:
        false if unable to compute.
        """
        ...
    
    def GetConstantUSection(self: MSPyBentleyGeom.DgnSphereDetail, indices: SolidLocationDetail.FaceIndices, fraction: float) -> MSPyBentleyGeom.ICurvePrimitive:
        """
        Copy a section at constant u of a single face to a single
        ICurvePrimitive.
        
        :param (input):
        indices selects face
        
        :param (input):
        fraction u fraction for section curve
        """
        ...
    
    def GetConstantVSection(self: MSPyBentleyGeom.DgnSphereDetail, indices: SolidLocationDetail.FaceIndices, fraction: float) -> MSPyBentleyGeom.ICurvePrimitive:
        """
        Copy a section curve at constant v of a single face to a single
        ICurvePrimitive.
        
        :param (input):
        indices selects face
        
        :param (input):
        fraction v fraction for section curve
        """
        ...
    
    def GetFace(self: MSPyBentleyGeom.DgnSphereDetail, indices: SolidLocationDetail.FaceIndices) -> MSPyBentleyGeom.IGeometry:
        """
        Return a single face of the solid primitive
        
        :param indices:
        integer selectors for the face.
        """
        ...
    
    def GetFaceIndices(self: MSPyBentleyGeom.DgnSphereDetail, indices: MSPyBentleyGeom.FaceIndicesArray) -> None:
        """
        Fill a list of all possible face indices.
        
        :param (output):
        indices array of selectors for the faces.
        """
        ...
    
    def GetNonUniformTransforms(self: MSPyBentleyGeom.DgnSphereDetail, localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform) -> bool:
        """
        Return (nonuniform) transforms for normalized system where sphere
        radius is 1.
        """
        ...
    
    def GetRange(*args, **kwargs):
        """
        Overloaded function.
        
        1. GetRange(self: MSPyBentleyGeom.DgnSphereDetail, range: MSPyBentleyGeom.DRange3d) -> bool
        
        Return range.
        
        2. GetRange(self: MSPyBentleyGeom.DgnSphereDetail, range: MSPyBentleyGeom.DRange3d, transform: MSPyBentleyGeom.Transform) -> bool
        
        Return range.
        """
        ...
    
    def GetSweepLimits(self: MSPyBentleyGeom.DgnSphereDetail, forceSweepNorth: bool) -> tuple:
        """
        :param (output):
        latitude0 latitude at start of sweep.
        
        :param (output):
        latitude1 latitude at end of sweep.
        
        :param (output):
        z0 z coordinate at start of sweep.
        
        :param (output):
        z1 z coordinate at end of sweep.
        
        :param (input):
        forceSweepNorth true to exchange if necessary to make sweep south
        to north.
        
        :returns:
        false if no sweep limits (full sphere)
        """
        ...
    
    def GetTransforms(self: MSPyBentleyGeom.DgnSphereDetail, localTransform: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform) -> bool:
        """
        Return transforms for unit-axis system.
        """
        ...
    
    def IntersectBoundedArc(self: MSPyBentleyGeom.DgnSphereDetail, arc: MSPyBentleyGeom.DEllipse3d, arcFractions: MSPyBentleyGeom.DoubleArray, normalizedConePoints: MSPyBentleyGeom.DPoint3dArray, localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform, boundedZ: bool) -> None:
        """
        Return all intersection points of an (unbounded) arc with the sphere.
        Returned data is the detailed local coordinates, with additional data
        to relate it back to world.
        """
        ...
    
    def IsClosedVolume(self: MSPyBentleyGeom.DgnSphereDetail) -> bool:
        """
        Test if this is a closed volume.
        """
        ...
    
    def IsRealCap(self: MSPyBentleyGeom.DgnSphereDetail, select01: int) -> bool:
        """
        Test if caps are active and the indicated cap is not at a pole
        """
        ...
    
    def IsSameStructure(self: MSPyBentleyGeom.DgnSphereDetail, other: ISolidPrimitive) -> bool:
        """
        Test for same type and structure (but no coordinate comparison)
        """
        ...
    
    def IsSameStructureAndGeometry(self: MSPyBentleyGeom.DgnSphereDetail, other: ISolidPrimitive, tolerance: float) -> bool:
        """
        Test for same type, structure and coordinates.
        """
        ...
    
    def IsTrueRotationAroundZ(self: MSPyBentleyGeom.DgnSphereDetail, center: MSPyBentleyGeom.DPoint3d, unitX: MSPyBentleyGeom.DVec3d, unitY: MSPyBentleyGeom.DVec3d, unitZ: MSPyBentleyGeom.DVec3d) -> tuple:
        """
        Return true (with supporting local coordinate frame) iff this is a
        rotation around the Z axis.
        """
        ...
    
    def IsTrueSphere(self: MSPyBentleyGeom.DgnSphereDetail, center: MSPyBentleyGeom.DPoint3d, axes: MSPyBentleyGeom.RotMatrix) -> tuple:
        """
        Return true (with supporting data) iff this is a (complete) true
        sphere.
        """
        ...
    
    def LatitudeToVFraction(self: MSPyBentleyGeom.DgnSphereDetail, latitude: float) -> float:
        """
        Compute the v fraction of latitude
        """
        ...
    
    def LongitudeToUFraction(self: MSPyBentleyGeom.DgnSphereDetail, longitude: float) -> float:
        """
        Compute the u fraction of longitude
        """
        ...
    
    def ParameterizationSign(self: MSPyBentleyGeom.DgnSphereDetail) -> float:
        """
        Return +1 or -1 that matches the volume sign after integration over
        the parameter space.
        """
        ...
    
    @staticmethod
    def SetDetailUVFromUnitSphereCoordinates(detail: MSPyBentleyGeom.SolidLocationDetail, localuvw: MSPyBentleyGeom.DPoint3d, localToWorld: MSPyBentleyGeom.Transform, startLatitude: float, sweepLatitude: float) -> None:
        """
        set point, uv coordinates, and uv derivatives vectors
        """
        ...
    
    def SilhouetteCurves(self: MSPyBentleyGeom.DgnSphereDetail, eyePoint: MSPyBentleyGeom.DPoint4d, curves: MSPyBentleyGeom.CurveVector) -> bool:
        """
        Return curves which are silhoutte curves OTHER than hard edges
        
        :returns:
        return false if not implemented. return true if implemented -- but
        curves may still be empty.
        """
        ...
    
    def TransformInPlace(self: MSPyBentleyGeom.DgnSphereDetail, transform: MSPyBentleyGeom.Transform) -> bool:
        """
        Transform in place.
        """
        ...
    
    def TryGetConstructiveFrame(self: MSPyBentleyGeom.DgnSphereDetail, localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform) -> bool:
        """
        Return coordinate system with 1) XY plane in equatorial plane, origin
        at sphere center. 2) Z perpendicular
        """
        ...
    
    def TryGetMaxUVLength(self: MSPyBentleyGeom.DgnSphereDetail, indices: SolidLocationDetail.FaceIndices, uvLength: MSPyBentleyGeom.DVec2d) -> bool:
        """
        Compute the lengths of the longest u and v direction sections of a
        single face of a solid primitive.
        
        :param (input):
        indices selects face.
        
        :param (input):
        uvLength sizes in u, v directions.
        """
        ...
    
    def TryGetRotationAxis(self: MSPyBentleyGeom.DgnSphereDetail, center: MSPyBentleyGeom.DPoint3d, axes: MSPyBentleyGeom.DVec3d) -> tuple:
        """
        :param center:
        (output) center of rotation.
        
        :param axis:
        (output) axis of rotation.
        
        :param sweepRadians:
        (output) angle of rotation.
        """
        ...
    
    def TryUVFractionToXYZ(self: MSPyBentleyGeom.DgnSphereDetail, faceIndices: SolidLocationDetail.FaceIndices, uFraction: float, vFraction: float, xyz: MSPyBentleyGeom.DPoint3d, dXdu: MSPyBentleyGeom.DVec3d, dXdv: MSPyBentleyGeom.DVec3d) -> bool:
        """
        convert u,v fraction on specified face to xyz and derivatives.
        
        :param (input):
        faceIndices face selection indices
        
        :param (input):
        uFraction fractional coordinate in u direction.
        
        :param (input):
        vFraction fractional coordinate in v direction.
        
        :param (output):
        xyz point on face.
        
        :param (output):
        dXdu derivative of face point wrt uFraction.
        
        :param (output):
        dXdv derivative of face point wrt vFraction.
        """
        ...
    
    def UFractionToVSectionDEllipse3d(self: MSPyBentleyGeom.DgnSphereDetail, fraction: float) -> MSPyBentleyGeom.DEllipse3d:
        """
        Return the ellipse on the meridian at fractional position.
        """
        ...
    
    def VFractionToLatitude(self: MSPyBentleyGeom.DgnSphereDetail, v: float) -> float:
        """
        Compute the latitude at v fraction.
        """
        ...
    
    def VFractionToUSectionDEllipse3d(self: MSPyBentleyGeom.DgnSphereDetail, fraction: float) -> MSPyBentleyGeom.DEllipse3d:
        """
        Return the ellipse on the parallel at fractional position.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DgnSphereDetail) -> None
        
        2. __init__(self: MSPyBentleyGeom.DgnSphereDetail, center: MSPyBentleyGeom.DPoint3d, radius: float) -> None
        
        3. __init__(self: MSPyBentleyGeom.DgnSphereDetail, center: MSPyBentleyGeom.DPoint3d, axes: MSPyBentleyGeom.RotMatrix, radius: float) -> None
        
        4. __init__(self: MSPyBentleyGeom.DgnSphereDetail, center: MSPyBentleyGeom.DPoint3d, vectorX: MSPyBentleyGeom.DVec3d, vectorZ: MSPyBentleyGeom.DVec3d, radiusXY: float, radiusZ: float, startLatitude: float, latitudeSweep: float, capped: bool) -> None
        """
        ...
    
class DgnTorusPipeDetail:
    """
    None
    """

    def AddCurveIntersections(*args, **kwargs):
        """
        Overloaded function.
        
        1. AddCurveIntersections(self: MSPyBentleyGeom.DgnTorusPipeDetail, curves: MSPyBentleyGeom.CurveVector, curvePoints: MSPyBentleyGeom.CurveLocationDetailArray, solidPoints: MSPyBentleyGeom.SolidLocationDetailArray, messages: MSPyBentleyGeom.MeshAnnotationVector) -> None
        
        Compute intersections with curves and add to the data array.
        
        :param (input):
        curves
        
        :param [in,out]:
        curvePoints growing array of curve points.
        
        :param [in,out]:
        solidPoints growing array of solid points.
        
        :param [in,out]:
        messages array of error messages
        
        2. AddCurveIntersections(self: MSPyBentleyGeom.DgnTorusPipeDetail, curves: MSPyBentleyGeom.ICurvePrimitive, curvePoints: MSPyBentleyGeom.CurveLocationDetailArray, solidPoints: MSPyBentleyGeom.SolidLocationDetailArray, messages: MSPyBentleyGeom.MeshAnnotationVector) -> None
        
        Compute intersections with curves and add to the data array.
        
        :param (input):
        curves
        
        :param [in,out]:
        curvePoints growing array of curve points.
        
        :param [in,out]:
        solidPoints growing array of solid points.
        
        :param [in,out]:
        messages array of error messages
        """
        ...
    
    def AddRayIntersections(self: MSPyBentleyGeom.DgnTorusPipeDetail, pickData: MSPyBentleyGeom.SolidLocationDetailArray, ray: MSPyBentleyGeom.DRay3d, parentId: int, minParameter: float) -> None:
        """
        Compute intersections with a ray and add to the pickData.
        
        :param (input):
        ray origin and direction
        
        :param (input):
        minParameter smallest parameter of pick. (e.g. 0 for picking along
        a positive ray from an eyepoint)
        
        :param [in,out]:
        pickData growing array of picks.
        
        :param (input):
        parentId caller's id for this solid. Will be placed in each
        pickData entry has parentId.
        """
        ...
    
    def Clone(self: MSPyBentleyGeom.DgnTorusPipeDetail) -> ISolidPrimitive:
        """
        Copy to a new (allocated) solid primitive.
        """
        ...
    
    def ClosestPoint(self: MSPyBentleyGeom.DgnTorusPipeDetail, spacePoint: MSPyBentleyGeom.DPoint3d, pickDetail: MSPyBentleyGeom.SolidLocationDetail) -> bool:
        """
        :param (input):
        spacePoint search for point close to here and on the solid surface
        
        :param (output):
        pickDetail closest point data.
        
        :returns:
        false if not supported.
        """
        ...
    
    def ComputeSecondMomentAreaProducts(self: MSPyBentleyGeom.DgnTorusPipeDetail, localToWorld: MSPyBentleyGeom.Transform, localProducts: MSPyBentleyGeom.DMatrix4d) -> bool:
        """
        Return the various integrated products for area moment calculations.
        The primitive is treated as a thin shell.
        
        :param (output):
        localToWorld transform from preferred system where the products
        are most easily computed to world.
        
        :param (output):
        localProducts integrated [xx xy xz x; xy yy yz y; xz yz zz z; x y
        z 1] dA
        
        :returns:
        false if unable to compute.
        """
        ...
    
    def ComputeSecondMomentVolumeProducts(self: MSPyBentleyGeom.DgnTorusPipeDetail, localToWorld: MSPyBentleyGeom.Transform, localProducts: MSPyBentleyGeom.DMatrix4d) -> bool:
        """
        Return the various integrated products for moment calculations. The
        primitive is treated as a volume
        
        :param (output):
        localToWorld transform from preferred system where the products
        are most easily computed to world.
        
        :param (output):
        localProducts integrated [xx xy xz x; xy yy yz y; xz yz zz z; x y
        z 1] dA
        
        :returns:
        false if unable to compute.
        """
        ...
    
    def GetConstantUSection(self: MSPyBentleyGeom.DgnTorusPipeDetail, indices: SolidLocationDetail.FaceIndices, fraction: float) -> MSPyBentleyGeom.ICurvePrimitive:
        """
        Copy a section at constant u of a single face to a single
        ICurvePrimitive.
        
        :param (input):
        indices selects face
        
        :param (input):
        fraction u fraction for section curve
        """
        ...
    
    def GetConstantVSection(self: MSPyBentleyGeom.DgnTorusPipeDetail, indices: SolidLocationDetail.FaceIndices, fraction: float) -> MSPyBentleyGeom.ICurvePrimitive:
        """
        Copy a section curve at constant v of a single face to a single
        ICurvePrimitive.
        
        :param (input):
        indices selects face
        
        :param (input):
        fraction v fraction for section curve
        """
        ...
    
    def GetFace(self: MSPyBentleyGeom.DgnTorusPipeDetail, indices: SolidLocationDetail.FaceIndices) -> MSPyBentleyGeom.IGeometry:
        """
        Return a single face of the solid primitive
        
        :param indices:
        integer selectors for the face.
        """
        ...
    
    def GetFaceIndices(self: MSPyBentleyGeom.DgnTorusPipeDetail, indices: MSPyBentleyGeom.FaceIndicesArray) -> None:
        """
        Fill a list of all possible face indices.
        
        :param (output):
        indices array of selectors for the faces.
        """
        ...
    
    def GetRange(*args, **kwargs):
        """
        Overloaded function.
        
        1. GetRange(self: MSPyBentleyGeom.DgnTorusPipeDetail, range: MSPyBentleyGeom.DRange3d) -> bool
        
        Return range.
        
        2. GetRange(self: MSPyBentleyGeom.DgnTorusPipeDetail, range: MSPyBentleyGeom.DRange3d, transform: MSPyBentleyGeom.Transform) -> bool
        
        Return range.
        """
        ...
    
    def HasRealCaps(self: MSPyBentleyGeom.DgnTorusPipeDetail) -> bool:
        """
        Return true if capped and incomplete major sweep.
        """
        ...
    
    def IntersectCurveLocal(*args, **kwargs):
        """
        Overloaded function.
        
        1. IntersectCurveLocal(self: MSPyBentleyGeom.DgnTorusPipeDetail, curve: MSPyBentleyGeom.ICurvePrimitive, curveFractions: MSPyBentleyGeom.DoubleArray, normalizedConePoints: MSPyBentleyGeom.DPoint3dArray, localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform, boundedConeZ: bool) -> tuple
        
        Return all intersection points of a curve with the pipe body Returned
        data is the detailed local coordinates, with additional data to relate
        it back to world.
        
        2. IntersectCurveLocal(self: MSPyBentleyGeom.DgnTorusPipeDetail, curve: MSPyBentleyGeom.ICurvePrimitive, curveFractions: MSPyBentleyGeom.DoubleArray, normalizedConePoints: list, localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform, boundedConeZ: bool) -> tuple
        
        Return all intersection points of a curve with the pipe body Returned
        data is the detailed local coordinates, with additional data to relate
        it back to world.
        """
        ...
    
    def IsClosedVolume(self: MSPyBentleyGeom.DgnTorusPipeDetail) -> bool:
        """
        Test if this is a closed volume.
        """
        ...
    
    def IsSameStructure(self: MSPyBentleyGeom.DgnTorusPipeDetail, other: ISolidPrimitive) -> bool:
        """
        Test for same type and structure (but no coordinate comparison)
        """
        ...
    
    def IsSameStructureAndGeometry(self: MSPyBentleyGeom.DgnTorusPipeDetail, other: ISolidPrimitive, tolerance: float) -> bool:
        """
        Test for same type, structure and coordinates.
        """
        ...
    
    def ParameterizationSign(self: MSPyBentleyGeom.DgnTorusPipeDetail) -> float:
        """
        Return +1 or -1 that matches the volume sign after integration over
        the parameter space.
        """
        ...
    
    def SetDetailCoordinatesFromLocalPipeCoordinates(self: MSPyBentleyGeom.DgnTorusPipeDetail, detail: MSPyBentleyGeom.SolidLocationDetail, localuvw: MSPyBentleyGeom.DPoint3d, localToWorld: MSPyBentleyGeom.Transform) -> tuple:
        """
        set point, uv coordinates, and uv derivatives vectors
        """
        ...
    
    def SilhouetteCurves(self: MSPyBentleyGeom.DgnTorusPipeDetail, eyePoint: MSPyBentleyGeom.DPoint4d, curves: MSPyBentleyGeom.CurveVector) -> bool:
        """
        Return curves which are silhoutte curves OTHER than hard edges
        
        :returns:
        return false if not implemented. return true if implemented -- but
        curves may still be empty.
        """
        ...
    
    def TransformInPlace(self: MSPyBentleyGeom.DgnTorusPipeDetail, transform: MSPyBentleyGeom.Transform) -> bool:
        """
        Transform in place.
        """
        ...
    
    def TryGetConstructiveFrame(self: MSPyBentleyGeom.DgnTorusPipeDetail, localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform) -> bool:
        """
        Return coordinate system with origin at major hoop center, X axis
        towards starting minor circle center.
        """
        ...
    
    def TryGetFrame(*args, **kwargs):
        """
        Overloaded function.
        
        1. TryGetFrame(self: MSPyBentleyGeom.DgnTorusPipeDetail, center: MSPyBentleyGeom.DPoint3d, axis: MSPyBentleyGeom.RotMatrix) -> tuple
        
        :param (output):
        center center of rotation.
        
        :param (output):
        axes coordinate axes, xy in major plane, z through hole.
        
        :param (output):
        radiusA major radius (elbow radius)
        
        :param (output):
        radiusB minor radius (pipe diameter)
        
        :param (output):
        sweepRadians angle of rotation.
        
        2. TryGetFrame(self: MSPyBentleyGeom.DgnTorusPipeDetail, center: MSPyBentleyGeom.Transform, axis: MSPyBentleyGeom.Transform) -> tuple
        
        :param (output):
        center center of rotation.
        
        :param (output):
        axes coordinate axes, xy in major plane, z through hole.
        
        :param (output):
        radiusA major radius (elbow radius)
        
        :param (output):
        radiusB minor radius (pipe diameter)
        
        :param (output):
        sweepRadians angle of rotation.
        """
        ...
    
    def TryGetMaxUVLength(self: MSPyBentleyGeom.DgnTorusPipeDetail, indices: SolidLocationDetail.FaceIndices, uvLength: MSPyBentleyGeom.DVec2d) -> bool:
        """
        Compute the lengths of the longest u and v direction sections of a
        single face of a solid primitive.
        
        :param (input):
        indices selects face.
        
        :param (output):
        uvLength sizes in u, v directions.
        """
        ...
    
    def TryGetRotationAxis(self: MSPyBentleyGeom.DgnTorusPipeDetail, center: MSPyBentleyGeom.DPoint3d, axis: MSPyBentleyGeom.DVec3d) -> tuple:
        """
        :param center:
        (output) center of rotation.
        
        :param axis:
        (output) axis of rotation.
        
        :param sweepRadians:
        (output) angle of rotation.
        """
        ...
    
    def TryUVFractionToXYZ(self: MSPyBentleyGeom.DgnTorusPipeDetail, faceIndices: SolidLocationDetail.FaceIndices, uFraction: float, vFraction: float, xyz: MSPyBentleyGeom.DPoint3d, dXdu: MSPyBentleyGeom.DVec3d, dXdv: MSPyBentleyGeom.DVec3d) -> bool:
        """
        convert u,v fraction on specified face to xyz and derivatives.
        
        :param (input):
        faceIndices face selection indices
        
        :param (input):
        uFraction fractional coordinate in u direction.
        
        :param (input):
        vFraction fractional coordinate in v direction.
        
        :param (output):
        xyz point on face.
        
        :param (output):
        dXdu derivative of face point wrt uFraction.
        
        :param (output):
        dXdv derivative of face point wrt vFraction.
        """
        ...
    
    def UFractionToVSectionDEllipse3d(self: MSPyBentleyGeom.DgnTorusPipeDetail, fraction: float) -> MSPyBentleyGeom.DEllipse3d:
        """
        Return full ellipse on minor hoop at fractional position along major
        circle.
        """
        ...
    
    def VFractionToUSectionDEllipse3d(self: MSPyBentleyGeom.DgnTorusPipeDetail, fraction: float) -> MSPyBentleyGeom.DEllipse3d:
        """
        Return full ellipse on minor hoop at fractional position along minor
        circle.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DgnTorusPipeDetail) -> None
        
        2. __init__(self: MSPyBentleyGeom.DgnTorusPipeDetail, center: MSPyBentleyGeom.DPoint3d, vectorX: MSPyBentleyGeom.DVec3d, vectorY: MSPyBentleyGeom.DVec3d, majorRadius: float, minorRadius: float, sweepAngle: float, capped: bool) -> None
        """
        ...
    
class DirectionalVolumeData:
    """
    None
    """

    def __init__(self: MSPyBentleyGeom.DirectionalVolumeData) -> None:
        ...
    
    @property
    def areaProducts(self: MSPyBentleyGeom.DirectionalVolumeData) -> MSPyBentleyGeom.DMatrix4d:
        ...
    @areaProducts.setter
    def areaProducts(self: MSPyBentleyGeom.DirectionalVolumeData, arg0: MSPyBentleyGeom.DMatrix4d) -> None:
        ...
    
    @property
    def volume(self: MSPyBentleyGeom.DirectionalVolumeData) -> float:
        ...
    @volume.setter
    def volume(self: MSPyBentleyGeom.DirectionalVolumeData, arg0: float) -> None:
        ...
    
class DoubleArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DoubleArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.DoubleArray, arg0: MSPyBentleyGeom.DoubleArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.DoubleArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.DoubleArray, x: float) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.DoubleArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def count(self: MSPyBentleyGeom.DoubleArray, x: float) -> int:
        """
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.DoubleArray, L: MSPyBentleyGeom.DoubleArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.DoubleArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.DoubleArray, i: int, x: float) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.DoubleArray) -> float
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.DoubleArray, i: int) -> float
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(self: MSPyBentleyGeom.DoubleArray, x: float) -> None:
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class DoubleSizeSize:
    """
    None
    """

    def Get(self: MSPyBentleyGeom.DoubleSizeSizeT) -> float:
        ...
    
    def GetCR(self: MSPyBentleyGeom.DoubleSizeSizeT) -> float:
        ...
    
    def GetTag(self: MSPyBentleyGeom.DoubleSizeSizeT, tagA: bool) -> int:
        ...
    
    def GetTagA(self: MSPyBentleyGeom.DoubleSizeSizeT) -> int:
        ...
    
    def GetTagB(self: MSPyBentleyGeom.DoubleSizeSizeT) -> int:
        ...
    
    def Set(self: MSPyBentleyGeom.DoubleSizeSizeT, value: float) -> None:
        ...
    
    def SetTagA(self: MSPyBentleyGeom.DoubleSizeSizeT, tag: int) -> None:
        ...
    
    def SetTagB(self: MSPyBentleyGeom.DoubleSizeSizeT, tag: int) -> None:
        ...
    
    def SwapTags(self: MSPyBentleyGeom.DoubleSizeSizeT) -> None:
        ...
    
    def __init__(self: MSPyBentleyGeom.DoubleSizeSize, value: float, tagA: int, tagB: int) -> None:
        ...
    
class DoubleSizeSizeT:
    """
    None
    """

    def Get(self: MSPyBentleyGeom.DoubleSizeSizeT) -> float:
        ...
    
    def GetCR(self: MSPyBentleyGeom.DoubleSizeSizeT) -> float:
        ...
    
    def GetTag(self: MSPyBentleyGeom.DoubleSizeSizeT, tagA: bool) -> int:
        ...
    
    def GetTagA(self: MSPyBentleyGeom.DoubleSizeSizeT) -> int:
        ...
    
    def GetTagB(self: MSPyBentleyGeom.DoubleSizeSizeT) -> int:
        ...
    
    def Set(self: MSPyBentleyGeom.DoubleSizeSizeT, value: float) -> None:
        ...
    
    def SetTagA(self: MSPyBentleyGeom.DoubleSizeSizeT, tag: int) -> None:
        ...
    
    def SetTagB(self: MSPyBentleyGeom.DoubleSizeSizeT, tag: int) -> None:
        ...
    
    def SwapTags(self: MSPyBentleyGeom.DoubleSizeSizeT) -> None:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.DoubleSizeSizeT) -> None
        
        2. __init__(self: MSPyBentleyGeom.DoubleSizeSizeT, value: float, tagA: int, tagB: int) -> None
        """
        ...
    
class EdgeId:
    """
    None
    """

    def GetFaces(self: MSPyBentleyGeom.EdgeId) -> tuple:
        ...
    
    def SetFaces(self: MSPyBentleyGeom.EdgeId, f1: MSPyBentleyGeom.FaceId, f2: MSPyBentleyGeom.FaceId) -> None:
        ...
    
    def __init__(self: MSPyBentleyGeom.EdgeId) -> None:
        ...
    
class EdgeIdArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.EdgeIdArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.EdgeIdArray, arg0: MSPyBentleyGeom.EdgeIdArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.EdgeIdArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.EdgeIdArray, x: MSPyBentleyGeom.EdgeId) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.EdgeIdArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.EdgeIdArray, L: MSPyBentleyGeom.EdgeIdArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.EdgeIdArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.EdgeIdArray, i: int, x: MSPyBentleyGeom.EdgeId) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.EdgeIdArray) -> MSPyBentleyGeom.EdgeId
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.EdgeIdArray, i: int) -> MSPyBentleyGeom.EdgeId
        
        Remove and return the item at index ``i``
        """
        ...
    
FIT_CATMULLROM: int

FIT_LEASTSQUARES: int

FIT_POINTS: int

FIT_POLES: int

class FaceId:
    """
    None
    """

    def __init__(self: MSPyBentleyGeom.FaceId) -> None:
        ...
    
    @property
    def entityId(self: MSPyBentleyGeom.FaceId) -> int:
        ...
    @entityId.setter
    def entityId(self: MSPyBentleyGeom.FaceId, arg0: int) -> None:
        ...
    
    @property
    def nodeId(self: MSPyBentleyGeom.FaceId) -> int:
        ...
    @nodeId.setter
    def nodeId(self: MSPyBentleyGeom.FaceId, arg0: int) -> None:
        ...
    
class FaceIdArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.FaceIdArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.FaceIdArray, arg0: MSPyBentleyGeom.FaceIdArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.FaceIdArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.FaceIdArray, x: MSPyBentleyGeom.FaceId) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.FaceIdArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def count(self: MSPyBentleyGeom.FaceIdArray, x: MSPyBentleyGeom.FaceId) -> int:
        """
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.FaceIdArray, L: MSPyBentleyGeom.FaceIdArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.FaceIdArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.FaceIdArray, i: int, x: MSPyBentleyGeom.FaceId) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.FaceIdArray) -> MSPyBentleyGeom.FaceId
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.FaceIdArray, i: int) -> MSPyBentleyGeom.FaceId
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(self: MSPyBentleyGeom.FaceIdArray, x: MSPyBentleyGeom.FaceId) -> None:
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class FaceIndicesArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.FaceIndicesArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.FaceIndicesArray, arg0: MSPyBentleyGeom.FaceIndicesArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.FaceIndicesArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.FaceIndicesArray, x: MSPyBentleyGeom.SolidLocationDetail.FaceIndices) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.FaceIndicesArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.FaceIndicesArray, L: MSPyBentleyGeom.FaceIndicesArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.FaceIndicesArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.FaceIndicesArray, i: int, x: MSPyBentleyGeom.SolidLocationDetail.FaceIndices) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.FaceIndicesArray) -> MSPyBentleyGeom.SolidLocationDetail.FaceIndices
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.FaceIndicesArray, i: int) -> MSPyBentleyGeom.SolidLocationDetail.FaceIndices
        
        Remove and return the item at index ``i``
        """
        ...
    
class FacetCutFillHandler:
    """
    None
    """

    def ContinueSearch(self: MSPyBentleyGeom.FacetCutFillHandler) -> bool:
        """
        Test if the handler object is still interested in the calls. This is
        not normally implemented
        """
        ...
    
    def ProcessCutFillFacet(self: MSPyBentleyGeom.FacetCutFillHandler, dtm: MSPyBentleyGeom.DPoint3dArray, dtmReadIndex: int, road: MSPyBentleyGeom.DPoint3dArray, roadReadIndex: int, roadBoundaryFlag: MSPyBentleyGeom.BoolArray, isCut: bool) -> None:
        """
        Announce coordinates in paired dtm and road loops.
        
        * both loops are oriented CCW.
        
        * Hence when building closed meshes, the lower of the two must be
        reversed to get the downward directed surface properly oriented
        
        * points are in corresponding order -- dtm[i] and road[i] have
        identical xy coordinates, different z
        
        * isCut is true when the dtm is above the road
        
        * isCut is false for road above dtm.
        
        * isCut (or comparison of corresponding z coordinates) is consistent
        around the entire facet.
        """
        ...
    
    def ProcessSideFacet(self: MSPyBentleyGeom.FacetCutFillHandler, points: MSPyBentleyGeom.DPoint3dArray, isCut: bool) -> None:
        ...
    
    def Reset(self: MSPyBentleyGeom.FacetCutFillHandler) -> None:
        """
        Called to reset the computation. This is important:The FastCutFill
        caller may decide to throw away partially completed results and
        restart.
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.FacetCutFillHandler) -> None:
        ...
    
class FacetEdgeLocationDetail:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.FacetEdgeLocationDetail) -> None
        
        2. __init__(self: MSPyBentleyGeom.FacetEdgeLocationDetail, readIndex: int, fraction: float) -> None
        """
        ...
    
    @property
    def fraction(self: MSPyBentleyGeom.FacetEdgeLocationDetail) -> float:
        ...
    @fraction.setter
    def fraction(self: MSPyBentleyGeom.FacetEdgeLocationDetail, arg0: float) -> None:
        ...
    
    @property
    def readIndex(self: MSPyBentleyGeom.FacetEdgeLocationDetail) -> int:
        ...
    @readIndex.setter
    def readIndex(self: MSPyBentleyGeom.FacetEdgeLocationDetail, arg0: int) -> None:
        ...
    
class FacetFaceData:
    """
    None
    """

    def ConvertParamToDistance(self: MSPyBentleyGeom.FacetFaceData, distanceParam: MSPyBentleyGeom.DPoint2d, param: MSPyBentleyGeom.DPoint2d) -> None:
        """
        convert parameter from stored value to distance-based parameter.
        """
        ...
    
    def ConvertParamToNormalized(self: MSPyBentleyGeom.FacetFaceData, normalizedParam: MSPyBentleyGeom.DPoint2d, param: MSPyBentleyGeom.DPoint2d) -> None:
        """
        convert parameter from stored value to normalized (0-1) parameter.
        """
        ...
    
    def Init(self: MSPyBentleyGeom.FacetFaceData) -> None:
        """
        restore to constructor state.
        """
        ...
    
    def ScaleDistances(self: MSPyBentleyGeom.FacetFaceData, distanceScale: float) -> None:
        """
        Scale distance parameters
        """
        ...
    
    def SetParamDistanceRangeFromNewFaceData(self: MSPyBentleyGeom.FacetFaceData, polyface: PolyfaceHeader, endIndex: int = 0) -> None:
        """
        To be called just after one or more " one - based, zero terminated "
        facets have been added to the polyface. The new facets are identified
        as a " face " and the face size data is recorded. Face size is tied to
        parameter range by scale factors from simple triangulation of all
        facets.
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.FacetFaceData) -> None:
        ...
    
    @property
    def faceIndices(self: MSPyBentleyGeom.FacetFaceData) -> SolidLocationDetail.FaceIndices:
        ...
    @faceIndices.setter
    def faceIndices(self: MSPyBentleyGeom.FacetFaceData, arg0: SolidLocationDetail.FaceIndices) -> None:
        ...
    
    @property
    def normalRange(self: MSPyBentleyGeom.FacetFaceData) -> MSPyBentleyGeom.DRange3d:
        ...
    @normalRange.setter
    def normalRange(self: MSPyBentleyGeom.FacetFaceData, arg0: MSPyBentleyGeom.DRange3d) -> None:
        ...
    
    @property
    def paramDistanceRange(self: MSPyBentleyGeom.FacetFaceData) -> MSPyBentleyGeom.DRange2d:
        ...
    @paramDistanceRange.setter
    def paramDistanceRange(self: MSPyBentleyGeom.FacetFaceData, arg0: MSPyBentleyGeom.DRange2d) -> None:
        ...
    
    @property
    def paramRange(self: MSPyBentleyGeom.FacetFaceData) -> MSPyBentleyGeom.DRange2d:
        ...
    @paramRange.setter
    def paramRange(self: MSPyBentleyGeom.FacetFaceData, arg0: MSPyBentleyGeom.DRange2d) -> None:
        ...
    
    @property
    def sourceIndex(self: MSPyBentleyGeom.FacetFaceData) -> int:
        ...
    @sourceIndex.setter
    def sourceIndex(self: MSPyBentleyGeom.FacetFaceData, arg0: int) -> None:
        ...
    
    @property
    def xyzRange(self: MSPyBentleyGeom.FacetFaceData) -> MSPyBentleyGeom.DRange3d:
        ...
    @xyzRange.setter
    def xyzRange(self: MSPyBentleyGeom.FacetFaceData, arg0: MSPyBentleyGeom.DRange3d) -> None:
        ...
    
class FacetFaceDataArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.FacetFaceDataArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.FacetFaceDataArray, arg0: MSPyBentleyGeom.FacetFaceDataArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.FacetFaceDataArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.FacetFaceDataArray, x: MSPyBentleyGeom.FacetFaceData) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.FacetFaceDataArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.FacetFaceDataArray, L: MSPyBentleyGeom.FacetFaceDataArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.FacetFaceDataArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.FacetFaceDataArray, i: int, x: MSPyBentleyGeom.FacetFaceData) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.FacetFaceDataArray) -> MSPyBentleyGeom.FacetFaceData
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.FacetFaceDataArray, i: int) -> MSPyBentleyGeom.FacetFaceData
        
        Remove and return the item at index ``i``
        """
        ...
    
class FacetLocationDetail:
    """
    None
    """

    def AccumulateScaledData(self: MSPyBentleyGeom.FacetLocationDetail, source: MSPyBentleyGeom.FacetLocationDetail, fraction: float) -> None:
        """
        accumulate a scaled multiple of all numeric data from source. append
        index data and fraction arrays to arrays (if possible within space
        restrictions). Fractions from the source are scaled by the new
        fraction.
        """
        ...
    
    def CompareUV(self: MSPyBentleyGeom.FacetLocationDetail, other: MSPyBentleyGeom.FacetLocationDetail) -> bool:
        """
        lexical compare in u,v coordinates.
        """
        ...
    
    def GetIsInterior(self: MSPyBentleyGeom.FacetLocationDetail) -> bool:
        """
        Get interior point flag
        """
        ...
    
    def GetNumWeights(self: MSPyBentleyGeom.FacetLocationDetail) -> int:
        """
        Return the number of vertices that are weighted together for the
        computed values. This (along with the weight fractions, intColor, and
        colorTable indices) can be used compute additional data accessed
        through the indices. At most 4 weights can be stored. The possible
        data is:
        
        * vertex index -- the index of the vertex (numbered within the facet)
        
        * fraction -- (double) the weight used for data at this indexed
        vertex.
        
        * intColor -- integer color data.
        
        * colorTable -- color table index
        """
        ...
    
    def GetReadIndex(self: MSPyBentleyGeom.FacetLocationDetail) -> int:
        """
        Get read index
        """
        ...
    
    @property
    def IsInterior(arg0: MSPyBentleyGeom.FacetLocationDetail) -> bool:
        ...
    @IsInterior.setter
    def IsInterior(arg0: MSPyBentleyGeom.FacetLocationDetail, arg1: bool) -> None:
        ...
    
    @property
    def NumWeights(arg0: MSPyBentleyGeom.FacetLocationDetail) -> int:
        ...
    
    @property
    def ReadIndex(arg0: MSPyBentleyGeom.FacetLocationDetail) -> int:
        ...
    @ReadIndex.setter
    def ReadIndex(arg0: MSPyBentleyGeom.FacetLocationDetail, arg1: int) -> None:
        ...
    
    def SetDoubleColor(self: MSPyBentleyGeom.FacetLocationDetail, data: MSPyBentleyGeom.RgbFactor) -> None:
        ...
    
    def SetFloatColor(self: MSPyBentleyGeom.FacetLocationDetail, data: MSPyBentleyGeom.FloatRgb) -> None:
        ...
    
    def SetIsInterior(self: MSPyBentleyGeom.FacetLocationDetail, value: bool) -> None:
        """
        Set flag as interior point
        """
        ...
    
    def SetNormal(self: MSPyBentleyGeom.FacetLocationDetail, data: MSPyBentleyGeom.DVec3d) -> None:
        """
        Set the normal and record that it is valid.
        """
        ...
    
    def SetParam(self: MSPyBentleyGeom.FacetLocationDetail, data: MSPyBentleyGeom.DPoint2d) -> None:
        ...
    
    def SetReadIndex(self: MSPyBentleyGeom.FacetLocationDetail, readIndex: int) -> None:
        """
        Set read index
        """
        ...
    
    @staticmethod
    def SortUV(data: MSPyBentleyGeom.FacetLocationDetailArray) -> None:
        """
        Sort an array based by CompareUV ...
        """
        ...
    
    def TryGetColorTable(self: MSPyBentleyGeom.FacetLocationDetail, index: int) -> tuple:
        """
        Access a color table index (by index within the facet)
        """
        ...
    
    def TryGetDoubleColor(self: MSPyBentleyGeom.FacetLocationDetail, data: MSPyBentleyGeom.RgbFactor) -> bool:
        """
        Copy doubleColor data. Return false if not available.
        """
        ...
    
    def TryGetFloatColor(self: MSPyBentleyGeom.FacetLocationDetail, data: MSPyBentleyGeom.FloatRgb) -> bool:
        """
        Copy floatColor data. Return false if not available.
        """
        ...
    
    def TryGetIntColor(self: MSPyBentleyGeom.FacetLocationDetail, index: int) -> tuple:
        """
        Access (for an index into the tables within the detail) the int color
        """
        ...
    
    def TryGetNormal(self: MSPyBentleyGeom.FacetLocationDetail, data: MSPyBentleyGeom.DVec3d) -> bool:
        """
        Copy normal data. Return false if not available.
        """
        ...
    
    def TryGetParam(self: MSPyBentleyGeom.FacetLocationDetail, data: MSPyBentleyGeom.DPoint2d) -> bool:
        """
        Copy parameter data. Return false if not available.
        """
        ...
    
    def TryGetPoint(self: MSPyBentleyGeom.FacetLocationDetail, data: MSPyBentleyGeom.DPoint3d) -> bool:
        """
        Copy point data. Return false if not available.
        """
        ...
    
    def TryGetVertexIndex(self: MSPyBentleyGeom.FacetLocationDetail, index: int) -> tuple:
        """
        Access (for an index into the tables within the detail) the vertex
        index (numbered within the facet)
        """
        ...
    
    def TryGetWeight(self: MSPyBentleyGeom.FacetLocationDetail, index: int) -> tuple:
        """
        Access (for an index into the tables within the detail) a weight for
        contributing data.
        """
        ...
    
    def Zero(self: MSPyBentleyGeom.FacetLocationDetail) -> None:
        """
        Zero all contents.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.FacetLocationDetail) -> None
        
        2. __init__(self: MSPyBentleyGeom.FacetLocationDetail, readIndex: int, a: float = 0.0) -> None
        """
        ...
    
class FacetLocationDetailArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.FacetLocationDetailArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.FacetLocationDetailArray, arg0: MSPyBentleyGeom.FacetLocationDetailArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.FacetLocationDetailArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.FacetLocationDetailArray, x: MSPyBentleyGeom.FacetLocationDetail) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.FacetLocationDetailArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.FacetLocationDetailArray, L: MSPyBentleyGeom.FacetLocationDetailArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.FacetLocationDetailArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.FacetLocationDetailArray, i: int, x: MSPyBentleyGeom.FacetLocationDetail) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.FacetLocationDetailArray) -> MSPyBentleyGeom.FacetLocationDetail
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.FacetLocationDetailArray, i: int) -> MSPyBentleyGeom.FacetLocationDetail
        
        Remove and return the item at index ``i``
        """
        ...
    
class FacetLocationDetailPair:
    """
    None
    """

    def __init__(self: MSPyBentleyGeom.FacetLocationDetailPair) -> None:
        ...
    
    @property
    def detailA(self: MSPyBentleyGeom.FacetLocationDetailPair) -> MSPyBentleyGeom.FacetLocationDetail:
        ...
    @detailA.setter
    def detailA(self: MSPyBentleyGeom.FacetLocationDetailPair, arg0: MSPyBentleyGeom.FacetLocationDetail) -> None:
        ...
    
    @property
    def detailB(self: MSPyBentleyGeom.FacetLocationDetailPair) -> MSPyBentleyGeom.FacetLocationDetail:
        ...
    @detailB.setter
    def detailB(self: MSPyBentleyGeom.FacetLocationDetailPair, arg0: MSPyBentleyGeom.FacetLocationDetail) -> None:
        ...
    
class FacetLocationDetailPairWithIndices:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.FacetLocationDetailPairWithIndices, defaultIndex: int) -> None
        
        2. __init__(self: MSPyBentleyGeom.FacetLocationDetailPairWithIndices, detailA: MSPyBentleyGeom.FacetLocationDetail, detailB: MSPyBentleyGeom.FacetLocationDetail, indexA: int, indexB: int) -> None
        """
        ...
    
    @property
    def detailA(self: MSPyBentleyGeom.FacetLocationDetailPair) -> MSPyBentleyGeom.FacetLocationDetail:
        ...
    @detailA.setter
    def detailA(self: MSPyBentleyGeom.FacetLocationDetailPair, arg0: MSPyBentleyGeom.FacetLocationDetail) -> None:
        ...
    
    @property
    def detailB(self: MSPyBentleyGeom.FacetLocationDetailPair) -> MSPyBentleyGeom.FacetLocationDetail:
        ...
    @detailB.setter
    def detailB(self: MSPyBentleyGeom.FacetLocationDetailPair, arg0: MSPyBentleyGeom.FacetLocationDetail) -> None:
        ...
    
    @property
    def indexA(self: MSPyBentleyGeom.FacetLocationDetailPairWithIndices) -> int:
        ...
    @indexA.setter
    def indexA(self: MSPyBentleyGeom.FacetLocationDetailPairWithIndices, arg0: int) -> None:
        ...
    
    @property
    def indexB(self: MSPyBentleyGeom.FacetLocationDetailPairWithIndices) -> int:
        ...
    @indexB.setter
    def indexB(self: MSPyBentleyGeom.FacetLocationDetailPairWithIndices, arg0: int) -> None:
        ...
    
class FacetParamMode:
    """
    Members:
    
    eFACET_PARAM_01BothAxes
    
    eFACET_PARAM_01LargerAxis
    
    eFACET_PARAM_Distance
    """

    def __init__(self: MSPyBentleyGeom.FacetParamMode, value: int) -> None:
        ...
    
    eFACET_PARAM_01BothAxes: FacetParamMode
    
    eFACET_PARAM_01LargerAxis: FacetParamMode
    
    eFACET_PARAM_Distance: FacetParamMode
    
    @property
    def name(self: handle) -> str:
        ...
    
    @property
    def value(arg0: MSPyBentleyGeom.FacetParamMode) -> int:
        ...
    
class FilletDetailArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.FilletDetailArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.FilletDetailArray, arg0: MSPyBentleyGeom.FilletDetailArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.FilletDetailArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.FilletDetailArray, x: MSPyBentleyGeom.CurveCurve.FilletDetail) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.FilletDetailArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.FilletDetailArray, L: MSPyBentleyGeom.FilletDetailArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.FilletDetailArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.FilletDetailArray, i: int, x: MSPyBentleyGeom.CurveCurve.FilletDetail) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.FilletDetailArray) -> MSPyBentleyGeom.CurveCurve.FilletDetail
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.FilletDetailArray, i: int) -> MSPyBentleyGeom.CurveCurve.FilletDetail
        
        Remove and return the item at index ``i``
        """
        ...
    
class FloatArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.FloatArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.FloatArray, arg0: MSPyBentleyGeom.FloatArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.FloatArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.FloatArray, x: float) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.FloatArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def count(self: MSPyBentleyGeom.FloatArray, x: float) -> int:
        """
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.FloatArray, L: MSPyBentleyGeom.FloatArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.FloatArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.FloatArray, i: int, x: float) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.FloatArray) -> float
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.FloatArray, i: int) -> float
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(self: MSPyBentleyGeom.FloatArray, x: float) -> None:
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class FloatRgb:
    """
    None
    """

    def __init__(self: MSPyBentleyGeom.FloatRgb) -> None:
        ...
    
    @property
    def blue(self: MSPyBentleyGeom.FloatRgb) -> float:
        ...
    @blue.setter
    def blue(self: MSPyBentleyGeom.FloatRgb, arg0: float) -> None:
        ...
    
    @property
    def green(self: MSPyBentleyGeom.FloatRgb) -> float:
        ...
    @green.setter
    def green(self: MSPyBentleyGeom.FloatRgb, arg0: float) -> None:
        ...
    
    @property
    def red(self: MSPyBentleyGeom.FloatRgb) -> float:
        ...
    @red.setter
    def red(self: MSPyBentleyGeom.FloatRgb, arg0: float) -> None:
        ...
    
class FloatRgbArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.FloatRgbArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.FloatRgbArray, arg0: MSPyBentleyGeom.FloatRgbArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.FloatRgbArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.FloatRgbArray, x: MSPyBentleyGeom.FloatRgb) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.FloatRgbArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.FloatRgbArray, L: MSPyBentleyGeom.FloatRgbArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.FloatRgbArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.FloatRgbArray, i: int, x: MSPyBentleyGeom.FloatRgb) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.FloatRgbArray) -> MSPyBentleyGeom.FloatRgb
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.FloatRgbArray, i: int) -> MSPyBentleyGeom.FloatRgb
        
        Remove and return the item at index ``i``
        """
        ...
    
class GeoPoint:
    """
    None
    """

    def Init(self: MSPyBentleyGeom.GeoPoint, longitudeValue: float, latitudeValue: float, elevationValue: float) -> None:
        ...
    
    def __init__(self: MSPyBentleyGeom.GeoPoint) -> None:
        ...
    
    @property
    def elevation(self: MSPyBentleyGeom.GeoPoint) -> float:
        ...
    @elevation.setter
    def elevation(self: MSPyBentleyGeom.GeoPoint, arg0: float) -> None:
        ...
    
    @property
    def latitude(self: MSPyBentleyGeom.GeoPoint) -> float:
        ...
    @latitude.setter
    def latitude(self: MSPyBentleyGeom.GeoPoint, arg0: float) -> None:
        ...
    
    @property
    def longitude(self: MSPyBentleyGeom.GeoPoint) -> float:
        ...
    @longitude.setter
    def longitude(self: MSPyBentleyGeom.GeoPoint, arg0: float) -> None:
        ...
    
class GeoPoint2d:
    """
    None
    """

    def Init(self: MSPyBentleyGeom.GeoPoint2d, longitudeValue: float, latitudeValue: float) -> None:
        ...
    
    def __init__(self: MSPyBentleyGeom.GeoPoint2d) -> None:
        ...
    
    @property
    def latitude(self: MSPyBentleyGeom.GeoPoint2d) -> float:
        ...
    @latitude.setter
    def latitude(self: MSPyBentleyGeom.GeoPoint2d, arg0: float) -> None:
        ...
    
    @property
    def longitude(self: MSPyBentleyGeom.GeoPoint2d) -> float:
        ...
    @longitude.setter
    def longitude(self: MSPyBentleyGeom.GeoPoint2d, arg0: float) -> None:
        ...
    
class ICurvePrimitive:
    """
    None
    """

    @staticmethod
    def AddRuledSurfaceRayIntersections(pickData: MSPyBentleyGeom.SolidLocationDetailArray, curveA: MSPyBentleyGeom.ICurvePrimitive, curveB: MSPyBentleyGeom.ICurvePrimitive, ray: DRay3d) -> bool:
        """
        Compute intersections of a ray with a ruled surface between two
        primitves.
        
        :returns:
        false if primitives are not compatible
        
        :param (output):
        pickData array to receive picks
        
        :param (input):
        curveA first curve
        
        :param (input):
        curveB second curve
        
        :param (input):
        ray ray
        """
        ...
    
    def AddStrokes(*args, **kwargs):
        """
        Overloaded function.
        
        1. AddStrokes(self: MSPyBentleyGeom.ICurvePrimitive, points: List[DPoint3d], options: IFacetOptions, includeStartPoint: bool = True, startFraction: float = 0.0, endFraction: float = 1.0) -> bool
        
        Stroke the curve and add points to the bvector. return true if this is
        a strokable primitive -- Line, Arc, Bspline, Spiral, Akima, or partial
        curve. false for non-strokable -- i.e. child vector or point vector.
        
        :param [in,out]:
        points growing vector of strokes.
        
        :param (input):
        options stroke tolerance.
        
        :param (input):
        includeStartPoint if false, do NOT put start point in the output.
        
        :param (input):
        startFraction start of partial curve interval.
        
        :param (input):
        endFraction end of partial curve interval.
        
        2. AddStrokes(self: MSPyBentleyGeom.ICurvePrimitive, points: list, options: IFacetOptions, includeStartPoint: bool = True, startFraction: float = 0.0, endFraction: float = 1.0) -> bool
        
        Stroke the curve and add points to the bvector. return true if this is
        a strokable primitive -- Line, Arc, Bspline, Spiral, Akima, or partial
        curve. false for non-strokable -- i.e. child vector or point vector.
        
        :param [in,out]:
        points growing vector of strokes.
        
        :param (input):
        options stroke tolerance.
        
        :param (input):
        includeStartPoint if false, do NOT put start point in the output.
        
        :param (input):
        startFraction start of partial curve interval.
        
        :param (input):
        endFraction end of partial curve interval.
        
        3. AddStrokes(self: MSPyBentleyGeom.ICurvePrimitive, points: DPoint3dDoubleUVCurveArrays, options: IFacetOptions, startFraction: float = 0.0, endFraction: float = 1.0) -> bool
        
        Stroke the curve and add points to the bvector. return true if this is
        a strokable primitive -- Line, Arc, Bspline, Spiral, Akima, or partial
        curve. false for non-strokable -- i.e. child vector or point vector.
        
        :param [in,out]:
        points growing vector of strokes.
        
        :param (input):
        options stroke tolerance.
        
        :param (input):
        includeStartPoint if false, do NOT put start point in the output.
        
        :param (input):
        startFraction start of partial curve interval.
        
        :param (input):
        endFraction end of partial curve interval.
        """
        ...
    
    def AdjustFractionToBreakFraction(self: MSPyBentleyGeom.ICurvePrimitive, arg0: float, arg1: Rounding.RoundingMode) -> tuple:
        """
        Move a fraction to the nearest break fraction.
        """
        ...
    
    @property
    def AkimaCurve(arg0: MSPyBentleyGeom.ICurvePrimitive) -> List[DPoint3d]:
        ...
    
    def AnnounceKeyPoints(self: MSPyBentleyGeom.ICurvePrimitive, spacePoint: DPoint3d, collector: MSPyBentleyGeom.CurveKeyPointCollector, extend0: bool, extend1: bool) -> None:
        """
        Search for various keypoints (as requested by the collector) During
        recursion, extension bits are changed to false for interior points of
        paths
        """
        ...
    
    def AppendCurveBilinearPatchIntersections(self: MSPyBentleyGeom.ICurvePrimitive, patch: DBilinearPatch3d, intersections: MSPyBentleyGeom.CurveAndSolidLocationDetailArray) -> None:
        """
        Return intesections of curve primitive with a bilinear patch
        """
        ...
    
    def AppendCurvePlaneIntersections(*args, **kwargs):
        """
        Overloaded function.
        
        1. AppendCurvePlaneIntersections(self: MSPyBentleyGeom.ICurvePrimitive, plane: DPlane3d, intersections: MSPyBentleyGeom.CurveLocationDetailPairArray, tolerance: float = 0.0) -> None
        
        Return vector of intersections with a plane. Single point intersection
        appears as a CurveLocationDetailPair with identical locations for both
        parts of the pair (SameCurveAndFraction) Curve-on-plane appears as
        CurveLocationDetailPair with curve,fraction data for start and end of
        on-plane sections.
        
        :param (input):
        plane
        
        :param (output):
        intersections intersection details
        
        :param (input):
        tolerance for on-plane decisions. If 0, a tolerance is computed
        based on the coordinates in the curve.
        
        2. AppendCurvePlaneIntersections(self: MSPyBentleyGeom.ICurvePrimitive, plane: DPlane3dByVectors, bounded: UVBoundarySelect, intersections: MSPyBentleyGeom.CurveAndSolidLocationDetailArray) -> None
        
        Return vector of intersections with a plane. Single point intersection
        appears as a CurveLocationDetailPair with identical locations for both
        parts of the pair (SameCurveAndFraction) Curve-on-plane appears as
        CurveLocationDetailPair with curve,fraction data for start and end of
        on-plane sections.
        
        :param (input):
        plane
        
        :param (output):
        intersections intersection details
        
        :param (input):
        tolerance for on-plane decisions. If 0, a tolerance is computed
        based on the coordinates in the curve.
        """
        ...
    
    def AppendCurveRangeIntersections(self: MSPyBentleyGeom.ICurvePrimitive, range: MSPyBentleyGeom.LocalRange, intersections: MSPyBentleyGeom.PartialCurveDetailArray) -> None:
        """
        Return intesections of curve primitive with a range box.
        """
        ...
    
    @property
    def Arc(arg0: MSPyBentleyGeom.ICurvePrimitive) -> DEllipse3d:
        ...
    
    @property
    def BsplineCurve(arg0: MSPyBentleyGeom.ICurvePrimitive) -> RefCountedMSBsplineCurve:
        ...
    
    @property
    def ChildCurveVector(arg0: MSPyBentleyGeom.ICurvePrimitive) -> CurveVector:
        ...
    
    def Clone(self: MSPyBentleyGeom.ICurvePrimitive) -> MSPyBentleyGeom.ICurvePrimitive:
        """
        Return a deep copy
        """
        ...
    
    def CloneAsSingleOffsetPrimitiveXY(self: MSPyBentleyGeom.ICurvePrimitive, options: MSPyBentleyGeom.CurveOffsetOptions) -> MSPyBentleyGeom.ICurvePrimitive:
        """
        Return an offset primitive. This operates only on single primtives
        that can offset to another single primitive.
        
        :param (input):
        options contains tolerance for bspline and ellipse offset.
        """
        ...
    
    def CloneBetweenFractions(self: MSPyBentleyGeom.ICurvePrimitive, fractionA: float, fractionB: float, allowExtrapolation: bool) -> MSPyBentleyGeom.ICurvePrimitive:
        """
        Return a copy of a subset. The fraction interval may be high to low;
        fraction clamping respects the interval direction. return null pointer
        if fraction clamping resulted in zero-length interval.
        
        :param (input):
        fractionA start of returned invterval.
        
        :param (input):
        fractionB end of returned interval.
        
        :param (input):
        allowExtrapolation If false, out of bounds values are clamped.
        """
        ...
    
    def CloneComponent(self: MSPyBentleyGeom.ICurvePrimitive, componentIndex: int) -> MSPyBentleyGeom.ICurvePrimitive:
        """
        Return a copy of a component. Component index only applies to
        linestring. Any invalid index clones entire linestring. All others are
        complete Clone.
        """
        ...
    
    def CloneDereferenced(self: MSPyBentleyGeom.ICurvePrimitive, allowExtrapolation: bool = False, maximumDeref: bool = True) -> MSPyBentleyGeom.ICurvePrimitive:
        """
        Return a (deep) clone with all partial curves replaced by complete
        curves.
        
        :param (input):
        maximumDeref true to recurse through all steps of PartialCurve
        chains
        
        :param (input):
        allowExtrapolation true to allow extension before/after endpoints.
        """
        ...
    
    def ClosestPointBounded(*args, **kwargs):
        """
        Overloaded function.
        
        1. ClosestPointBounded(self: MSPyBentleyGeom.ICurvePrimitive, spacePoint: DPoint3d) -> tuple
        
        Find the closest point to a space point. return false if not a simple
        curve. (EXAMPLE:ChildCurveVector)
        
        :param (input):
        spacePoint reference point.
        
        :param (output):
        fraction fractional position at closest point.
        
        :param (output):
        curvePoint coordinates on curve
        
        2. ClosestPointBounded(self: MSPyBentleyGeom.ICurvePrimitive, spacePoint: DPoint3d, location: MSPyBentleyGeom.CurveLocationDetail, extend0: bool, extend1: bool) -> bool
        
        Find the closest point to a space point. return false if not a simple
        curve. (EXAMPLE:ChildCurveVector)
        
        :param (input):
        spacePoint reference point.
        
        :param (output):
        fraction fractional position at closest point.
        
        :param (output):
        curvePoint coordinates on curve
        
        3. ClosestPointBounded(self: MSPyBentleyGeom.ICurvePrimitive, spacePoint: DPoint3d, location: MSPyBentleyGeom.CurveLocationDetail) -> bool
        
        Find the closest point to a space point. return false if not a simple
        curve. (EXAMPLE:ChildCurveVector)
        
        :param (input):
        spacePoint reference point.
        
        :param (output):
        fraction fractional position at closest point.
        
        :param (output):
        curvePoint coordinates on curve
        """
        ...
    
    def ClosestPointBoundedXY(*args, **kwargs):
        """
        Overloaded function.
        
        1. ClosestPointBoundedXY(self: MSPyBentleyGeom.ICurvePrimitive, spacePoint: DPoint3d, worldToLocal: DMatrix4d, location: MSPyBentleyGeom.CurveLocationDetail) -> bool
        
        Find closest point, measuring in xy plane after applying a (possibly
        perspective) transform to both the curve and space point.
        
        :param (input):
        spacePoint reference point.
        
        :param (input):
        worldToLocal optional transform.
        
        :param (output):
        location details of closest point. See ClosestPointBounded.
        
        2. ClosestPointBoundedXY(self: MSPyBentleyGeom.ICurvePrimitive, spacePoint: DPoint3d, worldToLocal: DMatrix4d, location: MSPyBentleyGeom.CurveLocationDetail, entend0: bool, extend1: bool) -> bool
        
        Find closest point, measuring in xy plane after applying a (possibly
        perspective) transform to both the curve and space point.
        
        :param (input):
        spacePoint reference point.
        
        :param (input):
        worldToLocal optional transform.
        
        :param (output):
        location details of closest point. See ClosestPointBounded.
        """
        ...
    
    def ComponentFractionToPoint(*args, **kwargs):
        """
        Overloaded function.
        
        1. ComponentFractionToPoint(self: MSPyBentleyGeom.ICurvePrimitive, componentIndex: int, f: float, point: DPoint3d) -> bool
        
        Evaluate curve fractional position within the parameter space of a
        component. (For anything except a linestring, componentIndex is
        ignored and this is equivalent to FractionToPoint) return false if
        this is not a parameterized curve (EXAMPLE:A ChildCurveVector)
        
        :param (input):
        componentIndex index of the component to evaluate.
        
        :param (input):
        f evaluation fraction.
        
        :param (output):
        point point on curve.
        
        2. ComponentFractionToPoint(self: MSPyBentleyGeom.ICurvePrimitive, componentIndex: int, f: float, point: DPoint3d, tangent: DVec3d) -> bool
        
        Evaluate curve fractional position within the parameter space of a
        component. (For anything except a linestring, componentIndex is
        ignored and this is equivalent to FractionToPoint) return false if
        this is not a parameterized curve (EXAMPLE:A ChildCurveVector)
        
        :param (input):
        componentIndex index of the component to evaluate.
        
        :param (input):
        f evaluation fraction.
        
        :param (output):
        point point on curve.
        """
        ...
    
    @staticmethod
    def CreateAkimaCurve(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateAkimaCurve(points: List[DPoint3d]) -> MSPyBentleyGeom.ICurvePrimitive
        
        Allocate and fill a new akima curve
        
        :param (input):
        points akima control points to copy into the primitive. First two
        and final two points are slope end condition controls. Others are
        pass-through.
        
        :param (input):
        nPoints control point count.
        
        2. CreateAkimaCurve(points: list) -> MSPyBentleyGeom.ICurvePrimitive
        
        Allocate and fill a new akima curve
        
        :param (input):
        points akima control points to copy into the primitive. First two
        and final two points are slope end condition controls. Others are
        pass-through.
        
        :param (input):
        nPoints control point count.
        """
        ...
    
    @staticmethod
    def CreateArc(ellipse: DEllipse3d) -> MSPyBentleyGeom.ICurvePrimitive:
        """
        Allocate and fill a new elliptic arc
        
        :param (input):
        ellipse source ellipse.
        """
        ...
    
    @staticmethod
    def CreateAustralianRailCorpBearingRadiusLengthRadius(startPoint: DPoint3d, startRadians: float, startRadius: float, targetLength: float, endRadius: float) -> MSPyBentleyGeom.ICurvePrimitive:
        ...
    
    @staticmethod
    def CreateBsplineCurve(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateBsplineCurve(curve: MSBsplineCurve) -> MSPyBentleyGeom.ICurvePrimitive
        
        Allocate and fill a new bspline curve
        
        :param (input):
        curve source curve. A copy (clone, repeat allocation of memory) of
        the curve is placed into the new object. Caller is still
        responsible for freeing the input curve.
        
        2. CreateBsplineCurve(curve: RefCountedMSBsplineCurve) -> MSPyBentleyGeom.ICurvePrimitive
        
        Allocate and fill a new bspline curve
        
        :param (input):
        curve source curve. A copy (clone, repeat allocation of memory) of
        the curve is placed into the new object. Caller is still
        responsible for freeing the input curve.
        """
        ...
    
    @staticmethod
    def CreateBsplineCurveSwapFromSource(curve: MSBsplineCurve) -> MSPyBentleyGeom.ICurvePrimitive:
        """
        Allocate and fill a new bspline curve
        
        :param (input):
        curve source curve. Bits (including pointers) are copied to the
        CurvePrimtive. source curve is zeroed -- caller has no " free "
        responsibilities.
        """
        ...
    
    @staticmethod
    def CreateChildCurveVector(source: CurveVector) -> MSPyBentleyGeom.ICurvePrimitive:
        """
        Create a curve primitive with (ref coutnted pointer to preexisting
        refcounted child.
        """
        ...
    
    @staticmethod
    def CreateChildCurveVector_CopyFromSource(source: CurveVector) -> MSPyBentleyGeom.ICurvePrimitive:
        """
        Create child vector, making deep copy of the source.
        """
        ...
    
    @staticmethod
    def CreateChildCurveVector_SwapFromSource(source: CurveVector) -> MSPyBentleyGeom.ICurvePrimitive:
        """
        Create a child vector; contents of source are taken, source itself is
        cleared.
        """
        ...
    
    @staticmethod
    def CreateInterpolationBetweenCurves(curveA: MSPyBentleyGeom.ICurvePrimitive, fraction: float, curveB: MSPyBentleyGeom.ICurvePrimitive) -> MSPyBentleyGeom.ICurvePrimitive:
        """
        Create a curve that is interpolated between parents.
        
        :param (input):
        curveA first curve
        
        :param (input):
        curveB second curve
        
        :param (input):
        fraction interpolation position.
        
        :returns:
        null curve pointer if curves are not compatible for interpolation.
        """
        ...
    
    @staticmethod
    def CreateInterpolationCurve(fitCurve: MSInterpolationCurve) -> MSPyBentleyGeom.ICurvePrimitive:
        """
        Allocate and fill a new interpolation curve
        
        :param (input):
        fitCurve source curve. Data is COPIED into the new object. Caller
        is still responsible for freeing the input fitCurve.
        """
        ...
    
    @staticmethod
    def CreateInterpolationCurveSwapFromSource(fitCurve: MSInterpolationCurve) -> MSPyBentleyGeom.ICurvePrimitive:
        """
        Allocate and fill a new interpolation curve
        
        :param (input):
        fitCurve source curve. Data is swapped into the curve. input
        fitCurve is zeroed.
        """
        ...
    
    @staticmethod
    def CreateLine(segment: DSegment3d) -> MSPyBentleyGeom.ICurvePrimitive:
        """
        Allocate and fill a new line segemnt.
        
        :param (input):
        segment source segment.
        """
        ...
    
    @staticmethod
    def CreateLineString(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateLineString(points: List[DPoint3d]) -> MSPyBentleyGeom.ICurvePrimitive
        
        Allocate and fill a new linestring
        
        :param (input):
        points source coordinates.
        
        :param (input):
        nPoints point count.
        
        2. CreateLineString(points: list) -> MSPyBentleyGeom.ICurvePrimitive
        
        Allocate and fill a new linestring
        
        :param (input):
        points source coordinates.
        
        :param (input):
        nPoints point count.
        """
        ...
    
    @staticmethod
    def CreatePartialCurve(parentCurve: MSPyBentleyGeom.ICurvePrimitive, fraction0: float, fraction1: float, index: int = 0) -> MSPyBentleyGeom.ICurvePrimitive:
        """
        Allocate and fill a reference to a portion of a parent curve.
        
        :param (input):
        parentCurve pointer to another curve.
        
        :param (input):
        fraction0 start of active portion of parent.
        
        :param (input):
        fraction1 end of active portion of parent.
        
        :param (input):
        index application data.
        
        Remark:
        fraction0 and fraction1 may be in forward or reverse relationship.
        """
        ...
    
    @staticmethod
    def CreatePointString(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreatePointString(points: List[DPoint3d]) -> MSPyBentleyGeom.ICurvePrimitive
        
        Allocate and fill a new point string
        
        :param (input):
        points coordinates to copy into the primitive
        
        :param (input):
        nPoints number of points
        
        2. CreatePointString(points: list) -> MSPyBentleyGeom.ICurvePrimitive
        
        Allocate and fill a new point string
        
        :param (input):
        points coordinates to copy into the primitive
        
        :param (input):
        nPoints number of points
        """
        ...
    
    @staticmethod
    def CreatePseudoSpiralPointBearingRadiusLengthRadius(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreatePseudoSpiralPointBearingRadiusLengthRadius(typeCode: int, startPoint: DPoint3d, startRadians: float, radiusA: float, lengthAB: float, radiusB: float) -> MSPyBentleyGeom.ICurvePrimitive
        
        Construct a spiral with start radius, spiral length, and end radius.
        ul> li> The spiral is paralllel to the xy plane. li> This is a special
        construction for " cubic " approximations. li> The constructed spiral is
        a fractional subset of another spiral that includes its inflection
        point (which may be outside the active fractional subset). ul>
        
        2. CreatePseudoSpiralPointBearingRadiusLengthRadius(typeCode: int, startPoint: DPoint3d, startRadians: float, radiusA: float, lengthAB: float, radiusB: float, startFraction: float, endFraction: float) -> MSPyBentleyGeom.ICurvePrimitive
        
        Construct a spiral with start radius, spiral length, and end radius.
        ul> li> The spiral is paralllel to the xy plane. li> This is a special
        construction for " cubic " approximations. li> The constructed spiral is
        a fractional subset of another spiral that includes its inflection
        point (which may be outside the active fractional subset). ul
        """
        ...
    
    @staticmethod
    def CreatePseudolSpiralWithTrueRadiusLengthRadius(transitionType: int, startPoint: DPoint3d, startRadians: float, startRadius: float, targetLength: float, endRadius: float) -> MSPyBentleyGeom.ICurvePrimitive:
        ...
    
    @staticmethod
    def CreateRectangle(x0: float, y0: float, x1: float, y1: float, z: float, areaSignPreference: int = 0) -> MSPyBentleyGeom.ICurvePrimitive:
        """
        Create a rectangle from xy corners.
        
        :param (input):
        x0 start point x coordinate
        
        :param (input):
        y0 start point y coordinate
        
        :param (input):
        x1 opposite corner x coordinate
        
        :param (input):
        y1 opposite corner y coordinate
        
        :param (input):
        z z value for all points.
        
        :param (input):
        areaSignPreference is one of
        
        * any positive integer to force positive xy areLa.
        
        * 0 to take order (x0,y0)(x1,y0),(x1,y1),(x0,y1)
        
        * any negative integer to force negative xy area.
        """
        ...
    
    @staticmethod
    def CreateSpiral(spiral: DSpiral2dBase, frame: Transform, fractionA: float, fractionB: float) -> MSPyBentleyGeom.ICurvePrimitive:
        """
        Allocate and fill a spiral curve.
        
        :param (input):
        spiral spiral structure (to be cloned -- caller still responsible
        for deallocation)
        
        :param (input):
        frame placement frame
        
        :param (input):
        fractionA start fraction for active portion of curve
        
        :param (input):
        fractionB end fraction for active portion of curve
        """
        ...
    
    @staticmethod
    def CreateSpiralBearingCurvatureBearingCurvature(transitionType: int, startRadians: float, startCurvature: float, endRadians: float, endCurvature: float, frame: Transform, fractionA: float, fractionB: float) -> MSPyBentleyGeom.ICurvePrimitive:
        """
        Allocate and fill a spiral curve.
        
        :param (input):
        startRadians bearing at start
        
        :param (input):
        startCurvature curvature at start (or 0 of flat)
        
        :param (input):
        endRadians bearing at end
        
        :param (input):
        endCurvature curvature at end (or 0 if flat)
        
        :param (input):
        transitionType (see DSpiral2dBase)
        
        :param (input):
        frame placement frame
        
        :param (input):
        fractionA start fraction for active portion of curve
        
        :param (input):
        fractionB end fraction for active portion of curve
        """
        ...
    
    @staticmethod
    def CreateSpiralBearingCurvatureLengthCurvature(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateSpiralBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float, frame: Transform, fractionA: float, fractionB: float, extraData: MSPyBentleyGeom.DoubleArray) -> MSPyBentleyGeom.ICurvePrimitive
        
        Allocate and fill a spiral curve.
        
        :param (input):
        startRadians bearing at start
        
        :param (input):
        startCurvature curvature at start (or 0 if flat)
        
        :param (input):
        length length along spiral
        
        :param (input):
        endCurvature curvature at end (or 0 if flat)
        
        :param (input):
        transitionType (see DSpiral2dBase)
        
        :param (input):
        frame placement frame
        
        :param (input):
        fractionA start fraction for active portion of curve
        
        :param (input):
        fractionB end fraction for active portion of curve @praam (input)
        extraData type-specific extra data.
        
        2. CreateSpiralBearingCurvatureLengthCurvature(transitionType: int, startRadians: float, startCurvature: float, length: float, endCurvature: float, frame: Transform, fractionA: float, fractionB: float) -> MSPyBentleyGeom.ICurvePrimitive
        
        Allocate and fill a spiral curve.
        
        :param (input):
        startRadians bearing at start
        
        :param (input):
        startCurvature curvature at start (or 0 if flat)
        
        :param (input):
        length length along spiral
        
        :param (input):
        endCurvature curvature at end (or 0 if flat)
        
        :param (input):
        transitionType (see DSpiral2dBase)
        
        :param (input):
        frame placement frame
        
        :param (input):
        fractionA start fraction for active portion of curve
        
        :param (input):
        fractionB end fraction for active portion of curve @praam (input)
        extraData type-specific extra data.
        """
        ...
    
    @staticmethod
    def CreateSpiralBearingRadiusBearingRadius(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateSpiralBearingRadiusBearingRadius(transitionType: int, startRadians: float, startRadius: float, endRadians: float, endRadius: float, frame: Transform, fractionA: float, fractionB: float, extraData: MSPyBentleyGeom.DoubleArray) -> MSPyBentleyGeom.ICurvePrimitive
        
        Allocate and fill a spiral curve.
        
        :param (input):
        startRadians bearing at start
        
        :param (input):
        startRadius radius at start (or 0 of flat)
        
        :param (input):
        endRadians bearing at end
        
        :param (input):
        endRadius radius at end (or 0 if flat)
        
        :param (input):
        transitionType (see DSpiral2dBase)
        
        :param (input):
        frame placement frame
        
        :param (input):
        fractionA start fraction for active portion of curve
        
        :param (input):
        fractionB end fraction for active portion of curve @praam (input)
        extraData type-specific extra data.
        
        2. CreateSpiralBearingRadiusBearingRadius(transitionType: int, startRadians: float, startRadius: float, endRadians: float, endRadius: float, frame: Transform, fractionA: float, fractionB: float) -> MSPyBentleyGeom.ICurvePrimitive
        
        Allocate and fill a spiral curve.
        
        :param (input):
        startRadians bearing at start
        
        :param (input):
        startRadius radius at start (or 0 of flat)
        
        :param (input):
        endRadians bearing at end
        
        :param (input):
        endRadius radius at end (or 0 if flat)
        
        :param (input):
        transitionType (see DSpiral2dBase)
        
        :param (input):
        frame placement frame
        
        :param (input):
        fractionA start fraction for active portion of curve
        
        :param (input):
        fractionB end fraction for active portion of curve @praam (input)
        extraData type-specific extra data.
        """
        ...
    
    @staticmethod
    def CreateSpiralBearingRadiusLengthRadius(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateSpiralBearingRadiusLengthRadius(transitionType: int, startRadians: float, startRadius: float, length: float, endRadius: float, frame: Transform, fractionA: float, fractionB: float, extraData: MSPyBentleyGeom.DoubleArray) -> MSPyBentleyGeom.ICurvePrimitive
        
        Allocate and fill a spiral curve.
        
        :param (input):
        startRadians bearing at start
        
        :param (input):
        startRadius radius at start (or 0 if flat)
        
        :param (input):
        length length along spiral
        
        :param (input):
        endRadius radius at end (or 0 if flat)
        
        :param (input):
        transitionType (see DSpiral2dBase)
        
        :param (input):
        frame placement frame
        
        :param (input):
        fractionA start fraction for active portion of curve
        
        :param (input):
        fractionB end fraction for active portion of curve @praam (input)
        extraData type-specific extra data.
        
        2. CreateSpiralBearingRadiusLengthRadius(transitionType: int, startRadians: float, startRadius: float, length: float, endRadius: float, frame: Transform, fractionA: float, fractionB: float) -> MSPyBentleyGeom.ICurvePrimitive
        
        Allocate and fill a spiral curve.
        
        :param (input):
        startRadians bearing at start
        
        :param (input):
        startRadius radius at start (or 0 if flat)
        
        :param (input):
        length length along spiral
        
        :param (input):
        endRadius radius at end (or 0 if flat)
        
        :param (input):
        transitionType (see DSpiral2dBase)
        
        :param (input):
        frame placement frame
        
        :param (input):
        fractionA start fraction for active portion of curve
        
        :param (input):
        fractionB end fraction for active portion of curve @praam (input)
        extraData type-specific extra data.
        """
        ...
    
    @staticmethod
    def CreateXYCatenaryVertexCoefficientSignedDistanceLimits(a: float, basis: DPlane3dByVectors, s0: float, s1: float) -> MSPyBentleyGeom.ICurvePrimitive:
        ...
    
    class CurvePrimitiveMarkerBit:
        """
        Members:
        
        eCURVE_PRIMITIVE_BIT_GapCurve
        
        eCURVE_PRIMITIVE_BIT_AllApplicationBits
        """
    
        def __init__(self: MSPyBentleyGeom.ICurvePrimitive.CurvePrimitiveMarkerBit, value: int) -> None:
            ...
        
        eCURVE_PRIMITIVE_BIT_AllApplicationBits: CurvePrimitiveMarkerBit
        
        eCURVE_PRIMITIVE_BIT_GapCurve: CurvePrimitiveMarkerBit
        
        @property
        def name(self: handle) -> str:
            ...
        
        @property
        def value(arg0: MSPyBentleyGeom.ICurvePrimitive.CurvePrimitiveMarkerBit) -> int:
            ...
        
    @property
    def CurvePrimitiveType(arg0: MSPyBentleyGeom.ICurvePrimitive) -> MSPyBentleyGeom.ICurvePrimitive.CurvePrimitiveType:
        ...
    
    def FastLength(self: MSPyBentleyGeom.ICurvePrimitive) -> tuple:
        """
        Compute a fast approximation of curve length. return false if no
        measurable curves.
        
        :param (output):
        length curve length. For ChildCurveVector, length of contained
        curves is summed.
        """
        ...
    
    def FastMaxAbs(self: MSPyBentleyGeom.ICurvePrimitive) -> float:
        """
        Return a representative large coordinate. This is not required to be a
        true range limit. For instance, a max abs of a bspline pole range is
        acceptable.
        """
        ...
    
    def FractionToFrenetFrame(*args, **kwargs):
        """
        Overloaded function.
        
        1. FractionToFrenetFrame(self: MSPyBentleyGeom.ICurvePrimitive, f: float, frame: Transform) -> bool
        
        Evaluate curve point at fractional position within its parameter
        space.
        
        :returns:
        false if this is not a parameterized curve (EXAMPLE:A
        ChildCurveVector)
        
        :param (input):
        f evaluation fraction.
        
        :param (output):
        frame Coordinate frame with origin on curve, x direction along
        curve, y direction in curvature plane, z direction perpendicular.
        
        2. FractionToFrenetFrame(self: MSPyBentleyGeom.ICurvePrimitive, f: float, frame: Transform) -> tuple
        
        Evaluate curve point at fractional position within its parameter
        space.
        
        :returns:
        false if this is not a parameterized curve (EXAMPLE:A
        ChildCurveVector)
        
        :param (input):
        f evaluation fraction.
        
        :param (output):
        frame Coordinate frame with origin on curve, x direction along
        curve, y direction in curvature plane, z direction perpendicular.
        
        3. FractionToFrenetFrame(self: MSPyBentleyGeom.ICurvePrimitive, f: float) -> ValidatedValue<Transform>
        
        Evaluate curve point at fractional position within its parameter
        space.
        
        :returns:
        false if this is not a parameterized curve (EXAMPLE:A
        ChildCurveVector)
        
        :param (input):
        f evaluation fraction.
        
        :param (output):
        frame Coordinate frame with origin on curve, x direction along
        curve, y direction in curvature plane, z direction perpendicular.
        """
        ...
    
    def FractionToPoint(*args, **kwargs):
        """
        Overloaded function.
        
        1. FractionToPoint(self: MSPyBentleyGeom.ICurvePrimitive, f: float, point: DPoint3d) -> bool
        
        Evaluate curve fractional position within its parameter space. return
        false if this is not a parameterized curve (EXAMPLE:A
        ChildCurveVector)
        
        :param (input):
        f evaluation fraction.
        
        :param (output):
        point point on curve.
        
        2. FractionToPoint(self: MSPyBentleyGeom.ICurvePrimitive, f: float, point: DPoint3d, tangent: DVec3d) -> bool
        
        Evaluate curve fractional position within its parameter space. return
        false if this is not a parameterized curve (EXAMPLE:A
        ChildCurveVector)
        
        :param (input):
        f evaluation fraction.
        
        :param (output):
        point point on curve.
        
        3. FractionToPoint(self: MSPyBentleyGeom.ICurvePrimitive, f: float, ray: DRay3d) -> bool
        
        Evaluate curve fractional position within its parameter space. return
        false if this is not a parameterized curve (EXAMPLE:A
        ChildCurveVector)
        
        :param (input):
        f evaluation fraction.
        
        :param (output):
        point point on curve.
        
        4. FractionToPoint(self: MSPyBentleyGeom.ICurvePrimitive, f: float, detail: MSPyBentleyGeom.CurveLocationDetail) -> bool
        
        Evaluate curve fractional position within its parameter space. return
        false if this is not a parameterized curve (EXAMPLE:A
        ChildCurveVector)
        
        :param (input):
        f evaluation fraction.
        
        :param (output):
        point point on curve.
        
        5. FractionToPoint(self: MSPyBentleyGeom.ICurvePrimitive, f: float, point: DPoint3d, tangent: DVec3d, derivate2: DVec3d) -> bool
        
        Evaluate curve fractional position within its parameter space. return
        false if this is not a parameterized curve (EXAMPLE:A
        ChildCurveVector)
        
        :param (input):
        f evaluation fraction.
        
        :param (output):
        point point on curve.
        
        6. FractionToPoint(self: MSPyBentleyGeom.ICurvePrimitive, f: float, point: DPoint3d, tangent: DVec3d, derivate2: DVec3d, derivate3: DVec3d) -> bool
        
        Evaluate curve fractional position within its parameter space. return
        false if this is not a parameterized curve (EXAMPLE:A
        ChildCurveVector)
        
        :param (input):
        f evaluation fraction.
        
        :param (output):
        point point on curve.
        """
        ...
    
    def FractionToPointWithTwoSidedDerivative(self: MSPyBentleyGeom.ICurvePrimitive, f: float, point: DPoint3d, derivativeA: DVec3d, derivativeB: DVec3d) -> bool:
        """
        Evaluate curve fractional position within its parameter space.
        
        * On a smooth curve, incoming and outgoing derivatives will be
        identical.
        
        * Incoming and outgoing derivatives can differ at linestring interior
        points and bspline knots.
        
        return false if this is not a parameterized curve (EXAMPLE:A
        ChildCurveVector)
        
        :param (input):
        f evaluation fraction.
        
        :param (output):
        point point on curve.
        
        :param (output):
        derivativeA first derivative with respect to the fractional
        coordinate, taken on the inbound (lower parameter) side of the
        parameter.
        
        :param (output):
        derivativeB first derivative with respect to the fractional
        coordinate, taken on the outbound (higher parameter) side of the
        parameter.
        """
        ...
    
    def GetAkimaCurve(self: MSPyBentleyGeom.ICurvePrimitive) -> List[DPoint3d]:
        ...
    
    def GetArc(self: MSPyBentleyGeom.ICurvePrimitive) -> DEllipse3d:
        ...
    
    def GetBreakFraction(self: MSPyBentleyGeom.ICurvePrimitive, arg0: int) -> tuple:
        """
        Return the fractional postion of a point where the curve's continuity
        has a break.
        """
        ...
    
    def GetBsplineCurve(self: MSPyBentleyGeom.ICurvePrimitive) -> RefCountedMSBsplineCurve:
        ...
    
    def GetChildCurveVector(self: MSPyBentleyGeom.ICurvePrimitive) -> CurveVector:
        ...
    
    def GetCurvePrimitiveType(self: MSPyBentleyGeom.ICurvePrimitive) -> MSPyBentleyGeom.ICurvePrimitive.CurvePrimitiveType:
        """
        Return the integer type code for the curve primitive type.
        """
        ...
    
    def GetId(self: MSPyBentleyGeom.ICurvePrimitive) -> CurvePrimitiveId:
        ...
    
    def GetIntTag(self: MSPyBentleyGeom.ICurvePrimitive) -> int:
        """
        Get the Int64 tag (cast to int)
        """
        ...
    
    def GetInterpolationCurve(self: MSPyBentleyGeom.ICurvePrimitive) -> MSInterpolationCurve:
        ...
    
    def GetLine(self: MSPyBentleyGeom.ICurvePrimitive) -> DSegment3d:
        ...
    
    def GetLineString(self: MSPyBentleyGeom.ICurvePrimitive) -> List[DPoint3d]:
        ...
    
    def GetMSBsplineCurvePtr(self: MSPyBentleyGeom.ICurvePrimitive, fraction0: float = 0.0, fraction1: float = 1.0) -> RefCountedMSBsplineCurve:
        ...
    
    def GetMarkerBit(self: MSPyBentleyGeom.ICurvePrimitive, selector: MSPyBentleyGeom.ICurvePrimitive.CurvePrimitiveMarkerBit) -> bool:
        """
        Ask if specified marker bit is on or off
        """
        ...
    
    def GetPartialCurveDetail(self: MSPyBentleyGeom.ICurvePrimitive) -> MSPyBentleyGeom.PartialCurveDetail:
        ...
    
    def GetPointString(self: MSPyBentleyGeom.ICurvePrimitive) -> List[DPoint3d]:
        ...
    
    def GetProxyBsplineCurve(self: MSPyBentleyGeom.ICurvePrimitive) -> RefCountedMSBsplineCurve:
        ...
    
    def GetRange(*args, **kwargs):
        """
        Overloaded function.
        
        1. GetRange(self: MSPyBentleyGeom.ICurvePrimitive, range: DRange3d) -> bool
        
        Return range of the primitive.
        
        2. GetRange(self: MSPyBentleyGeom.ICurvePrimitive, range: DRange3d, transform: Transform) -> bool
        
        Return range of the primitive.
        """
        ...
    
    def GetSpiralPlacement(self: MSPyBentleyGeom.ICurvePrimitive) -> DSpiral2dPlacement:
        ...
    
    def GetStartEnd(*args, **kwargs):
        """
        Overloaded function.
        
        1. GetStartEnd(self: MSPyBentleyGeom.ICurvePrimitive, pointA: DPoint3d, pointB: DPoint3d) -> bool
        
        return the start and end points of the curve
        
        :param (output):
        pointA start point
        
        :param (output):
        pointB end point
        
        Remark:
        For ChildCurveVector, the first and last component endpoints are
        determined.
        
        2. GetStartEnd(self: MSPyBentleyGeom.ICurvePrimitive, pointA: DPoint3d, pointB: DPoint3d, unitTangentA: DVec3d, unitTangentB: DVec3d) -> bool
        
        return the start and end points of the curve
        
        :param (output):
        pointA start point
        
        :param (output):
        pointB end point
        
        Remark:
        For ChildCurveVector, the first and last component endpoints are
        determined.
        """
        ...
    
    def GetStartPoint(self: MSPyBentleyGeom.ICurvePrimitive, point: DPoint3d) -> bool:
        """
        Return first primitive in a deep search.
        
        :param (output):
        point start point.
        """
        ...
    
    def GetStrokeCount(self: MSPyBentleyGeom.ICurvePrimitive, options: IFacetOptions, startFraction: float = 0.0, endFraction: float = 1.0) -> int:
        """
        Return the number of strokes needed to approximate this curve
        primitive.
        """
        ...
    
    def GetTag(self: MSPyBentleyGeom.ICurvePrimitive) -> int:
        """
        Get the Int64 tag ...
        """
        ...
    
    @property
    def Id(arg0: MSPyBentleyGeom.ICurvePrimitive) -> CurvePrimitiveId:
        ...
    
    @property
    def IntTag(arg0: MSPyBentleyGeom.ICurvePrimitive) -> int:
        ...
    @IntTag.setter
    def IntTag(arg0: MSPyBentleyGeom.ICurvePrimitive, arg1: int) -> None:
        ...
    
    @property
    def InterpolationCurve(arg0: MSPyBentleyGeom.ICurvePrimitive) -> MSInterpolationCurve:
        ...
    
    def IsExtensibleFractionSpace(self: MSPyBentleyGeom.ICurvePrimitive) -> bool:
        """
        Test if fractional queries allow extension. When this is true, the
        CurvePrimitive recognizes fractions outside of 0..1.
        """
        ...
    
    def IsFractionSpace(self: MSPyBentleyGeom.ICurvePrimitive) -> bool:
        """
        Test if this is a curve (i.e. not a child vector or point string)
        """
        ...
    
    def IsMappableFractionSpace(self: MSPyBentleyGeom.ICurvePrimitive) -> bool:
        """
        Test if cloned fractional intervals map linearly back to parent
        fractions. (Not true for linestrings and child curve vectors.
        """
        ...
    
    def IsPeriodicFractionSpace(self: MSPyBentleyGeom.ICurvePrimitive) -> tuple:
        """
        Return true if the curve is part of a (possibly larger) periodic
        curve.
        
        :param (output):
        period period as a multiple of the bounded curve's fraction space.
        For example, a quarter arc has a period of 4.
        """
        ...
    
    def IsSameStructure(self: MSPyBentleyGeom.ICurvePrimitive, other: MSPyBentleyGeom.ICurvePrimitive) -> bool:
        """
        Recursive check for structural match (tree structure and leaf type)
        with the other curve primitive.
        """
        ...
    
    def IsSameStructureAndGeometry(self: MSPyBentleyGeom.ICurvePrimitive, other: MSPyBentleyGeom.ICurvePrimitive, tolerance: float = 0.0) -> bool:
        """
        Recursive check for match (tree structure. leaf type, and geometry)
        with a peer. <param name=" other ">peer for comparison</param> <param
        name=" tolerance ">distance tolerance. (See DoubleOps.AlmostEqual
        ())</param
        """
        ...
    
    def Length(*args, **kwargs):
        """
        Overloaded function.
        
        1. Length(self: MSPyBentleyGeom.ICurvePrimitive) -> tuple
        
        Compute curve length. return false if no measurable curves.
        
        :param (output):
        length curve length. For ChildCurveVector, length of contained
        curves is summed.
        
        2. Length(self: MSPyBentleyGeom.ICurvePrimitive, arg0: RotMatrix) -> tuple
        
        Compute curve length. return false if no measurable curves.
        
        :param (output):
        length curve length. For ChildCurveVector, length of contained
        curves is summed.
        """
        ...
    
    @property
    def Line(arg0: MSPyBentleyGeom.ICurvePrimitive) -> DSegment3d:
        ...
    
    @property
    def LineString(arg0: MSPyBentleyGeom.ICurvePrimitive) -> List[DPoint3d]:
        ...
    
    def NumComponent(self: MSPyBentleyGeom.ICurvePrimitive) -> int:
        """
        Return the number of components that can be parameterized. This is ul>
        li> 1 for all curves except linestrings. li> 0 for child curve vector
        li> the number of edges in a linestring. ul
        """
        ...
    
    @property
    def PartialCurveDetail(arg0: MSPyBentleyGeom.ICurvePrimitive) -> MSPyBentleyGeom.PartialCurveDetail:
        ...
    
    def PointAtSignedDistanceFromFraction(*args, **kwargs):
        """
        Overloaded function.
        
        1. PointAtSignedDistanceFromFraction(self: MSPyBentleyGeom.ICurvePrimitive, startFraction: float, signedDistance: float, allowExtension: bool, location: MSPyBentleyGeom.CurveLocationDetail) -> bool
        
        Attempt to move a specified distance from given fraction.
        
        :param (input):
        startFraction starting position.
        
        :param (input):
        signedDistance distance for attempted move.
        
        :param (input):
        allowExtension controls extended behaior of line, arc, and
        linestring.
        
        :param (output):
        location fraction and point after move.{a} field indicates actual
        signed distance moved (which may be less than request!!)
        
        Remark:
        If extension is not allowed, there are fussy rules for both the
        input and output. (1) The startFraction is clamped to{0..1} (2)
        Movement stops at the endpoint in the indicated direction.
        
        2. PointAtSignedDistanceFromFraction(self: MSPyBentleyGeom.ICurvePrimitive, worldToView: RotMatrix, startFraction: float, signedDistance: float, allowExtension: bool, location: MSPyBentleyGeom.CurveLocationDetail) -> bool
        
        Attempt to move a specified distance from given fraction.
        
        :param (input):
        startFraction starting position.
        
        :param (input):
        signedDistance distance for attempted move.
        
        :param (input):
        allowExtension controls extended behaior of line, arc, and
        linestring.
        
        :param (output):
        location fraction and point after move.{a} field indicates actual
        signed distance moved (which may be less than request!!)
        
        Remark:
        If extension is not allowed, there are fussy rules for both the
        input and output. (1) The startFraction is clamped to{0..1} (2)
        Movement stops at the endpoint in the indicated direction.
        """
        ...
    
    @property
    def PointString(arg0: MSPyBentleyGeom.ICurvePrimitive) -> List[DPoint3d]:
        ...
    
    def ProjectedParameterRange(*args, **kwargs):
        """
        Overloaded function.
        
        1. ProjectedParameterRange(self: MSPyBentleyGeom.ICurvePrimitive, ray: DRay3d) -> DRange1d
        
        Return the range the primitive projected onto a ray. return DRange1d
        with range data.
        
        :param (input):
        ray test ray.
        
        :param (input):
        fraction0 start fraction of active part.
        
        :param (input):
        fraction1 end fraction of active part.
        
        Remark:
        If the ray's direction vector is a unit vector, the projected
        parameters are physical distances.
        
        Remark:
        If the ray's direction vector is NOT a unit vector, the projected
        parameters are fractions of the ray's direction vector.
        
        Remark:
        If the primitive has no curves, the returned range returns true on
        the DRange1d.IsNull() predicate.
        
        2. ProjectedParameterRange(self: MSPyBentleyGeom.ICurvePrimitive, ray: DRay3d, fraction0: float, fraction1: float) -> DRange1d
        
        Return the range the primitive projected onto a ray. return DRange1d
        with range data.
        
        :param (input):
        ray test ray.
        
        :param (input):
        fraction0 start fraction of active part.
        
        :param (input):
        fraction1 end fraction of active part.
        
        Remark:
        If the ray's direction vector is a unit vector, the projected
        parameters are physical distances.
        
        Remark:
        If the ray's direction vector is NOT a unit vector, the projected
        parameters are fractions of the ray's direction vector.
        
        Remark:
        If the primitive has no curves, the returned range returns true on
        the DRange1d.IsNull() predicate.
        """
        ...
    
    @property
    def ProxyBsplineCurve(arg0: MSPyBentleyGeom.ICurvePrimitive) -> RefCountedMSBsplineCurve:
        ...
    
    def ReverseCurvesInPlace(self: MSPyBentleyGeom.ICurvePrimitive) -> bool:
        """
        reverse the parameterization in place.
        """
        ...
    
    def SetIntTag(self: MSPyBentleyGeom.ICurvePrimitive, tag: int) -> None:
        ...
    
    def SetMarkerBit(self: MSPyBentleyGeom.ICurvePrimitive, selector: MSPyBentleyGeom.ICurvePrimitive.CurvePrimitiveMarkerBit, value: bool) -> None:
        """
        Set the specified marker bit on or off
        """
        ...
    
    def SetTag(self: MSPyBentleyGeom.ICurvePrimitive, tag: int) -> None:
        """
        Set the Int64 tag
        """
        ...
    
    def SignedDistanceBetweenFractions(*args, **kwargs):
        """
        Overloaded function.
        
        1. SignedDistanceBetweenFractions(self: MSPyBentleyGeom.ICurvePrimitive, startFraction: float, endFraction: float) -> tuple
        
        Return distance between fractions. Primitives that do not have
        extensible fraction spaces will SILENTLY clamp the fractions to 0..1.
        return false if this is not a parameterized curve (EXAMPLE:A
        ChildCurveVector)
        
        :param (input):
        startFraction starting position for partial curve.
        
        :param (input):
        endFraction end position for partial curve.
        
        :param (output):
        signedDistance distance along curve, negative if fraction
        direction is reversed.
        
        2. SignedDistanceBetweenFractions(self: MSPyBentleyGeom.ICurvePrimitive, worldToLocal: RotMatrix, startFraction: float, endFraction: float) -> tuple
        
        Return distance between fractions. Primitives that do not have
        extensible fraction spaces will SILENTLY clamp the fractions to 0..1.
        return false if this is not a parameterized curve (EXAMPLE:A
        ChildCurveVector)
        
        :param (input):
        startFraction starting position for partial curve.
        
        :param (input):
        endFraction end position for partial curve.
        
        :param (output):
        signedDistance distance along curve, negative if fraction
        direction is reversed.
        """
        ...
    
    @property
    def SpiralPlacement(arg0: MSPyBentleyGeom.ICurvePrimitive) -> DSpiral2dPlacement:
        ...
    
    @property
    def Tag(arg0: MSPyBentleyGeom.ICurvePrimitive) -> int:
        ...
    @Tag.setter
    def Tag(arg0: MSPyBentleyGeom.ICurvePrimitive, arg1: int) -> None:
        ...
    
    def TransformInPlace(self: MSPyBentleyGeom.ICurvePrimitive, transform: Transform) -> bool:
        """
        Transform in place.
        """
        ...
    
    def TryAddLineStringPoint(self: MSPyBentleyGeom.ICurvePrimitive, xyz: DPoint3d) -> bool:
        """
        If this is a linestring, add a point.
        """
        ...
    
    def TryGetArc(self: MSPyBentleyGeom.ICurvePrimitive, arc: DEllipse3d) -> bool:
        """
        If this is a line primitive, copy its coordinate data to a DEllipse3d.
        """
        ...
    
    def TryGetLine(self: MSPyBentleyGeom.ICurvePrimitive, segment: DSegment3d) -> bool:
        """
        If this is a line primitive, copy its coordinate data to a DSegment3d.
        """
        ...
    
    def TryGetPartialCurveData(self: MSPyBentleyGeom.ICurvePrimitive) -> tuple:
        ...
    
    def TryGetSegmentInLineString(self: MSPyBentleyGeom.ICurvePrimitive, segment: DSegment3d, startPointIndex: int) -> bool:
        """
        If this is a linestring and index is valid, get the (single) indexed
        segment.
        """
        ...
    
    def TrySetEnd(self: MSPyBentleyGeom.ICurvePrimitive, xyz: DPoint3d) -> bool:
        """
        Modify the end point if possible
        """
        ...
    
    def TrySetStart(self: MSPyBentleyGeom.ICurvePrimitive, xyz: DPoint3d) -> bool:
        """
        Modify the start point if possible
        """
        ...
    
    def WireCentroid(self: MSPyBentleyGeom.ICurvePrimitive, fraction0: float = 0.0, fraction1: float = 1.0) -> tuple:
        """
        Return the centroid of (a portion of) the curve.
        
        :param (output):
        length curve length
        
        :param (output):
        centroid curve centroid
        
        :param (input):
        fraction0 start fraction of active part of sweep.
        
        :param (input):
        fraction1 end fraction of active part of sweep.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    
    eCURVE_PRIMITIVE_BIT_AllApplicationBits: CurvePrimitiveMarkerBit
    
    eCURVE_PRIMITIVE_BIT_GapCurve: CurvePrimitiveMarkerBit
    
    eCURVE_PRIMITIVE_TYPE_AkimaCurve: CurvePrimitiveType
    
    eCURVE_PRIMITIVE_TYPE_Arc: CurvePrimitiveType
    
    eCURVE_PRIMITIVE_TYPE_BsplineCurve: CurvePrimitiveType
    
    eCURVE_PRIMITIVE_TYPE_CurveVector: CurvePrimitiveType
    
    eCURVE_PRIMITIVE_TYPE_InterpolationCurve: CurvePrimitiveType
    
    eCURVE_PRIMITIVE_TYPE_Invalid: CurvePrimitiveType
    
    eCURVE_PRIMITIVE_TYPE_Line: CurvePrimitiveType
    
    eCURVE_PRIMITIVE_TYPE_LineString: CurvePrimitiveType
    
    eCURVE_PRIMITIVE_TYPE_NotClassified: CurvePrimitiveType
    
    eCURVE_PRIMITIVE_TYPE_PartialCurve: CurvePrimitiveType
    
    eCURVE_PRIMITIVE_TYPE_PointString: CurvePrimitiveType
    
    eCURVE_PRIMITIVE_TYPE_Spiral: CurvePrimitiveType
    
class ICurvePrimitivePtrArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ICurvePrimitivePtrArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.ICurvePrimitivePtrArray, arg0: MSPyBentleyGeom.ICurvePrimitivePtrArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.ICurvePrimitivePtrArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.ICurvePrimitivePtrArray, x: MSPyBentleyGeom.ICurvePrimitive) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.ICurvePrimitivePtrArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def count(self: MSPyBentleyGeom.ICurvePrimitivePtrArray, x: MSPyBentleyGeom.ICurvePrimitive) -> int:
        """
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.ICurvePrimitivePtrArray, L: MSPyBentleyGeom.ICurvePrimitivePtrArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.ICurvePrimitivePtrArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.ICurvePrimitivePtrArray, i: int, x: MSPyBentleyGeom.ICurvePrimitive) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.ICurvePrimitivePtrArray) -> MSPyBentleyGeom.ICurvePrimitive
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.ICurvePrimitivePtrArray, i: int) -> MSPyBentleyGeom.ICurvePrimitive
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(self: MSPyBentleyGeom.ICurvePrimitivePtrArray, x: MSPyBentleyGeom.ICurvePrimitive) -> None:
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class IFacetOptions:
    """
    None
    """

    @property
    def AngleTolerance(arg0: MSPyBentleyGeom.IFacetOptions) -> float:
        ...
    @AngleTolerance.setter
    def AngleTolerance(arg0: MSPyBentleyGeom.IFacetOptions, arg1: float) -> None:
        ...
    
    @property
    def BSurfSmoothTriangleFlowRequired(arg0: MSPyBentleyGeom.IFacetOptions) -> bool:
        ...
    @BSurfSmoothTriangleFlowRequired.setter
    def BSurfSmoothTriangleFlowRequired(arg0: MSPyBentleyGeom.IFacetOptions, arg1: bool) -> None:
        ...
    
    def BezierStrokeCount(self: MSPyBentleyGeom.IFacetOptions, poles: MSPyBentleyGeom.DPoint4dArray, index0: int, order: int) -> tuple:
        """
        Compute the number of strokes needed for a (weighted) bezier.
        """
        ...
    
    def BsplineCurveStrokeCount(self: MSPyBentleyGeom.IFacetOptions, curve: MSBsplineCurve) -> int:
        """
        Comptue the number of strokes needed for a bspline curve.
        """
        ...
    
    @property
    def ChordTolerance(arg0: MSPyBentleyGeom.IFacetOptions) -> float:
        ...
    @ChordTolerance.setter
    def ChordTolerance(arg0: MSPyBentleyGeom.IFacetOptions, arg1: float) -> None:
        ...
    
    def Clone(self: MSPyBentleyGeom.IFacetOptions) -> MSPyBentleyGeom.IFacetOptions:
        """
        Create a copy.
        """
        ...
    
    @property
    def CombineFacets(arg0: MSPyBentleyGeom.IFacetOptions) -> bool:
        ...
    @CombineFacets.setter
    def CombineFacets(arg0: MSPyBentleyGeom.IFacetOptions, arg1: bool) -> None:
        ...
    
    @property
    def ConvexFacetsRequired(arg0: MSPyBentleyGeom.IFacetOptions) -> bool:
        ...
    @ConvexFacetsRequired.setter
    def ConvexFacetsRequired(arg0: MSPyBentleyGeom.IFacetOptions, arg1: bool) -> None:
        ...
    
    @staticmethod
    def CreateForCurves() -> MSPyBentleyGeom.IFacetOptions:
        """
        Return a (smart pointer) implementation of the interface, with
        tolerances set for typical curves.
        """
        ...
    
    @staticmethod
    def CreateForSurfaces(chordTol: float = 0.0, angleRadians: float = 0.26179938779914946, maxEdgeLength: float = 0.0, triangulate: bool = False, normals: bool = False, params: bool = False) -> MSPyBentleyGeom.IFacetOptions:
        """
        Return a (smart pointer) implementation of the interface
        """
        ...
    
    @property
    def CurvatureWeightFactor(arg0: MSPyBentleyGeom.IFacetOptions) -> float:
        ...
    @CurvatureWeightFactor.setter
    def CurvatureWeightFactor(arg0: MSPyBentleyGeom.IFacetOptions, arg1: float) -> None:
        ...
    
    @property
    def CurveParameterMapping(arg0: MSPyBentleyGeom.IFacetOptions) -> CurveParameterMapping:
        ...
    @CurveParameterMapping.setter
    def CurveParameterMapping(arg0: MSPyBentleyGeom.IFacetOptions, arg1: CurveParameterMapping) -> None:
        ...
    
    @property
    def CurvedSurfaceMaxPerFace(arg0: MSPyBentleyGeom.IFacetOptions) -> int:
        ...
    @CurvedSurfaceMaxPerFace.setter
    def CurvedSurfaceMaxPerFace(arg0: MSPyBentleyGeom.IFacetOptions, arg1: int) -> None:
        ...
    
    def DistanceAndTurnStrokeCount(self: MSPyBentleyGeom.IFacetOptions, distance: float, turnRadians: float) -> int:
        """
        Compute the number of strokes needed for distance with turn.
        """
        ...
    
    def DistanceStrokeCount(self: MSPyBentleyGeom.IFacetOptions, distance: float) -> int:
        """
        Compute the number of strokes needed for a distance.
        """
        ...
    
    @property
    def DoSpatialLaplaceSmoothing(arg0: MSPyBentleyGeom.IFacetOptions) -> bool:
        ...
    @DoSpatialLaplaceSmoothing.setter
    def DoSpatialLaplaceSmoothing(arg0: MSPyBentleyGeom.IFacetOptions, arg1: bool) -> None:
        ...
    
    @property
    def EdgeChainsRequired(arg0: MSPyBentleyGeom.IFacetOptions) -> bool:
        ...
    @EdgeChainsRequired.setter
    def EdgeChainsRequired(arg0: MSPyBentleyGeom.IFacetOptions, arg1: bool) -> None:
        ...
    
    @property
    def EdgeHiding(arg0: MSPyBentleyGeom.IFacetOptions) -> bool:
        ...
    @EdgeHiding.setter
    def EdgeHiding(arg0: MSPyBentleyGeom.IFacetOptions, arg1: bool) -> None:
        ...
    
    def EllipseStrokeCount(self: MSPyBentleyGeom.IFacetOptions, ellipse: MSPyBentleyGeom.DEllipse3d) -> int:
        """
        Compute the number of strokes needed for a partial ellipse.
        """
        ...
    
    def FullEllipseStrokeCount(self: MSPyBentleyGeom.IFacetOptions, ellipse: MSPyBentleyGeom.DEllipse3d) -> int:
        """
        Compute the number of strokes needed for a complete ellipse.
        """
        ...
    
    def GetAngleTolerance(self: MSPyBentleyGeom.IFacetOptions) -> float:
        """
        Get the AngleTolerance facet control.
        """
        ...
    
    def GetBSurfSmoothTriangleFlowRequired(self: MSPyBentleyGeom.IFacetOptions) -> bool:
        """
        Get the SmoothTriangleFlow facet control -- bspline surfaces only.
        """
        ...
    
    def GetChordTolerance(self: MSPyBentleyGeom.IFacetOptions) -> float:
        """
        Get the ChordTolerance facet control.
        """
        ...
    
    def GetCombineFacets(self: MSPyBentleyGeom.IFacetOptions) -> bool:
        """
        Get the CombineFacets facet control.
        """
        ...
    
    def GetConvexFacetsRequired(self: MSPyBentleyGeom.IFacetOptions) -> bool:
        """
        Get the ConvexFacetsRequired facet control.
        """
        ...
    
    def GetCurvatureWeightFactor(self: MSPyBentleyGeom.IFacetOptions) -> float:
        """
        Get the CurvatureWeightFactor control.
        """
        ...
    
    def GetCurveParameterMapping(self: MSPyBentleyGeom.IFacetOptions) -> CurveParameterMapping:
        """
        Get the CurveParameterMapping facet control.
        """
        ...
    
    def GetCurvedSurfaceMaxPerFace(self: MSPyBentleyGeom.IFacetOptions) -> int:
        """
        Get the CurvedSurfaceMaxPerFace facet control.
        """
        ...
    
    def GetDoSpatialLaplaceSmoothing(self: MSPyBentleyGeom.IFacetOptions) -> bool:
        """
        Get the SmoothTriangleFlow facet control -- bspline surfaces only.
        """
        ...
    
    def GetEdgeChainsRequired(self: MSPyBentleyGeom.IFacetOptions) -> bool:
        """
        Get the EdgeChainsRequired facet control.
        """
        ...
    
    def GetEdgeHiding(self: MSPyBentleyGeom.IFacetOptions) -> bool:
        """
        Get the EdgeHiding facet control.
        """
        ...
    
    def GetHideSmoothEdgesWhenGeneratingNormals(self: MSPyBentleyGeom.IFacetOptions) -> bool:
        """
        Get whether mooth edges between facets are marked as hidden when
        normals are genereted for a polyface without normals.
        """
        ...
    
    def GetIgnoreFaceMaterialAttachments(self: MSPyBentleyGeom.IFacetOptions) -> bool:
        """
        Get whether facets returned for BReps are separated by color/material
        when there is per-face symbology attachments.
        """
        ...
    
    def GetMaxEdgeLength(self: MSPyBentleyGeom.IFacetOptions) -> float:
        """
        Get the MaxEdgeLength facet control.
        """
        ...
    
    def GetMaxFacetWidth(self: MSPyBentleyGeom.IFacetOptions) -> float:
        """
        Gets the maximum facet width.
        """
        ...
    
    def GetMaxPerBezier(self: MSPyBentleyGeom.IFacetOptions) -> int:
        """
        Get the MaxPerBezier facet control.
        """
        ...
    
    def GetMaxPerFace(self: MSPyBentleyGeom.IFacetOptions) -> int:
        """
        Get the MaxPerFace facet control.
        """
        ...
    
    def GetMinPerBezier(self: MSPyBentleyGeom.IFacetOptions) -> int:
        """
        Get the MinPerBezier facet control.
        """
        ...
    
    def GetNormalsRequired(self: MSPyBentleyGeom.IFacetOptions) -> bool:
        """
        Get the NormalsRequired facet control.
        """
        ...
    
    def GetParamDistanceScale(self: MSPyBentleyGeom.IFacetOptions) -> float:
        """
        Get the ParamDistanceScale facet control.
        """
        ...
    
    def GetParamMode(self: MSPyBentleyGeom.IFacetOptions) -> MSPyBentleyGeom.FacetParamMode:
        """
        Get the ParamMode facet control.
        """
        ...
    
    def GetParamsRequired(self: MSPyBentleyGeom.IFacetOptions) -> bool:
        """
        Get the ParamsRequired facet control.
        """
        ...
    
    def GetSilhouetteDirection(self: MSPyBentleyGeom.IFacetOptions) -> MSPyBentleyGeom.DVec3d:
        """
        Get the SilhouetteDirection facet control.
        """
        ...
    
    def GetSilhouetteOrigin(self: MSPyBentleyGeom.IFacetOptions) -> MSPyBentleyGeom.DPoint3d:
        """
        Get the SilhouetteOrigin facet control.
        """
        ...
    
    def GetSilhouetteToleranceDivisor(self: MSPyBentleyGeom.IFacetOptions) -> float:
        """
        Get the SilhouetteToleranceDivisor facet control.
        """
        ...
    
    def GetSilhouetteType(self: MSPyBentleyGeom.IFacetOptions) -> int:
        """
        Get the SilhouetteType facet control.
        """
        ...
    
    def GetSmoothTriangleFlowRequired(self: MSPyBentleyGeom.IFacetOptions) -> bool:
        """
        Get the SmoothTriangleFlow facet control.
        """
        ...
    
    def GetToleranceDistanceScale(self: MSPyBentleyGeom.IFacetOptions) -> float:
        """
        Get the ToleranceDistanceScale facet control.
        """
        ...
    
    def GetVertexColorsRequired(self: MSPyBentleyGeom.IFacetOptions) -> bool:
        """
        Get the VertexColorsRequired facet control.
        """
        ...
    
    @property
    def HideSmoothEdgesWhenGeneratingNormals(arg0: MSPyBentleyGeom.IFacetOptions) -> bool:
        ...
    @HideSmoothEdgesWhenGeneratingNormals.setter
    def HideSmoothEdgesWhenGeneratingNormals(arg0: MSPyBentleyGeom.IFacetOptions, arg1: bool) -> None:
        ...
    
    @property
    def IgnoreFaceMaterialAttachments(arg0: MSPyBentleyGeom.IFacetOptions) -> bool:
        ...
    @IgnoreFaceMaterialAttachments.setter
    def IgnoreFaceMaterialAttachments(arg0: MSPyBentleyGeom.IFacetOptions, arg1: bool) -> None:
        ...
    
    def LineStringStrokeCount(self: MSPyBentleyGeom.IFacetOptions, points: MSPyBentleyGeom.DPoint3dArray) -> int:
        """
        Comptue the number of strokes needed for a linestring. This is the sum
        of counts on individual segments.
        """
        ...
    
    @property
    def MaxEdgeLength(arg0: MSPyBentleyGeom.IFacetOptions) -> float:
        ...
    @MaxEdgeLength.setter
    def MaxEdgeLength(arg0: MSPyBentleyGeom.IFacetOptions, arg1: float) -> None:
        ...
    
    @property
    def MaxFacetWidth(arg0: MSPyBentleyGeom.IFacetOptions) -> float:
        ...
    @MaxFacetWidth.setter
    def MaxFacetWidth(arg0: MSPyBentleyGeom.IFacetOptions, arg1: float) -> None:
        ...
    
    @property
    def MaxPerBezier(arg0: MSPyBentleyGeom.IFacetOptions) -> int:
        ...
    @MaxPerBezier.setter
    def MaxPerBezier(arg0: MSPyBentleyGeom.IFacetOptions, arg1: int) -> None:
        ...
    
    @property
    def MaxPerFace(arg0: MSPyBentleyGeom.IFacetOptions) -> int:
        ...
    @MaxPerFace.setter
    def MaxPerFace(arg0: MSPyBentleyGeom.IFacetOptions, arg1: int) -> None:
        ...
    
    @property
    def MinPerBezier(arg0: MSPyBentleyGeom.IFacetOptions) -> int:
        ...
    @MinPerBezier.setter
    def MinPerBezier(arg0: MSPyBentleyGeom.IFacetOptions, arg1: int) -> None:
        ...
    
    @property
    def NormalsRequired(arg0: MSPyBentleyGeom.IFacetOptions) -> bool:
        ...
    @NormalsRequired.setter
    def NormalsRequired(arg0: MSPyBentleyGeom.IFacetOptions, arg1: bool) -> None:
        ...
    
    @property
    def ParamDistanceScale(arg0: MSPyBentleyGeom.IFacetOptions) -> float:
        ...
    @ParamDistanceScale.setter
    def ParamDistanceScale(arg0: MSPyBentleyGeom.IFacetOptions, arg1: float) -> None:
        ...
    
    @property
    def ParamMode(arg0: MSPyBentleyGeom.IFacetOptions) -> MSPyBentleyGeom.FacetParamMode:
        ...
    @ParamMode.setter
    def ParamMode(arg0: MSPyBentleyGeom.IFacetOptions, arg1: MSPyBentleyGeom.FacetParamMode) -> None:
        ...
    
    @property
    def ParamsRequired(arg0: MSPyBentleyGeom.IFacetOptions) -> bool:
        ...
    @ParamsRequired.setter
    def ParamsRequired(arg0: MSPyBentleyGeom.IFacetOptions, arg1: bool) -> None:
        ...
    
    def SegmentStrokeCount(self: MSPyBentleyGeom.IFacetOptions, segment: MSPyBentleyGeom.DSegment3d) -> int:
        """
        Compute the number of strokes needed for a line segment.
        """
        ...
    
    def SetAngleTolerance(self: MSPyBentleyGeom.IFacetOptions, normalAngleTolerance: float) -> None:
        """
        Set the AngleTolerance facet control.
        """
        ...
    
    def SetBSurfSmoothTriangleFlowRequired(self: MSPyBentleyGeom.IFacetOptions, value: bool) -> None:
        """
        Set the SmoothTriangleFlow facet control -- bspline surfaces only. A
        true unqualified SetSmoothTriangleFlowRequired overrides false for the
        Bsurf setting!!
        """
        ...
    
    def SetChordTolerance(self: MSPyBentleyGeom.IFacetOptions, chordTolerance: float) -> None:
        """
        Set the ChordTolerance facet control.
        """
        ...
    
    def SetCombineFacets(self: MSPyBentleyGeom.IFacetOptions, combineFacets: bool) -> None:
        """
        Set the CombineFacets facet control.
        """
        ...
    
    def SetConvexFacetsRequired(self: MSPyBentleyGeom.IFacetOptions, convexFacetsRequired: bool) -> None:
        """
        Set the ConvexFacetsRequired facet control.
        """
        ...
    
    def SetCurvatureWeightFactor(self: MSPyBentleyGeom.IFacetOptions, value: float) -> None:
        """
        Set the CurvatureWeightFactor facet control.
        """
        ...
    
    def SetCurveDefaults(self: MSPyBentleyGeom.IFacetOptions) -> None:
        """
        Set all parameters to default values for curves. (This will have finer
        angle tolerance than surfaces)
        """
        ...
    
    def SetCurveParameterMapping(self: MSPyBentleyGeom.IFacetOptions, curveParameterMapping: CurveParameterMapping) -> None:
        """
        Set the CurveParameterMapping facet control.
        """
        ...
    
    def SetCurvedSurfaceMaxPerFace(self: MSPyBentleyGeom.IFacetOptions, curvedSurfaceMaxPerFace: int) -> None:
        """
        Set the CurvedSurfaceMaxPerFace facet control.
        """
        ...
    
    def SetDefaults(self: MSPyBentleyGeom.IFacetOptions) -> None:
        """
        Set all parameters to default values
        """
        ...
    
    def SetDoSpatialLaplaceSmoothing(self: MSPyBentleyGeom.IFacetOptions, value: bool) -> None:
        """
        Set the SmoothTriangleFlow facet control -- bspline surfaces only. A
        true unqualified SetSmoothTriangleFlowRequired overrides false for the
        Bsurf setting!!
        """
        ...
    
    def SetEdgeChainsRequired(self: MSPyBentleyGeom.IFacetOptions, edgeChainRequired: bool) -> None:
        """
        Set the EdgeChainsRequired facet control.
        """
        ...
    
    def SetEdgeHiding(self: MSPyBentleyGeom.IFacetOptions, edgeHiding: bool) -> None:
        """
        Set the EdgeHiding facet control.
        """
        ...
    
    def SetHideSmoothEdgesWhenGeneratingNormals(self: MSPyBentleyGeom.IFacetOptions, hideSmoothEdgesWhenGeneratingNormals: bool) -> None:
        """
        Set whether smooth edges between facets are marked as hidden when
        normals are genereted for a polyface without normals.
        """
        ...
    
    def SetIgnoreFaceMaterialAttachments(self: MSPyBentleyGeom.IFacetOptions, inoreFaceAttachments: bool) -> None:
        """
        Set whether facets returned for BReps are separated by color/material
        when there is per-face symbology attachments.
        """
        ...
    
    def SetMaxEdgeLength(self: MSPyBentleyGeom.IFacetOptions, maxEdgeLength: float) -> None:
        """
        Set the MaxEdgeLength facet control.
        """
        ...
    
    def SetMaxFacetWidth(self: MSPyBentleyGeom.IFacetOptions, maxWidth: float) -> None:
        """
        Sets maximum facet width. As of now, only bodies faceted by Parasolid
        use this parameter.
        """
        ...
    
    def SetMaxPerBezier(self: MSPyBentleyGeom.IFacetOptions, maxPerBezier: int) -> None:
        """
        Set the MaxPerBezier facet control.
        """
        ...
    
    def SetMaxPerFace(self: MSPyBentleyGeom.IFacetOptions, maxPerFace: int) -> None:
        """
        Set the MaxPerFace facet control.
        """
        ...
    
    def SetMinPerBezier(self: MSPyBentleyGeom.IFacetOptions, minPerBezier: int) -> None:
        """
        Set the MinPerBezier facet control.
        """
        ...
    
    def SetNormalsRequired(self: MSPyBentleyGeom.IFacetOptions, normalIsRequired: bool) -> None:
        """
        Set the NormalsRequired facet control.
        """
        ...
    
    def SetParamDistanceScale(self: MSPyBentleyGeom.IFacetOptions, paramDistanceScale: float) -> None:
        """
        Set the ParamDistanceScale facet control.
        """
        ...
    
    def SetParamMode(self: MSPyBentleyGeom.IFacetOptions, paramMode: MSPyBentleyGeom.FacetParamMode) -> None:
        """
        Set the ParamMode facet control.
        """
        ...
    
    def SetParamsRequired(self: MSPyBentleyGeom.IFacetOptions, paramsRequired: bool) -> None:
        """
        Set the ParamsRequired facet control.
        """
        ...
    
    def SetSilhouetteDirection(self: MSPyBentleyGeom.IFacetOptions, silhouetteDirection: MSPyBentleyGeom.DVec3d) -> None:
        """
        Set the SilhouetteDirection facet control.
        """
        ...
    
    def SetSilhouetteOrigin(self: MSPyBentleyGeom.IFacetOptions, silhouetteOrigin: MSPyBentleyGeom.DPoint3d) -> None:
        """
        Set the SilhouetteOrigin facet control.
        """
        ...
    
    def SetSilhouetteToleranceDivisor(self: MSPyBentleyGeom.IFacetOptions, silhouetteToleranceDivisor: float) -> None:
        """
        Set the SilhouetteToleranceDivisor facet control.
        """
        ...
    
    def SetSilhouetteType(self: MSPyBentleyGeom.IFacetOptions, silhouetteType: int) -> None:
        """
        Set the SilhouetteType facet control.
        """
        ...
    
    def SetSmoothTriangleFlowRequired(self: MSPyBentleyGeom.IFacetOptions, value: bool) -> None:
        """
        Set the SmoothTriangleFlow facet control. (This can apply to both
        bspline and non-bspline. See
        """
        ...
    
    def SetToleranceDistanceScale(self: MSPyBentleyGeom.IFacetOptions, toleranceDistanceScale: float) -> None:
        """
        Set the ToleranceDistanceScale facet control.
        """
        ...
    
    def SetVertexColorsRequired(self: MSPyBentleyGeom.IFacetOptions, vertexColorsRequired: bool) -> None:
        """
        Set the VertexColorsRequired facet control.
        """
        ...
    
    @property
    def SilhouetteDirection(arg0: MSPyBentleyGeom.IFacetOptions) -> MSPyBentleyGeom.DVec3d:
        ...
    @SilhouetteDirection.setter
    def SilhouetteDirection(arg0: MSPyBentleyGeom.IFacetOptions, arg1: MSPyBentleyGeom.DVec3d) -> None:
        ...
    
    @property
    def SilhouetteOrigin(arg0: MSPyBentleyGeom.IFacetOptions) -> MSPyBentleyGeom.DPoint3d:
        ...
    @SilhouetteOrigin.setter
    def SilhouetteOrigin(arg0: MSPyBentleyGeom.IFacetOptions, arg1: MSPyBentleyGeom.DPoint3d) -> None:
        ...
    
    @property
    def SilhouetteToleranceDivisor(arg0: MSPyBentleyGeom.IFacetOptions) -> float:
        ...
    @SilhouetteToleranceDivisor.setter
    def SilhouetteToleranceDivisor(arg0: MSPyBentleyGeom.IFacetOptions, arg1: float) -> None:
        ...
    
    @property
    def SilhouetteType(arg0: MSPyBentleyGeom.IFacetOptions) -> int:
        ...
    @SilhouetteType.setter
    def SilhouetteType(arg0: MSPyBentleyGeom.IFacetOptions, arg1: int) -> None:
        ...
    
    @property
    def SmoothTriangleFlowRequired(arg0: MSPyBentleyGeom.IFacetOptions) -> bool:
        ...
    @SmoothTriangleFlowRequired.setter
    def SmoothTriangleFlowRequired(arg0: MSPyBentleyGeom.IFacetOptions, arg1: bool) -> None:
        ...
    
    @property
    def ToleranceDistanceScale(arg0: MSPyBentleyGeom.IFacetOptions) -> float:
        ...
    @ToleranceDistanceScale.setter
    def ToleranceDistanceScale(arg0: MSPyBentleyGeom.IFacetOptions, arg1: float) -> None:
        ...
    
    @property
    def VertexColorsRequired(arg0: MSPyBentleyGeom.IFacetOptions) -> bool:
        ...
    @VertexColorsRequired.setter
    def VertexColorsRequired(arg0: MSPyBentleyGeom.IFacetOptions, arg1: bool) -> None:
        ...
    
    def __init__(self: MSPyBentleyGeom.IFacetOptions) -> None:
        ...
    
class IGeometry:
    """
    None
    """

    def Clone(*args, **kwargs):
        """
        Overloaded function.
        
        1. Clone(self: MSPyBentleyGeom.IGeometry) -> MSPyBentleyGeom.IGeometry
        
        2. Clone(self: MSPyBentleyGeom.IGeometry, transform: Transform) -> MSPyBentleyGeom.IGeometry
        """
        ...
    
    @property
    def GeometryType(arg0: MSPyBentleyGeom.IGeometry) -> MSPyBentleyGeom.IGeometry.GeometryType:
        ...
    
    def GetAsCurveVector(self: MSPyBentleyGeom.IGeometry) -> MSPyBentleyGeom.CurveVector:
        ...
    
    def GetAsICurvePrimitive(self: MSPyBentleyGeom.IGeometry) -> MSPyBentleyGeom.ICurvePrimitive:
        ...
    
    def GetAsISolidPrimitive(self: MSPyBentleyGeom.IGeometry) -> ISolidPrimitive:
        ...
    
    def GetAsMSBsplineSurface(self: MSPyBentleyGeom.IGeometry) -> RefCountedMSBsplineSurface:
        ...
    
    def GetAsPolyfaceHeader(self: MSPyBentleyGeom.IGeometry) -> PolyfaceHeader:
        ...
    
    def GetGeometryType(self: MSPyBentleyGeom.IGeometry) -> MSPyBentleyGeom.IGeometry.GeometryType:
        ...
    
    def IsSameStructureAndGeometry(self: MSPyBentleyGeom.IGeometry, other: MSPyBentleyGeom.IGeometry, tolerance: float = 0.0) -> bool:
        ...
    
    def TryGetRange(*args, **kwargs):
        """
        Overloaded function.
        
        1. TryGetRange(self: MSPyBentleyGeom.IGeometry, range: MSPyBentleyGeom.DRange3d) -> bool
        
        2. TryGetRange(self: MSPyBentleyGeom.IGeometry, range: MSPyBentleyGeom.DRange3d, transform: Transform) -> bool
        """
        ...
    
    def TryTransformInPlace(self: MSPyBentleyGeom.IGeometry, transform: Transform) -> bool:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.IGeometry, source: MSPyBentleyGeom.ICurvePrimitive) -> None
        
        2. __init__(self: MSPyBentleyGeom.IGeometry, source: MSPyBentleyGeom.CurveVector) -> None
        
        3. __init__(self: MSPyBentleyGeom.IGeometry, source: ISolidPrimitive) -> None
        
        4. __init__(self: MSPyBentleyGeom.IGeometry, source: RefCountedMSBsplineSurface) -> None
        
        5. __init__(self: MSPyBentleyGeom.IGeometry, source: PolyfaceHeader) -> None
        """
        ...
    
    eBsplineSurface: GeometryType
    
    eCurvePrimitive: GeometryType
    
    eCurveVector: GeometryType
    
    ePolyface: GeometryType
    
    eSolidPrimitive: GeometryType
    
class IGeometryPtrArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.IGeometryPtrArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.IGeometryPtrArray, arg0: MSPyBentleyGeom.IGeometryPtrArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.IGeometryPtrArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.IGeometryPtrArray, x: MSPyBentleyGeom.IGeometry) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.IGeometryPtrArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def count(self: MSPyBentleyGeom.IGeometryPtrArray, x: MSPyBentleyGeom.IGeometry) -> int:
        """
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.IGeometryPtrArray, L: MSPyBentleyGeom.IGeometryPtrArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.IGeometryPtrArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.IGeometryPtrArray, i: int, x: MSPyBentleyGeom.IGeometry) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.IGeometryPtrArray) -> MSPyBentleyGeom.IGeometry
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.IGeometryPtrArray, i: int) -> MSPyBentleyGeom.IGeometry
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(self: MSPyBentleyGeom.IGeometryPtrArray, x: MSPyBentleyGeom.IGeometry) -> None:
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class IPolyfaceConstruction:
    """
    None
    """

    def Add(*args, **kwargs):
        """
        Overloaded function.
        
        1. Add(self: MSPyBentleyGeom.IPolyfaceConstruction, surface: MSBsplineSurface) -> None
        
        Add bspline surface mesh
        
        2. Add(self: MSPyBentleyGeom.IPolyfaceConstruction, cone: DgnConeDetail) -> bool
        
        Add bspline surface mesh
        
        3. Add(self: MSPyBentleyGeom.IPolyfaceConstruction, sphere: DgnSphereDetail) -> bool
        
        Add bspline surface mesh
        
        4. Add(self: MSPyBentleyGeom.IPolyfaceConstruction, box: DgnBoxDetail) -> bool
        
        Add bspline surface mesh
        
        5. Add(self: MSPyBentleyGeom.IPolyfaceConstruction, torus: DgnTorusPipeDetail) -> bool
        
        Add bspline surface mesh
        
        6. Add(self: MSPyBentleyGeom.IPolyfaceConstruction, extrusion: DgnExtrusionDetail) -> bool
        
        Add bspline surface mesh
        
        7. Add(self: MSPyBentleyGeom.IPolyfaceConstruction, sweep: DgnRotationalSweepDetail) -> bool
        
        Add bspline surface mesh
        
        8. Add(self: MSPyBentleyGeom.IPolyfaceConstruction, sweep: DgnRuledSweepDetail) -> bool
        
        Add bspline surface mesh
        
        9. Add(self: MSPyBentleyGeom.IPolyfaceConstruction, sweep: PolyfaceHeader) -> bool
        
        Add bspline surface mesh
        """
        ...
    
    def AddColorIndex(self: MSPyBentleyGeom.IPolyfaceConstruction, zeroBasedIndex: int) -> int:
        """
        Add a color index, adjusted to 1-based indexing Return the (0-based)
        position in the ParamIndex array.
        """
        ...
    
    def AddColorIndexQuad(self: MSPyBentleyGeom.IPolyfaceConstruction, index0: int, index1: int, index2: int, index3: int) -> int:
        """
        Add a quad to the color index table. Return the (0-based) position in
        the ColorIndex array.
        """
        ...
    
    def AddColorIndexTerminator(self: MSPyBentleyGeom.IPolyfaceConstruction) -> int:
        """
        Add a terminator to the color index table. Return the (0-based)
        position in the ColorIndex array.
        """
        ...
    
    def AddColorIndexTriangle(self: MSPyBentleyGeom.IPolyfaceConstruction, index0: int, index1: int, index2: int) -> int:
        """
        Add a triangle to the color index table. Return the (0-based) position
        in the ColorIndex array.
        """
        ...
    
    def AddEllipsoidPatch(self: MSPyBentleyGeom.IPolyfaceConstruction, center: MSPyBentleyGeom.DPoint3d, radiusX: float, radiusY: float, radiusPole: float, numEastWestEdge: int = 0, numNorthSouthEdge: int = 0, longitudeStart: float = 0.0, longitudeSweep: float = 6.283185307179586, latitudeStart: float = -1.5707963267948966, latitudeSweep: float = 3.141592653589793, capped: bool = False, orientationSelect: int = 1) -> None:
        ...
    
    def AddFullDisk(self: MSPyBentleyGeom.IPolyfaceConstruction, ellipse: MSPyBentleyGeom.DEllipse3d, numPerQuadrant: int = 0) -> None:
        """
        Add complete disk. When options specify maxEdgeLength, radial lines go
        full distance from center to edge. (See AddFulLDiskTriangles)
        
        :param (input):
        ellipse arc to stroke
        
        :param (input):
        numPerQuadrant overrides all options controls.
        """
        ...
    
    def AddFullDiskTriangles(self: MSPyBentleyGeom.IPolyfaceConstruction, ellipse: MSPyBentleyGeom.DEllipse3d, numPerQuadrant: int = 0) -> None:
        """
        Add complete disk. When options specify maxEdgeLength, triangles are
        created without imposed radial edges.
        
        :param (input):
        ellipse arc to stroke
        
        :param (input):
        numPerQuadrant overrides all options controls.
        """
        ...
    
    def AddFullSphere(self: MSPyBentleyGeom.IPolyfaceConstruction, center: MSPyBentleyGeom.DPoint3d, radius: float, numPerQuadrantEW: int = 0, numPerQuadrantNS: int = 0) -> None:
        """
        Add complete sphere.
        
        :param (input):
        center ellipse center
        
        :param (input):
        radius ellipse radius
        
        :param (input):
        numPerQuadrantNS if nonzero overrides all option controls.
        
        :param (input):
        numPerQuadrantEW if nonzero overrides all option controls.
        """
        ...
    
    def AddLinearSweep(*args, **kwargs):
        """
        Overloaded function.
        
        1. AddLinearSweep(self: MSPyBentleyGeom.IPolyfaceConstruction, pointA: MSPyBentleyGeom.DPoint3dArray, tangentA: MSPyBentleyGeom.DVec3dArray, step: MSPyBentleyGeom.DVec3d) -> None
        
        Make a linear sweep from base points. To indicate a sharp corner,
        duplicate the point, using incoming tangent on the first, outgoing on
        the second. Any zero-length edge will be skipped, and the sweep edge
        will be marked visible.
        
        2. AddLinearSweep(self: MSPyBentleyGeom.IPolyfaceConstruction, pointA: list, tangentA: MSPyBentleyGeom.DVec3dArray, step: MSPyBentleyGeom.DVec3d) -> None
        
        Make a linear sweep from base points. To indicate a sharp corner,
        duplicate the point, using incoming tangent on the first, outgoing on
        the second. Any zero-length edge will be skipped, and the sweep edge
        will be marked visible.
        """
        ...
    
    def AddNormalIndex(self: MSPyBentleyGeom.IPolyfaceConstruction, zeroBasedIndex: int) -> int:
        """
        Add a normal index, adjusted to 1-based indexing. Return the (0-based)
        position in the NormalIndex array.
        """
        ...
    
    def AddNormalIndexFan(self: MSPyBentleyGeom.IPolyfaceConstruction, centerIndex: int, index: MSPyBentleyGeom.UInt64Array, numChord: int, reverse: bool) -> None:
        """
        Add normal triangles from a center index to multiple edges.
        """
        ...
    
    def AddNormalIndexPlanarFan(*args, **kwargs):
        """
        Overloaded function.
        
        1. AddNormalIndexPlanarFan(self: MSPyBentleyGeom.IPolyfaceConstruction, vectorA: MSPyBentleyGeom.DVec3d, vectorB: MSPyBentleyGeom.DVec3d, reverse: bool, numChord: int) -> None
        
        Add triangles that share index to the a new normal whose coordinates
        are the cross product of given vectors.
        
        2. AddNormalIndexPlanarFan(self: MSPyBentleyGeom.IPolyfaceConstruction, normalIndex: int, numChord: int) -> None
        
        Add triangles that share index to the a new normal whose coordinates
        are the cross product of given vectors.
        """
        ...
    
    def AddNormalIndexPlanarStrip(self: MSPyBentleyGeom.IPolyfaceConstruction, index: int, numQuad: int) -> None:
        """
        Add quads that share index to the a single normal.
        """
        ...
    
    def AddNormalIndexQuad(self: MSPyBentleyGeom.IPolyfaceConstruction, index0: int, index1: int, index2: int, index3: int) -> int:
        """
        Add a quad to the normal index table. Return the (0-based) position in
        the NormalIndex array.
        """
        ...
    
    def AddNormalIndexTerminator(self: MSPyBentleyGeom.IPolyfaceConstruction) -> int:
        """
        Add a terminator to the normal index table. Return the (0-based)
        position in the NormalIndex array.
        """
        ...
    
    def AddNormalIndexTriangle(self: MSPyBentleyGeom.IPolyfaceConstruction, index0: int, index1: int, index2: int) -> int:
        """
        Add a triangle to the normal index table. Return the (0-based)
        position in the NormalIndex array.
        """
        ...
    
    def AddParamIndex(self: MSPyBentleyGeom.IPolyfaceConstruction, zeroBasedIndex: int) -> int:
        """
        Add a param index, adjusted to 1-based indexing Return the (0-based)
        position in the ParamIndex array.
        """
        ...
    
    def AddParamIndexFan(self: MSPyBentleyGeom.IPolyfaceConstruction, centerIndex: int, index: MSPyBentleyGeom.UInt64Array, numChord: int, reverse: bool) -> None:
        """
        Add parameter triangles from a center index to edges of a polyline.
        """
        ...
    
    def AddParamIndexQuad(self: MSPyBentleyGeom.IPolyfaceConstruction, index0: int, index1: int, index2: int, index3: int) -> int:
        """
        Add a quad to the param index table. Return the (0-based) position in
        the ParamIndex array.
        """
        ...
    
    def AddParamIndexStrip(self: MSPyBentleyGeom.IPolyfaceConstruction, indexA: MSPyBentleyGeom.UInt64Array, indexB: MSPyBentleyGeom.UInt64Array, numQuad: int, reverse: bool) -> None:
        """
        Add parameter quads between same-size indices.
        """
        ...
    
    def AddParamIndexTerminator(self: MSPyBentleyGeom.IPolyfaceConstruction) -> int:
        """
        Add a terminator to the param index table. Return the (0-based)
        position in the ParamIndex array.
        """
        ...
    
    def AddParamIndexTriangle(self: MSPyBentleyGeom.IPolyfaceConstruction, index0: int, index1: int, index2: int) -> int:
        """
        Add a triangle to the param index table. Return the (0-based) position
        in the ParamIndex array.
        """
        ...
    
    def AddPointIndex(self: MSPyBentleyGeom.IPolyfaceConstruction, zeroBasedIndex: int, visible: bool) -> int:
        """
        Add a point index, adjusted to 1-based indexing with visibility in
        sign. Return the (0-based) position in the PointIndex array.
        """
        ...
    
    def AddPointIndexFan(*args, **kwargs):
        """
        Overloaded function.
        
        1. AddPointIndexFan(self: MSPyBentleyGeom.IPolyfaceConstruction, centerIndex: int, index: MSPyBentleyGeom.UInt64Array, numChord: int, reverse: bool) -> None
        
        Add point triangles from a center index to edges of a polyline. spoke
        edges are hidden, outer edges are visible.
        
        2. AddPointIndexFan(self: MSPyBentleyGeom.IPolyfaceConstruction, centerIndex: int, index: MSPyBentleyGeom.UInt64Array, numChord: int, reverse: bool, spokesVisible: bool, visibleBoundary: bool) -> None
        
        Add point triangles from a center index to edges of a polyline. spoke
        edges are hidden, outer edges are visible.
        """
        ...
    
    def AddPointIndexQuad(self: MSPyBentleyGeom.IPolyfaceConstruction, index0: int, visible0: bool, index1: int, visible1: bool, index2: int, visible2: bool, index3: int, visible3: bool) -> int:
        """
        Add a quad to the point index table. Return the (0-based) position in
        the PointIndex array.
        """
        ...
    
    def AddPointIndexStrip(self: MSPyBentleyGeom.IPolyfaceConstruction, visibleLeft: bool, indexA: MSPyBentleyGeom.UInt64Array, visibleA: bool, indexB: MSPyBentleyGeom.UInt64Array, visibleB: bool, visibleRight: bool, numQuad: int, reverse: bool) -> None:
        """
        Add point quads between EQUAL LENGTH index vectors.
        """
        ...
    
    def AddPointIndexTerminator(self: MSPyBentleyGeom.IPolyfaceConstruction) -> int:
        """
        Add a terminator to the point index table. Return the (0-based)
        position in the PointIndex array.
        """
        ...
    
    def AddPointIndexTriangle(self: MSPyBentleyGeom.IPolyfaceConstruction, index0: int, visible0: bool, index1: int, visible1: bool, index2: int, visible2: bool) -> int:
        """
        Add a triangle to the point index table. Return the (0-based) position
        in the PointIndex array.
        """
        ...
    
    def AddPolyface(self: MSPyBentleyGeom.IPolyfaceConstruction, polyface: PolyfaceQuery, drawMethodIndex: int = 0) -> bool:
        """
        Add polyface mesh.
        """
        ...
    
    def AddRegion(self: MSPyBentleyGeom.IPolyfaceConstruction, region: MSPyBentleyGeom.CurveVector) -> None:
        """
        Add (triangulation of) the region bounded by a curve vector.
        """
        ...
    
    def AddRotationalSweep(self: MSPyBentleyGeom.IPolyfaceConstruction, curve: MSPyBentleyGeom.CurveVector, center: MSPyBentleyGeom.DPoint3d, axis: MSPyBentleyGeom.DVec3d, totalSweep: float, capped: bool) -> None:
        """
        Add rotational sweep from curves
        """
        ...
    
    def AddRotationalSweepLoop(self: MSPyBentleyGeom.IPolyfaceConstruction, pointA: MSPyBentleyGeom.DPoint3dArray, tangentA: MSPyBentleyGeom.DVec3dArray, center: MSPyBentleyGeom.DPoint3d, rotationAxis: MSPyBentleyGeom.DVec3d, totalSweepRadians: float, reverse: bool, nominalBaseCurveLength: float, startCapPointAccumulator: MSPyBentleyGeom.DPoint3dArray, endCapPointAccumulator: MSPyBentleyGeom.DPoint3dArray) -> None:
        """
        Make a Rotational sweep from base points. To indicate a sharp corner,
        duplicate the point, using incoming tangent on the first, outgoing on
        the second. The zero-length edge will be skipped, and the sweep edge
        will be marked visible.
        
        :param (input):
        pointA base curve points
        
        :param (input):
        tangentA base curve tangents
        
        :param (input):
        center center of rotation
        
        :param (input):
        rotationAxis rotation axis
        
        :param (input):
        totalSweepRadians sweep angle
        
        :param (input):
        reverse true to reverse facet orientations.
        
        :param (input):
        nominalBaseCurveLength if nonzero, parameter distances along the
        base curve are scaled to this length
        
        :param (input):
        startCapPointAccumulator optional array to receive fully
        transformed endcap points. This array is NOT cleared (so caller
        can combine over multiple calls.)
        
        :param (input):
        endCapPointAccumulator optional array to receive fully transformed
        endcap points. This array is NOT cleared (so caller can combine
        over multiple calls.)
        """
        ...
    
    def AddRowMajorQuadGrid(self: MSPyBentleyGeom.IPolyfaceConstruction, points: List[MSPyBentleyGeom.DPoint3d], normals: List[MSPyBentleyGeom.DVec3d], params: List[MSPyBentleyGeom.DPoint2d], numPerRow: int, numRow: int, forceTriangles: bool = False) -> None:
        """
        Add square grid with normal, param at each point.
        """
        ...
    
    def AddRuled(self: MSPyBentleyGeom.IPolyfaceConstruction, ellipse0: MSPyBentleyGeom.DEllipse3d, ellipse1: MSPyBentleyGeom.DEllipse3d, cap: bool) -> None:
        """
        Add ruled facets between ellipses.
        """
        ...
    
    def AddSignedOneBasedColorIndex(self: MSPyBentleyGeom.IPolyfaceConstruction, zeroBasedIndex: int) -> int:
        """
        Add a color index, directly, i.e. caller is responsible for providing
        a one based index
        """
        ...
    
    def AddSignedOneBasedNormalIndex(self: MSPyBentleyGeom.IPolyfaceConstruction, zeroBasedIndex: int) -> int:
        """
        Add a normal index, directly, i.e. caller is responsible for providing
        a one based index
        """
        ...
    
    def AddSignedOneBasedParamIndex(self: MSPyBentleyGeom.IPolyfaceConstruction, zeroBasedIndex: int) -> int:
        """
        Add a param index, directly, i.e. caller is responsible for providing
        a one based index
        """
        ...
    
    def AddSignedOneBasedPointIndex(self: MSPyBentleyGeom.IPolyfaceConstruction, zeroBasedIndex: int) -> int:
        """
        Add a point index directly, i.e. caller is responsible for providing a
        one based index with optional negation for hidden edges.
        """
        ...
    
    def AddSmoothed(self: MSPyBentleyGeom.IPolyfaceConstruction, surface: MSBsplineSurface) -> None:
        """
        Add bspline surface mesh, with smoothing effects.
        """
        ...
    
    def AddSolidPrimitive(self: MSPyBentleyGeom.IPolyfaceConstruction, primitive: ISolidPrimitive) -> bool:
        """
        Add facets for all faces of a solid primitive.
        """
        ...
    
    def AddSweptNGon(self: MSPyBentleyGeom.IPolyfaceConstruction, n: int, rOuter: float, z0: float, z1: float, bottomCap: bool, topCap: bool) -> bool:
        """
        Sweep a regular polygon (parallel to xy plane) from z0 to z1.
        
        :param (input):
        n number of edges. Must be 3 or greater.
        
        :param (input):
        rOuter outer radius
        
        :param (input):
        z0 start z
        
        :param (input):
        z1 end z
        
        :param (input):
        bottomCap true to include bottom cap
        
        :param (input):
        topCap true to include top cap.
        """
        ...
    
    def AddTriStrip(self: MSPyBentleyGeom.IPolyfaceConstruction, points: List[MSPyBentleyGeom.DPoint3d], normals: List[MSPyBentleyGeom.DVec3d], params: List[MSPyBentleyGeom.DPoint2d], firstTriangle012: bool) -> None:
        """
        Add square grid with normal, param at each point.
        
        :param (input):
        points coordinates alternating between bottom and top of strip.
        
        :param (input):
        params corresponding parameters
        
        :param (input):
        normals corresponding normals
        
        :param (input):
        numPoint number of points (2 more than number of triangles)
        
        :param (input):
        firstTriangle012 true if 012 is leading triangle order, false if
        021 is leading triangle order.
        """
        ...
    
    def AddTriangles(self: MSPyBentleyGeom.IPolyfaceConstruction, triangles: MSPyBentleyGeom.DTriangle3dArray, reverse: bool = False, paramTriangles: MSPyBentleyGeom.DTriangle3dArray = None) -> None:
        """
        Add all triangles to mesh. Optionally reverse orientations.
        """
        ...
    
    def AddTriangulation(self: MSPyBentleyGeom.IPolyfaceConstruction, points: MSPyBentleyGeom.DPoint3dArray) -> bool:
        """
        Triangulate a space polygon and add to mesh. Disconnect points
        separate multiple loops.
        """
        ...
    
    def AddTriangulationPair(self: MSPyBentleyGeom.IPolyfaceConstruction, pointA: MSPyBentleyGeom.DPoint3dArray, reverseA: bool, pointB: MSPyBentleyGeom.DPoint3dArray, reverseB: bool) -> None:
        """
        AddTriangulation on 2 sets of points, optionally reversing each.
        """
        ...
    
    def AddTubeMesh(self: MSPyBentleyGeom.IPolyfaceConstruction, centerlineCurve: MSBsplineCurve, radius: float, numEdgePerSection: int, numSectionEdge: int) -> None:
        """
        Add facets to a mesh. Facets approximate a tube around a centerline.
        The centerline curve (bspline) should be planar or nearly so. (If it
        is not, the successive circular sections may pinch in strange ways)
        
        :param (input):
        centerlineCurve tube centerline
        
        :param (input):
        radius tube radius
        
        :param (input):
        numEdgePerSection number of edges around each section circle. If
        zero, determined from builder's facet options.
        
        :param (input):
        numSectionEdge number of edges along curve. If zero, determined
        from builder's facet options.
        """
        ...
    
    def ApplyLocalToWorld(self: MSPyBentleyGeom.IPolyfaceConstruction, relativeTransform: Transform) -> bool:
        """
        Apply (right multiply) the local to world transform.
        
        :returns:
        false if the given transform is not invertible.
        """
        ...
    
    def Clear(self: MSPyBentleyGeom.IPolyfaceConstruction) -> None:
        """
        Clear client mesh and all construction support
        """
        ...
    
    @property
    def ClientMesh(arg0: MSPyBentleyGeom.IPolyfaceConstruction) -> PolyfaceHeader:
        ...
    
    def CollectCurrentFaceRanges(self: MSPyBentleyGeom.IPolyfaceConstruction) -> None:
        """
        Collect point, param, and normal range data in the current face.
        """
        ...
    
    def EndFace(self: MSPyBentleyGeom.IPolyfaceConstruction) -> None:
        """
        Finalize data for the current face.
        """
        ...
    
    @property
    def FaceData(arg0: MSPyBentleyGeom.IPolyfaceConstruction) -> FacetFaceData:
        ...
    @FaceData.setter
    def FaceData(arg0: MSPyBentleyGeom.IPolyfaceConstruction, arg1: FacetFaceData) -> None:
        ...
    
    @property
    def FaceIndex(arg0: MSPyBentleyGeom.IPolyfaceConstruction) -> int:
        ...
    @FaceIndex.setter
    def FaceIndex(arg0: MSPyBentleyGeom.IPolyfaceConstruction, arg1: int) -> None:
        ...
    
    @property
    def FacetOptions(arg0: MSPyBentleyGeom.IPolyfaceConstruction) -> MSPyBentleyGeom.IFacetOptions:
        ...
    
    def FindOrAddDoubleColor(self: MSPyBentleyGeom.IPolyfaceConstruction, color: RgbFactor) -> int:
        """
        Find or add a color. Return the (0-based) index.
        """
        ...
    
    def FindOrAddNormal(self: MSPyBentleyGeom.IPolyfaceConstruction, normal: MSPyBentleyGeom.DVec3d) -> int:
        """
        Find or add a normal. Return the (0-based) index.
        """
        ...
    
    def FindOrAddNormals(self: MSPyBentleyGeom.IPolyfaceConstruction, point: MSPyBentleyGeom.DVec3dArray, n: int, numWrap: int, index: MSPyBentleyGeom.UInt64Array) -> None:
        """
        Find or add n indices. Return the n indices plus numWrap additional
        wraparounds.
        """
        ...
    
    def FindOrAddParam(self: MSPyBentleyGeom.IPolyfaceConstruction, param: MSPyBentleyGeom.DPoint2d) -> int:
        """
        Find or add a param. Return the (0-based) index.
        """
        ...
    
    def FindOrAddParams(self: MSPyBentleyGeom.IPolyfaceConstruction, params: MSPyBentleyGeom.DPoint2dArray, index: MSPyBentleyGeom.UInt64Array) -> None:
        """
        Find or add n indices. Return the n indices plus numWrap additional
        wraparounds.
        """
        ...
    
    def FindOrAddPoint(self: MSPyBentleyGeom.IPolyfaceConstruction, point: MSPyBentleyGeom.DPoint3d) -> int:
        """
        Find or add a point. Return the (0-based) index.
        """
        ...
    
    def FindOrAddPoints(*args, **kwargs):
        """
        Overloaded function.
        
        1. FindOrAddPoints(self: MSPyBentleyGeom.IPolyfaceConstruction, point: MSPyBentleyGeom.DPoint3dArray, n: int, numWrap: int, index: MSPyBentleyGeom.UInt64Array) -> None
        
        Find or add n indices. Return the n indices plus numWrap additional
        wraparounds.
        
        2. FindOrAddPoints(self: MSPyBentleyGeom.IPolyfaceConstruction, point: list, n: int, numWrap: int, index: MSPyBentleyGeom.UInt64Array) -> None
        
        Find or add n indices. Return the n indices plus numWrap additional
        wraparounds.
        """
        ...
    
    def GetClientMesh(self: MSPyBentleyGeom.IPolyfaceConstruction) -> PolyfaceHeader:
        ...
    
    def GetFaceData(self: MSPyBentleyGeom.IPolyfaceConstruction) -> FacetFaceData:
        """
        Return the current face data.
        """
        ...
    
    def GetFaceIndex(self: MSPyBentleyGeom.IPolyfaceConstruction) -> int:
        """
        Get the (modal) face index.
        """
        ...
    
    def GetFacetOptions(self: MSPyBentleyGeom.IPolyfaceConstruction) -> MSPyBentleyGeom.IFacetOptions:
        ...
    
    def GetLocalToWorld(self: MSPyBentleyGeom.IPolyfaceConstruction, transform: Transform) -> bool:
        """
        Get the local to world placement transform.
        
        :returns:
        false if the transform is an identity.
        
        Remark:
        s This is affected by PushState/PopState operations.
        """
        ...
    
    def GetLocalToWorldNormals(self: MSPyBentleyGeom.IPolyfaceConstruction, matrix: RotMatrix) -> bool:
        """
        Get the local to world matrix for surface normals.
        
        :param (output):
        matrix returned matrix
        
        :returns:
        false if no local to world transform is in effect.
        """
        ...
    
    def GetLocalToWorldScale(self: MSPyBentleyGeom.IPolyfaceConstruction) -> float:
        """
        Get the (average) scale factor of the local to world transform.
        
        Remark:
        s This is affected by PushState/PopState operations.
        """
        ...
    
    def GetReverseNewFacetIndexOrder(self: MSPyBentleyGeom.IPolyfaceConstruction) -> bool:
        """
        Ask if facets are to be reversed as received.
        
        Remark:
        s This is affected by PushState/PopState operations.
        """
        ...
    
    def GetReverseNewNormals(self: MSPyBentleyGeom.IPolyfaceConstruction) -> bool:
        """
        Get the current normal vector reversal state.
        """
        ...
    
    def GetWorldToLocal(self: MSPyBentleyGeom.IPolyfaceConstruction, transform: Transform) -> bool:
        """
        Get the world to local placement transform.
        
        :returns:
        false if the transform is an identity.
        
        Remark:
        s This is affected by PushState/PopState operations.
        """
        ...
    
    def GetWorldToLocalScale(self: MSPyBentleyGeom.IPolyfaceConstruction) -> float:
        """
        Get the (average) scale factor of the world to local transform.
        
        Remark:
        s This is affected by PushState/PopState operations.
        """
        ...
    
    def IncrementFaceIndex(self: MSPyBentleyGeom.IPolyfaceConstruction) -> int:
        """
        Increment the (modal) face index. (And clear the modal parameter
        range) return the (incremented) index.
        """
        ...
    
    def InitializeConstructionStateAndStack(self: MSPyBentleyGeom.IPolyfaceConstruction) -> None:
        """
        Clear the construction state stack and set current state.
        """
        ...
    
    def InitializeCurrentConstructionState(self: MSPyBentleyGeom.IPolyfaceConstruction) -> None:
        """
        Clear the current construction state, but leave the stack unchanged.
        """
        ...
    
    def IsTransformed(self: MSPyBentleyGeom.IPolyfaceConstruction) -> bool:
        """
        Ask if the local to world transform is nontrivial
        
        Remark:
        s This is affected by PushState/PopState operations.
        """
        ...
    
    @property
    def LocalToWorldScale(arg0: MSPyBentleyGeom.IPolyfaceConstruction) -> float:
        ...
    
    def MultiplyByLocalToWorld(self: MSPyBentleyGeom.IPolyfaceConstruction, localPoint: MSPyBentleyGeom.DPoint3d) -> MSPyBentleyGeom.DPoint3d:
        """
        Multiply the local to world transform times the input point.
        
        :returns:
        transformed point.
        """
        ...
    
    def MultiplyNormalByLocalToWorld(self: MSPyBentleyGeom.IPolyfaceConstruction, localNormal: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.DVec3d:
        """
        Multiply a surface normal by the local to world effects and
        renormalize. This also applies the normal reversal flag.
        
        :returns:
        transformed ponit.
        """
        ...
    
    def NeedNormals(self: MSPyBentleyGeom.IPolyfaceConstruction) -> bool:
        """
        Ask if normals are needed.
        """
        ...
    
    def NeedParams(self: MSPyBentleyGeom.IPolyfaceConstruction) -> bool:
        """
        Ask if params are needed.
        """
        ...
    
    def PopState(self: MSPyBentleyGeom.IPolyfaceConstruction) -> bool:
        """
        Pop the current transform and revesal state.
        
        :returns:
        true if the stack had a state to pop.
        """
        ...
    
    def PushState(self: MSPyBentleyGeom.IPolyfaceConstruction, initializeCurrentState: bool = False) -> None:
        """
        Push the current transform and revesal state.
        
        :param (input):
        initializeCurrentState controls whether current state is
        reinitialized (true) or left unchanged (false)
        """
        ...
    
    def RemapPseudoDistanceParams(*args, **kwargs):
        """
        Overloaded function.
        
        1. RemapPseudoDistanceParams(self: MSPyBentleyGeom.IPolyfaceConstruction, params: MSPyBentleyGeom.DPoint2dArray, distanceRange: MSPyBentleyGeom.DRange2d, paramRange: MSPyBentleyGeom.DRange2d, xDistanceFactor: float, yDistanceFactor: float, transform: Transform) -> bool
        
        Apply the FacetParamMode to an array of parameters. On input, params
        are in coordinates that can be scaled independently in x and y to
        obtain distances. On ouptut, params are in PARAM_MODE_01BothAxes,
        PARAM_MODE_01LargerAxis, or PARAM_MODE_Distance as requested by the
        facet options in effect.
        
        :param [in,out]:
        params parameters to remap.
        
        :param (output):
        distanceRange range of parameters when scaled to distance (whether
        or not params are returned as distances)
        
        :param (output):
        paramRange range of parameters as actually returned.
        
        :param (input):
        xDistanceFactor scale factor to turn input x coordinates to
        distance (if distance requested either as final result or for
        larger axis scaling)
        
        :param (input):
        yDistanceFactor scale factor to turn input y coordinates to
        distance (if distance requested either as final result or for
        larger axis scaling)
        
        :param (output):
        transform optional transform (e.g. to be applied later to more
        params in the same parameter space) (May be nullptr)
        
        2. RemapPseudoDistanceParams(self: MSPyBentleyGeom.IPolyfaceConstruction, params: MSPyBentleyGeom.DPoint2dArray, distanceRange: MSPyBentleyGeom.DRange2d, paramRange: MSPyBentleyGeom.DRange2d, xDistanceFactor: float, yDistanceFactor: float) -> bool
        
        Apply the FacetParamMode to an array of parameters. On input, params
        are in coordinates that can be scaled independently in x and y to
        obtain distances. On ouptut, params are in PARAM_MODE_01BothAxes,
        PARAM_MODE_01LargerAxis, or PARAM_MODE_Distance as requested by the
        facet options in effect.
        
        :param [in,out]:
        params parameters to remap.
        
        :param (output):
        distanceRange range of parameters when scaled to distance (whether
        or not params are returned as distances)
        
        :param (output):
        paramRange range of parameters as actually returned.
        
        :param (input):
        xDistanceFactor scale factor to turn input x coordinates to
        distance (if distance requested either as final result or for
        larger axis scaling)
        
        :param (input):
        yDistanceFactor scale factor to turn input y coordinates to
        distance (if distance requested either as final result or for
        larger axis scaling)
        
        :param (output):
        transform optional transform (e.g. to be applied later to more
        params in the same parameter space) (May be nullptr)
        """
        ...
    
    def SetCurrentFaceParamDistanceRange(self: MSPyBentleyGeom.IPolyfaceConstruction, range: MSPyBentleyGeom.DRange2d) -> None:
        """
        Set (only) the paramDistance range part of the current FacetFacetData.
        """
        ...
    
    def SetFaceData(self: MSPyBentleyGeom.IPolyfaceConstruction, data: FacetFaceData) -> None:
        """
        Set the current face data.
        """
        ...
    
    def SetFaceIndex(self: MSPyBentleyGeom.IPolyfaceConstruction, index: int) -> None:
        """
        Set the (modal) face index. (And clear the modal parameter range)
        """
        ...
    
    def SetLocalToWorld(self: MSPyBentleyGeom.IPolyfaceConstruction, transform: Transform) -> bool:
        """
        Set the local to world transform.
        
        :returns:
        false if the given transform is not invertible.
        
        Remark:
        s This is affected by PushState/PopState operations.
        """
        ...
    
    def SetReverseNewFacetIndexOrder(self: MSPyBentleyGeom.IPolyfaceConstruction, reverse: bool) -> None:
        """
        Set the current facet index reversal state.
        """
        ...
    
    def SetReverseNewNormals(self: MSPyBentleyGeom.IPolyfaceConstruction, reverse: bool) -> None:
        """
        Set the current normal vector reversal state.
        """
        ...
    
    def Stroke(self: MSPyBentleyGeom.IPolyfaceConstruction, curves: MSPyBentleyGeom.CurveVector, points: MSPyBentleyGeom.DPoint3dArray) -> tuple:
        """
        Stroke with facet options from the PolyfaceConstruction. Return false
        if not a simple loop.
        
        Remark:
        points are doubled at hard corners (so the incoming and outgoing
        tangents can be distinguished)
        """
        ...
    
    def StrokeWithDoubledPointsAtCorners(*args, **kwargs):
        """
        Overloaded function.
        
        1. StrokeWithDoubledPointsAtCorners(self: MSPyBentleyGeom.IPolyfaceConstruction, curves: MSPyBentleyGeom.CurveVector, points: MSPyBentleyGeom.DPoint3dArray, tangents: MSPyBentleyGeom.DVec3dArray) -> tuple
        
        Stroke with facet options from the PolyfaceConstruction. Return false
        if not a simple loop.
        
        Remark:
        points are doubled at hard corners (so the incoming and outgoing
        tangents can be distinguished)
        
        2. StrokeWithDoubledPointsAtCorners(self: MSPyBentleyGeom.IPolyfaceConstruction, curves: MSPyBentleyGeom.CurveVector, points: list, tangents: MSPyBentleyGeom.DVec3dArray) -> tuple
        
        Stroke with facet options from the PolyfaceConstruction. Return false
        if not a simple loop.
        
        Remark:
        points are doubled at hard corners (so the incoming and outgoing
        tangents can be distinguished)
        
        3. StrokeWithDoubledPointsAtCorners(self: MSPyBentleyGeom.IPolyfaceConstruction, curves: MSPyBentleyGeom.CurveVector, points: MSPyBentleyGeom.DPoint3dVecArray, tangent: MSPyBentleyGeom.DVec3dVecArray, curveLengths: MSPyBentleyGeom.DoubleArray) -> bool
        
        Stroke with facet options from the PolyfaceConstruction. Return false
        if not a simple loop.
        
        Remark:
        points are doubled at hard corners (so the incoming and outgoing
        tangents can be distinguished)
        """
        ...
    
    def ToggleIndexOrderAndNormalReversal(self: MSPyBentleyGeom.IPolyfaceConstruction) -> None:
        """
        Toggle both index order and normal
        """
        ...
    
    @property
    def WorldToLocalScale(arg0: MSPyBentleyGeom.IPolyfaceConstruction) -> float:
        ...
    
    def __init__(self: MSPyBentleyGeom.IPolyfaceConstruction, options: MSPyBentleyGeom.IFacetOptions) -> None:
        ...
    
class ISolidPrimitive:
    """
    None
    """

    def AddCurveIntersections(*args, **kwargs):
        """
        Overloaded function.
        
        1. AddCurveIntersections(self: MSPyBentleyGeom.ISolidPrimitive, curves: MSPyBentleyGeom.CurveVector, curvePoints: MSPyBentleyGeom.CurveLocationDetailArray, solidPoints: MSPyBentleyGeom.SolidLocationDetailArray, messages: MSPyBentleyGeom.MeshAnnotationVector) -> None
        
        Compute intersections with curves and add to the data array.
        
        :param (input):
        curves
        
        :param [in,out]:
        curvePoints growing array of curve points.
        
        :param [in,out]:
        solidPoints growing array of solid points.
        
        :param [in,out]:
        messages array of error messages
        
        2. AddCurveIntersections(self: MSPyBentleyGeom.ISolidPrimitive, curves: MSPyBentleyGeom.ICurvePrimitive, curvePoints: MSPyBentleyGeom.CurveLocationDetailArray, solidPoints: MSPyBentleyGeom.SolidLocationDetailArray, messages: MSPyBentleyGeom.MeshAnnotationVector) -> None
        
        Compute intersections with curves and add to the data array.
        
        :param (input):
        curves
        
        :param [in,out]:
        curvePoints growing array of curve points.
        
        :param [in,out]:
        solidPoints growing array of solid points.
        
        :param [in,out]:
        messages array of error messages
        """
        ...
    
    def AddRayIntersections(self: MSPyBentleyGeom.ISolidPrimitive, pickData: MSPyBentleyGeom.SolidLocationDetailArray, ray: MSPyBentleyGeom.DRay3d, parentId: int, minParameter: float = -1.7976931348623157e+308) -> None:
        """
        Compute intersections with a ray and add to the pickData.
        
        :param (input):
        ray origin and direction
        
        :param (input):
        minParameter smallest parameter of pick. (e.g. 0 for picking along
        a positive ray from an eyepoint)
        
        :param [in,out]:
        pickData growing array of picks.
        
        :param (input):
        parentId caller's id for this solid. Will be placed in each
        pickData entry has parentId.
        """
        ...
    
    @property
    def Capped(arg0: MSPyBentleyGeom.ISolidPrimitive) -> bool:
        ...
    @Capped.setter
    def Capped(arg0: MSPyBentleyGeom.ISolidPrimitive, arg1: bool) -> None:
        ...
    
    def Clone(self: MSPyBentleyGeom.ISolidPrimitive) -> MSPyBentleyGeom.ISolidPrimitive:
        """
        Deep copy.
        """
        ...
    
    def ClosestPoint(self: MSPyBentleyGeom.ISolidPrimitive, spacePoint: MSPyBentleyGeom.DPoint3d, pickDetail: MSPyBentleyGeom.SolidLocationDetail) -> bool:
        """
        :param (input):
        spacePoint search for point close to here and on the solid surface
        
        :param (output):
        pickDetail closest point data.
        
        :returns:
        false if not supported.
        """
        ...
    
    def ComputeFacetedPrincipalAreaMoments(self: MSPyBentleyGeom.ISolidPrimitive, options: MSPyBentleyGeom.IFacetOptions, centroid: MSPyBentleyGeom.DVec3d, axes: MSPyBentleyGeom.RotMatrix, momentxyz: MSPyBentleyGeom.DVec3d) -> tuple:
        """
        Return the volume, centroid, orientation, and principal momentsof the
        surface area (shell), using a faceted approximation.
        
        Remark:
        This method only attempts faceted computations. Use
        ComputePrincipalMoments to get exact moments.
        
        :param (input):
        options optional controls for facets
        
        :param (input):
        options optional controls for facet density.
        
        :param (output):
        area surface area
        
        :param (output):
        centroid centroid
        
        :param (output):
        axes columns of this matrix are the principal directions.
        
        :param (output):
        momentxyz moments (yy+zz,xx+zz,xx+yy) around the principal
        directions.
        
        :returns:
        false if (a) solid primitive is not capped or (b) facets failed.
        """
        ...
    
    def ComputeFacetedPrincipalMoments(self: MSPyBentleyGeom.ISolidPrimitive, options: MSPyBentleyGeom.IFacetOptions, centroid: MSPyBentleyGeom.DVec3d, axes: MSPyBentleyGeom.RotMatrix, momentxyz: MSPyBentleyGeom.DVec3d) -> tuple:
        """
        Return the volume, centroid, orientation, and principal moments, using
        a faceted approximation.
        
        Remark:
        This method only attempts faceted computations. Use
        ComputePrincipalMoments to get exact moments.
        
        :param (input):
        options optional controls for facets
        
        :param (input):
        options optional controls for facet density.
        
        :param (output):
        volume volume
        
        :param (output):
        centroid centroid
        
        :param (output):
        axes columns of this matrix are the principal directions.
        
        :param (output):
        momentxyz moments (yy+zz,xx+zz,xx+yy) around the principal
        directions.
        
        :returns:
        false if (a) solid primitive is not capped or (b) facets failed.
        """
        ...
    
    def ComputePrincipalAreaMoments(self: MSPyBentleyGeom.ISolidPrimitive, centroid: MSPyBentleyGeom.DVec3d, axes: MSPyBentleyGeom.RotMatrix, momentxyz: MSPyBentleyGeom.DVec3d) -> tuple:
        """
        Return the volume, centroid, orientation, and principal moments of the
        surface area (shell) using most accurate (possibly exact) formulas.
        
        Remark:
        This method only attempts " exact " computations. Use
        ComputeFacetedPrincipalMoments to get approximate moments.
        
        :param (output):
        area surface area
        
        :param (output):
        centroid centroid
        
        :param (output):
        axes columns of this matrix are the principal directions.
        
        :param (output):
        momentxyz moments (yy+zz,xx+zz,xx+yy) around the principal
        directions.
        
        :returns:
        false if (a) solid primitive is not capped or (b) high accuracy
        moments are not supported for this type.
        """
        ...
    
    def ComputePrincipalMoments(self: MSPyBentleyGeom.ISolidPrimitive, centroid: MSPyBentleyGeom.DVec3d, axes: MSPyBentleyGeom.RotMatrix, momentxyz: MSPyBentleyGeom.DVec3d) -> tuple:
        """
        Return the volume, centroid, orientation, and principal moments using
        most accurate (possibly exact) formulas.
        
        Remark:
        This method only attempts " exact " computations. Use
        ComputeFacetedPrincipalMoments to get approximate moments.
        
        :param (output):
        volume volume
        
        :param (output):
        centroid centroid
        
        :param (output):
        axes columns of this matrix are the principal directions.
        
        :param (output):
        momentxyz moments (yy+zz,xx+zz,xx+yy) around the principal
        directions.
        
        :returns:
        false if (a) solid primitive is not capped or (b) high accuracy
        moments are not supported for this type.
        """
        ...
    
    def ComputeSecondMomentAreaProducts(*args, **kwargs):
        """
        Overloaded function.
        
        1. ComputeSecondMomentAreaProducts(self: MSPyBentleyGeom.ISolidPrimitive, localToWorld: MSPyBentleyGeom.Transform, localProducts: MSPyBentleyGeom.DMatrix4d) -> bool
        
        Return the various integrated products for area moment calculations.
        The primitive is treated as a thin shell.
        
        :param (output):
        localToWorld transform from preferred system where the products
        are most easily computed to world.
        
        :param (output):
        localProducts integrated [xx xy xz x; xy yy yz y; xz yz zz z; x y
        z 1] dA
        
        :returns:
        false if unable to compute.
        
        2. ComputeSecondMomentAreaProducts(self: MSPyBentleyGeom.ISolidPrimitive, worldProducts: MSPyBentleyGeom.DMatrix4d) -> bool
        
        Return the various integrated products for area moment calculations.
        The primitive is treated as a thin shell.
        
        :param (output):
        localToWorld transform from preferred system where the products
        are most easily computed to world.
        
        :param (output):
        localProducts integrated [xx xy xz x; xy yy yz y; xz yz zz z; x y
        z 1] dA
        
        :returns:
        false if unable to compute.
        """
        ...
    
    def ComputeSecondMomentVolumeProducts(*args, **kwargs):
        """
        Overloaded function.
        
        1. ComputeSecondMomentVolumeProducts(self: MSPyBentleyGeom.ISolidPrimitive, localToWorld: MSPyBentleyGeom.Transform, localProducts: MSPyBentleyGeom.DMatrix4d) -> bool
        
        Return the various integrated products for moment calculations. The
        primitive is treated as a volume
        
        :param (output):
        localToWorld transform from preferred system where the products
        are most easily computed to world.
        
        :param (output):
        localProducts integrated [xx xy xz x; xy yy yz y; xz yz zz z; x y
        z 1] dA
        
        :returns:
        false if unable to compute.
        
        2. ComputeSecondMomentVolumeProducts(self: MSPyBentleyGeom.ISolidPrimitive, worldProducts: MSPyBentleyGeom.DMatrix4d) -> bool
        
        Return the various integrated products for moment calculations. The
        primitive is treated as a volume
        
        :param (output):
        localToWorld transform from preferred system where the products
        are most easily computed to world.
        
        :param (output):
        localProducts integrated [xx xy xz x; xy yy yz y; xz yz zz z; x y
        z 1] dA
        
        :returns:
        false if unable to compute.
        """
        ...
    
    @staticmethod
    def CreateDgnBox(data: MSPyBentleyGeom.DgnBoxDetail) -> MSPyBentleyGeom.ISolidPrimitive:
        """
        Return a new ISolidPrimtive which is a DgnBox.
        """
        ...
    
    @staticmethod
    def CreateDgnCone(data: MSPyBentleyGeom.DgnConeDetail) -> MSPyBentleyGeom.ISolidPrimitive:
        """
        Return a new ISolidPrimtive which is a DgnCone.
        """
        ...
    
    @staticmethod
    def CreateDgnExtrusion(data: MSPyBentleyGeom.DgnExtrusionDetail) -> MSPyBentleyGeom.ISolidPrimitive:
        """
        Return a new ISolidPrimtive which is a DgnExtrusion.
        """
        ...
    
    @staticmethod
    def CreateDgnRotationalSweep(data: MSPyBentleyGeom.DgnRotationalSweepDetail) -> MSPyBentleyGeom.ISolidPrimitive:
        """
        Return a new ISolidPrimtive which is a DgnRotationalSweep.
        """
        ...
    
    @staticmethod
    def CreateDgnRuledSweep(data: MSPyBentleyGeom.DgnRuledSweepDetail) -> MSPyBentleyGeom.ISolidPrimitive:
        """
        Return a new ISolidPrimtive which is a DgnRuledSweep.
        """
        ...
    
    @staticmethod
    def CreateDgnSphere(data: MSPyBentleyGeom.DgnSphereDetail) -> MSPyBentleyGeom.ISolidPrimitive:
        """
        Return a new ISolidPrimtive which is a DgnSphere.
        """
        ...
    
    @staticmethod
    def CreateDgnTorusPipe(data: MSPyBentleyGeom.DgnTorusPipeDetail) -> MSPyBentleyGeom.ISolidPrimitive:
        """
        Return a new ISolidPrimtive which is a DgnTorusPipe.
        """
        ...
    
    def GetCapped(self: MSPyBentleyGeom.ISolidPrimitive) -> bool:
        """
        return flag for cap surface. Note that sphere and torus can be closed
        without having a cap surface, so this is not a closure test, just a
        test if the field for capping is set.
        """
        ...
    
    def GetConstantUSection(self: MSPyBentleyGeom.ISolidPrimitive, indices: SolidLocationDetail.FaceIndices, fraction: float) -> MSPyBentleyGeom.ICurvePrimitive:
        """
        Copy a section at constant u of a single face to a single
        ICurvePrimitive. This is usually a single primitive, but can have a
        disjoint, multi-component child for cut of non-convex cap,
        
        :param (input):
        indices selects face
        
        :param (input):
        fraction u fraction for section curve
        """
        ...
    
    def GetConstantVSection(self: MSPyBentleyGeom.ISolidPrimitive, indices: SolidLocationDetail.FaceIndices, fraction: float) -> MSPyBentleyGeom.ICurvePrimitive:
        """
        Copy a section curve at constant v of a single face to a single
        ICurvePrimitive. This is usually a single primitive, but can have a
        disjoint, multi-component child for cut of non-convex cap.
        
        :param (input):
        indices selects face
        
        :param (input):
        fraction v fraction for section curve
        """
        ...
    
    def GetFace(self: MSPyBentleyGeom.ISolidPrimitive, indices: SolidLocationDetail.FaceIndices) -> MSPyBentleyGeom.IGeometry:
        """
        Copy a single face to a new object.
        
        :param (input):
        indices indices of face.
        
        :returns:
        IGeometryPtr with representing a single face. End caps will always
        return as CurveVectorPtr. Planar side faces will return as
        CurveVectorPtr. Cylindrical side faces will return as
        DgnConeDetail with no cap. Other ruled side faces will appear as
        DgnRuledSweepDetail with one swept primitive and no cap.
        Rotational sweeps of arcs will appear as (preferably)
        DgnTorusPipeDetail or DgnRotationalRotationalSweep.
        """
        ...
    
    def GetFaceIndices(self: MSPyBentleyGeom.ISolidPrimitive, indices: MSPyBentleyGeom.FaceIndicesArray) -> None:
        """
        Fill an array containing all the valid face indices for this
        primitive.
        
        :param (output):
        indices array of FaceIndices of all faces of the solid.
        """
        ...
    
    def GetRange(*args, **kwargs):
        """
        Overloaded function.
        
        1. GetRange(self: MSPyBentleyGeom.ISolidPrimitive, range: MSPyBentleyGeom.DRange3d) -> bool
        
        Compute range of primitive
        
        2. GetRange(self: MSPyBentleyGeom.ISolidPrimitive, range: MSPyBentleyGeom.DRange3d, transform: MSPyBentleyGeom.Transform) -> bool
        
        Compute range of primitive
        """
        ...
    
    def GetSolidPrimitiveType(self: MSPyBentleyGeom.ISolidPrimitive) -> MSPyBentleyGeom.SolidPrimitiveType:
        """
        Query the primitive type.
        """
        ...
    
    def HasCurvedFaceOrEdge(self: MSPyBentleyGeom.ISolidPrimitive) -> bool:
        """
        Return true if solid primitve has a non-linear edge or non-planar
        face.
        """
        ...
    
    def IsClosedVolume(self: MSPyBentleyGeom.ISolidPrimitive) -> bool:
        """
        Test if this is a closed volume.
        """
        ...
    
    def IsSameStructure(self: MSPyBentleyGeom.ISolidPrimitive, other: MSPyBentleyGeom.ISolidPrimitive) -> bool:
        """
        Test for same type and structure (but no coordinate comparison)
        """
        ...
    
    def IsSameStructureAndGeometry(self: MSPyBentleyGeom.ISolidPrimitive, other: MSPyBentleyGeom.ISolidPrimitive, tolerance: float) -> bool:
        """
        Test for same type, structure and coordinates.
        """
        ...
    
    def SetCapped(self: MSPyBentleyGeom.ISolidPrimitive, value: bool) -> None:
        """
        Set flag for cap surface.
        """
        ...
    
    def SilhouetteCurves(self: MSPyBentleyGeom.ISolidPrimitive, eyePoint: MSPyBentleyGeom.DPoint4d, curves: MSPyBentleyGeom.CurveVector) -> bool:
        """
        Return curves which are silhoutte curves OTHER than hard edges
        
        :param (input):
        eyePoint For flat view, the view direction with weight=0. For
        perspective, the eye point with weight=1.
        
        :param (input):
        curves silhouette curves.
        
        :returns:
        return false if not implemented. return true if implemented -- but
        curves may still be empty.
        """
        ...
    
    @staticmethod
    def Simplify(primitive: MSPyBentleyGeom.ISolidPrimitive) -> bool:
        """
        Detect a solid primitive that could be represented as a simpler type
        and change it to the simple type. Tests for rotational sweeps that are
        a sphere or torus as well as ruled sweeps that are a box, cone, or
        extrusion.
        
        :returns:
        true if input primitive was simplified.
        """
        ...
    
    @property
    def SolidPrimitiveType(arg0: MSPyBentleyGeom.ISolidPrimitive) -> MSPyBentleyGeom.SolidPrimitiveType:
        ...
    
    def TransformInPlace(self: MSPyBentleyGeom.ISolidPrimitive, transform: MSPyBentleyGeom.Transform) -> bool:
        """
        Transform in place.
        """
        ...
    
    def TryGetConstructiveFrame(self: MSPyBentleyGeom.ISolidPrimitive, localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform) -> bool:
        """
        Return a typical coordinate frame
        """
        ...
    
    def TryGetDgnBoxDetail(self: MSPyBentleyGeom.ISolidPrimitive, data: MSPyBentleyGeom.DgnBoxDetail) -> bool:
        """
        Ask if this is a DgnBox If so, return true with copy of detail data.
        If not, return false, leave data untouched.
        """
        ...
    
    def TryGetDgnConeDetail(self: MSPyBentleyGeom.ISolidPrimitive, data: MSPyBentleyGeom.DgnConeDetail) -> bool:
        """
        Ask if this is a DgnCone If so, return true with copy of detail data.
        If not, return false, leave data untouched.
        """
        ...
    
    def TryGetDgnExtrusionDetail(self: MSPyBentleyGeom.ISolidPrimitive, data: MSPyBentleyGeom.DgnExtrusionDetail) -> bool:
        """
        Ask if this is a DgnExtrusion If so, return true with copy of detail
        data. If not, return false, leave data untouched.
        """
        ...
    
    def TryGetDgnRotationalSweepDetail(self: MSPyBentleyGeom.ISolidPrimitive, data: MSPyBentleyGeom.DgnRotationalSweepDetail) -> bool:
        """
        Ask if this is a DgnRotationalSweep If so, return true with copy of
        detail data. If not, return false, leave data untouched.
        """
        ...
    
    def TryGetDgnRuledSweepDetail(self: MSPyBentleyGeom.ISolidPrimitive, data: MSPyBentleyGeom.DgnRuledSweepDetail) -> bool:
        """
        Ask if this is a DgnRuledSweep If so, return true with copy of detail
        data. If not, return false, leave data untouched.
        """
        ...
    
    def TryGetDgnSphereDetail(self: MSPyBentleyGeom.ISolidPrimitive, data: MSPyBentleyGeom.DgnSphereDetail) -> bool:
        """
        Ask if this is a DgnSphere If so, return true with copy of detail
        data. If not, return false, leave data untouched.
        """
        ...
    
    def TryGetDgnTorusPipeDetail(self: MSPyBentleyGeom.ISolidPrimitive, data: MSPyBentleyGeom.DgnTorusPipeDetail) -> bool:
        """
        Ask if this is a DgnTorusPipe If so, return true with copy of detail
        data. If not, return false, leave data untouched.
        """
        ...
    
    def TryGetMaxUVLength(self: MSPyBentleyGeom.ISolidPrimitive, indices: SolidLocationDetail.FaceIndices, uvLength: MSPyBentleyGeom.DVec2d) -> bool:
        """
        Compute the lengths of the longest u and v direction sections of a
        single face of a solid primitive.
        
        :param (input):
        indices selects face.
        
        :param (input):
        uvLength sizes in u, v directions.
        """
        ...
    
    def TrySetDgnBoxDetail(self: MSPyBentleyGeom.ISolidPrimitive, data: MSPyBentleyGeom.DgnBoxDetail) -> bool:
        """
        Set DgnBoxDetail content.
        """
        ...
    
    def TrySetDgnConeDetail(self: MSPyBentleyGeom.ISolidPrimitive, data: MSPyBentleyGeom.DgnConeDetail) -> bool:
        """
        Set DgnConeDetail content.
        """
        ...
    
    def TrySetDgnExtrusionDetail(self: MSPyBentleyGeom.ISolidPrimitive, data: MSPyBentleyGeom.DgnExtrusionDetail) -> bool:
        """
        Set DgnExtrusionDetail content.
        """
        ...
    
    def TrySetDgnRotationalSweepDetail(self: MSPyBentleyGeom.ISolidPrimitive, data: MSPyBentleyGeom.DgnRotationalSweepDetail) -> bool:
        """
        Set DgnRotationalSweepDetail content.
        """
        ...
    
    def TrySetDgnRuledSweepDetail(self: MSPyBentleyGeom.ISolidPrimitive, data: MSPyBentleyGeom.DgnRuledSweepDetail) -> bool:
        """
        Set DgnRuledSweepDetail content.
        """
        ...
    
    def TrySetDgnSphereDetail(self: MSPyBentleyGeom.ISolidPrimitive, data: MSPyBentleyGeom.DgnSphereDetail) -> bool:
        """
        Set DgnSphereDetail content.
        """
        ...
    
    def TrySetDgnTorusPipeDetail(self: MSPyBentleyGeom.ISolidPrimitive, data: MSPyBentleyGeom.DgnTorusPipeDetail) -> bool:
        """
        Set DgnTorusPipeDetail content.
        """
        ...
    
    def TryUVFractionToXYZ(self: MSPyBentleyGeom.ISolidPrimitive, faceIndices: SolidLocationDetail.FaceIndices, uFraction: float, vFraction: float, xyz: MSPyBentleyGeom.DPoint3d, dXdu: MSPyBentleyGeom.DVec3d, dXdv: MSPyBentleyGeom.DVec3d) -> bool:
        """
        convert u,v fraction on specified face to xyz and derivatives.
        
        :param (input):
        faceIndices face selection indices
        
        :param (input):
        uFraction fractional coordinate in u direction.
        
        :param (input):
        vFraction fractional coordinate in v direction.
        
        :param (output):
        xyz point on face.
        
        :param (output):
        dXdu derivative of face point wrt uFraction.
        
        :param (output):
        dXdv derivative of face point wrt vFraction.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    
class IndexedParameterMap:
    """
    None
    """

    def ConstructMapping(self: MSPyBentleyGeom.IndexedParameterMap, points: MSPyBentleyGeom.DPoint3dArray) -> bool:
        """
        Find any 3 non-colinear points and construct world-to-barycentric map.
        Return false (with identity transforms) if no independent triple
        found.
        """
        ...
    
    def MapDVec3d(self: MSPyBentleyGeom.IndexedParameterMap, xyz: MSPyBentleyGeom.DPoint3d, normals: MSPyBentleyGeom.DVec3dArray) -> MSPyBentleyGeom.DVec3d:
        ...
    
    def MapPoint2d(self: MSPyBentleyGeom.IndexedParameterMap, xyz: MSPyBentleyGeom.DPoint3d, params: MSPyBentleyGeom.DPoint2dArray) -> MSPyBentleyGeom.DPoint2d:
        ...
    
    def __init__(self: MSPyBentleyGeom.IndexedParameterMap) -> None:
        ...
    
    @property
    def index0(self: MSPyBentleyGeom.IndexedParameterMap) -> int:
        ...
    @index0.setter
    def index0(self: MSPyBentleyGeom.IndexedParameterMap, arg0: int) -> None:
        ...
    
    @property
    def index1(self: MSPyBentleyGeom.IndexedParameterMap) -> int:
        ...
    @index1.setter
    def index1(self: MSPyBentleyGeom.IndexedParameterMap, arg0: int) -> None:
        ...
    
    @property
    def index2(self: MSPyBentleyGeom.IndexedParameterMap) -> int:
        ...
    @index2.setter
    def index2(self: MSPyBentleyGeom.IndexedParameterMap, arg0: int) -> None:
        ...
    
    @property
    def localToWorld(self: MSPyBentleyGeom.IndexedParameterMap) -> MSPyBentleyGeom.Transform:
        ...
    @localToWorld.setter
    def localToWorld(self: MSPyBentleyGeom.IndexedParameterMap, arg0: MSPyBentleyGeom.Transform) -> None:
        ...
    
    @property
    def worldToLocal(self: MSPyBentleyGeom.IndexedParameterMap) -> MSPyBentleyGeom.Transform:
        ...
    @worldToLocal.setter
    def worldToLocal(self: MSPyBentleyGeom.IndexedParameterMap, arg0: MSPyBentleyGeom.Transform) -> None:
        ...
    
class Int16Array:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.Int16Array) -> None
        
        2. __init__(self: MSPyBentleyGeom.Int16Array, arg0: MSPyBentleyGeom.Int16Array) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.Int16Array, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.Int16Array, x: int) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.Int16Array) -> None:
        """
        Clear the contents
        """
        ...
    
    def count(self: MSPyBentleyGeom.Int16Array, x: int) -> int:
        """
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.Int16Array, L: MSPyBentleyGeom.Int16Array) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.Int16Array, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.Int16Array, i: int, x: int) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.Int16Array) -> int
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.Int16Array, i: int) -> int
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(self: MSPyBentleyGeom.Int16Array, x: int) -> None:
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class Int32Array:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.Int32Array) -> None
        
        2. __init__(self: MSPyBentleyGeom.Int32Array, arg0: MSPyBentleyGeom.Int32Array) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.Int32Array, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.Int32Array, x: int) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.Int32Array) -> None:
        """
        Clear the contents
        """
        ...
    
    def count(self: MSPyBentleyGeom.Int32Array, x: int) -> int:
        """
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.Int32Array, L: MSPyBentleyGeom.Int32Array) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.Int32Array, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.Int32Array, i: int, x: int) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.Int32Array) -> int
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.Int32Array, i: int) -> int
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(self: MSPyBentleyGeom.Int32Array, x: int) -> None:
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class Int64Array:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.Int64Array) -> None
        
        2. __init__(self: MSPyBentleyGeom.Int64Array, arg0: MSPyBentleyGeom.Int64Array) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.Int64Array, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.Int64Array, x: int) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.Int64Array) -> None:
        """
        Clear the contents
        """
        ...
    
    def count(self: MSPyBentleyGeom.Int64Array, x: int) -> int:
        """
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.Int64Array, L: MSPyBentleyGeom.Int64Array) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.Int64Array, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.Int64Array, i: int, x: int) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.Int64Array) -> int
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.Int64Array, i: int) -> int
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(self: MSPyBentleyGeom.Int64Array, x: int) -> None:
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class Int64VecArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.Int64VecArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.Int64VecArray, arg0: MSPyBentleyGeom.Int64VecArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.Int64VecArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.Int64VecArray, x: MSPyBentleyGeom.Int64Array) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.Int64VecArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def count(self: MSPyBentleyGeom.Int64VecArray, x: MSPyBentleyGeom.Int64Array) -> int:
        """
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.Int64VecArray, L: MSPyBentleyGeom.Int64VecArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.Int64VecArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.Int64VecArray, i: int, x: MSPyBentleyGeom.Int64Array) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.Int64VecArray) -> MSPyBentleyGeom.Int64Array
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.Int64VecArray, i: int) -> MSPyBentleyGeom.Int64Array
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(self: MSPyBentleyGeom.Int64VecArray, x: MSPyBentleyGeom.Int64Array) -> None:
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class Int8Array:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.Int8Array) -> None
        
        2. __init__(self: MSPyBentleyGeom.Int8Array, arg0: MSPyBentleyGeom.Int8Array) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.Int8Array, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.Int8Array, x: int) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.Int8Array) -> None:
        """
        Clear the contents
        """
        ...
    
    def count(self: MSPyBentleyGeom.Int8Array, x: int) -> int:
        """
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.Int8Array, L: MSPyBentleyGeom.Int8Array) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.Int8Array, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.Int8Array, i: int, x: int) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.Int8Array) -> int
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.Int8Array, i: int) -> int
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(self: MSPyBentleyGeom.Int8Array, x: int) -> None:
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class ItemsView[BeExtendedDataGeometryMap]:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    
class KeysView[BeExtendedDataGeometryMap]:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    
class LocalCoordinateSelect:
    """
    Members:
    
    eLOCAL_COORDINATE_SCALE_UnitAxesAtStart
    
    eLOCAL_COORDINATE_SCALE_UnitAxesAtLowerLeft
    
    eLOCAL_COORDINATE_SCALE_01RangeBothAxes
    
    eLOCAL_COORDINATE_SCALE_01RangeLargerAxis
    """

    def __init__(self: MSPyBentleyGeom.LocalCoordinateSelect, value: int) -> None:
        ...
    
    eLOCAL_COORDINATE_SCALE_01RangeBothAxes: LocalCoordinateSelect
    
    eLOCAL_COORDINATE_SCALE_01RangeLargerAxis: LocalCoordinateSelect
    
    eLOCAL_COORDINATE_SCALE_UnitAxesAtLowerLeft: LocalCoordinateSelect
    
    eLOCAL_COORDINATE_SCALE_UnitAxesAtStart: LocalCoordinateSelect
    
    @property
    def name(self: handle) -> str:
        ...
    
    @property
    def value(arg0: MSPyBentleyGeom.LocalCoordinateSelect) -> int:
        ...
    
class LocalRange:
    """
    None
    """

    def DistanceOutside(self: MSPyBentleyGeom.LocalRange, spacePoint: DPoint3d) -> float:
        ...
    
    def InitFromPrincipalAxesOfPoints(*args, **kwargs):
        """
        Overloaded function.
        
        1. InitFromPrincipalAxesOfPoints(self: MSPyBentleyGeom.LocalRange, xyz: List[DPoint3d]) -> bool
        
        2. InitFromPrincipalAxesOfPoints(self: MSPyBentleyGeom.LocalRange, xyzw: List[DPoint4d]) -> bool
        
        3. InitFromPrincipalAxesOfPoints(self: MSPyBentleyGeom.LocalRange, xyz: list) -> bool
        """
        ...
    
    def InitNullRange(self: MSPyBentleyGeom.LocalRange) -> None:
        """
        Initialize with identity transforms and an empty range. Initialize
        with identity transforms and an empty range.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.LocalRange) -> None
        
        2. __init__(self: MSPyBentleyGeom.LocalRange, localToWorld: Transform, worldToLocal: Transform, localRange: DRange3d) -> None
        """
        ...
    
    @property
    def localRange(self: MSPyBentleyGeom.LocalRange) -> DRange3d:
        ...
    @localRange.setter
    def localRange(self: MSPyBentleyGeom.LocalRange, arg0: DRange3d) -> None:
        ...
    
    @property
    def localToWorld(self: MSPyBentleyGeom.LocalRange) -> Transform:
        ...
    @localToWorld.setter
    def localToWorld(self: MSPyBentleyGeom.LocalRange, arg0: Transform) -> None:
        ...
    
    @property
    def worldRange(self: MSPyBentleyGeom.LocalRange) -> DRange3d:
        ...
    @worldRange.setter
    def worldRange(self: MSPyBentleyGeom.LocalRange, arg0: DRange3d) -> None:
        ...
    
    @property
    def worldToLocal(self: MSPyBentleyGeom.LocalRange) -> Transform:
        ...
    @worldToLocal.setter
    def worldToLocal(self: MSPyBentleyGeom.LocalRange, arg0: Transform) -> None:
        ...
    
MATRIX_DATA_ELM_INDEX_TYPE_BLOCK_FIXED: int

MATRIX_DATA_ELM_INDEX_TYPE_BLOCK_NONE: int

MATRIX_DATA_ELM_INDEX_TYPE_BLOCK_VARIABLE: int

MATRIX_DATA_ELM_TRANSFORM_TYPE_COORD_COVECTOR: int

MATRIX_DATA_ELM_TRANSFORM_TYPE_COORD_NONE: int

MATRIX_DATA_ELM_TRANSFORM_TYPE_COORD_POINT: int

MATRIX_DATA_ELM_TRANSFORM_TYPE_COORD_VECTOR: int

MATRIX_ELM_INDEX_FAMILY_NONE: int

MATRIX_ELM_TAG_NONE: int

MESH_ELM_INDEX_FAMILY_BY_FACE: int

MESH_ELM_INDEX_FAMILY_BY_FACE_LOOP: int

MESH_ELM_INDEX_FAMILY_BY_VERTEX: int

MESH_ELM_INDEX_FAMILY_NONE: int

MESH_ELM_STYLE_COORDINATE_QUADS: int

MESH_ELM_STYLE_COORDINATE_TRIANGLES: int

MESH_ELM_STYLE_INDEXED_FACE_LOOPS: int

MESH_ELM_STYLE_LARGE_MESH: int

MESH_ELM_STYLE_POINT_CLOUD: int

MESH_ELM_STYLE_QUAD_GRID: int

MESH_ELM_STYLE_QVXLARGE_TRI_MESH: int

MESH_ELM_STYLE_TRIANGLE_GRID: int

MESH_ELM_TAG_DENSITY: int

MESH_ELM_TAG_DISPLACEMENT: int

MESH_ELM_TAG_DOUBLE_COLOR: int

MESH_ELM_TAG_FACE_LOOP_TO_DENSITY_INDICES: int

MESH_ELM_TAG_FACE_LOOP_TO_DISPLACEMENT_INDICES: int

MESH_ELM_TAG_FACE_LOOP_TO_DOUBLE_COLOR_INDICES: int

MESH_ELM_TAG_FACE_LOOP_TO_FACE_INDICES: int

MESH_ELM_TAG_FACE_LOOP_TO_INT_COLOR_INDICES: int

MESH_ELM_TAG_FACE_LOOP_TO_NORMAL_INDICES: int

MESH_ELM_TAG_FACE_LOOP_TO_PRESSURE_INDICES: int

MESH_ELM_TAG_FACE_LOOP_TO_TABLE_COLOR_INDICES: int

MESH_ELM_TAG_FACE_LOOP_TO_TEMPERATURE_INDICES: int

MESH_ELM_TAG_FACE_LOOP_TO_UV_PARAMETER_INDICES: int

MESH_ELM_TAG_FACE_LOOP_TO_VELOCITY_INDICES: int

MESH_ELM_TAG_FACE_LOOP_TO_VERTEX_INDICES: int

MESH_ELM_TAG_FACE_TO_DENSITY_INDICES: int

MESH_ELM_TAG_FACE_TO_DISPLACEMENT_INDICES: int

MESH_ELM_TAG_FACE_TO_DOUBLE_COLOR_INDICES: int

MESH_ELM_TAG_FACE_TO_INT_COLOR_INDICES: int

MESH_ELM_TAG_FACE_TO_NORMAL_INDICES: int

MESH_ELM_TAG_FACE_TO_PRESSURE_INDICES: int

MESH_ELM_TAG_FACE_TO_TABLE_COLOR_INDICES: int

MESH_ELM_TAG_FACE_TO_TEMPERATURE_INDICES: int

MESH_ELM_TAG_FACE_TO_UV_PARAMETER_INDICES: int

MESH_ELM_TAG_FACE_TO_VELOCITY_INDICES: int

MESH_ELM_TAG_FLOAT_COLOR: int

MESH_ELM_TAG_INT_COLOR: int

MESH_ELM_TAG_NONE: int

MESH_ELM_TAG_NORMAL_COORDINATES: int

MESH_ELM_TAG_PRESSURE: int

MESH_ELM_TAG_TABLE_COLOR: int

MESH_ELM_TAG_TEMPERATURE: int

MESH_ELM_TAG_UV_PARAMETERS: int

MESH_ELM_TAG_VELOCITY: int

MESH_ELM_TAG_VERTEX_COORDINATES: int

MESH_ELM_TAG_VERTEX_TO_DENSITY_INDICES: int

MESH_ELM_TAG_VERTEX_TO_DISPLACEMENT_INDICES: int

MESH_ELM_TAG_VERTEX_TO_DOUBLE_COLOR_INDICES: int

MESH_ELM_TAG_VERTEX_TO_INT_COLOR_INDICES: int

MESH_ELM_TAG_VERTEX_TO_NORMAL_INDICES: int

MESH_ELM_TAG_VERTEX_TO_PRESSURE_INDICES: int

MESH_ELM_TAG_VERTEX_TO_TABLE_COLOR_INDICES: int

MESH_ELM_TAG_VERTEX_TO_TEMPERATURE_INDICES: int

MESH_ELM_TAG_VERTEX_TO_UV_PARAMETER_INDICES: int

MESH_ELM_TAG_VERTEX_TO_VELOCITY_INDICES: int

MSB_ERROR: int

MSB_SUCCESS: int

class MSBsplineCurve:
    """
    None
    """

    def AddArcIntersectionsXY(self: MSPyBentleyGeom.MSBsplineCurve, curvePoints: MSPyBentleyGeom.DPoint3dArray, curveFractions: MSPyBentleyGeom.DoubleArray, ellipsePoints: MSPyBentleyGeom.DPoint3dArray, ellipseFractions: MSPyBentleyGeom.DoubleArray, arc: MSPyBentleyGeom.DEllipse3d, extendConic: bool, matrix: MSPyBentleyGeom.DMatrix4d) -> None:
        ...
    
    def AddCurveIntersectionsXY(self: MSPyBentleyGeom.MSBsplineCurve, curveAPoints: MSPyBentleyGeom.DPoint3dArray, curveAFractions: MSPyBentleyGeom.DoubleArray, curveBPoints: MSPyBentleyGeom.DPoint3dArray, curveBFractions: MSPyBentleyGeom.DoubleArray, curveB: MSPyBentleyGeom.MSBsplineCurve, matrix: MSPyBentleyGeom.DMatrix4d) -> None:
        ...
    
    def AddCusps(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, fractionParameters: MSPyBentleyGeom.DoubleArray) -> None:
        """
        Find full 3d cusps.
        
        :param (output):
        points array to receive xyz of cusps.
        
        :param (output):
        fractionParameters array to receive fraction parameters of cusps.
        """
        ...
    
    def AddCuspsXY(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, fractionParameters: MSPyBentleyGeom.DoubleArray, matrix: MSPyBentleyGeom.DMatrix4d) -> None:
        """
        Find full cusps as viewed in xy.
        
        :param (output):
        points array to receive xyz of cusps.
        
        :param (output):
        fractionParameters array to receive fraction parameters of cusps.
        
        :param (input):
        matrix optional transformation into viewing space.
        """
        ...
    
    def AddKnot(self: MSPyBentleyGeom.MSBsplineCurve, unnormalizedKnotValue: float, newMultiplicity: int) -> int:
        """
        Add a given knot value to the B-spline curve. that newMultiplicity is
        the desired final multiplicity of a knot that may already exist.
        """
        ...
    
    def AddLineIntersectionsXY(*args, **kwargs):
        """
        Overloaded function.
        
        1. AddLineIntersectionsXY(self: MSPyBentleyGeom.MSBsplineCurve, curvePoints: MSPyBentleyGeom.DPoint3dArray, curveFractions: MSPyBentleyGeom.DoubleArray, linePoints: MSPyBentleyGeom.DPoint3dArray, lineFractions: MSPyBentleyGeom.DoubleArray, segment: MSPyBentleyGeom.DSegment3d, extendSegment: bool, matrix: MSPyBentleyGeom.DMatrix4d) -> None
        
        2. AddLineIntersectionsXY(self: MSPyBentleyGeom.MSBsplineCurve, curvePoints: MSPyBentleyGeom.DPoint3dArray, curveFractions: MSPyBentleyGeom.DoubleArray, linePoints: MSPyBentleyGeom.DPoint3dArray, lineFractions: MSPyBentleyGeom.DoubleArray, segment: MSPyBentleyGeom.DSegment3d, extendSegment0: bool, extendSegment1: bool, matrix: MSPyBentleyGeom.DMatrix4d) -> None
        """
        ...
    
    def AddLinestringIntersectionsXY(*args, **kwargs):
        """
        Overloaded function.
        
        1. AddLinestringIntersectionsXY(self: MSPyBentleyGeom.MSBsplineCurve, curveAPoints: MSPyBentleyGeom.DPoint3dArray, curveAFractions: MSPyBentleyGeom.DoubleArray, curveBPoints: MSPyBentleyGeom.DPoint3dArray, curveBFractions: MSPyBentleyGeom.DoubleArray, lineString: MSPyBentleyGeom.DPoint3dArray, matrix: MSPyBentleyGeom.DMatrix4d) -> None
        
        2. AddLinestringIntersectionsXY(self: MSPyBentleyGeom.MSBsplineCurve, curveAPoints: MSPyBentleyGeom.DPoint3dArray, curveAFractions: MSPyBentleyGeom.DoubleArray, curveBPoints: MSPyBentleyGeom.DPoint3dArray, curveBFractions: MSPyBentleyGeom.DoubleArray, lineString: MSPyBentleyGeom.DPoint3dArray, extendLineString: bool, matrix: MSPyBentleyGeom.DMatrix4d) -> None
        """
        ...
    
    def AddPlaneIntersections(*args, **kwargs):
        """
        Overloaded function.
        
        1. AddPlaneIntersections(self: MSPyBentleyGeom.MSBsplineCurve, point: MSPyBentleyGeom.DPoint3dArray, fractionParameters: MSPyBentleyGeom.DoubleArray, plane: MSPyBentleyGeom.DPlane3d) -> None
        
        2. AddPlaneIntersections(self: MSPyBentleyGeom.MSBsplineCurve, point: MSPyBentleyGeom.DPoint3dArray, fractionParameters: MSPyBentleyGeom.DoubleArray, planeCoeffs: MSPyBentleyGeom.DPoint4d) -> None
        """
        ...
    
    @staticmethod
    def AddRuleSurfaceRayIntersections(pickData: MSPyBentleyGeom.SolidLocationDetailArray, curveA: MSPyBentleyGeom.MSBsplineCurve, curveB: MSPyBentleyGeom.MSBsplineCurve, ray: MSPyBentleyGeom.DRay3d) -> bool:
        ...
    
    def AddStrokes(*args, **kwargs):
        """
        Overloaded function.
        
        1. AddStrokes(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, chordTol: float = 0.0, angleTol: float = 0.2, maxEdgeLength: float = 0.0, includeStartPoint: bool = True) -> None
        
        2. AddStrokes(self: MSPyBentleyGeom.MSBsplineCurve, points: list, chordTol: float = 0.0, angleTol: float = 0.2, maxEdgeLength: float = 0.0, includeStartPoint: bool = True) -> None
        
        3. AddStrokes(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, derivatives: MSPyBentleyGeom.DVec3dArray = None, params: MSPyBentleyGeom.DoubleArray = None, chordTol: float = 0.0, angleTol: float = 0.2, maxEdgeLength: float = 0.0, includeStartPoint: bool = True, parameterSelect: MSPyBentleyGeom.CurveParameterMapping = <CurveParameterMapping.eCURVE_PARAMETER_MAPPING_CurveKnot: 1>) -> None
        
        4. AddStrokes(self: MSPyBentleyGeom.MSBsplineCurve, points: list, derivatives: MSPyBentleyGeom.DVec3dArray = None, params: MSPyBentleyGeom.DoubleArray = None, chordTol: float = 0.0, angleTol: float = 0.2, c: float = 0.0, includeStartPoint: bool = True, parameterSelect: MSPyBentleyGeom.CurveParameterMapping = <CurveParameterMapping.eCURVE_PARAMETER_MAPPING_CurveKnot: 1>) -> None
        
        5. AddStrokes(self: MSPyBentleyGeom.MSBsplineCurve, options: MSPyBentleyGeom.IFacetOptions, points: MSPyBentleyGeom.DPoint3dArray, derivatives: MSPyBentleyGeom.DVec3dArray = None, params: MSPyBentleyGeom.DoubleArray = None, includeStart: bool = True) -> None
        
        6. AddStrokes(self: MSPyBentleyGeom.MSBsplineCurve, options: MSPyBentleyGeom.IFacetOptions, points: list, derivatives: MSPyBentleyGeom.DVec3dArray = None, params: MSPyBentleyGeom.DoubleArray = None, includeStart: bool = True) -> None
        
        7. AddStrokes(self: MSPyBentleyGeom.MSBsplineCurve, numPoints: int, points: MSPyBentleyGeom.DPoint3dArray, derivatives: MSPyBentleyGeom.DVec3dArray = None, params: MSPyBentleyGeom.DoubleArray = None, includeStartPoint: bool = True, parameterSelect: MSPyBentleyGeom.CurveParameterMapping = <CurveParameterMapping.eCURVE_PARAMETER_MAPPING_CurveKnot: 1>) -> None
        
        8. AddStrokes(self: MSPyBentleyGeom.MSBsplineCurve, numPoints: int, points: list, derivatives: MSPyBentleyGeom.DVec3dArray = None, params: MSPyBentleyGeom.DoubleArray = None, includeStartPoint: bool = True, parameterSelect: MSPyBentleyGeom.CurveParameterMapping = <CurveParameterMapping.eCURVE_PARAMETER_MAPPING_CurveKnot: 1>) -> None
        """
        ...
    
    def AdvanceToBezierInFractionInterval(self: MSPyBentleyGeom.MSBsplineCurve, segment: MSPyBentleyGeom.BCurveSegment, interval: MSPyBentleyGeom.DRange1d) -> tuple:
        ...
    
    def AdvanceToBezierInKnotInterval(self: MSPyBentleyGeom.MSBsplineCurve, segment: MSPyBentleyGeom.BCurveSegment, bezierSelect: int, interval: MSPyBentleyGeom.DRange1d) -> tuple:
        ...
    
    def AllParallellTangentsXY(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, fractions: MSPyBentleyGeom.DoubleArray, vector: MSPyBentleyGeom.DVec3d) -> None:
        """
        Find all curve points X where the tangents is parallel to the given
        vector.
        
        :param (output):
        points array to receive points.
        
        :param (output):
        fractions array to receive fraction parameters.
        
        :param (input):
        vector given direction.
        """
        ...
    
    def AllTangents(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, fractions: MSPyBentleyGeom.DoubleArray, spacePoint: MSPyBentleyGeom.DPoint3d) -> None:
        """
        For space point Q, find all curve points X where line XQ is tangent to
        the curve.
        
        :param (output):
        points array to receive points.
        
        :param (output):
        fractions array to receive fraction parameters.
        
        :param (input):
        spacePoint space point.
        """
        ...
    
    def AllTangentsXY(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, fractions: MSPyBentleyGeom.DoubleArray, spacePoint: MSPyBentleyGeom.DPoint3d, matrix: MSPyBentleyGeom.DMatrix4d) -> None:
        """
        For space point Q (spacePoint), find all curve points X where line XQ
        is tangent to the curve.
        
        :param (output):
        points array to receive points.
        
        :param (output):
        fractions array to receive fraction parameters.
        
        :param (input):
        spacePoint space point.
        
        :param (input):
        matrix optional transformation into viewing space.
        """
        ...
    
    def Allocate(*args, **kwargs):
        """
        Overloaded function.
        
        1. Allocate(self: MSPyBentleyGeom.MSBsplineCurve) -> int
        
        Allocate memory arrays to match the current counts.
        
        2. Allocate(self: MSPyBentleyGeom.MSBsplineCurve, numPoles: int, order: int, closed: bool, rational: bool) -> int
        
        Allocate memory arrays to match the current counts.
        """
        ...
    
    def AllocateKnots(self: MSPyBentleyGeom.MSBsplineCurve, count: int, data: float = None) -> int:
        """
        <summary>Allocate knot pointer to specified count. (Optionally)copy
        data from callers buffer</summary
        """
        ...
    
    def AllocatePoles(self: MSPyBentleyGeom.MSBsplineCurve, count: int, data: MSPyBentleyGeom.DPoint3d = None) -> int:
        """
        <summary>Allocate pole pointer to specified count. (Optionally)copy
        data from callers buffer</summary
        """
        ...
    
    def AllocateWeights(self: MSPyBentleyGeom.MSBsplineCurve, count: int, data: float = None) -> int:
        """
        <summary>Allocate weight pointer to specified count. (Optionally)copy
        data from callers buffer</summary
        """
        ...
    
    def AlmostEqual(*args, **kwargs):
        """
        Overloaded function.
        
        1. AlmostEqual(self: MSPyBentleyGeom.MSBsplineCurve, other: MSPyBentleyGeom.MSBsplineCurve) -> bool
        
        Compare curves.
        
        2. AlmostEqual(self: MSPyBentleyGeom.MSBsplineCurve, other: MSPyBentleyGeom.MSBsplineCurve, tolerance: float) -> bool
        
        Compare curves.
        """
        ...
    
    def AppendCurve(self: MSPyBentleyGeom.MSBsplineCurve, inCurve: MSPyBentleyGeom.MSBsplineCurve) -> int:
        """
        Change the B-spline curve by appending a given curve.
        """
        ...
    
    def AppendCurves(self: MSPyBentleyGeom.MSBsplineCurve, inCurve1: MSPyBentleyGeom.MSBsplineCurve, inCurve2: MSPyBentleyGeom.MSBsplineCurve, forceContinuity: bool, reparam: bool) -> int:
        """
        Create the B-spline curve by appending two input curves with
        continuity and reparameterization constraints.
        """
        ...
    
    def ApproximateAnyCurve(self: MSPyBentleyGeom.MSBsplineCurve, inCurve: MSPyBentleyGeom.MSBsplineCurve, tolerance: float, order: int, parameterization: int, bMaintainEndTangents: bool) -> int:
        """
        This routine computes a B-spline curve approximated the old one.
        return ERROR if no results.
        
        :param (input):
        pIn Input G1 curve.
        
        :param (input):
        tolerance Geometric tolerance, this should be in general the chord
        height tol.
        
        :param (input):
        order Desired degree of the pOut, 4 is recommended.
        
        :param (input):
        parametrization CHORDLENGTH = 2, CENTRIPETAL = 3.
        
        :param (input):
        bMaintainEndTangents true to maintain the end tangents.
        """
        ...
    
    @staticmethod
    def ApproximateG1Curve(outCurve: MSPyBentleyGeom.MSBsplineCurve, inCurve: MSPyBentleyGeom.MSBsplineCurve, degree: int, keepTangent: bool, parametrization: int, geomTol: float, paramTol: float, pointTol: float) -> int:
        ...
    
    @staticmethod
    def ApproximateNurbsCurve(outCurve: MSPyBentleyGeom.MSBsplineCurve, inCurve: MSPyBentleyGeom.MSBsplineCurve, degree: int, keepTangent: bool, parametrization: int, tol: float) -> int:
        ...
    
    @staticmethod
    def AreCompatible(curveA: MSPyBentleyGeom.MSBsplineCurve, curveB: MSPyBentleyGeom.MSBsplineCurve) -> bool:
        """
        <summary>Test if two curves have compatible knots, order, and pole
        count</summary
        """
        ...
    
    def AreKnotsValid(self: MSPyBentleyGeom.MSBsplineCurve, clampingRequired: bool = True) -> bool:
        """
        Return false if knot counts or values are invalid.
        """
        ...
    
    @staticmethod
    def AreSameKnots(knot0: float, knot1: float) -> bool:
        """
        Compare knots. Absolute tolerance 1e-8 for knots in -1..1. Relative
        tolerance 1e-8 outside.
        """
        ...
    
    @staticmethod
    def AreSameWeights(w0: float, w1: float) -> bool:
        """
        Compare weights with arbitrary but consistent tolerance.
        """
        ...
    
    def CleanKnots(self: MSPyBentleyGeom.MSBsplineCurve) -> int:
        """
        Clean all unnecessary knots.
        """
        ...
    
    def ClosestPoint(self: MSPyBentleyGeom.MSBsplineCurve, curvePoint: MSPyBentleyGeom.DPoint3d, spacePoint: MSPyBentleyGeom.DPoint3d) -> float:
        ...
    
    def ClosestPointXY(self: MSPyBentleyGeom.MSBsplineCurve, curvePoint: MSPyBentleyGeom.DPoint3d, spacePoint: MSPyBentleyGeom.DPoint3d, viewMatrix: MSPyBentleyGeom.DMatrix4d) -> tuple:
        ...
    
    def ClosestTangent(self: MSPyBentleyGeom.MSBsplineCurve, curvePoint: MSPyBentleyGeom.DPoint3d, spacePoint: MSPyBentleyGeom.DPoint3d, biasPoint: MSPyBentleyGeom.DPoint3d) -> tuple:
        ...
    
    def ClosestTangentXY(self: MSPyBentleyGeom.MSBsplineCurve, curvePoint: MSPyBentleyGeom.DPoint3d, spacePoint: MSPyBentleyGeom.DPoint3d, biasPoint: MSPyBentleyGeom.DPoint3d, matrix: MSPyBentleyGeom.DMatrix4d) -> tuple:
        ...
    
    @staticmethod
    def CompressKnots(inKnot: MSPyBentleyGeom.DoubleArray, order: int, outKnot: MSPyBentleyGeom.DoubleArray, multiplicities: MSPyBentleyGeom.UInt64Array) -> tuple:
        ...
    
    def ComputeDerivatives(self: MSPyBentleyGeom.MSBsplineCurve, arg0: MSPyBentleyGeom.DVec3dArray, arg1: int, arg2: float) -> None:
        ...
    
    def ComputeGrevilleAbscissa(self: MSPyBentleyGeom.MSBsplineCurve, averageKnots: MSPyBentleyGeom.DoubleArray = True) -> None:
        ...
    
    def ComputeInflectionPoints(*args, **kwargs):
        """
        Overloaded function.
        
        1. ComputeInflectionPoints(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, params: MSPyBentleyGeom.DoubleArray) -> int
        
        Calculate the parameters and location of the all inflection points of
        a B-spline curve. @DotNetMethodExclude
        
        2. ComputeInflectionPoints(self: MSPyBentleyGeom.MSBsplineCurve, points: list, params: MSPyBentleyGeom.DoubleArray) -> None
        
        Calculate the parameters and location of the all inflection points of
        a B-spline curve. @DotNetMethodExclude
        """
        ...
    
    def ComputeInflectionPointsXY(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, params: MSPyBentleyGeom.DoubleArray, transform: RotMatrix) -> int:
        """
        Calculate the parameters and location of the all inflection points of
        a B-spline curve.
        """
        ...
    
    @staticmethod
    def ComputeUniformKnotGrevilleAbscissa(averageKnots: MSPyBentleyGeom.DoubleArray, numInterval: int, order: int) -> None:
        ...
    
    def ComputeUniformKnots(self: MSPyBentleyGeom.MSBsplineCurve) -> bool:
        """
        Compute uniformly spaced knots. This uses counts from params.
        
        :returns:
        false if param counts are not set.
        """
        ...
    
    def CopyClosed(self: MSPyBentleyGeom.MSBsplineCurve, source: MSPyBentleyGeom.MSBsplineCurve) -> int:
        """
        Create B-spline curve by closing a open B-spline curve.
        """
        ...
    
    def CopyFractionSegment(self: MSPyBentleyGeom.MSBsplineCurve, source: MSPyBentleyGeom.MSBsplineCurve, fractionA: float, fractionB: float) -> int:
        """
        Create B-spline curve by extracting a part of a B-spline curve.
        """
        ...
    
    def CopyFrom(self: MSPyBentleyGeom.MSBsplineCurve, source: MSPyBentleyGeom.MSBsplineCurve) -> int:
        ...
    
    def CopyOpen(self: MSPyBentleyGeom.MSBsplineCurve, source: MSPyBentleyGeom.MSBsplineCurve, unnormalizedKnot: float) -> int:
        """
        Create B-spline curve by opening a closed B-spline curve.
        """
        ...
    
    def CopyReversed(self: MSPyBentleyGeom.MSBsplineCurve, source: MSPyBentleyGeom.MSBsplineCurve) -> int:
        """
        Create B-spline curve by reserving the direction of a B-spline curve.
        """
        ...
    
    def CopySegment(self: MSPyBentleyGeom.MSBsplineCurve, source: MSPyBentleyGeom.MSBsplineCurve, unnormalizedKnotA: float, unnormalizedKnotB: float) -> int:
        """
        Create B-spline curve by extracting a part of a B-spline curve.
        """
        ...
    
    def CopyTransformed(self: MSPyBentleyGeom.MSBsplineCurve, source: MSPyBentleyGeom.MSBsplineCurve, transform: Transform) -> int:
        """
        Create B-spline curve by transforming a B-spline curve.
        """
        ...
    
    def CountDistinctBeziers(self: MSPyBentleyGeom.MSBsplineCurve) -> int:
        """
        Count the number of beziers that have non-null knot intervals.
        """
        ...
    
    @staticmethod
    def Create() -> MSPyBentleyGeom.RefCountedMSBsplineCurve:
        ...
    
    def CreateCapture(self: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.RefCountedMSBsplineCurve:
        """
        <summary>Copy bits into smart pointer. Caller instance zeroed
        out.<summary
        """
        ...
    
    def CreateCopy(self: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.RefCountedMSBsplineCurve:
        """
        <summary>Return copy as smart pointer target.</summary
        """
        ...
    
    def CreateCopyBetweenFractions(self: MSPyBentleyGeom.MSBsplineCurve, fraction0: float, fraction1: float) -> MSPyBentleyGeom.RefCountedMSBsplineCurve:
        """
        <summary>Copy the portion between specified fractions.</summary
        """
        ...
    
    def CreateCopyBetweenKnots(self: MSPyBentleyGeom.MSBsplineCurve, konot0: float, knot1: float) -> MSPyBentleyGeom.RefCountedMSBsplineCurve:
        """
        <summary>Copy the portion between specified knots.</summary
        """
        ...
    
    def CreateCopyBezier(self: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.RefCountedMSBsplineCurve:
        """
        <summary>Copy with all knots saturated.</summary
        """
        ...
    
    def CreateCopyClosed(self: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.RefCountedMSBsplineCurve:
        """
        <summary>Return copy as smart pointer target; if physically closed
        revise poles to be a closed bspline</summary
        """
        ...
    
    def CreateCopyOffsetXY(self: MSPyBentleyGeom.MSBsplineCurve, offset0: float, offset1: float, options: MSPyBentleyGeom.CurveOffsetOptions) -> MSPyBentleyGeom.RefCountedMSBsplineCurve:
        """
        <summary>Copy with offset in XY plane.</summary
        """
        ...
    
    def CreateCopyOpenAtFraction(self: MSPyBentleyGeom.MSBsplineCurve, fraction: float) -> MSPyBentleyGeom.RefCountedMSBsplineCurve:
        """
        <summary>Return copy as smart pointer target; if closed, open it at
        fraction.</summary
        """
        ...
    
    def CreateCopyOpenAtKnot(self: MSPyBentleyGeom.MSBsplineCurve, knot: float) -> MSPyBentleyGeom.RefCountedMSBsplineCurve:
        """
        <summary>Return copy as smart pointer target; if closed, open it at
        knot.</summary
        """
        ...
    
    def CreateCopyReversed(self: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.RefCountedMSBsplineCurve:
        """
        <summary>Complete copy with reversed parameterization.</summary
        """
        ...
    
    def CreateCopyTransformed(self: MSPyBentleyGeom.MSBsplineCurve, transform: Transform) -> MSPyBentleyGeom.RefCountedMSBsplineCurve:
        """
        <summary>Copy with transform applied to poles.</summary
        """
        ...
    
    @staticmethod
    def CreateFromInterpolationAtBasisFunctionPeaks(xyz: MSPyBentleyGeom.DPoint3dArray, order: int, selector: int = 0) -> MSPyBentleyGeom.RefCountedMSBsplineCurve:
        ...
    
    @staticmethod
    def CreateFromInterpolationAtGrevilleKnots(curve: MSPyBentleyGeom.ICurvePrimitive, numPoles: int, order: int, normalizeKnots: bool, knotSelector: int = 0) -> MSPyBentleyGeom.RefCountedMSBsplineCurve:
        ...
    
    @staticmethod
    def CreateFromInterpolationPointsWithKnots(xyz: MSPyBentleyGeom.DPoint3dArray, interpolationKnots: MSPyBentleyGeom.DoubleArray, curveKnots: MSPyBentleyGeom.DoubleArray, order: int) -> MSPyBentleyGeom.RefCountedMSBsplineCurve:
        ...
    
    def CreateFromPointsAndOrder(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateFromPointsAndOrder(self: MSPyBentleyGeom.MSBsplineCurve, pointArray: MSPyBentleyGeom.DPoint3dArray, order: int, closed: bool = False) -> int
        
        Create the B-spline curve from point array and order.
        
        2. CreateFromPointsAndOrder(self: MSPyBentleyGeom.MSBsplineCurve, pointArray: list, order: int, closed: bool = False) -> int
        
        Create the B-spline curve from point array and order.
        """
        ...
    
    @staticmethod
    def CreateFromPolesAndOrder(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateFromPolesAndOrder(poles: MSPyBentleyGeom.DPoint3dArray, weights: MSPyBentleyGeom.DoubleArray, knots: MSPyBentleyGeom.DoubleArray, order: int, closed: bool, inputPolesAlreadyWeighted: bool = True) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        
        2. CreateFromPolesAndOrder(poles: list, weights: MSPyBentleyGeom.DoubleArray, knots: MSPyBentleyGeom.DoubleArray, order: int, closed: bool, inputPolesAlreadyWeighted: bool = True) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        
        3. CreateFromPolesAndOrder(poles: MSPyBentleyGeom.DPoint3dArray, order: int, closed: bool = True) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        
        4. CreateFromPolesAndOrder(poles: list, order: int, closed: bool = True) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        
        5. CreateFromPolesAndOrder(poles: MSPyBentleyGeom.DPoint2dArray, order: int, closed: bool = True) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        """
        ...
    
    @staticmethod
    def CreateInterpolationBetweenCurves(curveA: MSPyBentleyGeom.MSBsplineCurve, fraction: float, curveB: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.RefCountedMSBsplineCurve:
        """
        <summary>Create a curve whose poles are interpolated between the poles
        of two curves.</summary> <remarks>This will only succeed if the curves
        have the same pole, knot, and order structure</remarks
        """
        ...
    
    @property
    def CurveDisplay(arg0: MSPyBentleyGeom.MSBsplineCurve) -> bool:
        ...
    @CurveDisplay.setter
    def CurveDisplay(arg0: MSPyBentleyGeom.MSBsplineCurve, arg1: bool) -> None:
        ...
    
    def ElevateDegree(self: MSPyBentleyGeom.MSBsplineCurve, newDegree: int) -> int:
        """
        Elevate the degree (increases the order) of the B-spline curve.
        """
        ...
    
    def ExtractCurveNormal(self: MSPyBentleyGeom.MSBsplineCurve, normal: MSPyBentleyGeom.DVec3d, position: MSPyBentleyGeom.DPoint3d) -> tuple:
        ...
    
    def ExtractEndPoints(self: MSPyBentleyGeom.MSBsplineCurve, start: MSPyBentleyGeom.DPoint3d, end: MSPyBentleyGeom.DPoint3d) -> None:
        """
        Extract the start or end point of the B-spline curve.
        """
        ...
    
    def ExtractSegmentBetweenKnots(self: MSPyBentleyGeom.MSBsplineCurve, target: MSPyBentleyGeom.MSBsplineCurve, unnormalizedKnotA: float, unnormalizedKnotB: float) -> int:
        """
        Exteact the curve from the B-spline curve at the interval
        [unnormalizedKnotA, unnormalizedKnotB].
        """
        ...
    
    def ExtractTo(self: MSPyBentleyGeom.MSBsplineCurve, dest: MSPyBentleyGeom.MSBsplineCurve) -> None:
        """
        Copy bits into simple structure. Caller instance zeroed.
        """
        ...
    
    def FindKnotInterval(self: MSPyBentleyGeom.MSBsplineCurve, knotValue: float) -> int:
        """
        Return the index of the knot at the left of the interval containing
        specified knot. When knotValue exactly matches a knot, the returned
        index is of the knot to the left - i.e. knotValue appears at the RIGHT
        of the returned interval. (favor knot[index]<knotValue <= knot[index
        + 1])
        """
        ...
    
    def FractionAtSignedDistance(*args, **kwargs):
        """
        Overloaded function.
        
        1. FractionAtSignedDistance(self: MSPyBentleyGeom.MSBsplineCurve, startParam: float, signedDistance: float) -> tuple
        
        2. FractionAtSignedDistance(self: MSPyBentleyGeom.MSBsplineCurve, worldToLocal: RotMatrix, startParam: float, signedDistance: float) -> tuple
        """
        ...
    
    def FractionToKnot(self: MSPyBentleyGeom.MSBsplineCurve, f: float) -> float:
        """
        Return the knot value at a fractional parameter ...
        """
        ...
    
    def FractionToPoint(*args, **kwargs):
        """
        Overloaded function.
        
        1. FractionToPoint(self: MSPyBentleyGeom.MSBsplineCurve, xyz: MSPyBentleyGeom.DPoint3d, f: float) -> None
        
        2. FractionToPoint(self: MSPyBentleyGeom.MSBsplineCurve, xyz: MSPyBentleyGeom.DPoint3d, tangent: MSPyBentleyGeom.DVec3d, f: float) -> None
        
        3. FractionToPoint(self: MSPyBentleyGeom.MSBsplineCurve, xyz: MSPyBentleyGeom.DPoint3d, tangent: MSPyBentleyGeom.DVec3d, f: float) -> float
        
        4. FractionToPoint(self: MSPyBentleyGeom.MSBsplineCurve, xyz: MSPyBentleyGeom.DPoint3d, dXYZ: MSPyBentleyGeom.DVec3d, ddXYZ: MSPyBentleyGeom.DVec3d, f: float) -> None
        
        5. FractionToPoint(self: MSPyBentleyGeom.MSBsplineCurve, points: list, numPoints: int) -> None
        
        6. FractionToPoint(self: MSPyBentleyGeom.MSBsplineCurve, points: list, fractions: MSPyBentleyGeom.DoubleArray) -> None
        """
        ...
    
    def FractionToPoints(*args, **kwargs):
        """
        Overloaded function.
        
        1. FractionToPoints(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, numPoints: int) -> None
        
        2. FractionToPoints(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, fractions: MSPyBentleyGeom.DoubleArray) -> None
        """
        ...
    
    @staticmethod
    def GeneralLeastSquaresApproximation(outCurve: MSPyBentleyGeom.MSBsplineCurve, Q: MSPyBentleyGeom.DPoint3dArray, u: MSPyBentleyGeom.DoubleArray, knots: MSPyBentleyGeom.DoubleArray, numPoles: int, order: int) -> int:
        ...
    
    def GetBezier(self: MSPyBentleyGeom.MSBsplineCurve, segment: MSPyBentleyGeom.BCurveSegment, bezierSelect: int) -> bool:
        """
        Get poles for a single bezier poles from the curve. return false if
        invalid bezierSelect. Note that the bezierSelect for a high
        multiplicity knot returns true for the function but marks the interval
        as null. Normal usage is to loop over all beziers in a bspline but
        skip processing the null intervals.
        
        :param (output):
        segment a filled BCurveSegment.
        
        :param (input):
        bezierSelect selects a bezier interval within the bspline
        @DotNetMethodExclude
        """
        ...
    
    def GetC1DiscontinuousCurves(self: MSPyBentleyGeom.MSBsplineCurve, fractions: MSPyBentleyGeom.DoubleArray, curves: MSPyBentleyGeom.MSBsplineCurvePtrArray) -> None:
        """
        Create copies of each segment with breaks at point or tangent changes.
        """
        ...
    
    def GetC1DiscontinuousFractions(self: MSPyBentleyGeom.MSBsplineCurve, fractions: MSPyBentleyGeom.DoubleArray) -> None:
        """
        Get all C1 fractional Discontinuities. This inspects xyz and tangent
        at each knot break. (It does not look for intraknot cusps)
        @DotNetMethodExclude
        """
        ...
    
    def GetCurveDisplay(self: MSPyBentleyGeom.MSBsplineCurve) -> bool:
        """
        Return curve display flag.
        """
        ...
    
    def GetDisjointCurves(self: MSPyBentleyGeom.MSBsplineCurve, curves: MSPyBentleyGeom.MSBsplineCurvePtrArray) -> None:
        """
        Create copies of each segment with breaks at disjoint knot points.
        """
        ...
    
    def GetFrenetFrame(*args, **kwargs):
        """
        Overloaded function.
        
        1. GetFrenetFrame(self: MSPyBentleyGeom.MSBsplineCurve, frame: MSPyBentleyGeom.DVec3dArray, point: MSPyBentleyGeom.DPoint3d, u: float) -> tuple
        
        2. GetFrenetFrame(self: MSPyBentleyGeom.MSBsplineCurve, frame: Transform, u: float) -> int
        """
        ...
    
    def GetKnot(self: MSPyBentleyGeom.MSBsplineCurve, index: int) -> float:
        """
        return knot by index. returns 0 if out of range. (Use
        NumberAllocatedKnots to determine index range).
        """
        ...
    
    def GetKnotP(self: MSPyBentleyGeom.MSBsplineCurve) -> float:
        """
        return pointer to contiguous knots. @DotNetMethodExclude
        """
        ...
    
    def GetKnotRange(*args, **kwargs):
        """
        Overloaded function.
        
        1. GetKnotRange(self: MSPyBentleyGeom.MSBsplineCurve) -> tuple
        
        2. GetKnotRange(self: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.DSegment1d
        
        Return the knot values corresponding to fraction 0 and fraction 1 ...
        """
        ...
    
    def GetKnots(*args, **kwargs):
        """
        Overloaded function.
        
        1. GetKnots(self: MSPyBentleyGeom.MSBsplineCurve, outData: MSPyBentleyGeom.DoubleArray) -> None
        
        Copy all knots out into caller array.
        
        2. GetKnots(self: MSPyBentleyGeom.MSBsplineCurve, outData: MSPyBentleyGeom.DPoint4dArray) -> None
        
        Copy all knots out into caller array.
        """
        ...
    
    def GetNumKnots(self: MSPyBentleyGeom.MSBsplineCurve) -> int:
        ...
    
    def GetNumPoles(self: MSPyBentleyGeom.MSBsplineCurve) -> int:
        ...
    
    def GetOrder(self: MSPyBentleyGeom.MSBsplineCurve) -> int:
        ...
    
    def GetPole(self: MSPyBentleyGeom.MSBsplineCurve, index: int) -> MSPyBentleyGeom.DPoint3d:
        ...
    
    def GetPoleDPoint4d(self: MSPyBentleyGeom.MSBsplineCurve, index: int) -> MSPyBentleyGeom.DPoint4d:
        """
        return pole by index. returns 0 point if out of range. (Use
        NumberAllocatedPoles to determine index range). @DotNetMethodExclude
        """
        ...
    
    def GetPoleP(self: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.DPoint3d:
        """
        return pointer to contiguous poles. @DotNetMethodExclude
        """
        ...
    
    def GetPoleRange(self: MSPyBentleyGeom.MSBsplineCurve, range: MSPyBentleyGeom.DRange3d) -> None:
        """
        Get the range of the poles of the B-spline curve.
        """
        ...
    
    def GetPoles(self: MSPyBentleyGeom.MSBsplineCurve, outData: MSPyBentleyGeom.DPoint3dArray) -> None:
        """
        Copy all poles out into caller array.
        """
        ...
    
    def GetPolygonDisplay(self: MSPyBentleyGeom.MSBsplineCurve) -> bool:
        """
        Return polygon display flag.
        """
        ...
    
    def GetRange(self: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.DRange3d:
        """
        Get the range of the B-spline curve.
        """
        ...
    
    def GetRangeOfProjectionOnRay(self: MSPyBentleyGeom.MSBsplineCurve, ray: MSPyBentleyGeom.DRay3d, fraction0: float = 0.0, fraction1: float = 1.0) -> MSPyBentleyGeom.DRange1d:
        """
        Get the range of parameters of the projection of (a fractional portion
        of the curve onto a ray return range whose low and high values are the
        extreme parameters (in ray fractions) of the projection of the curve
        onto the ray.
        
        :param (input):
        ray ray to project to
        
        :param (input):
        fraction0 start of active part of the curve
        
        :param (input):
        fraction1 end of active part of the curve
        """
        ...
    
    @staticmethod
    def GetRemovalKnotBound(curve: MSPyBentleyGeom.MSBsplineCurve, r: int, s: int) -> float:
        """
        Compute the bound of remove r-th knot s times
        """
        ...
    
    def GetReversePole(self: MSPyBentleyGeom.MSBsplineCurve, index: int) -> MSPyBentleyGeom.DPoint3d:
        """
        return pole by index, counting from the last pole . (i.e. index 0 is
        the final weight) Returns 0 point if out of range. (Use
        NumberAllocatedPoles to determine index range). @DotNetMethodExclude
        """
        ...
    
    def GetReverseWeight(self: MSPyBentleyGeom.MSBsplineCurve, index: int) -> float:
        """
        return weight by index, counting from the last weight. (i.e. index 0
        is the final weight) Returns 1.0 if out of range. (Use
        NumberAllocatedPoles to determine index range). @DotNetMethodExclude
        """
        ...
    
    def GetStrokeCount(self: MSPyBentleyGeom.MSBsplineCurve, chordTol: float, angleTol: float, maxEdgeLength: float) -> int:
        """
        Compute stroke count
        """
        ...
    
    def GetTailBezierSelect(self: MSPyBentleyGeom.MSBsplineCurve) -> int:
        """
        return an index to use to start " Retreat " order bezier access.
        """
        ...
    
    def GetUnWeightedPole(self: MSPyBentleyGeom.MSBsplineCurve, index: int, reverse: bool = False) -> MSPyBentleyGeom.DPoint3d:
        """
        return pole by index. returns 0 point if out of range. If spline is
        weighted, the weight is divided out. If weight zero, no division
        happens. (Use NumberAllocatedPoles to determine index range).
        @DotNetMethodExclude
        """
        ...
    
    def GetUnWeightedPoles(self: MSPyBentleyGeom.MSBsplineCurve, outData: MSPyBentleyGeom.DPoint3dArray) -> None:
        """
        Copy all poles out into caller array, dividing each by its weight
        """
        ...
    
    def GetWeight(self: MSPyBentleyGeom.MSBsplineCurve, arg0: int) -> float:
        """
        index
        """
        ...
    
    def GetWeightP(self: MSPyBentleyGeom.MSBsplineCurve) -> float:
        """
        return pointer to contiguous weights @DotNetMethodExclude
        """
        ...
    
    def GetWeightRange(self: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.DRange1d:
        ...
    
    def GetWeights(self: MSPyBentleyGeom.MSBsplineCurve, outData: MSPyBentleyGeom.DoubleArray) -> None:
        """
        Copy all weights out into caller array.
        """
        ...
    
    def HasValidCountsAndAllocations(self: MSPyBentleyGeom.MSBsplineCurve) -> bool:
        ...
    
    def HasValidKnotAllocation(self: MSPyBentleyGeom.MSBsplineCurve) -> bool:
        ...
    
    def HasValidOrder(self: MSPyBentleyGeom.MSBsplineCurve) -> bool:
        ...
    
    def HasValidPoleAllocation(self: MSPyBentleyGeom.MSBsplineCurve) -> bool:
        ...
    
    def HasValidPoleCounts(self: MSPyBentleyGeom.MSBsplineCurve) -> bool:
        ...
    
    def HasValidWeightAllocation(self: MSPyBentleyGeom.MSBsplineCurve) -> bool:
        ...
    
    def HasWeights(self: MSPyBentleyGeom.MSBsplineCurve) -> bool:
        """
        Check whether the B-spline curve has stored weights (This does not
        check if any are other than 1.0)
        """
        ...
    
    def InitAkima(*args, **kwargs):
        """
        Overloaded function.
        
        1. InitAkima(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, compressPoints: bool) -> None
        
        2. InitAkima(self: MSPyBentleyGeom.MSBsplineCurve, points: list, compressPoints: bool) -> None
        """
        ...
    
    def InitEllipticArc(self: MSPyBentleyGeom.MSBsplineCurve, center: MSPyBentleyGeom.DPoint3d, rX: float, rY: float, startRadians: float = 0.0, sweepRadians: float = 6.283185307179586, axes: RotMatrix = None) -> int:
        ...
    
    def InitFromBeziers(self: MSPyBentleyGeom.MSBsplineCurve, beziers: MSPyBentleyGeom.MSBsplineCurveArray) -> int:
        """
        Create a B-spline curve from a series of Bezier curve.
        """
        ...
    
    def InitFromDEllipse3d(self: MSPyBentleyGeom.MSBsplineCurve, ellipse: MSPyBentleyGeom.DEllipse3d) -> int:
        """
        Initialize the B-spline curve for an ellipse.
        """
        ...
    
    def InitFromDPoint4dArray(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint4dArray, order: int) -> None:
        ...
    
    def InitFromGeneralLeastSquares(self: MSPyBentleyGeom.MSBsplineCurve, avgDistance: float, maxDistance: float, info: MSPyBentleyGeom.BsplineParam, knts: MSPyBentleyGeom.DoubleArray, pnts: MSPyBentleyGeom.DPoint3d, uValues: float, numPnts: int) -> int:
        ...
    
    def InitFromInterpolatePoints(*args, **kwargs):
        """
        Overloaded function.
        
        1. InitFromInterpolatePoints(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, parameterization: int, endControl: bool, sTangent: MSPyBentleyGeom.DVec3d, eTangent: MSPyBentleyGeom.DVec3d, keepTanMag: bool, order: int) -> None
        
        2. InitFromInterpolatePoints(self: MSPyBentleyGeom.MSBsplineCurve, points: list, parameterization: int, endControl: bool, sTangent: MSPyBentleyGeom.DVec3d, eTangent: MSPyBentleyGeom.DVec3d, keepTanMag: bool, order: int) -> None
        """
        ...
    
    def InitFromLeastSquaresFit(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3d, numPoints: int, endControl: bool, sTangent: MSPyBentleyGeom.DVec3d, eTangent: MSPyBentleyGeom.DVec3d, keepTanMag: bool, iterDegree: int, reqDegree: int, singleKnot: bool, tolerance: float) -> int:
        ...
    
    def InitFromPoints(*args, **kwargs):
        """
        Overloaded function.
        
        1. InitFromPoints(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray) -> None
        
        2. InitFromPoints(self: MSPyBentleyGeom.MSBsplineCurve, points: list) -> None
        """
        ...
    
    def IsClosed(self: MSPyBentleyGeom.MSBsplineCurve) -> bool:
        """
        Check whether the B-spline curve is periodic.
        """
        ...
    
    def IsParabola(self: MSPyBentleyGeom.MSBsplineCurve, localToWorld: Transform, worldToLocal: Transform, localStart: MSPyBentleyGeom.DPoint3d, localEnd: MSPyBentleyGeom.DPoint3d) -> tuple:
        ...
    
    def IsPhysicallyClosed(self: MSPyBentleyGeom.MSBsplineCurve, tolerance: float) -> bool:
        """
        Check whether the B-spline curve is physically closed. A B-spline
        curve may be non-periodic, but still return true if its first and last
        poles coincide.
        """
        ...
    
    def IsSameGeometry(self: MSPyBentleyGeom.MSBsplineCurve, other: MSPyBentleyGeom.MSBsplineCurve) -> bool:
        """
        Check if the B-spline curves has same parameters with the given curve.
        """
        ...
    
    class KnotPosition:
        """
        Members:
        
        eKNOTPOS_BEFORE_START
        
        eKNOTPOS_START
        
        eKNOTPOS_INTERVAL
        
        eKNOTPOS_INTERIOR
        
        eKNOTPOS_FINAL
        
        eKNOTPOS_AFTER_FINAL
        """
    
        def __init__(self: MSPyBentleyGeom.MSBsplineCurve.KnotPosition, value: int) -> None:
            ...
        
        eKNOTPOS_AFTER_FINAL: KnotPosition
        
        eKNOTPOS_BEFORE_START: KnotPosition
        
        eKNOTPOS_FINAL: KnotPosition
        
        eKNOTPOS_INTERIOR: KnotPosition
        
        eKNOTPOS_INTERVAL: KnotPosition
        
        eKNOTPOS_START: KnotPosition
        
        @property
        def name(self: handle) -> str:
            ...
        
        @property
        def value(arg0: MSPyBentleyGeom.MSBsplineCurve.KnotPosition) -> int:
            ...
        
    @staticmethod
    def KnotRefinement(X: MSPyBentleyGeom.DoubleArray, curve: MSPyBentleyGeom.MSBsplineCurve) -> int:
        ...
    
    def KnotToBlendFunctions(self: MSPyBentleyGeom.MSBsplineCurve, blend: float, blendDerivatives: float, u: float) -> int:
        ...
    
    def KnotToFraction(self: MSPyBentleyGeom.MSBsplineCurve, knot: float) -> float:
        """
        Return the fractional parameter corresponding to a knot value ...
        """
        ...
    
    def Length(*args, **kwargs):
        """
        Overloaded function.
        
        1. Length(self: MSPyBentleyGeom.MSBsplineCurve) -> float
        
        compute the length of the B-spline curve.
        
        2. Length(self: MSPyBentleyGeom.MSBsplineCurve, worldToLocal: RotMatrix) -> float
        
        compute the length of the B-spline curve.
        """
        ...
    
    def LengthBetweenFractions(*args, **kwargs):
        """
        Overloaded function.
        
        1. LengthBetweenFractions(self: MSPyBentleyGeom.MSBsplineCurve, startKnot: float, endKnot: float) -> float
        
        2. LengthBetweenFractions(self: MSPyBentleyGeom.MSBsplineCurve, worldToLocal: RotMatrix, startKnot: float, endKnot: float) -> float
        """
        ...
    
    def LengthBetweenKnots(*args, **kwargs):
        """
        Overloaded function.
        
        1. LengthBetweenKnots(self: MSPyBentleyGeom.MSBsplineCurve, startKnot: float, endKnot: float) -> float
        
        2. LengthBetweenKnots(self: MSPyBentleyGeom.MSBsplineCurve, worldToLocal: RotMatrix, startKnot: float, endKnot: float) -> float
        """
        ...
    
    def MakeBezier(self: MSPyBentleyGeom.MSBsplineCurve, bezierCurve: MSPyBentleyGeom.MSBsplineCurve) -> int:
        """
        Create equivalent Bezier curve for the B-spline curve.
        """
        ...
    
    def MakeBeziers(self: MSPyBentleyGeom.MSBsplineCurve, beziers: MSPyBentleyGeom.MSBsplineCurveArray) -> int:
        """
        Create a series of Bezier curve for the B-spline curve.
        @DotNetMethodExclude
        """
        ...
    
    def MakeClosed(self: MSPyBentleyGeom.MSBsplineCurve) -> int:
        """
        Close the open B-spline curve.
        """
        ...
    
    def MakeOpen(self: MSPyBentleyGeom.MSBsplineCurve, u: float) -> int:
        """
        Open the closed B-spline curve.
        """
        ...
    
    def MakeRational(self: MSPyBentleyGeom.MSBsplineCurve) -> int:
        """
        Make an equivalent rational B-spline curve.
        """
        ...
    
    def MakeReversed(self: MSPyBentleyGeom.MSBsplineCurve) -> int:
        """
        Reverse the direction of the B-spline curve.
        """
        ...
    
    @staticmethod
    def MapFractions(params: MSPyBentleyGeom.DoubleArray, derivatives: MSPyBentleyGeom.DVec3dArray, i0: int, knot0: float, knot1: float, select: MSPyBentleyGeom.CurveParameterMapping, curve: MSPyBentleyGeom.MSBsplineCurve) -> None:
        ...
    
    def MapKnots(self: MSPyBentleyGeom.MSBsplineCurve, a: float, b: float) -> bool:
        """
        rewrite knot values in a..b. Return true if a,b and current start,end
        define a valid scale factor
        """
        ...
    
    def NormalizeKnots(self: MSPyBentleyGeom.MSBsplineCurve) -> None:
        """
        Normalize knots to 01
        """
        ...
    
    def PointsAtUniformArcLength(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, fractions: MSPyBentleyGeom.DoubleArray, numPoints: int) -> bool:
        """
        Compute points at uniform arclength steps.
        
        :param (output):
        points array to receive points.
        
        :param (output):
        fractions array to receive fractions.
        
        :param (input):
        numPoints number of points.
        """
        ...
    
    def PointsAtUniformFractions(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, fractions: MSPyBentleyGeom.DoubleArray, numPoints: int) -> None:
        """
        Compute strokes at uniform fraction step.
        
        :param (output):
        points array to receive points.
        
        :param (output):
        fractions array to receive fractions.
        
        :param (input):
        numPoints number of points.
        """
        ...
    
    @property
    def PolygonDisplay(arg0: MSPyBentleyGeom.MSBsplineCurve) -> bool:
        ...
    @PolygonDisplay.setter
    def PolygonDisplay(arg0: MSPyBentleyGeom.MSBsplineCurve, arg1: bool) -> None:
        ...
    
    def PolygonLength(self: MSPyBentleyGeom.MSBsplineCurve) -> float:
        """
        Compute the length of the control polygon of the B-spline curve.
        """
        ...
    
    def Populate(*args, **kwargs):
        """
        Overloaded function.
        
        1. Populate(self: MSPyBentleyGeom.MSBsplineCurve, pointVector: MSPyBentleyGeom.DPoint3dArray, weightVector: MSPyBentleyGeom.DoubleArray, knotVector: MSPyBentleyGeom.DoubleArray, order: int, closed: bool, inputPolesAlreadyWeighted: bool) -> int
        
        2. Populate(self: MSPyBentleyGeom.MSBsplineCurve, pointVector: list, weightVector: MSPyBentleyGeom.DoubleArray, knotVector: MSPyBentleyGeom.DoubleArray, order: int, closed: bool, inputPolesAlreadyWeighted: bool) -> int
        """
        ...
    
    def ProjectToZFocalPlane(self: MSPyBentleyGeom.MSBsplineCurve, focalLength: float) -> None:
        """
        convert to a weighted curve whose normalized points fall on a focal
        plane
        """
        ...
    
    @property
    def Range(arg0: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.DRange3d:
        ...
    
    def ReleaseMem(self: MSPyBentleyGeom.MSBsplineCurve) -> None:
        """
        Free memory allocated for the poles, weights and knot vector of a
        B-spline curve.
        """
        ...
    
    def RemoveKnotsBounded(self: MSPyBentleyGeom.MSBsplineCurve, tol: float, startPreservation: int, endPreservation: int) -> int:
        """
        Remove all removable knots with the tolerance and end condition
        constraints.
        """
        ...
    
    def Resolution(*args, **kwargs):
        """
        Overloaded function.
        
        1. Resolution(self: MSPyBentleyGeom.MSBsplineCurve) -> float
        
        Get a (fairly tight) tolerance for the B-spline curve.
        
        2. Resolution(self: MSPyBentleyGeom.MSBsplineCurve, abstol: float, reltol: float) -> float
        
        Get a (fairly tight) tolerance for the B-spline curve.
        """
        ...
    
    def RetreatToBezierInKnotInterval(self: MSPyBentleyGeom.MSBsplineCurve, segment: MSPyBentleyGeom.BCurveSegment, bezierSelect: int, interval: MSPyBentleyGeom.DRange1d) -> tuple:
        ...
    
    def RotateCurve(self: MSPyBentleyGeom.MSBsplineCurve, rMatrix: RotMatrix) -> int:
        """
        Rotate the B-spline curve.
        """
        ...
    
    @staticmethod
    def RuledSurfaceClosestPoint(pickData: MSPyBentleyGeom.SolidLocationDetail, curveA: MSPyBentleyGeom.MSBsplineCurve, curveB: MSPyBentleyGeom.MSBsplineCurve, spacePoint: MSPyBentleyGeom.DPoint3d) -> bool:
        ...
    
    @staticmethod
    def SampleG1CurveByPoints(P: MSPyBentleyGeom.DPoint3dArray, up: MSPyBentleyGeom.DoubleArray, uq: MSPyBentleyGeom.DoubleArray, curve: MSPyBentleyGeom.MSBsplineCurve, par: int, Eg: float, ptol: float) -> int:
        ...
    
    def SearchKnot(self: MSPyBentleyGeom.MSBsplineCurve, unnormalizedKnotValue: float) -> tuple:
        ...
    
    def SegmentAkimaCurve(self: MSPyBentleyGeom.MSBsplineCurve, segment: MSPyBentleyGeom.DPoint3dArray, akimaCurve: MSPyBentleyGeom.DPoint3dArray, transform: Transform, param0: float, param1: float, tolerance: float = -1.0) -> bool:
        ...
    
    def SetCurveDisplay(self: MSPyBentleyGeom.MSBsplineCurve, value: bool) -> None:
        """
        Set the curve display flag.
        """
        ...
    
    def SetKnot(self: MSPyBentleyGeom.MSBsplineCurve, index: int, value: float) -> bool:
        """
        set weight by index. returns false if index out of range.
        @DotNetMethodExclude
        """
        ...
    
    def SetKnots(self: MSPyBentleyGeom.MSBsplineCurve, index: int, value: float, n: int) -> bool:
        """
        set weight by index. returns false if index out of range.
        @DotNetMethodExclude
        """
        ...
    
    def SetPole(*args, **kwargs):
        """
        Overloaded function.
        
        1. SetPole(self: MSPyBentleyGeom.MSBsplineCurve, index: int, value: MSPyBentleyGeom.DPoint3d) -> bool
        
        set pole by index. returns false if index out of range.
        @DotNetMethodExclude
        
        2. SetPole(self: MSPyBentleyGeom.MSBsplineCurve, index: int, x: float, y: float, z: float) -> bool
        
        set pole by index. returns false if index out of range.
        @DotNetMethodExclude
        """
        ...
    
    def SetPoles(self: MSPyBentleyGeom.MSBsplineCurve, index: int, value: MSPyBentleyGeom.DPoint3d, n: int) -> bool:
        """
        set pole by index. returns false if index out of range.
        @DotNetMethodExclude
        """
        ...
    
    def SetPolygonDisplay(self: MSPyBentleyGeom.MSBsplineCurve, value: bool) -> None:
        """
        Set the polygon display flag.
        """
        ...
    
    def SetReWeightedPole(self: MSPyBentleyGeom.MSBsplineCurve, index: int, value: MSPyBentleyGeom.DPoint3d, reverse: bool = False) -> bool:
        """
        set pole by index. returns false if index out of range. If the curve
        is weighted, the current weight is multiplied into the input pole.
        @DotNetMethodExclude
        """
        ...
    
    def SetWeight(self: MSPyBentleyGeom.MSBsplineCurve, index: int, value: float) -> bool:
        """
        set weight by index. returns false if index out of range.
        @DotNetMethodExclude
        """
        ...
    
    def SetWeights(self: MSPyBentleyGeom.MSBsplineCurve, index: int, value: float, n: int) -> bool:
        """
        set weight by index. returns false if index out of range.
        @DotNetMethodExclude
        """
        ...
    
    def SwapContents(self: MSPyBentleyGeom.MSBsplineCurve, other: MSPyBentleyGeom.MSBsplineCurve) -> None:
        """
        Exchange all bits with other. Usually used to transfer poles etc and
        leave zeros behind.
        """
        ...
    
    def TransformCurve(self: MSPyBentleyGeom.MSBsplineCurve, transform: Transform) -> int:
        """
        Transform the B-spline curve.
        """
        ...
    
    def TransformCurve4d(self: MSPyBentleyGeom.MSBsplineCurve, transform4d: MSPyBentleyGeom.DMatrix4d) -> int:
        """
        Transform the B-spline curve using a 4d transformation.
        """
        ...
    
    def TransformPoles(*args, **kwargs):
        """
        Overloaded function.
        
        1. TransformPoles(self: MSPyBentleyGeom.MSBsplineCurve, transform: Transform, index: int, n: int) -> None
        
        Apply a transform to a single pole.
        
        2. TransformPoles(self: MSPyBentleyGeom.MSBsplineCurve, transform: Transform, index: int, n: int) -> None
        
        Apply a transform to a single pole.
        """
        ...
    
    def UnWeightPoles(self: MSPyBentleyGeom.MSBsplineCurve) -> None:
        """
        if the curve is rational, divide (wx,wy,wz) style poles by the weights
        """
        ...
    
    def WeightPoles(self: MSPyBentleyGeom.MSBsplineCurve) -> None:
        """
        if the curve is rational, multiply (wx,wy,wz) style poles by the
        weights
        """
        ...
    
    @staticmethod
    def WeightedLeastSquaresFit(outCurve: MSPyBentleyGeom.MSBsplineCurve, Q: MSPyBentleyGeom.DPoint3dArray, u: MSPyBentleyGeom.DoubleArray, endControl: bool, sTangent: MSPyBentleyGeom.DVec3d, eTangent: MSPyBentleyGeom.DVec3d, numPoles: int, order: int) -> int:
        ...
    
    def WireCentroid(self: MSPyBentleyGeom.MSBsplineCurve, centroid: MSPyBentleyGeom.DPoint3d, fraction0: float, fraction1: float) -> float:
        ...
    
    def Zero(self: MSPyBentleyGeom.MSBsplineCurve) -> None:
        """
        <summary>Zero out the curve. This is customarily applied immediately
        after allocation on stack or heap. This does NOT free memory from
        prior contents. </summary
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    
    @property
    def display(self: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.BsplineDisplay:
        ...
    @display.setter
    def display(self: MSPyBentleyGeom.MSBsplineCurve, arg0: MSPyBentleyGeom.BsplineDisplay) -> None:
        ...
    
    eKNOTPOS_AFTER_FINAL: KnotPosition
    
    eKNOTPOS_BEFORE_START: KnotPosition
    
    eKNOTPOS_FINAL: KnotPosition
    
    eKNOTPOS_INTERIOR: KnotPosition
    
    eKNOTPOS_INTERVAL: KnotPosition
    
    eKNOTPOS_START: KnotPosition
    
    @property
    def knots(arg0: MSPyBentleyGeom.MSBsplineCurve) -> list:
        ...
    
    @property
    def params(self: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.BsplineParam:
        ...
    @params.setter
    def params(self: MSPyBentleyGeom.MSBsplineCurve, arg0: MSPyBentleyGeom.BsplineParam) -> None:
        ...
    
    @property
    def poles(arg0: MSPyBentleyGeom.MSBsplineCurve) -> list:
        ...
    
    @property
    def rational(self: MSPyBentleyGeom.MSBsplineCurve) -> int:
        ...
    @rational.setter
    def rational(self: MSPyBentleyGeom.MSBsplineCurve, arg0: int) -> None:
        ...
    
    @property
    def type(self: MSPyBentleyGeom.MSBsplineCurve) -> int:
        ...
    @type.setter
    def type(self: MSPyBentleyGeom.MSBsplineCurve, arg0: int) -> None:
        ...
    
    @property
    def weights(arg0: MSPyBentleyGeom.MSBsplineCurve) -> list:
        ...
    
class MSBsplineCurveArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.MSBsplineCurveArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.MSBsplineCurveArray, arg0: MSPyBentleyGeom.MSBsplineCurveArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.MSBsplineCurveArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.MSBsplineCurveArray, x: MSPyBentleyGeom.MSBsplineCurve) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.MSBsplineCurveArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.MSBsplineCurveArray, L: MSPyBentleyGeom.MSBsplineCurveArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.MSBsplineCurveArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.MSBsplineCurveArray, i: int, x: MSPyBentleyGeom.MSBsplineCurve) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.MSBsplineCurveArray) -> MSPyBentleyGeom.MSBsplineCurve
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.MSBsplineCurveArray, i: int) -> MSPyBentleyGeom.MSBsplineCurve
        
        Remove and return the item at index ``i``
        """
        ...
    
class MSBsplineCurvePtrArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.MSBsplineCurvePtrArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.MSBsplineCurvePtrArray, arg0: MSPyBentleyGeom.MSBsplineCurvePtrArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.MSBsplineCurvePtrArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.MSBsplineCurvePtrArray, x: MSPyBentleyGeom.RefCountedMSBsplineCurve) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.MSBsplineCurvePtrArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def count(self: MSPyBentleyGeom.MSBsplineCurvePtrArray, x: MSPyBentleyGeom.RefCountedMSBsplineCurve) -> int:
        """
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.MSBsplineCurvePtrArray, L: MSPyBentleyGeom.MSBsplineCurvePtrArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.MSBsplineCurvePtrArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.MSBsplineCurvePtrArray, i: int, x: MSPyBentleyGeom.RefCountedMSBsplineCurve) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.MSBsplineCurvePtrArray) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.MSBsplineCurvePtrArray, i: int) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(self: MSPyBentleyGeom.MSBsplineCurvePtrArray, x: MSPyBentleyGeom.RefCountedMSBsplineCurve) -> None:
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class MSBsplineSurface:
    """
    None
    """

    def AddKnot(self: MSPyBentleyGeom.MSBsplineSurface, unnormalizedKnotValue: float, newMultiplicity: int, direction: int) -> int:
        """
        Add a given knot value to the B-spline surface in given direction.
        newMultiplicity is the desired final multiplicity of a knot that may
        already exist.
        """
        ...
    
    def AddTrimBoundary(*args, **kwargs):
        """
        Overloaded function.
        
        1. AddTrimBoundary(self: MSPyBentleyGeom.MSBsplineSurface, uvPoints: MSPyBentleyGeom.DPoint2dArray) -> bool
        
        Add a uv polyline trim boundary.
        
        2. AddTrimBoundary(self: MSPyBentleyGeom.MSBsplineSurface, xyzPoints: MSPyBentleyGeom.DPoint3dArray) -> bool
        
        Add a uv polyline trim boundary.
        
        3. AddTrimBoundary(self: MSPyBentleyGeom.MSBsplineSurface, xyzPoints: list) -> bool
        
        Add a uv polyline trim boundary.
        """
        ...
    
    def Allocate(self: MSPyBentleyGeom.MSBsplineSurface) -> int:
        """
        Allocate memory arrays to match the current counts.
        """
        ...
    
    def AllocateUKnots(self: MSPyBentleyGeom.MSBsplineSurface) -> int:
        """
        Allocate uKnots. Prior knot buffer is freed if present (do not call on
        pre-zeroed surface!!)
        """
        ...
    
    def AllocateVKnots(self: MSPyBentleyGeom.MSBsplineSurface) -> int:
        """
        Allocate vKnots. Prior knot buffer is freed if present (do not call on
        pre-zeroed surface!!)
        """
        ...
    
    def AreUKnotsValid(self: MSPyBentleyGeom.MSBsplineSurface, clampingRequired: bool) -> bool:
        """
        Return the true allocated size of the pole array....
        """
        ...
    
    def AreVKnotsValid(self: MSPyBentleyGeom.MSBsplineSurface, clampingRequired: bool) -> bool:
        ...
    
    def BoundaryLoopArea(self: MSPyBentleyGeom.MSBsplineSurface, boundaryIndex: int) -> float:
        """
        Return the area of a single boundary loop ..
        """
        ...
    
    def CleanKnots(self: MSPyBentleyGeom.MSBsplineSurface) -> int:
        """
        Clean all unnecessary knots.
        """
        ...
    
    def Clone(self: MSPyBentleyGeom.MSBsplineSurface) -> MSPyBentleyGeom.RefCountedMSBsplineSurface:
        ...
    
    def ClosestPoint(self: MSPyBentleyGeom.MSBsplineSurface, surfacePoint: MSPyBentleyGeom.DPoint3d, surfaceUV: MSPyBentleyGeom.DPoint2d, spacePoint: MSPyBentleyGeom.DPoint3d) -> None:
        """
        Find closest point on surface
        """
        ...
    
    def ComputePrincipalAreaMoments(self: MSPyBentleyGeom.MSBsplineSurface, centroid: MSPyBentleyGeom.DVec3d, axes: RotMatrix, momentxyz: MSPyBentleyGeom.DVec3d) -> tuple:
        ...
    
    def ComputeSecondMomentAreaProducts(self: MSPyBentleyGeom.MSBsplineSurface, products: MSPyBentleyGeom.DMatrix4d) -> bool:
        """
        Return the integrals of products of inertia [xx xy xz x; xy yy yz y;
        xz yz zz 1] * dA
        """
        ...
    
    def ComputeUniformUKnots(self: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        """
        Compute uniformly spaced knots. This uses counts from params.
        
        :returns:
        false if param counts are not set.
        """
        ...
    
    def ComputeUniformVKnots(self: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        """
        Compute uniformly spaced knots. This uses counts from params.
        
        :returns:
        false if param counts are not set.
        """
        ...
    
    def ControlPolygonFractionToControlPolygonDPoint3d(self: MSPyBentleyGeom.MSBsplineSurface, i: int, j: int, u: float, v: float) -> MSPyBentleyGeom.ValidatedDPoint3d:
        """
        Calculate the control polygon point at fractional position within a
        control polygon quad.
        """
        ...
    
    def ControlPolygonFractionToControlPolygonDPoint4d(self: MSPyBentleyGeom.MSBsplineSurface, i: int, j: int, u: float, v: float) -> MSPyBentleyGeom.ValidatedDPoint4d:
        """
        Calculate the control polygon point at fractional position within a
        control polygon quad.
        """
        ...
    
    def ControlPolygonFractionToKnot(self: MSPyBentleyGeom.MSBsplineSurface, i: int, j: int, u: float, v: float) -> MSPyBentleyGeom.ValidatedDPoint2d:
        """
        Calculate the knot values at fractional position within a control
        polygon quad.
        """
        ...
    
    def CopyClosed(self: MSPyBentleyGeom.MSBsplineSurface, source: MSPyBentleyGeom.MSBsplineSurface, edge: int) -> int:
        """
        Create B-spline surface by closing a open B-spline surface.
        """
        ...
    
    def CopyFrom(self: MSPyBentleyGeom.MSBsplineSurface, source: MSPyBentleyGeom.MSBsplineSurface) -> int:
        """
        Allocate memory for the B-spline surface and copies all data from the
        input B-spline surface.
        """
        ...
    
    def CopyOpen(self: MSPyBentleyGeom.MSBsplineSurface, source: MSPyBentleyGeom.MSBsplineSurface, unnormalizedKnot: float, edge: int) -> int:
        """
        Create B-spline surface by opening a closed B-spline surface about
        given direction.
        """
        ...
    
    def CopyReversed(self: MSPyBentleyGeom.MSBsplineSurface, source: MSPyBentleyGeom.MSBsplineSurface, edge: int) -> int:
        """
        Create B-spline surface by reversing the given direction of surface.
        """
        ...
    
    @staticmethod
    def Create() -> MSPyBentleyGeom.RefCountedMSBsplineSurface:
        ...
    
    def CreateCapture(self: MSPyBentleyGeom.MSBsplineSurface) -> MSPyBentleyGeom.RefCountedMSBsplineSurface:
        """
        Returns a smart pointer to an MSBsplineSurface on the heap. Copy bits
        from instance, zero the instance.
        """
        ...
    
    @staticmethod
    def CreateCatmullRom(points: MSPyBentleyGeom.DPoint3dArray, numU: int, numV: int, uv: MSPyBentleyGeom.DPoint2dArray) -> MSPyBentleyGeom.RefCountedMSBsplineSurface:
        ...
    
    def CreateCopyTransformed(self: MSPyBentleyGeom.MSBsplineSurface, transform: Transform) -> MSPyBentleyGeom.RefCountedMSBsplineSurface:
        """
        Clone as new refcounted pointer.
        """
        ...
    
    @staticmethod
    def CreateFromPolesAndOrder(pointVector: MSPyBentleyGeom.DPoint3dArray, weightVector: MSPyBentleyGeom.DoubleArray, uKnotVector: MSPyBentleyGeom.DoubleArray, uOrder: int, numUPoints: int, uClosed: bool, vKnotVector: MSPyBentleyGeom.DoubleArray, vOrder: int, numVPoints: int, vClosed: bool, inputPolesAlreadyWeighted: bool) -> MSPyBentleyGeom.RefCountedMSBsplineSurface:
        ...
    
    @staticmethod
    def CreateLinearSweep(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateLinearSweep(primitive: MSPyBentleyGeom.ICurvePrimitive, delta: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.RefCountedMSBsplineSurface
        
        Create a linear sweep from a (single) base curve. Fails (i.e. returns
        NULL) if the primitive has children.
        
        :param (input):
        primitive base curve to be swept
        
        :param (input):
        delta sweep direction.
        
        2. CreateLinearSweep(primitive: MSPyBentleyGeom.MSBsplineCurve, delta: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.RefCountedMSBsplineSurface
        
        Create a linear sweep from a (single) base curve. Fails (i.e. returns
        NULL) if the primitive has children.
        
        :param (input):
        primitive base curve to be swept
        
        :param (input):
        delta sweep direction.
        
        3. CreateLinearSweep(surfaces: MSPyBentleyGeom.MSBsplineSurfacePtrArray, baseCurves: MSPyBentleyGeom.CurveVector, delta: MSPyBentleyGeom.DVec3d) -> bool
        
        Create a linear sweep from a (single) base curve. Fails (i.e. returns
        NULL) if the primitive has children.
        
        :param (input):
        primitive base curve to be swept
        
        :param (input):
        delta sweep direction.
        """
        ...
    
    @staticmethod
    def CreateRotationalSweep(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateRotationalSweep(primitive: MSPyBentleyGeom.ICurvePrimitive, center: MSPyBentleyGeom.DPoint3d, axis: MSPyBentleyGeom.DVec3d, sweepRadians: float) -> MSPyBentleyGeom.RefCountedMSBsplineSurface
        
        2. CreateRotationalSweep(primitive: MSPyBentleyGeom.MSBsplineCurve, center: MSPyBentleyGeom.DPoint3d, axis: MSPyBentleyGeom.DVec3d, sweepRadians: float) -> MSPyBentleyGeom.RefCountedMSBsplineSurface
        
        3. CreateRotationalSweep(surfaces: MSPyBentleyGeom.MSBsplineSurfacePtrArray, baseCurves: MSPyBentleyGeom.CurveVector, center: MSPyBentleyGeom.DPoint3d, axis: MSPyBentleyGeom.DVec3d, sweepRadians: float) -> bool
        """
        ...
    
    @staticmethod
    def CreateRuled(curveA: MSPyBentleyGeom.ICurvePrimitive, curveB: MSPyBentleyGeom.ICurvePrimitive) -> MSPyBentleyGeom.RefCountedMSBsplineSurface:
        """
        Create a linear sweep from a ruled surface between two curves. Fails
        (i.e. returns NULL) if the primitives have children or are not
        compatible.
        
        :param (input):
        curveA first curve
        
        :param (input):
        curveB second curve
        """
        ...
    
    @staticmethod
    def CreateTrimmedDisk(ellipse: MSPyBentleyGeom.DEllipse3d) -> MSPyBentleyGeom.RefCountedMSBsplineSurface:
        """
        Create a planar (bilinear) surface for the parallelogram around the
        ellipse. Insert a trim curve for the ellipse.
        
        :param (input):
        ellipse space ellipse
        """
        ...
    
    @staticmethod
    def CreateTrimmedSurfaces(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateTrimmedSurfaces(surfaces: MSPyBentleyGeom.MSBsplineSurfacePtrArray, source: MSPyBentleyGeom.CurveVector, options: MSPyBentleyGeom.IFacetOptions = None) -> bool
        
        2. CreateTrimmedSurfaces(surfaces: MSPyBentleyGeom.MSBsplineSurfacePtrArray, source: ISolidPrimitive, options: MSPyBentleyGeom.IFacetOptions = None) -> bool
        """
        ...
    
    @staticmethod
    def CreateTubeSurface(baseCurve: MSPyBentleyGeom.MSBsplineCurve, translateBaseCurve: bool, traceCurve: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.RefCountedMSBsplineSurface:
        """
        Create a surface swept along a trace curve.
        
        :param (input):
        baseCurve base contour
        
        :param (input):
        translateBaseCurve true to translate section, false to rotate with
        trace
        
        :param (input):
        traceCurve path to sweep
        """
        ...
    
    def DeleteBoundaries(self: MSPyBentleyGeom.MSBsplineSurface) -> None:
        """
        Remove all trim boundaries.
        """
        ...
    
    def ElevateDegree(self: MSPyBentleyGeom.MSBsplineSurface, newDegree: int, edge: int) -> int:
        """
        Elevate the degree (increases the order) of the B-spline surface in
        given direction.
        """
        ...
    
    def EvaluateAllPartials(self: MSPyBentleyGeom.MSBsplineSurface, xyz: MSPyBentleyGeom.DPoint3d, dPdU: MSPyBentleyGeom.DVec3d, dPdV: MSPyBentleyGeom.DVec3d, dPdUU: MSPyBentleyGeom.DVec3d, dPdVV: MSPyBentleyGeom.DVec3d, dPdUv: MSPyBentleyGeom.DVec3d, normal: MSPyBentleyGeom.DVec3d, u: float, v: float) -> None:
        ...
    
    def EvaluateNormalizedFrame(self: MSPyBentleyGeom.MSBsplineSurface, transform: Transform, u: float, v: float) -> bool:
        """
        Calculate a coordinate frame on the surface.
        
        :param (input):
        u u parameter
        
        :param (input):
        v v parameter.
        
        :param (output):
        transform transform with (a) origin at surface point, (b) x axis
        in u direction, (c) y axis perpendicular to x and in the surface
        tangent plane, (d) z axis normal to surface. Return false if
        tangent vectors are parallel or zero.
        """
        ...
    
    def EvaluatePoint(*args, **kwargs):
        """
        Overloaded function.
        
        1. EvaluatePoint(self: MSPyBentleyGeom.MSBsplineSurface, xyz: MSPyBentleyGeom.DPoint3d, u: float, v: float) -> None
        
        2. EvaluatePoint(self: MSPyBentleyGeom.MSBsplineSurface, xyz: MSPyBentleyGeom.DPoint3d, dPdU: MSPyBentleyGeom.DVec3d, dPdV: MSPyBentleyGeom.DVec3d, u: float, v: float) -> None
        """
        ...
    
    def EvaluatePointAndUnitNormal(self: MSPyBentleyGeom.MSBsplineSurface, ray: MSPyBentleyGeom.DRay3d, u: float, v: float) -> bool:
        """
        Calculate the point and unit normal on the B-spline surface at the
        input u and v parameter values. Return false if tangent vectors are
        parallel or zero.
        """
        ...
    
    def EvaluatePrincipalCurvature(self: MSPyBentleyGeom.MSBsplineSurface, xyz: MSPyBentleyGeom.DPoint3d, unitA: MSPyBentleyGeom.DVec3d, unitB: MSPyBentleyGeom.DVec3d, u: float, v: float) -> tuple:
        ...
    
    def EvaluateUniformGrid(*args, **kwargs):
        """
        Overloaded function.
        
        1. EvaluateUniformGrid(self: MSPyBentleyGeom.MSBsplineSurface, numUPoint: int, numVPoint: int, uParams: MSPyBentleyGeom.DoubleArray, vParams: MSPyBentleyGeom.DoubleArray, gridPoints: MSPyBentleyGeom.DPoint3dArray) -> None
        
        2. EvaluateUniformGrid(self: MSPyBentleyGeom.MSBsplineSurface, numUPoint: int, numVPoint: int, uParams: MSPyBentleyGeom.DoubleArray, vParams: MSPyBentleyGeom.DoubleArray, gridPoints: list) -> None
        
        3. EvaluateUniformGrid(self: MSPyBentleyGeom.MSBsplineSurface, numUPoint: int, numVPoint: int, uvParams: MSPyBentleyGeom.DPoint2dArray, gridPoints: MSPyBentleyGeom.DPoint3dArray) -> None
        
        4. EvaluateUniformGrid(self: MSPyBentleyGeom.MSBsplineSurface, numUPoint: int, numVPoint: int, uvParams: MSPyBentleyGeom.DPoint2dArray, gridPoints: list) -> None
        """
        ...
    
    def ExtractTo(self: MSPyBentleyGeom.MSBsplineSurface, dest: MSPyBentleyGeom.MSBsplineSurface) -> None:
        """
        Copy bits into simple structure. Caller instance zeroed.
        """
        ...
    
    def FindKnotInterval(self: MSPyBentleyGeom.MSBsplineSurface, knotValue: float, direction: int) -> int:
        ...
    
    def FixupBoundaryLoopParity(self: MSPyBentleyGeom.MSBsplineSurface) -> None:
        """
        Analyze loop parity among all boundary loops. Replace as " complete "
        loop set -- no implicit 01 outer boundary.
        """
        ...
    
    def FractionToKnot(self: MSPyBentleyGeom.MSBsplineSurface, f: float, direction: int) -> float:
        """
        Return the knot value at a fractional parameter about given
        direction...
        """
        ...
    
    def GetBoundaryUV(self: MSPyBentleyGeom.MSBsplineSurface, boundaryIndex: int, pointIndex: int) -> MSPyBentleyGeom.DPoint2d:
        ...
    
    def GetIntervalCounts(self: MSPyBentleyGeom.MSBsplineSurface) -> tuple:
        ...
    
    def GetIsUClosed(self: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        """
        return the u direction periodic state.
        """
        ...
    
    def GetIsVClosed(self: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        """
        return the v direction periodic state.
        """
        ...
    
    def GetIsoUCurve(self: MSPyBentleyGeom.MSBsplineSurface, u: float) -> MSPyBentleyGeom.RefCountedMSBsplineCurve:
        """
        Get the (untrimmed) v-direction curve at u
        """
        ...
    
    def GetIsoUCurveSegments(self: MSPyBentleyGeom.MSBsplineSurface, u: float, segments: MSPyBentleyGeom.MSBsplineCurvePtrArray) -> None:
        """
        Get scan line intersections at constant u.
        """
        ...
    
    def GetIsoULineVIntersections(self: MSPyBentleyGeom.MSBsplineSurface, u: float, vParams: MSPyBentleyGeom.DoubleArray) -> None:
        """
        Get scan line intersections at constant u.
        """
        ...
    
    def GetIsoVCurve(self: MSPyBentleyGeom.MSBsplineSurface, v: float) -> MSPyBentleyGeom.RefCountedMSBsplineCurve:
        """
        Get the (untrimmed) u-direction curve at v
        """
        ...
    
    def GetIsoVCurveSegments(self: MSPyBentleyGeom.MSBsplineSurface, v: float, segments: MSPyBentleyGeom.MSBsplineCurvePtrArray) -> None:
        """
        Get scan line intersections at constant v.
        """
        ...
    
    def GetIsoVLineUIntersections(self: MSPyBentleyGeom.MSBsplineSurface, v: float, uParams: MSPyBentleyGeom.DoubleArray) -> None:
        """
        Get scan line intersections at constant v.
        """
        ...
    
    def GetKnotRange(self: MSPyBentleyGeom.MSBsplineSurface, direction: int) -> tuple:
        ...
    
    def GetNumBounds(self: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    
    def GetNumPointsInBoundary(self: MSPyBentleyGeom.MSBsplineSurface, boundaryIndex: int) -> int:
        """
        return the number of ponits in a boundary.
        """
        ...
    
    def GetNumPoles(self: MSPyBentleyGeom.MSBsplineSurface) -> int:
        """
        return the product of u and v direction poles counts.
        """
        ...
    
    def GetNumUKnots(self: MSPyBentleyGeom.MSBsplineSurface) -> int:
        """
        return the u direction knot count.
        """
        ...
    
    def GetNumUPoles(self: MSPyBentleyGeom.MSBsplineSurface) -> int:
        """
        return the u direction pole count.
        """
        ...
    
    def GetNumVKnots(self: MSPyBentleyGeom.MSBsplineSurface) -> int:
        """
        return the v direction knot count.
        """
        ...
    
    def GetNumVPoles(self: MSPyBentleyGeom.MSBsplineSurface) -> int:
        """
        return the v direction pole count.
        """
        ...
    
    def GetParameterRegion(self: MSPyBentleyGeom.MSBsplineSurface) -> tuple:
        ...
    
    def GetPole(*args, **kwargs):
        """
        Overloaded function.
        
        1. GetPole(self: MSPyBentleyGeom.MSBsplineSurface, i: int) -> MSPyBentleyGeom.DPoint3d
        
        2. GetPole(self: MSPyBentleyGeom.MSBsplineSurface, i: int, j: int) -> MSPyBentleyGeom.DPoint3d
        """
        ...
    
    def GetPoleDPoint4d(*args, **kwargs):
        """
        Overloaded function.
        
        1. GetPoleDPoint4d(self: MSPyBentleyGeom.MSBsplineSurface, i: int) -> MSPyBentleyGeom.DPoint4d
        
        2. GetPoleDPoint4d(self: MSPyBentleyGeom.MSBsplineSurface, i: int, j: int) -> MSPyBentleyGeom.DPoint4d
        """
        ...
    
    def GetPoleRange(*args, **kwargs):
        """
        Overloaded function.
        
        1. GetPoleRange(self: MSPyBentleyGeom.MSBsplineSurface, range: MSPyBentleyGeom.DRange3d) -> None
        
        Get the range of the poles of the B-spline surface.
        
        2. GetPoleRange(self: MSPyBentleyGeom.MSBsplineSurface, range: MSPyBentleyGeom.DRange3d, transform: Transform) -> None
        
        Get the range of the poles of the B-spline surface.
        """
        ...
    
    def GetPoles(self: MSPyBentleyGeom.MSBsplineSurface, outData: MSPyBentleyGeom.DPoint3dArray) -> None:
        """
        Copy all poles out into caller array.
        """
        ...
    
    def GetPolygonColumnAsCurve(self: MSPyBentleyGeom.MSBsplineSurface, index: int) -> MSPyBentleyGeom.RefCountedMSBsplineCurve:
        """
        Copy poles from a column into a curve structure. index -1 is
        understood as " end "
        """
        ...
    
    def GetPolygonDisplay(self: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        ...
    
    def GetPolygonRowAsCurve(self: MSPyBentleyGeom.MSBsplineSurface, index: int) -> MSPyBentleyGeom.RefCountedMSBsplineCurve:
        """
        Copy poles from a row into a curve structure. index -1 is understood
        as " end "
        """
        ...
    
    def GetPrincipalExtents(self: MSPyBentleyGeom.MSBsplineSurface, extends: Transform) -> bool:
        """
        Return a transform whose columns are along edges parallel to the
        principal axes and sized to include the poles from the translation
        point.
        """
        ...
    
    def GetSupport(self: MSPyBentleyGeom.MSBsplineSurface, outPoles: MSPyBentleyGeom.DPoint4dArray, outUKnots: MSPyBentleyGeom.DoubleArray, outVKnots: MSPyBentleyGeom.DoubleArray, uIndex: int, vIndex: int) -> bool:
        """
        Extract the poles and knots that support a single bezier patch ...
        
        :param (output):
        outPoles{uOrder X vOrder} poles
        
        :param (output):
        outUKnots{2*(uOrder-1)} knots
        
        :param (output):
        outVKnots{2*(vOrder-1)} knots
        
        :param (input):
        uIndex index of bezier to extract.
        
        :param (input):
        vIndex index of bezier to extract. @DotNetMethodExclude
        """
        ...
    
    def GetSurfaceDisplay(self: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        ...
    
    def GetUKnot(self: MSPyBentleyGeom.MSBsplineSurface, outData: int) -> float:
        ...
    
    def GetUKnots(self: MSPyBentleyGeom.MSBsplineSurface, knots: MSPyBentleyGeom.DoubleArray) -> None:
        ...
    
    def GetUOrder(self: MSPyBentleyGeom.MSBsplineSurface) -> int:
        """
        return the u direction order.
        """
        ...
    
    def GetUVBoundaryCurves(self: MSPyBentleyGeom.MSBsplineSurface, addOuterLoopsIfActive: bool, preferCurves: bool) -> MSPyBentleyGeom.CurveVector:
        """
        Return current uv boundary data. This returns a parity region.
        """
        ...
    
    def GetUVBoundaryLoops(*args, **kwargs):
        """
        Overloaded function.
        
        1. GetUVBoundaryLoops(self: MSPyBentleyGeom.MSBsplineSurface, uvBoundaries: MSPyBentleyGeom.DPoint2dVecArray, addOuterLoopsIfActive: bool) -> None
        
        2. GetUVBoundaryLoops(self: MSPyBentleyGeom.MSBsplineSurface, uvBoundaries: MSPyBentleyGeom.DPoint2dVecArray, addOuterLoopsIfActive: bool, cleanupParity: bool) -> None
        """
        ...
    
    def GetUnWeightedPole(*args, **kwargs):
        """
        Overloaded function.
        
        1. GetUnWeightedPole(self: MSPyBentleyGeom.MSBsplineSurface, i: int, j: int) -> MSPyBentleyGeom.DPoint3d
        
        2. GetUnWeightedPole(self: MSPyBentleyGeom.MSBsplineSurface, i: int) -> MSPyBentleyGeom.DPoint3d
        """
        ...
    
    def GetUnWeightedPoles(self: MSPyBentleyGeom.MSBsplineSurface, outData: MSPyBentleyGeom.DPoint3dArray) -> None:
        """
        Copy all poles out into caller array, dividing each by its weight
        """
        ...
    
    def GetUnstructuredBoundaryCurves(*args, **kwargs):
        """
        Overloaded function.
        
        1. GetUnstructuredBoundaryCurves(self: MSPyBentleyGeom.MSBsplineSurface, tolerance: float, cubicFit: bool) -> MSPyBentleyGeom.CurveVector
        
        2. GetUnstructuredBoundaryCurves(self: MSPyBentleyGeom.MSBsplineSurface, tolerance: float, cubicFit: bool, addOuterLoopIfActive: bool) -> MSPyBentleyGeom.CurveVector
        """
        ...
    
    def GetVKnot(self: MSPyBentleyGeom.MSBsplineSurface, outData: int) -> float:
        ...
    
    def GetVKnots(self: MSPyBentleyGeom.MSBsplineSurface, knots: MSPyBentleyGeom.DoubleArray) -> None:
        ...
    
    def GetVOrder(self: MSPyBentleyGeom.MSBsplineSurface) -> int:
        """
        return the v direction order.
        """
        ...
    
    def GetWeight(*args, **kwargs):
        """
        Overloaded function.
        
        1. GetWeight(self: MSPyBentleyGeom.MSBsplineSurface, i: int) -> float
        
        2. GetWeight(self: MSPyBentleyGeom.MSBsplineSurface, i: int, j: int) -> float
        """
        ...
    
    def GetWeights(self: MSPyBentleyGeom.MSBsplineSurface, outData: MSPyBentleyGeom.DoubleArray) -> None:
        """
        Copy all weights out into caller array.
        """
        ...
    
    def HasValidBoundaryAllocation(self: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        ...
    
    def HasValidCountsAndAllocations(self: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        ...
    
    def HasValidOrder(self: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        ...
    
    def HasValidPoleAllocation(self: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        ...
    
    def HasValidPoleCounts(self: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        ...
    
    def HasValidWeightAllocation(self: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        ...
    
    def HasWeights(self: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        """
        ask if this is a " rational " (weighted) surface.
        """
        ...
    
    def InitFromPointsAndOrder(self: MSPyBentleyGeom.MSBsplineSurface, uOrder: int, vOrder: int, uNumPoles: int, vNumPoles: int, points: MSPyBentleyGeom.DPoint3d) -> int:
        """
        Initialize the B-spline surface from point array and U/V order.
        """
        ...
    
    def IntersectRay(*args, **kwargs):
        """
        Overloaded function.
        
        1. IntersectRay(self: MSPyBentleyGeom.MSBsplineSurface, intersectionPoints: MSPyBentleyGeom.DPoint3dArray, rayParameters: MSPyBentleyGeom.DoubleArray, surfaceParameters: MSPyBentleyGeom.DPoint2dArray, ray: MSPyBentleyGeom.DRay3d) -> None
        
        2. IntersectRay(self: MSPyBentleyGeom.MSBsplineSurface, intersectionPoints: list, rayParameters: MSPyBentleyGeom.DoubleArray, surfaceParameters: MSPyBentleyGeom.DPoint2dArray, ray: MSPyBentleyGeom.DRay3d) -> None
        
        3. IntersectRay(self: MSPyBentleyGeom.MSBsplineSurface, intersectionPoints: MSPyBentleyGeom.DPoint3dArray, rayParameters: MSPyBentleyGeom.DoubleArray, surfaceParameters: MSPyBentleyGeom.DPoint2dArray, ray: MSPyBentleyGeom.DRay3d, rayInterval: MSPyBentleyGeom.DRange1d) -> None
        
        4. IntersectRay(self: MSPyBentleyGeom.MSBsplineSurface, intersectionPoints: list, rayParameters: MSPyBentleyGeom.DoubleArray, surfaceParameters: MSPyBentleyGeom.DPoint2dArray, ray: MSPyBentleyGeom.DRay3d, rayInterval: MSPyBentleyGeom.DRange1d) -> None
        """
        ...
    
    def IsBidirectionalTranslation(self: MSPyBentleyGeom.MSBsplineSurface, relativeTolerance: float = 0.0) -> bool:
        """
        Check whether the u curves are all translations of the first u curve.
        (If this is true, the v curves are also translations of the first v
        curve0)
        
        :param (input):
        relativeTolerance tolerance as a fraction of the largest
        coordinate.
        """
        ...
    
    def IsDegenerateEdge(self: MSPyBentleyGeom.MSBsplineSurface, edgeCode: int, tolerance: float) -> bool:
        """
        Check whether an edge of the surface degenerates to a single point.
        """
        ...
    
    def IsOuterBoundaryActive(self: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        """
        :returns:
        the state of the outer boundary flag.
        """
        ...
    
    def IsPhysicallyClosed(self: MSPyBentleyGeom.MSBsplineSurface) -> tuple:
        ...
    
    def IsPlanarBilinear(*args, **kwargs):
        """
        Overloaded function.
        
        1. IsPlanarBilinear(self: MSPyBentleyGeom.MSBsplineSurface) -> bool
        
        Check whether the B-spline surface is bilinear and each face of the
        control polygon is planar, with tight system tolerance
        (Angle.SmallAngle (
        
        2. IsPlanarBilinear(self: MSPyBentleyGeom.MSBsplineSurface, angleTol: float) -> bool
        
        Check whether the B-spline surface is bilinear and each face of the
        control polygon is planar, with tight system tolerance
        (Angle.SmallAngle (
        """
        ...
    
    def IsPlane(self: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        """
        Check whether the poles are entirely within a plane. This does not
        check for goofy direction changes -- just planarity.
        """
        ...
    
    def IsSameStructure(self: MSPyBentleyGeom.MSBsplineSurface, other: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        """
        Compare all non-coordinate data.
        """
        ...
    
    def IsSameStructureAndGeometry(self: MSPyBentleyGeom.MSBsplineSurface, other: MSPyBentleyGeom.MSBsplineSurface, tolerance: float) -> bool:
        """
        Compare all data.
        """
        ...
    
    def IsSolid(self: MSPyBentleyGeom.MSBsplineSurface, tolerance: float) -> bool:
        """
        Check whether the B-spline surface encloses a valid space.
        """
        ...
    
    @property
    def IsUClosed(arg0: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        ...
    
    @property
    def IsVClosed(arg0: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        ...
    
    def KnotToBlendFunctions(self: MSPyBentleyGeom.MSBsplineSurface, blend: float, blendDerivatives: float, u: float, direction: int) -> int:
        ...
    
    def KnotToFraction(self: MSPyBentleyGeom.MSBsplineSurface, knot: float, direction: int) -> float:
        """
        Return the fractional parameter corresponding to a knot value ...
        """
        ...
    
    def LoftingSurface(self: MSPyBentleyGeom.MSBsplineSurface, pCurves: MSPyBentleyGeom.MSBsplineCurve, pStartNormal: MSPyBentleyGeom.DVec3d, pEndNormal: MSPyBentleyGeom.DVec3d, numCurves: int, approxComp: bool, closed: bool, smoothStart: bool, smoothEnd: bool, chordLength: bool, applyComp: bool, tolerance: float) -> int:
        ...
    
    def MakeBezier(self: MSPyBentleyGeom.MSBsplineSurface, outSurface: MSPyBentleyGeom.MSBsplineSurface) -> int:
        """
        Create equivalent Bezier surface for the B-spline surface.
        """
        ...
    
    def MakeBeziers(self: MSPyBentleyGeom.MSBsplineSurface, beziers: List[MSBsplineSurface]) -> int:
        """
        Create a series of Bezier surfaces for the B-spline surface.
        """
        ...
    
    def MakeClosed(self: MSPyBentleyGeom.MSBsplineSurface, direction: int) -> int:
        """
        Close the open B-spline surface about the given direction.
        """
        ...
    
    def MakeOpen(self: MSPyBentleyGeom.MSBsplineSurface, uv: float, direction: int) -> int:
        """
        Open the closed B-spline surface about the given direction.
        """
        ...
    
    def MakeRational(self: MSPyBentleyGeom.MSBsplineSurface) -> int:
        """
        Make an equivalent rational B-spline surface.
        """
        ...
    
    def MakeReversed(self: MSPyBentleyGeom.MSBsplineSurface, direction: int) -> int:
        """
        Reserve the given direction of the surface.
        """
        ...
    
    def NormalizeKnots(self: MSPyBentleyGeom.MSBsplineSurface) -> None:
        """
        Normalize knots to 01 (both directions)
        """
        ...
    
    def NormalizeSurface(self: MSPyBentleyGeom.MSBsplineSurface) -> None:
        """
        Scale and translate the parameter range of the surface and its
        boundary loops so all parameters are between 0 and 1.
        """
        ...
    
    @property
    def NumBounds(arg0: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    
    @property
    def NumPoles(arg0: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    
    @property
    def NumUKnots(arg0: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    
    @property
    def NumUPoles(arg0: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    
    @property
    def NumVKnots(arg0: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    
    @property
    def NumVPoles(arg0: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    
    @property
    def PolygonDisplay(arg0: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        ...
    @PolygonDisplay.setter
    def PolygonDisplay(arg0: MSPyBentleyGeom.MSBsplineSurface, arg1: bool) -> None:
        ...
    
    def Populate(self: MSPyBentleyGeom.MSBsplineSurface, pointVector: MSPyBentleyGeom.DPoint3dArray, weightVector: MSPyBentleyGeom.DoubleArray, uKnotVector: MSPyBentleyGeom.DoubleArray, uOrder: int, numUPoints: int, uClosed: bool, vKnotVector: MSPyBentleyGeom.DoubleArray, vOrder: int, numVPoints: int, vClosed: bool, inputPolesAlreadyWeighted: bool) -> int:
        ...
    
    def ReleaseMem(self: MSPyBentleyGeom.MSBsplineSurface) -> None:
        """
        Free memory allocated for the poles, weights and knot vector of a
        B-spline surface.
        """
        ...
    
    def RemoveKnotsBounded(self: MSPyBentleyGeom.MSBsplineSurface, dir: int, tol: float) -> int:
        """
        Remove all removable knots with the tolerance constraint.
        """
        ...
    
    def Resolution(*args, **kwargs):
        """
        Overloaded function.
        
        1. Resolution(self: MSPyBentleyGeom.MSBsplineSurface) -> float
        
        Get the resolution of the B-spline surface.
        
        2. Resolution(self: MSPyBentleyGeom.MSBsplineSurface, abstol: float, reltol: float) -> float
        
        Get the resolution of the B-spline surface.
        """
        ...
    
    def SetNumRules(self: MSPyBentleyGeom.MSBsplineSurface, numU: int, numV: int) -> None:
        ...
    
    def SetOuterBoundaryActive(self: MSPyBentleyGeom.MSBsplineSurface, active: bool) -> None:
        """
        :param (input):
        active If true, the outer boundary is active as an (implicit) trim
        boundary, so the outermost explict boundary acts as a hole.
        """
        ...
    
    def SetPole(*args, **kwargs):
        """
        Overloaded function.
        
        1. SetPole(self: MSPyBentleyGeom.MSBsplineSurface, index: int, value: MSPyBentleyGeom.DPoint3d) -> bool
        
        set pole by index. returns false if index out of range.
        @DotNetMethodExclude
        
        2. SetPole(self: MSPyBentleyGeom.MSBsplineSurface, i: int, j: int, value: MSPyBentleyGeom.DPoint3d) -> bool
        
        set pole by index. returns false if index out of range.
        @DotNetMethodExclude
        
        3. SetPole(self: MSPyBentleyGeom.MSBsplineSurface, i: int, x: float, y: float, z: float) -> bool
        
        set pole by index. returns false if index out of range.
        @DotNetMethodExclude
        """
        ...
    
    def SetPolygonDisplay(self: MSPyBentleyGeom.MSBsplineSurface, display: bool) -> None:
        ...
    
    def SetReWeightedPole(*args, **kwargs):
        """
        Overloaded function.
        
        1. SetReWeightedPole(self: MSPyBentleyGeom.MSBsplineSurface, index: int, value: MSPyBentleyGeom.DPoint3d) -> bool
        
        set pole by index. returns false if index out of range. If the surface
        is weighted, the current weight is multiplied into the input pole.
        
        2. SetReWeightedPole(self: MSPyBentleyGeom.MSBsplineSurface, i: int, j: int, value: MSPyBentleyGeom.DPoint3d) -> bool
        
        set pole by index. returns false if index out of range. If the surface
        is weighted, the current weight is multiplied into the input pole.
        """
        ...
    
    def SetSurfaceDisplay(self: MSPyBentleyGeom.MSBsplineSurface, display: bool) -> None:
        ...
    
    def SetTrim(self: MSPyBentleyGeom.MSBsplineSurface, cruves: MSPyBentleyGeom.CurveVector) -> None:
        """
        Delete previous trim and add new trim.
        """
        ...
    
    def SetUKnots(self: MSPyBentleyGeom.MSBsplineSurface, index: int, value: float, n: int) -> bool:
        """
        set uKnotw by index. returns false if any index out of range.
        @DotNetMethodExclude
        """
        ...
    
    def SetUParamsWithUniformKnots(self: MSPyBentleyGeom.MSBsplineSurface, numPoles: int, order: int, closed: bool) -> bool:
        """
        Install counts and set up uniform knots in u direction.
        """
        ...
    
    def SetVKnots(self: MSPyBentleyGeom.MSBsplineSurface, index: int, value: float, n: int) -> bool:
        """
        set vKnotw by index. returns false if any index out of range.
        @DotNetMethodExclude
        """
        ...
    
    def SetVParamsWithUniformKnots(self: MSPyBentleyGeom.MSBsplineSurface, numPoles: int, order: int, closed: bool) -> bool:
        """
        Install counts and set up uniform knots in v direction.
        """
        ...
    
    def SetWeight(self: MSPyBentleyGeom.MSBsplineSurface, index: int, w: float) -> bool:
        """
        set weight by index. returns false if index out of range.
        @DotNetMethodExclude
        """
        ...
    
    def SetWeights(self: MSPyBentleyGeom.MSBsplineSurface, index: int, value: float, n: int) -> bool:
        """
        set weight by index. returns false if any index out of range.
        @DotNetMethodExclude
        """
        ...
    
    @property
    def SurfaceDisplay(arg0: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        ...
    @SurfaceDisplay.setter
    def SurfaceDisplay(arg0: MSPyBentleyGeom.MSBsplineSurface, arg1: bool) -> None:
        ...
    
    def SwapUV(self: MSPyBentleyGeom.MSBsplineSurface) -> int:
        """
        Swap the U/V direction of the surface.
        """
        ...
    
    def TransformPoles(self: MSPyBentleyGeom.MSBsplineSurface, transform: Transform, i0: int, j0: int, numI: int, numJ: int) -> None:
        """
        Transform a block of poles wtih start index i0,j0
        """
        ...
    
    def TransformSurface(self: MSPyBentleyGeom.MSBsplineSurface, transform: Transform) -> int:
        """
        Transform the B-spline surface.
        """
        ...
    
    def TryGetBoundaryUV(self: MSPyBentleyGeom.MSBsplineSurface, boundaryIndex: int, pointIndex: int, uv: MSPyBentleyGeom.DPoint2d) -> bool:
        ...
    
    def TryGetUnWeightedPole(*args, **kwargs):
        """
        Overloaded function.
        
        1. TryGetUnWeightedPole(self: MSPyBentleyGeom.MSBsplineSurface, i: int, i: int, xyz: MSPyBentleyGeom.DPoint3d) -> bool
        
        Try to dereference index i,j.
        
        2. TryGetUnWeightedPole(self: MSPyBentleyGeom.MSBsplineSurface, i: int, xyz: MSPyBentleyGeom.DPoint3d) -> bool
        
        Try to dereference index i,j.
        """
        ...
    
    @property
    def UOrder(arg0: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    
    def UnWeightPoles(self: MSPyBentleyGeom.MSBsplineSurface) -> None:
        """
        if the surface is rational, divide (wx,wy,wz) style poles by the
        weights
        """
        ...
    
    @property
    def VOrder(arg0: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    
    def WeightPoles(self: MSPyBentleyGeom.MSBsplineSurface) -> None:
        """
        if the surface is rational, multiply (wx,wy,wz) style poles by the
        weights
        """
        ...
    
    def Zero(self: MSPyBentleyGeom.MSBsplineSurface) -> None:
        """
        zero out the surface
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.MSBsplineSurface) -> None:
        ...
    
    @property
    def display(self: MSPyBentleyGeom.MSBsplineSurface) -> MSPyBentleyGeom.BsplineDisplay:
        ...
    @display.setter
    def display(self: MSPyBentleyGeom.MSBsplineSurface, arg0: MSPyBentleyGeom.BsplineDisplay) -> None:
        ...
    
    @property
    def holeOrigin(self: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    @holeOrigin.setter
    def holeOrigin(self: MSPyBentleyGeom.MSBsplineSurface, arg0: int) -> None:
        ...
    
    @property
    def numBounds(self: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    @numBounds.setter
    def numBounds(self: MSPyBentleyGeom.MSBsplineSurface, arg0: int) -> None:
        ...
    
    @property
    def poles(arg0: MSPyBentleyGeom.MSBsplineSurface) -> numpy.typing.NDArray:
        ...
    @poles.setter
    def poles(arg0: MSPyBentleyGeom.MSBsplineSurface, arg1: numpy.typing.NDArray) -> None:
        ...
    
    @property
    def rational(self: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    @rational.setter
    def rational(self: MSPyBentleyGeom.MSBsplineSurface, arg0: int) -> None:
        ...
    
    @property
    def type(self: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    @type.setter
    def type(self: MSPyBentleyGeom.MSBsplineSurface, arg0: int) -> None:
        ...
    
    @property
    def uKnots(arg0: MSPyBentleyGeom.MSBsplineSurface) -> numpy.typing.NDArray:
        ...
    @uKnots.setter
    def uKnots(arg0: MSPyBentleyGeom.MSBsplineSurface, arg1: numpy.typing.NDArray) -> None:
        ...
    
    @property
    def uParams(self: MSPyBentleyGeom.MSBsplineSurface) -> MSPyBentleyGeom.BsplineParam:
        ...
    @uParams.setter
    def uParams(self: MSPyBentleyGeom.MSBsplineSurface, arg0: MSPyBentleyGeom.BsplineParam) -> None:
        ...
    
    @property
    def vKnots(arg0: MSPyBentleyGeom.MSBsplineSurface) -> numpy.typing.NDArray:
        ...
    @vKnots.setter
    def vKnots(arg0: MSPyBentleyGeom.MSBsplineSurface, arg1: numpy.typing.NDArray) -> None:
        ...
    
    @property
    def vParams(self: MSPyBentleyGeom.MSBsplineSurface) -> MSPyBentleyGeom.BsplineParam:
        ...
    @vParams.setter
    def vParams(self: MSPyBentleyGeom.MSBsplineSurface, arg0: MSPyBentleyGeom.BsplineParam) -> None:
        ...
    
    @property
    def weights(arg0: MSPyBentleyGeom.MSBsplineSurface) -> numpy.typing.NDArray:
        ...
    @weights.setter
    def weights(arg0: MSPyBentleyGeom.MSBsplineSurface, arg1: numpy.typing.NDArray) -> None:
        ...
    
class MSBsplineSurfacePtrArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.MSBsplineSurfacePtrArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.MSBsplineSurfacePtrArray, arg0: MSPyBentleyGeom.MSBsplineSurfacePtrArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.MSBsplineSurfacePtrArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.MSBsplineSurfacePtrArray, x: MSPyBentleyGeom.RefCountedMSBsplineSurface) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.MSBsplineSurfacePtrArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def count(self: MSPyBentleyGeom.MSBsplineSurfacePtrArray, x: MSPyBentleyGeom.RefCountedMSBsplineSurface) -> int:
        """
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.MSBsplineSurfacePtrArray, L: MSPyBentleyGeom.MSBsplineSurfacePtrArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.MSBsplineSurfacePtrArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.MSBsplineSurfacePtrArray, i: int, x: MSPyBentleyGeom.RefCountedMSBsplineSurface) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.MSBsplineSurfacePtrArray) -> MSPyBentleyGeom.RefCountedMSBsplineSurface
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.MSBsplineSurfacePtrArray, i: int) -> MSPyBentleyGeom.RefCountedMSBsplineSurface
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(self: MSPyBentleyGeom.MSBsplineSurfacePtrArray, x: MSPyBentleyGeom.RefCountedMSBsplineSurface) -> None:
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class MSInterpolationCurve:
    """
    None
    """

    def AllocateFitPoints(self: MSPyBentleyGeom.MSInterpolationCurve, count: int, data: MSPyBentleyGeom.DPoint3d = None) -> int:
        """
        Allocate specified number of fit points. Optionally copy in points
        from buffer.
        """
        ...
    
    def AllocateKnots(self: MSPyBentleyGeom.MSInterpolationCurve, count: int, data: float = None) -> int:
        """
        Allocate specified number of knots. Optionally copy in knots from
        buffer.
        """
        ...
    
    def AlmostEqual(self: MSPyBentleyGeom.MSInterpolationCurve, other: MSPyBentleyGeom.MSInterpolationCurve, tolerance: float) -> bool:
        ...
    
    def CopyFrom(self: MSPyBentleyGeom.MSInterpolationCurve, source: MSPyBentleyGeom.MSInterpolationCurve) -> int:
        """
        Allocate memory for the B-spline curve and copies all data from the
        input inerpolation curve.
        """
        ...
    
    @staticmethod
    def Create() -> MSPyBentleyGeom.RefCountedMSInterpolationCurve:
        ...
    
    def GetOrder(self: MSPyBentleyGeom.MSInterpolationCurve) -> int:
        ...
    
    def InitFromPointsAndEndTangents(*args, **kwargs):
        """
        Overloaded function.
        
        1. InitFromPointsAndEndTangents(self: MSPyBentleyGeom.MSInterpolationCurve, inPoints: MSPyBentleyGeom.DPoint3dArray, removeData: bool, removeTol: float, endTangents: MSPyBentleyGeom.DPoint3d, closedCurve: bool, colinearTangents: bool, chordLenTangents: bool, naturalTangents: bool) -> int
        
        2. InitFromPointsAndEndTangents(self: MSPyBentleyGeom.MSInterpolationCurve, inPoints: list, removeData: bool, removeTol: float, endTangents: MSPyBentleyGeom.DPoint3d, closedCurve: bool, colinearTangents: bool, chordLenTangents: bool, naturalTangents: bool) -> int
        """
        ...
    
    @property
    def Order(arg0: MSPyBentleyGeom.MSInterpolationCurve) -> int:
        ...
    
    def Populate(*args, **kwargs):
        """
        Overloaded function.
        
        1. Populate(self: MSPyBentleyGeom.MSInterpolationCurve, order: int, periodic: bool, isChordLenKnots: int, isColinearTangents: int, isChordLenTangents: int, isNaturalTangents: int, fitPoints: MSPyBentleyGeom.DPoint3dArray, knots: MSPyBentleyGeom.DoubleArray, startTangent: MSPyBentleyGeom.DVec3d, endTangent: MSPyBentleyGeom.DVec3d) -> int
        
        2. Populate(self: MSPyBentleyGeom.MSInterpolationCurve, order: int, periodic: bool, isChordLenKnots: int, isColinearTangents: int, isChordLenTangents: int, isNaturalTangents: int, fitPoints: list, knots: MSPyBentleyGeom.DoubleArray, startTangent: MSPyBentleyGeom.DVec3d, endTangent: MSPyBentleyGeom.DVec3d) -> int
        
        3. Populate(self: MSPyBentleyGeom.MSInterpolationCurve, order: int, periodic: bool, isChordLenKnots: int, isColinearTangents: int, isChordLenTangents: int, isNaturalTangents: int, fitPoints: List[MSPyBentleyGeom.DPoint3d], knots: List[float]) -> int
        """
        ...
    
    def ReleaseMem(self: MSPyBentleyGeom.MSInterpolationCurve) -> None:
        """
        Free the memory allocated to the poles of the interpolation curve.
        """
        ...
    
    def Zero(self: MSPyBentleyGeom.MSInterpolationCurve) -> None:
        """
        Clear to zero state. DOES NOT RELEASE MEMORY.
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.MSInterpolationCurve) -> None:
        ...
    
class MeshAnnotation:
    """
    None
    """

    def Description(self: MSPyBentleyGeom.MeshAnnotation) -> str:
        ...
    
    @property
    def Fail(self: MSPyBentleyGeom.MeshAnnotation) -> int:
        ...
    @Fail.setter
    def Fail(self: MSPyBentleyGeom.MeshAnnotation, arg0: int) -> None:
        ...
    
    def IncrementFail(self: MSPyBentleyGeom.MeshAnnotation) -> None:
        ...
    
    def IncrementPass(self: MSPyBentleyGeom.MeshAnnotation) -> None:
        ...
    
    @property
    def Pass(self: MSPyBentleyGeom.MeshAnnotation) -> int:
        ...
    @Pass.setter
    def Pass(self: MSPyBentleyGeom.MeshAnnotation, arg0: int) -> None:
        ...
    
    def Record(*args, **kwargs):
        """
        Overloaded function.
        
        1. Record(self: MSPyBentleyGeom.MeshAnnotation, index: int, tag: int) -> None
        
        2. Record(self: MSPyBentleyGeom.MeshAnnotation, index: int, tag: MSPyBentleyGeom.DPoint3d) -> None
        
        3. Record(self: MSPyBentleyGeom.MeshAnnotation, index: int, tag: int) -> None
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.MeshAnnotation, arg0: str) -> None:
        """
        name
        """
        ...
    
class MeshAnnotationArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.MeshAnnotationArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.MeshAnnotationArray, arg0: MSPyBentleyGeom.MeshAnnotationArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.MeshAnnotationArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.MeshAnnotationArray, x: MSPyBentleyGeom.MeshAnnotation) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.MeshAnnotationArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.MeshAnnotationArray, L: MSPyBentleyGeom.MeshAnnotationArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.MeshAnnotationArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.MeshAnnotationArray, i: int, x: MSPyBentleyGeom.MeshAnnotation) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.MeshAnnotationArray) -> MSPyBentleyGeom.MeshAnnotation
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.MeshAnnotationArray, i: int) -> MSPyBentleyGeom.MeshAnnotation
        
        Remove and return the item at index ``i``
        """
        ...
    
class MeshAnnotationVector:
    """
    None
    """

    def GetTotalFail(self: MSPyBentleyGeom.MeshAnnotationVector) -> int:
        """
        Query the total number of tests failed.
        """
        ...
    
    def GetTotalPass(self: MSPyBentleyGeom.MeshAnnotationVector) -> int:
        """
        Query the total number of tests passed.
        """
        ...
    
    @property
    def TotalFail(arg0: MSPyBentleyGeom.MeshAnnotationVector) -> int:
        ...
    
    @property
    def TotalPass(arg0: MSPyBentleyGeom.MeshAnnotationVector) -> int:
        ...
    
    def __init__(self: MSPyBentleyGeom.MeshAnnotationVector, recordAllTestDescriptions: bool) -> None:
        ...
    
    def append(self: MSPyBentleyGeom.MeshAnnotationArray, x: MSPyBentleyGeom.MeshAnnotation) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.MeshAnnotationArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.MeshAnnotationArray, L: MSPyBentleyGeom.MeshAnnotationArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.MeshAnnotationArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.MeshAnnotationArray, i: int, x: MSPyBentleyGeom.MeshAnnotation) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.MeshAnnotationArray) -> MSPyBentleyGeom.MeshAnnotation
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.MeshAnnotationArray, i: int) -> MSPyBentleyGeom.MeshAnnotation
        
        Remove and return the item at index ``i``
        """
        ...
    
NO_EDGE: int

OFFSET_ARC_CUSP: int

OFFSET_CHAMFER_CUSP: int

OFFSET_JUMP_CUSP: int

OFFSET_PARABOLA_CUSP: int

OFFSET_POINT_CUSP: int

class OrderedIGeometryPtr:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.OrderedIGeometryPtr, target: MSPyBentleyGeom.ICurvePrimitive) -> None
        
        2. __init__(self: MSPyBentleyGeom.OrderedIGeometryPtr, target: MSPyBentleyGeom.CurveVector) -> None
        
        3. __init__(self: MSPyBentleyGeom.OrderedIGeometryPtr, target: ISolidPrimitive) -> None
        
        4. __init__(self: MSPyBentleyGeom.OrderedIGeometryPtr, target: RefCountedMSBsplineSurface) -> None
        
        5. __init__(self: MSPyBentleyGeom.OrderedIGeometryPtr, target: PolyfaceHeader) -> None
        """
        ...
    
PI: float

POSITION_CONTINUITY: int

class PartialCurveDetail:
    """
    None
    """

    def ChildFractionToParentFraction(self: MSPyBentleyGeom.PartialCurveDetail, f: float) -> float:
        """
        map a local fraction into the parent fraction.
        """
        ...
    
    def IsSingleFraction(self: MSPyBentleyGeom.PartialCurveDetail) -> bool:
        """
        Test if the partial curve fraction range is a single fraction.
        """
        ...
    
    def ParentFractionToChildFraction(self: MSPyBentleyGeom.PartialCurveDetail, parentFraction: float) -> tuple:
        """
        (attempt to) map a parent fraction back to the child interval. This
        fails if the child is a single point.
        """
        ...
    
    def UpdateFraction1AndUserData(self: MSPyBentleyGeom.PartialCurveDetail, f1: float, newData: int) -> None:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.PartialCurveDetail) -> None
        
        2. __init__(self: MSPyBentleyGeom.PartialCurveDetail, parentCurve: ICurvePrimitive, fraction0: float, fraction1: float, userData: int) -> None
        
        3. __init__(self: MSPyBentleyGeom.PartialCurveDetail, parentCurve: ICurvePrimitive, interval: DSegment1d, userData: int = 0) -> None
        
        4. __init__(self: MSPyBentleyGeom.PartialCurveDetail, parent: MSPyBentleyGeom.PartialCurveDetail, f0: float, f1: float) -> None
        """
        ...
    
    @property
    def fraction0(self: MSPyBentleyGeom.PartialCurveDetail) -> float:
        ...
    @fraction0.setter
    def fraction0(self: MSPyBentleyGeom.PartialCurveDetail, arg0: float) -> None:
        ...
    
    @property
    def fraction1(self: MSPyBentleyGeom.PartialCurveDetail) -> float:
        ...
    @fraction1.setter
    def fraction1(self: MSPyBentleyGeom.PartialCurveDetail, arg0: float) -> None:
        ...
    
    @property
    def parentCurve(self: MSPyBentleyGeom.PartialCurveDetail) -> ICurvePrimitive:
        ...
    @parentCurve.setter
    def parentCurve(self: MSPyBentleyGeom.PartialCurveDetail, arg0: ICurvePrimitive) -> None:
        ...
    
    @property
    def userData(self: MSPyBentleyGeom.PartialCurveDetail) -> int:
        ...
    @userData.setter
    def userData(self: MSPyBentleyGeom.PartialCurveDetail, arg0: int) -> None:
        ...
    
class PartialCurveDetailArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.PartialCurveDetailArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.PartialCurveDetailArray, arg0: MSPyBentleyGeom.PartialCurveDetailArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.PartialCurveDetailArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.PartialCurveDetailArray, x: MSPyBentleyGeom.PartialCurveDetail) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.PartialCurveDetailArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.PartialCurveDetailArray, L: MSPyBentleyGeom.PartialCurveDetailArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.PartialCurveDetailArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.PartialCurveDetailArray, i: int, x: MSPyBentleyGeom.PartialCurveDetail) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.PartialCurveDetailArray) -> MSPyBentleyGeom.PartialCurveDetail
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.PartialCurveDetailArray, i: int) -> MSPyBentleyGeom.PartialCurveDetail
        
        Remove and return the item at index ``i``
        """
        ...
    
class PathLocationDetail:
    """
    None
    """

    @property
    def CurveLocationDetail(arg0: MSPyBentleyGeom.PathLocationDetail) -> MSPyBentleyGeom.CurveLocationDetail:
        ...
    
    def DistanceFromPathStart(self: MSPyBentleyGeom.PathLocationDetail) -> float:
        """
        Query the stored distance to path start. Note that this is not a
        recompute -- just a member access.
        """
        ...
    
    def DistanceSquaredToPoint(self: MSPyBentleyGeom.PathLocationDetail, xyz: DPoint3d) -> float:
        """
        distance squared to given point.
        """
        ...
    
    def DistanceToPoint(*args, **kwargs):
        """
        Overloaded function.
        
        1. DistanceToPoint(self: MSPyBentleyGeom.PathLocationDetail, other: MSPyBentleyGeom.PathLocationDetail) -> float
        
        distance between points of this and other detail.
        
        2. DistanceToPoint(self: MSPyBentleyGeom.PathLocationDetail, xyz: DPoint3d) -> float
        
        distance between points of this and other detail.
        """
        ...
    
    def FractionToPositionLocationDetail(self: MSPyBentleyGeom.PathLocationDetail, f: float, evaluateDistance: bool = True) -> MSPyBentleyGeom.PathLocationDetail:
        ...
    
    def GetCurveLocationDetail(self: MSPyBentleyGeom.PathLocationDetail) -> MSPyBentleyGeom.CurveLocationDetail:
        """
        Query CurveLocationDetail with fractional position for queries
        """
        ...
    
    def GetPrimitiveIndex(self: MSPyBentleyGeom.PathLocationDetail) -> int:
        """
        Get the index of this detail's curve within its containing
        CurveVectorWithDistanceIndex
        """
        ...
    
    def HasCurve(self: MSPyBentleyGeom.PathLocationDetail) -> bool:
        """
        Test if there is a curve.
        """
        ...
    
    @staticmethod
    def IsLessThan_ByPathDistance(dataA: MSPyBentleyGeom.PathLocationDetail, dataB: MSPyBentleyGeom.PathLocationDetail) -> bool:
        """
        Comparison using only the stored distance.
        """
        ...
    
    def Point(self: MSPyBentleyGeom.PathLocationDetail) -> DPoint3d:
        """
        Query xyz coordinates
        """
        ...
    
    def PointAndUnitTangent(self: MSPyBentleyGeom.PathLocationDetail, unitTangent: DVec3d) -> DPoint3d:
        """
        Query xyz coordinates and normalized tangent vector. (This reevaluates
        the curve)
        """
        ...
    
    @property
    def PrimitiveIndex(arg0: MSPyBentleyGeom.PathLocationDetail) -> int:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.PathLocationDetail) -> None
        
        2. __init__(self: MSPyBentleyGeom.PathLocationDetail, other: MSPyBentleyGeom.PathLocationDetail) -> None
        
        3. __init__(self: MSPyBentleyGeom.PathLocationDetail, curveDetail: MSPyBentleyGeom.CurveLocationDetail, pathIndex: int = -1, distance: float = 1.7976931348623157e+308) -> None
        
        4. __init__(self: MSPyBentleyGeom.PathLocationDetail, curveDetail: MSPyBentleyGeom.CurveLocationDetail, pathIndex: int, distance: float = 1.7976931348623157e+308) -> None
        
        5. __init__(self: MSPyBentleyGeom.PathLocationDetail, distance: float) -> None
        """
        ...
    
class PlanePolygonSSICode:
    """
    Members:
    
    eUnknown
    
    eTransverse
    
    eCoincident
    """

    def __init__(self: MSPyBentleyGeom.PlanePolygonSSICode, value: int) -> None:
        ...
    
    eCoincident: PlanePolygonSSICode
    
    eTransverse: PlanePolygonSSICode
    
    eUnknown: PlanePolygonSSICode
    
    @property
    def name(self: handle) -> str:
        ...
    
    @property
    def value(arg0: MSPyBentleyGeom.PlanePolygonSSICode) -> int:
        ...
    
class Point2d:
    """
    None
    """

    @property
    def X(self: MSPyBentleyGeom.Point2d) -> int:
        ...
    @X.setter
    def X(self: MSPyBentleyGeom.Point2d, arg0: int) -> None:
        ...
    
    @property
    def Y(self: MSPyBentleyGeom.Point2d) -> int:
        ...
    @Y.setter
    def Y(self: MSPyBentleyGeom.Point2d, arg0: int) -> None:
        ...
    
    def __init__(self: MSPyBentleyGeom.Point2d) -> None:
        ...
    
    @property
    def x(self: MSPyBentleyGeom.Point2d) -> int:
        ...
    @x.setter
    def x(self: MSPyBentleyGeom.Point2d, arg0: int) -> None:
        ...
    
    @property
    def y(self: MSPyBentleyGeom.Point2d) -> int:
        ...
    @y.setter
    def y(self: MSPyBentleyGeom.Point2d, arg0: int) -> None:
        ...
    
class Point2dArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.Point2dArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.Point2dArray, arg0: MSPyBentleyGeom.Point2dArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.Point2dArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.Point2dArray, x: MSPyBentleyGeom.Point2d) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.Point2dArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.Point2dArray, L: MSPyBentleyGeom.Point2dArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.Point2dArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.Point2dArray, i: int, x: MSPyBentleyGeom.Point2d) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.Point2dArray) -> MSPyBentleyGeom.Point2d
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.Point2dArray, i: int) -> MSPyBentleyGeom.Point2d
        
        Remove and return the item at index ``i``
        """
        ...
    
class Point3d:
    """
    None
    """

    @property
    def X(self: MSPyBentleyGeom.Point3d) -> int:
        ...
    @X.setter
    def X(self: MSPyBentleyGeom.Point3d, arg0: int) -> None:
        ...
    
    @property
    def Y(self: MSPyBentleyGeom.Point3d) -> int:
        ...
    @Y.setter
    def Y(self: MSPyBentleyGeom.Point3d, arg0: int) -> None:
        ...
    
    @property
    def Z(self: MSPyBentleyGeom.Point3d) -> int:
        ...
    @Z.setter
    def Z(self: MSPyBentleyGeom.Point3d, arg0: int) -> None:
        ...
    
    def __init__(self: MSPyBentleyGeom.Point3d) -> None:
        ...
    
    @property
    def x(self: MSPyBentleyGeom.Point3d) -> int:
        ...
    @x.setter
    def x(self: MSPyBentleyGeom.Point3d, arg0: int) -> None:
        ...
    
    @property
    def y(self: MSPyBentleyGeom.Point3d) -> int:
        ...
    @y.setter
    def y(self: MSPyBentleyGeom.Point3d, arg0: int) -> None:
        ...
    
    @property
    def z(self: MSPyBentleyGeom.Point3d) -> int:
        ...
    @z.setter
    def z(self: MSPyBentleyGeom.Point3d, arg0: int) -> None:
        ...
    
class Point3dArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.Point3dArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.Point3dArray, arg0: MSPyBentleyGeom.Point3dArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.Point3dArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.Point3dArray, x: MSPyBentleyGeom.Point3d) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.Point3dArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.Point3dArray, L: MSPyBentleyGeom.Point3dArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.Point3dArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.Point3dArray, i: int, x: MSPyBentleyGeom.Point3d) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.Point3dArray) -> MSPyBentleyGeom.Point3d
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.Point3dArray, i: int) -> MSPyBentleyGeom.Point3d
        
        Remove and return the item at index ``i``
        """
        ...
    
class PolyfaceEdgeChain:
    """
    None
    """

    def AddIndex(self: MSPyBentleyGeom.PolyfaceEdgeChain, index: int) -> None:
        """
        add an index.
        """
        ...
    
    def AddZeroBasedIndices(self: MSPyBentleyGeom.PolyfaceEdgeChain, indices: MSPyBentleyGeom.UInt64Array) -> None:
        """
        add indices
        """
        ...
    
    def GetId(self: MSPyBentleyGeom.PolyfaceEdgeChain) -> MSPyBentleyGeom.CurveTopologyId:
        """
        query the CurveTopologyId
        """
        ...
    
    def GetIndex(self: MSPyBentleyGeom.PolyfaceEdgeChain, arg0: MSPyBentleyGeom.Int32Array) -> int:
        ...
    
    def GetIndexCount(self: MSPyBentleyGeom.PolyfaceEdgeChain) -> int:
        """
        Query the number of indices.
        """
        ...
    
    @property
    def Id(arg0: MSPyBentleyGeom.PolyfaceEdgeChain) -> MSPyBentleyGeom.CurveTopologyId:
        ...
    
    @property
    def IndexCount(arg0: MSPyBentleyGeom.PolyfaceEdgeChain) -> int:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.PolyfaceEdgeChain) -> None
        
        2. __init__(self: MSPyBentleyGeom.PolyfaceEdgeChain, id: MSPyBentleyGeom.CurveTopologyId) -> None
        
        3. __init__(self: MSPyBentleyGeom.PolyfaceEdgeChain, id: MSPyBentleyGeom.CurveTopologyId, index0: int, index1: int) -> None
        """
        ...
    
class PolyfaceEdgeChainArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.PolyfaceEdgeChainArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.PolyfaceEdgeChainArray, arg0: MSPyBentleyGeom.PolyfaceEdgeChainArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.PolyfaceEdgeChainArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.PolyfaceEdgeChainArray, x: MSPyBentleyGeom.PolyfaceEdgeChain) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.PolyfaceEdgeChainArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.PolyfaceEdgeChainArray, L: MSPyBentleyGeom.PolyfaceEdgeChainArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.PolyfaceEdgeChainArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.PolyfaceEdgeChainArray, i: int, x: MSPyBentleyGeom.PolyfaceEdgeChain) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.PolyfaceEdgeChainArray) -> MSPyBentleyGeom.PolyfaceEdgeChain
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.PolyfaceEdgeChainArray, i: int) -> MSPyBentleyGeom.PolyfaceEdgeChain
        
        Remove and return the item at index ``i``
        """
        ...
    
class PolyfaceHeader:
    """
    None
    """

    def ActivateVectorsForIndexing(self: MSPyBentleyGeom.PolyfaceHeader, source: MSPyBentleyGeom.PolyfaceQuery) -> None:
        """
        Set active flags so this polyface carries data and indices for all the
        data in source.
        """
        ...
    
    def ActivateVectorsForPolylineIndexing(self: MSPyBentleyGeom.PolyfaceHeader, source: MSPyBentleyGeom.PolyfaceQuery) -> None:
        """
        Set active flags so this polyface carries data and indices for
        polylines compatible with source.
        """
        ...
    
    def AddEdgeChains(self: MSPyBentleyGeom.PolyfaceHeader, drawMethodIndex: int) -> BentleyStatus:
        """
        Add Edge Chains
        """
        ...
    
    def AddIfMatchedLayout(self: MSPyBentleyGeom.PolyfaceHeader, source: MSPyBentleyGeom.PolyfaceQuery) -> bool:
        """
        Add all content of source to this polyface. This does NOT attempt to
        recognize duplicate coordinate data.
        
        :returns:
        false if mismatched data -- e.g. arrays present on one but not the
        other.
        """
        ...
    
    def AddIndexedFacet(self: MSPyBentleyGeom.PolyfaceHeader, pointIndices: MSPyBentleyGeom.Int32Array, normalIndices: MSPyBentleyGeom.Int32Array, paramIndices: MSPyBentleyGeom.Int32Array, colorIndices: MSPyBentleyGeom.Int32Array) -> bool:
        ...
    
    def AddPolygon(*args, **kwargs):
        """
        Overloaded function.
        
        1. AddPolygon(self: MSPyBentleyGeom.PolyfaceHeader, xyz: MSPyBentleyGeom.DPoint3dArray, normal: MSPyBentleyGeom.DVec3dArray = None, param: MSPyBentleyGeom.DPoint2dArray = None) -> bool
        
        2. AddPolygon(self: MSPyBentleyGeom.PolyfaceHeader, xyz: list, normal: MSPyBentleyGeom.DVec3dArray = None, param: MSPyBentleyGeom.DPoint2dArray = None) -> bool
        
        3. AddPolygon(self: MSPyBentleyGeom.PolyfaceHeader, xyz: MSPyBentleyGeom.DPoint3dArray, visitor: PolyfaceVisitor, mapping: MSPyBentleyGeom.IndexedParameterMap) -> bool
        
        4. AddPolygon(self: MSPyBentleyGeom.PolyfaceHeader, xyz: list, visitor: PolyfaceVisitor, mapping: MSPyBentleyGeom.IndexedParameterMap) -> bool
        
        5. AddPolygon(self: MSPyBentleyGeom.PolyfaceHeader, xyz: MSPyBentleyGeom.DPoint3dArray, worldToParameterSpace: MSPyBentleyGeom.Transform, normal: MSPyBentleyGeom.DVec3d, compressNormal: bool, reverseXYZ: bool) -> bool
        
        6. AddPolygon(self: MSPyBentleyGeom.PolyfaceHeader, xyz: list, worldToParameterSpace: MSPyBentleyGeom.Transform, normal: MSPyBentleyGeom.DVec3d, compressNormal: bool, reverseXYZ: bool) -> bool
        """
        ...
    
    def AddToTaggedPolygons(*args, **kwargs):
        """
        Overloaded function.
        
        1. AddToTaggedPolygons(self: MSPyBentleyGeom.PolyfaceQuery, polygons: List[TaggedPolygon], indexA: int, numWrap: int, selectRange: MSPyBentleyGeom.DRange3d = None) -> None
        
        2. AddToTaggedPolygons(self: MSPyBentleyGeom.PolyfaceQuery, polygons: List[TaggedPolygon], indexA: int, numWrap: int, filer: IPolyfaceVisitorFilter) -> None
        """
        ...
    
    def BuildApproximateNormals(self: MSPyBentleyGeom.PolyfaceHeader, maxSignelEdgeAngle: float = 0.2, maxAccumulatedAngle: float = 0.3, markAllTransitionsVisible: bool = True) -> bool:
        ...
    
    def BuildPerFaceFaceData(self: MSPyBentleyGeom.PolyfaceHeader) -> bool:
        """
        Compute face data for each facet.
        """
        ...
    
    def BuildPerFaceNormals(self: MSPyBentleyGeom.PolyfaceHeader) -> bool:
        """
        Compute a normal vector for each faceet. Install indices.
        """
        ...
    
    def BuildPerFaceParameters(self: MSPyBentleyGeom.PolyfaceHeader, selector: MSPyBentleyGeom.LocalCoordinateSelect) -> bool:
        """
        Compute local coordinates within each facet.
        
        :returns:
        true if parameters computed.
        """
        ...
    
    def ClearAllArrays(self: MSPyBentleyGeom.PolyfaceVectors) -> None:
        """
        clear all arrays (but flags stay unchanged)
        """
        ...
    
    def ClearAllIndexVectors(self: MSPyBentleyGeom.PolyfaceHeader) -> None:
        """
        Clear all index vectors.
        """
        ...
    
    def ClearAllVectors(self: MSPyBentleyGeom.PolyfaceHeader) -> None:
        """
        Clear all facets.
        """
        ...
    
    def ClearNormals(self: MSPyBentleyGeom.PolyfaceHeader, active: bool) -> None:
        """
        Clear current normal data.
        
        :param (input):
        active active state (true/false) to be applied after clearing.
        """
        ...
    
    def ClearParameters(self: MSPyBentleyGeom.PolyfaceHeader, active: bool) -> None:
        """
        Clear current param data.
        
        :param (input):
        active active state (true/false) to be applied after clearing.
        """
        ...
    
    def ClearTags(self: MSPyBentleyGeom.PolyfaceHeader, numPerFace: int, meshStyle: int) -> None:
        """
        Initial setup for tag data in blocked vectors. Points are active.
        Point indices are active if style is MESH_ELM_STYLE_INDEXED_FACE_LOOPS
        All other coordinate and index arrays are NOT active. TwoSided is
        true.
        """
        ...
    
    def ClipPolyfaceToClipPlanes(insideClip: PolyfaceHeader, outsideClip: PolyfaceHeader, targetMesh: MSPyBentleyGeom.PolyfaceQuery, clipPlanes: MSPyBentleyGeom.ClipPlaneSet, formNewFacesOnClipPlanes: bool) -> bool:
        ...
    
    def ClipToPlaneSetIntersection(self: MSPyBentleyGeom.PolyfaceQuery, planeSets: List[ClipPlaneSet], output: MSPyBentleyGeom.PolyfaceQuery.IClipToPlaneSetOutput, trangulateOutput: bool) -> int:
        """
        @description Clip polyface to intersection of an array of plane sets.
        """
        ...
    
    def Clone(self: MSPyBentleyGeom.PolyfaceQuery) -> PolyfaceHeader:
        """
        Return a PolyfaceHeader with the same contents.
        """
        ...
    
    def CloneAsVariableSizeIndexed(self: MSPyBentleyGeom.PolyfaceQuery) -> PolyfaceHeader:
        """
        Return a PolyfaceHeader, with variable length faces.
        """
        ...
    
    def CloneWithDegenerateFacetsRemoved(self: MSPyBentleyGeom.PolyfaceHeader) -> MSPyBentleyGeom.PolyfaceHeader:
        ...
    
    def CloneWithFacetsInRandomOrder(self: MSPyBentleyGeom.PolyfaceHeader) -> MSPyBentleyGeom.PolyfaceHeader:
        ...
    
    def CloneWithIndexedDuplicatesRemoved(self: MSPyBentleyGeom.PolyfaceHeader) -> MSPyBentleyGeom.PolyfaceHeader:
        """
        Search the mesh for facets that identical sets of point indices.
        Return a clone with only one copy of each.
        """
        ...
    
    def CloneWithMaximalPlanarFacets(self: MSPyBentleyGeom.PolyfaceHeader, mergeCoplanarFacets: bool, mergeColinearEdges: bool) -> MSPyBentleyGeom.PolyfaceHeader:
        """
        Search for adjacent, coplanar facets. Merge to get maximual planar
        facets. Optionally remove vertices that have only two incident and
        colinear edges. This uses an very tight (Angle.SmallAngle()) angle
        tolerance. Use CloneWithMaximalPlanarFacetsExt for looser tolerance.
        """
        ...
    
    def CloneWithMaximalPlanarFacetsExt(self: MSPyBentleyGeom.PolyfaceHeader, mergeCoplanarFacets: bool, mergeColinearEdges: bool, planarityToleranceRadians: float = 1e-08, maxPass: int = 1) -> MSPyBentleyGeom.PolyfaceHeader:
        ...
    
    @staticmethod
    def CloneWithSidePanelsInserted(meshes: MSPyBentleyGeom.PolyfaceHeaderPtrArray, viewDirection: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.PolyfaceHeader:
        """
        * Input an array of meshes expected to have boundary segments are
        separated by " missing side panels " as viewed in a certain direction.
        
        * return a (separate, new) mesh with the side panels added. Additional
        midEdge vertices are inserted into the original facets if T vertices
        are present.
        
        * CreateSidePanelsForViewDirection creaates the panels
        
        * CloneWithTVertexFixup does touchup for extra vertices.
        """
        ...
    
    @staticmethod
    def CloneWithTVertexFixup(meshes: MSPyBentleyGeom.PolyfaceHeaderPtrArray, options: MSPyBentleyGeom.IFacetOptions = None, onEdgeTolerance: float = 0.0) -> MSPyBentleyGeom.PolyfaceHeader:
        """
        Clone the meshes as a single mesh, inserting vertices along edges
        where vertices from other facets create T-Vertex topology
        """
        ...
    
    def CloneWithTranslatedFacets(self: MSPyBentleyGeom.PolyfaceHeader, activeReadIndex: MSPyBentleyGeom.UInt64Array, vector: MSPyBentleyGeom.DVec3d, mode: MSPyBentleyGeom.PolyfaceHeader.FacetTranslationMode) -> MSPyBentleyGeom.PolyfaceHeader:
        ...
    
    def ClusteredVertexDecimate(self: MSPyBentleyGeom.PolyfaceQuery, tolerance: float) -> PolyfaceHeader:
        """
        @description Fas clustered vertex decimator - used during tile
        generation.
        """
        ...
    
    def CollectAdjacentFacetAndPointIndices(self: MSPyBentleyGeom.PolyfaceHeader, activeReadIndex: MSPyBentleyGeom.UInt64Array, fringeReadIndex: MSPyBentleyGeom.UInt64Array, activePointIndex: MSPyBentleyGeom.UInt64Array) -> None:
        """
        Collect indices of (1) adjacent facets and (2) points within the
        active facets.
        """
        ...
    
    def CollectCounts(self: MSPyBentleyGeom.PolyfaceQuery) -> tuple:
        ...
    
    def CollectEdgeMateData(self: MSPyBentleyGeom.PolyfaceHeader, segments: List[FacetEdgeDetail], includeMatched: bool = False, returnSingleEdgeReadIndex: bool = False) -> None:
        """
        Create segments containing edges of this polyface. The returned array
        indicates
        
        * segment coordinates
        
        * a readIndex. Based on the returnSingleEdgeReadIndex value, his can
        be either the base readIndex for the whole facet, or the detail read
        index for the individual edge.
        
        * clusterIndex. Shared edges will return the same cluster index.
        
        * number of edges in the cluster. If collecting only unmatched edges,
        this normally be 1, but can be
        
        :param (output):
        segments array of segment data.
        
        :param (input):
        includeMatched true to include interior segemnts that have mates.
        
        :param (input):
        returnSingleEdgeReadIndex if true, return read index to the base
        of the individual edge. If false, return readIndex for the entire
        facet. (The entire facet index is prefered for calling
        visitor->MoveToReadIndex ())
        """
        ...
    
    def CollectPerFaceCounts(self: MSPyBentleyGeom.PolyfaceQuery) -> tuple:
        ...
    
    def CollectSegments(self: MSPyBentleyGeom.PolyfaceQuery, segments: MSPyBentleyGeom.DSegment3dArray, omitInvisible: bool) -> None:
        """
        Collect individual segments for each distinct edge.
        
        :param (output):
        segments array to receive segments.
        
        :param (input):
        omitInvisibles true to hide segments that are not visible (due to
        negated indices)
        """
        ...
    
    @property
    def ColorCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    def ColorIndex(self: MSPyBentleyGeom.PolyfaceHeader) -> MSPyBentleyGeom.BlockedVectorInt:
        """
        Return a reference to the color index vector. Completion of color
        dereference depends on additional data in DoubleColor, IntColor, or
        ColorTable
        """
        ...
    
    def ColorTable(self: MSPyBentleyGeom.PolyfaceHeader) -> MSPyBentleyGeom.BlockedVectorUInt32:
        """
        Return a reference to the array of color table as integer table
        select.
        """
        ...
    
    def CompactArrays(self: MSPyBentleyGeom.PolyfaceHeader, arg0: bool) -> int:
        """
        Trim excess capacity from the data and index vectors. No data is removed.
        
        :returns:
        bytes trimmed
        
        :param (input):
        call CompactIndexArrays first
        """
        ...
    
    def CompactIndexArrays(self: MSPyBentleyGeom.PolyfaceHeader) -> bool:
        """
        Revise index structure to minimize array lengths.
        
        :returns:
        true if any changes were made.
        """
        ...
    
    def Compress(*args, **kwargs):
        """
        Overloaded function.
        
        1. Compress(self: MSPyBentleyGeom.PolyfaceHeader) -> None
        
        Compress duplicate coordinate data, with default realtive tolerances.
        
        2. Compress(self: MSPyBentleyGeom.PolyfaceHeader, pointAbsTol: float, normalAbsTol: float = -1.0, paramAbsTol: float = -1.0, relTol: float = -1.0) -> None
        
        Compress duplicate coordinate data, with default realtive tolerances.
        """
        ...
    
    def ComputeOffset(self: MSPyBentleyGeom.PolyfaceHeader, options: MSPyBentleyGeom.PolyfaceHeader.OffsetOptions, distance1: float, distance2: float, outputOffset1: bool = True, outputOffset2: bool = True, outputSideFacets: bool = True) -> MSPyBentleyGeom.PolyfaceHeader:
        ...
    
    def ComputeOverAndUnderXY(polyfaceA: PolyfaceHeader, filterA: IPolyfaceVisitorFilter, polyfaceB: PolyfaceHeader, filterB: IPolyfaceVisitorFilter, polyfaceAOverB: PolyfaceHeader, polyfaceBUnderA: PolyfaceHeader, computeAndApplyTransform: bool = True) -> None:
        ...
    
    def ComputePrincipalAreaMoments(self: MSPyBentleyGeom.PolyfaceQuery, centroid: MSPyBentleyGeom.DPoint3d, axes: MSPyBentleyGeom.RotMatrix, momentxyz: MSPyBentleyGeom.DVec3d) -> tuple:
        ...
    
    def ComputePrincipalMoments(self: MSPyBentleyGeom.PolyfaceQuery, centroid: MSPyBentleyGeom.DPoint3d, axes: MSPyBentleyGeom.RotMatrix, momentxyz: MSPyBentleyGeom.DVec3d, forcePositiveVolume: bool = False) -> tuple:
        ...
    
    def ComputePrincipalMomentsAllowMissingSideFacets(self: MSPyBentleyGeom.PolyfaceQuery, centroid: MSPyBentleyGeom.DPoint3d, axes: MSPyBentleyGeom.RotMatrix, momentxyz: MSPyBentleyGeom.DVec3d, forcePositiveVolume: bool, relativeTolerance: float = 1e-08) -> tuple:
        ...
    
    def ComputePunch(punch: MSPyBentleyGeom.PolyfaceQuery, target: MSPyBentleyGeom.PolyfaceQuery, keepInside: bool, result: List[PolyfaceHeader]) -> None:
        """
        @description " Punch " through target polygons.
        
        :param (input):
        punch punch polygons
        
        :param (input):
        target target polygons
        
        :param (input):
        keepInside true to return the target mesh parts that are inside
        the punch, false to return outside parts.
        
        :param (output):
        result punched mesh
        """
        ...
    
    def ComputePunchXYByPlaneSets(punch: MSPyBentleyGeom.PolyfaceQuery, target: MSPyBentleyGeom.PolyfaceQuery, inside: PolyfaceHeader, outside: PolyfaceHeader, debugMesh: PolyfaceHeader = None) -> None:
        """
        (input) each facet of this is used as a " punch " (input) facets to be split
        by the punch. (output) (target intersect punch) (output) (target outsideOf
        punch) (output) optional meshes for debugging
        """
        ...
    
    @staticmethod
    def ComputeSingleSheetCutFill(dtmMesh: MSPyBentleyGeom.PolyfaceHeader, roadMesh: MSPyBentleyGeom.PolyfaceHeader, viewVector: MSPyBentleyGeom.DVec3d, option: MSPyBentleyGeom.PolyfaceHeader.ComputeSingleSheetOption) -> tuple:
        ...
    
    class ComputeSingleSheetOption:
        """
        Members:
        
        eBoth
        
        eCutMeshOnly
        
        eFillMeshOnly
        """
    
        def __init__(self: MSPyBentleyGeom.PolyfaceHeader.ComputeSingleSheetOption, value: int) -> None:
            ...
        
        eBoth: ComputeSingleSheetOption
        
        eCutMeshOnly: ComputeSingleSheetOption
        
        eFillMeshOnly: ComputeSingleSheetOption
        
        @property
        def name(self: handle) -> str:
            ...
        
        @property
        def value(arg0: MSPyBentleyGeom.PolyfaceHeader.ComputeSingleSheetOption) -> int:
            ...
        
    def ComputeUndercut(polyfaceA: PolyfaceHeader, filterA: IPolyfaceVisitorFilter, polyfaceB: PolyfaceHeader, filterB: IPolyfaceVisitorFilter, undercutPolyface: PolyfaceHeader) -> None:
        """
        @description Compute volumes where polyfaceB undercuts polyfaceA
        """
        ...
    
    def ConstructOrderingForLongEdgeRemoval(self: MSPyBentleyGeom.PolyfaceHeader, readIndexSequence: MSPyBentleyGeom.UInt64Array, maxEdgeLength: float = 0.0) -> bool:
        """
        Determine a facet order such that the LAST facets are the first to be
        removed when applying the logic " Remove the longest exterior edge first " ul> li> If this is applied to facets of a triangulation (whose
        outer boundary is convex), the successive outer boundaries are
        polygons that contain short edges and have inlets where there are long
        edges on the outside. The readIndexSequence contains sequences of
        readIndices for the shuffled facets. li> Suppose a facet
        
        * initially has vertices, params, normals, and colors indicated at
        (consecutive) readIndices [a b c]
        
        * the edges from b to c is chosen for removal
        
        li> li>That facet will appear as [b c a SIZE_MAX]. ul
        """
        ...
    
    def ConvertTableColorToColorIndices(self: MSPyBentleyGeom.PolyfaceHeader, faceToTableColor: MSPyBentleyGeom.BlockedVectorInt, vertexToTableColor: MSPyBentleyGeom.BlockedVectorInt) -> bool:
        """
        Build color indices as face loops (as needed) Return false if no
        conversion or if point index tables asked for more table indices than
        present in the TableColor arrays.
        """
        ...
    
    def ConvertToVariableSizeSignedOneBasedIndexedFaceLoops(self: MSPyBentleyGeom.PolyfaceHeader) -> bool:
        """
        Convert the mesh indexing to signed, one-based, variable size face
        loops.
        """
        ...
    
    def CopyAllActiveFlagsFrom(self: MSPyBentleyGeom.PolyfaceVectors, source: MSPyBentleyGeom.PolyfaceVectors) -> None:
        """
        Copy active flags from the various arrays of the source.
        """
        ...
    
    def CopyAllActiveFlagsFromQuery(self: MSPyBentleyGeom.PolyfaceVectors, source: MSPyBentleyGeom.PolyfaceQuery) -> None:
        """
        In PolyfaceQuery, determine active status from pointers. This is only
        valid if the PolyfaceQuery has already been filled !!!
        """
        ...
    
    def CopyFrom(self: MSPyBentleyGeom.PolyfaceHeader, source: MSPyBentleyGeom.PolyfaceQuery) -> None:
        """
        Clear current data, append data from (readonly) source
        """
        ...
    
    def CopyPartitions(*args, **kwargs):
        """
        Overloaded function.
        
        1. CopyPartitions(self: MSPyBentleyGeom.PolyfaceHeader, blockedReadIndex: MSPyBentleyGeom.Int64Array, submeshArray: MSPyBentleyGeom.PolyfaceHeaderPtrArray) -> bool
        
        2. CopyPartitions(self: MSPyBentleyGeom.PolyfaceHeader, blockedReadIndex: MSPyBentleyGeom.Int64VecArray, submeshArray: MSPyBentleyGeom.PolyfaceHeaderPtrArray) -> bool
        """
        ...
    
    def CopyTo(self: MSPyBentleyGeom.PolyfaceHeader, dest: MSPyBentleyGeom.PolyfaceHeader) -> None:
        """
        Copy all data to another header.
        """
        ...
    
    def CountSharedEdges(self: MSPyBentleyGeom.PolyfaceQuery, ignoreSliverFaces: bool) -> tuple:
        ...
    
    @staticmethod
    def CreateDRange3dFaces(range: MSPyBentleyGeom.DRange3d, triangulate: bool = False, placement: MSPyBentleyGeom.Transform = None) -> MSPyBentleyGeom.PolyfaceHeader:
        """
        * Create a mesh with the faces of a DRange3d, optionally transformed and triangulated
        If the transform has negative determinant, indices are shuffled to get outward normals.
        
        :returns:
        a mesh with the faces of a DRange3d.
        
        :param (input):
        points to triangulate
        
        :param (input):
        if true, add a (hidden) diagonal in each face.
        
        :param (input):
        optional transform to apply.
        """
        ...
    
    @staticmethod
    def CreateFixedBlockCoordinates(numPerFaces: int) -> MSPyBentleyGeom.PolyfaceHeader:
        """
        Create a (smart pointer to a) new (empty) PolyfaceHeader, with each
        facet defined by 3 or 4 unindexed points as indicated by the arg.
        
        :returns:
        invalid if numPerFace is other than 3 or 4.
        """
        ...
    
    @staticmethod
    def CreateFixedBlockIndexed(numPerBlock: int) -> MSPyBentleyGeom.PolyfaceHeader:
        """
        Create a (smart pointer to a) new (empty) PolyfaceHeader, with fixed
        number of indices per face
        
        :returns:
        invalid if numPerBlock is less than 3.
        """
        ...
    
    @staticmethod
    def CreateFromTaggedPolygons(polygons: List[TaggedPolygon]) -> MSPyBentleyGeom.PolyfaceHeader:
        """
        Create a (indexed) polyface containing all polygons from a
        TaggedPolygonVector
        """
        ...
    
    @staticmethod
    def CreateIndexedMesh(numPerFace: int, points: MSPyBentleyGeom.DPoint3dArray, indexData: MSPyBentleyGeom.Int32Array) -> MSPyBentleyGeom.PolyfaceHeader:
        """
        Create a mesh with (just) point and index data.
        """
        ...
    
    @staticmethod
    def CreateQuadGrid(numPerRow: int) -> MSPyBentleyGeom.PolyfaceHeader:
        """
        Create a (smart pointer to a) new (empty) PolyfaceHeader, with
        quadrilaterals defined by points in a grid.
        
        :returns:
        invalid if numPerRow<2.
        """
        ...
    
    @staticmethod
    def CreateRegularPolyhedron(radius: float, polyhedronSelect: int, radiusSelect: int, transform: MSPyBentleyGeom.Transform = None) -> MSPyBentleyGeom.PolyfaceHeader:
        """
        Create a classic polyhedron, i.e. one of
        
        * 0 = Tetrahedron
        
        * 1 = Cube
        
        * 2 = Octahedron
        
        * 3 = Dodecahedron
        
        * 4 = Icosahedron
        
        The polyhedron is " in a sphere ", with measurement indicated by
        
        * 0 = measure radius to vertices
        
        * 1 = radius to midedge, orient with x axis to mid-edge (see 101)
        
        * 2 = radius to midface
        
        * 100 = radius to vertex, but orient cube and octahedron with square
        cross section in xy plane.
        
        * 101 = radius to midedge, but orient cube and octahedron with square
        cross section in xy plane.
        
        * 102 = radius to midface, but orient cube and octahedron with square
        cross section in xy plane.
        
        The orientation is as follows:
        
        * For selection 100, 101 and 102 for cube and octahedron, a square
        cross section is parallel to the xy plane.
        
        * For all other cases (0,1,2 for all polyhedra, and 101,101,102 for
        other than cube and octahedron)
        
        * A vertex, mid-edge, or centroid point (respective to the
        measurement) is on the positive x axis
        
        * Another edge of an incident face is in the y direction.
        
        * Hence when viewed from positive x towards center, there will be a
        horizontal edge
        
        * on a face with a vertex on the x axis.
        
        :param (input):
        radius radius of sphere
        
        :param (input):
        polyhedronSelect integer selector, as enumerated above.
        
        :param (input):
        radiusSelect control of sphere radius, as enumerated above.
        
        :param (input):
        transform optional transform to place the sphere.
        """
        ...
    
    @staticmethod
    def CreateRegularPolyhedronWithSubtriangulation(radius: float, polyhedronSelect: int, numExtraVerticesInBaseEdges: int, transform: MSPyBentleyGeom.Transform) -> MSPyBentleyGeom.PolyfaceHeader:
        ...
    
    @staticmethod
    def CreateSidePanelsForViewDirection(meshes: MSPyBentleyGeom.PolyfaceHeaderPtrArray, viewDirection: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.PolyfaceHeader:
        """
        Input an array of meshes expected to have boundary segments are
        separated by " missing side panels " as viewed in a certain direction.
        return a (separate, new) mesh with only the side panels.
        """
        ...
    
    @staticmethod
    def CreateTriangleGrid(numPerRow: int) -> MSPyBentleyGeom.PolyfaceHeader:
        """
        Create a (smart pointer to a) new (empty) PolyfaceHeader, with
        quadrilaterals defined by points in a grid, and then each quad is
        split to triangle.
        
        :returns:
        invalid if numPerRow<2.
        """
        ...
    
    @staticmethod
    def CreateUnifiedIndexMesh(source: MSPyBentleyGeom.PolyfaceQuery) -> MSPyBentleyGeom.PolyfaceHeader:
        """
        Copy all data to a new mesh, reorganizing so that all data arrays have
        the same index structure. This is a memory-efficient structure ONLY
        for smooth surfaces such as bspline, cylinder, sphere. This is a
        highly inefficent structure for any mesh with interior edges.
        Unfortunately it is a common mesh structure in exchange formats.
        """
        ...
    
    @staticmethod
    def CreateVariableSizeIndexed() -> MSPyBentleyGeom.PolyfaceHeader:
        """
        Create a (smart pointer to a) new (empty) PolyfaceHeader, with
        variable length faces. This is the most common mesh style.
        """
        ...
    
    @staticmethod
    def CreateVerticalPanelsBetweenSegments(segments: List[FacetEdgeDetail]) -> MSPyBentleyGeom.PolyfaceHeader:
        ...
    
    @staticmethod
    def CreateXYTriangulation(points: MSPyBentleyGeom.DPoint3dArray, fringeExpansionFactor: float = 0.1, retainFringeTriangles: bool = False) -> MSPyBentleyGeom.PolyfaceHeader:
        """
        Create a triangulation of points as viewed in xy. Add the triangles to
        the polyface. (Other than sharing vertices with matched xy, this does
        not coordinate in any way with prior mesh contents.)
        
        :param (input):
        points candidate points
        
        :param (input):
        fringeExpansionFactor fractional factor (usually 0.10 to 0.20) for
        defining a surrounding rectangle. The z of this triangle is at the
        low z of all the points.
        
        :param (input):
        retainFringeTriangles true to keep the fringe triangles. If false,
        any edge that reaches the outer rectangle is deleted.
        """
        ...
    
    def DirectionalAreaAndVolume(self: MSPyBentleyGeom.PolyfaceQuery, origin: MSPyBentleyGeom.DPoint3d, areaXYZ: MSPyBentleyGeom.DVec3d, volumeXYZ: MSPyBentleyGeom.DVec3d, centroidX: MSPyBentleyGeom.DVec3d, centroidY: MSPyBentleyGeom.DVec3d, centroidZ: MSPyBentleyGeom.DVec3d) -> None:
        """
        Compute areas, centroids, volumes of projections onto principal
        planes.
        """
        ...
    
    def DirectionalVolumeIntegrals(self: MSPyBentleyGeom.PolyfaceQuery, polyface: MSPyBentleyGeom.PolyfaceQuery, pData: MSPyBentleyGeom.DirectionalVolumeData, directionalProducts: MSPyBentleyGeom.DMatrix4d, origin: MSPyBentleyGeom.DPoint3d) -> None:
        """
        @description Compute (many) integrals of volume properties, using
        directional formulas that will give correct results (and confidence
        indicators) when " some " facets are missing
        
        :param (input):
        polyface facets for integration
        
        :param (output):
        pData array (allocated by caller) of various integrals:
        
        * pData[0], pData[1], pData[2] = view along respective axes. Use
        signed area, so result should be zero if all facets are present to
        cancel.
        
        * pData[0], pData[1], pData[2] = view along respective axes. Use
        absolute area, so result should be useful for setting tolerances.
        
        * pData[6] = full 3d area.
        
        :param (output):
        directionalProducts array of products integrals wrt origin.
        Allocated by caller.
        
        :param (output):
        origin origin used for directonal integrals. (Directional
        integrals are " from the principal " planes through this origin.)
        """
        ...
    
    def DoubleColor(self: MSPyBentleyGeom.PolyfaceHeader) -> MSPyBentleyGeom.BlockedVectorRgbFactor:
        """
        Return a reference to the vector of color-via-RgbFactor structs.
        """
        ...
    
    def DrapeLinestring(self: MSPyBentleyGeom.PolyfaceQuery, spacePoints: MSPyBentleyGeom.DPoint3dArray, direction: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.CurveVector:
        """
        Project linestring in given direction to intersection with facets.
        Return as a curve vector.
        
        :param (input):
        spacePoints points to project onto the polyface
        
        :param (input):
        direction direction to project.
        """
        ...
    
    def EdgeChain(self: MSPyBentleyGeom.PolyfaceHeader) -> MSPyBentleyGeom.BlockedVectorPolyfaceEdgeChain:
        """
        Return a reference to the edge chain index vector.
        """
        ...
    
    @property
    def EdgeChainCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    def EnsureFloatColor(self: MSPyBentleyGeom.PolyfaceQuery) -> bool:
        """
        If float colors are not already present, build them from double
        colors. Returns false if the implementing class is read only.
        """
        ...
    
    def ExcavateFacetsWithLongBoundaryEdges(self: MSPyBentleyGeom.PolyfaceHeader, maxEdgeLength: float = 0.0) -> bool:
        """
        * Find facets with boundary edges longer than maxEdgeLength.
        
        * Remove the facets.
        
        * Continue searching for long edges in the newly exposed facets.
        
        * If the initial facets are an xy triangulation of points (with the
        convex hull outer boundary), the first removals creates a non-convex
        outer boundary. Later removals can create islands of facets.
        """
        ...
    
    def ExtractBoundaryStrings(self: MSPyBentleyGeom.PolyfaceHeader) -> tuple:
        ...
    
    def ExtractTopologicalBoundaryStrings(self: MSPyBentleyGeom.PolyfaceHeader) -> tuple:
        ...
    
    @property
    def FaceCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    def FaceData(self: MSPyBentleyGeom.PolyfaceHeader) -> MSPyBentleyGeom.BlockedVectorFacetFaceData:
        """
        Return a reference to the face information.
        """
        ...
    
    def FaceIndex(self: MSPyBentleyGeom.PolyfaceHeader) -> MSPyBentleyGeom.BlockedVectorInt:
        """
        Return a reference to the face index vector.
        """
        ...
    
    @property
    def FaceIndexCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    class FacetTranslationMode:
        """
        Members:
        
        eJustTranslatePoints
        
        eTranslatePointsAndAddSweepFaces
        
        eTranslatePointsAndTriangulateFringeFaces
        """
    
        def __init__(self: MSPyBentleyGeom.PolyfaceHeader.FacetTranslationMode, value: int) -> None:
            ...
        
        eJustTranslatePoints: FacetTranslationMode
        
        eTranslatePointsAndAddSweepFaces: FacetTranslationMode
        
        eTranslatePointsAndTriangulateFringeFaces: FacetTranslationMode
        
        @property
        def name(self: handle) -> str:
            ...
        
        @property
        def value(arg0: MSPyBentleyGeom.PolyfaceHeader.FacetTranslationMode) -> int:
            ...
        
    def FindOrAddColorTable(self: MSPyBentleyGeom.PolyfaceVectors, tableIndex: int) -> int:
        """
        Find or add a color table. * Activate if needed. * This is a linear
        search !
        """
        ...
    
    def FixupVertexNormalDirectionToFaceOrientation(self: MSPyBentleyGeom.PolyfaceHeader, summary: MSPyBentleyGeom.MeshAnnotationVector, makeChanges: bool) -> bool:
        """
        Inspect and correct the direction of " at vertex " normals relative to
        the ordering of vertices around facets. Returns true if any changes
        were made. The summary vector will contain entries indicating:ul>
        li>Early exit if fails assertion " Mesh should ( but does not ) have both NormalIndex and Normal ( ) data " li>Quiet warning, not a change
        trigger:" Ignoring facet whose facet normal cannot be computed from vertex coordinates " li>Quiet warning, not a change trigger:" Ignoring out of range normal index " li>Quiet warning of change trigger:" vertex normal has both positive and negative incident facets A new negated normal is introduced " li>Quiet warning of change trigger:" All incident facets normals are reverse of vertex normal - - normal is negated " li>Quiet warning, not a change trigger:" unused normal coordinates " li> ul
        """
        ...
    
    def FloatColor(self: MSPyBentleyGeom.PolyfaceHeader) -> MSPyBentleyGeom.BlockedVectorFloatRgb:
        """
        Return a reference to the array of float rgb colors.
        """
        ...
    
    def GetColorCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Return the number of colors.
        """
        ...
    
    def GetColorIndexAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int, resolveToDefaults: bool = False) -> tuple:
        ...
    
    def GetColorTableAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple:
        ...
    
    def GetDoubleColorAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple:
        ...
    
    def GetEdgeChainAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple:
        ...
    
    def GetEdgeChainCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Return the number of edge chains.
        """
        ...
    
    def GetFaceCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Return the number of faces. Note that this is not a " facet " count --
        many facets can reference the same containing face in the parent
        geometry.
        """
        ...
    
    def GetFaceDataAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple:
        ...
    
    def GetFaceIndexAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int, resolveToDefaults: bool = False) -> tuple:
        ...
    
    def GetFaceIndexCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Return the number of face data indices
        """
        ...
    
    def GetFloatColorAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple:
        ...
    
    def GetIlluminationName(self: MSPyBentleyGeom.PolyfaceQuery) -> str:
        ...
    
    def GetIntColorAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple:
        ...
    
    def GetMediumTolerance(self: MSPyBentleyGeom.PolyfaceQuery) -> float:
        """
        Return a tolerance appropriate for medium accuracy calculations (8
        digits relative)
        """
        ...
    
    def GetMeshStyle(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Query the mesh style (MESH_ELM_STYLE_INDEXED_FACE_LOOPS etc)
        """
        ...
    
    def GetNormalAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple:
        ...
    
    def GetNormalCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Return the number of normals.
        """
        ...
    
    def GetNormalIndexAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int, resolveToDefaults: bool = False) -> tuple:
        ...
    
    def GetNumFacet(self: MSPyBentleyGeom.PolyfaceQuery) -> tuple:
        ...
    
    def GetNumPerFace(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Query the nominal number of facets per face. If this is 0 or 1, facets
        are variable size and separated by 0 as terminator. If larger the
        indices are blocked (with 0 as pad if needed)
        """
        ...
    
    def GetNumPerRow(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Query the row size for gridded mesh (quad or triangular)
        """
        ...
    
    def GetParamAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple:
        ...
    
    def GetParamCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Return the number of parameters.
        """
        ...
    
    def GetParamIndexAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int, resolveToDefaults: bool = False) -> tuple:
        ...
    
    def GetPointAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple:
        ...
    
    def GetPointCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Return the number of points.
        """
        ...
    
    def GetPointIndexAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple:
        ...
    
    def GetPointIndexCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Return the number of point indices.
        """
        ...
    
    def GetTextureId(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Return a pointer to contiguous texture id.
        """
        ...
    
    def GetTightTolerance(self: MSPyBentleyGeom.PolyfaceQuery) -> float:
        """
        Return a tolerance appropriate for high accuracy calculations (12 or
        more digits relative)
        """
        ...
    
    def GetTwoSided(self: MSPyBentleyGeom.PolyfaceQuery) -> bool:
        """
        Query if facets are considered two sided. (If not, outward normal can
        be used to cull backfaces)
        """
        ...
    
    def HasConvexFacets(self: MSPyBentleyGeom.PolyfaceQuery) -> bool:
        """
        Check convexity
        """
        ...
    
    def HasFacets(self: MSPyBentleyGeom.PolyfaceQuery) -> bool:
        """
        Test if any facets are defined (Specifically, true if the point index
        set is nonempty).
        """
        ...
    
    def HasIndexErrors(*args, **kwargs):
        """
        Overloaded function.
        
        1. HasIndexErrors(self: MSPyBentleyGeom.PolyfaceQuery, descripton: MSPyBentleyGeom.MeshAnnotationVector) -> bool
        
        Apply various checks for indexing structure.
        
        :returns:
        true if any errors were found.
        
        2. HasIndexErrors(self: MSPyBentleyGeom.PolyfaceQuery) -> bool
        
        Apply various checks for indexing structure.
        
        :returns:
        true if any errors were found.
        """
        ...
    
    def HealVerticalPanels(polyface: MSPyBentleyGeom.PolyfaceQuery, tryVerticalPanels: bool, trySpaceTriangulation: bool, healedPolyface: PolyfaceHeader) -> int:
        """
        Attempt to heal vertical gaps in a mesh.
        
        :param (input):
        polyface original polyface
        
        :param (input):
        tryVerticalPanels true to seek pure vertical panels
        
        :param (input):
        trySpaceTriangulation true to seek triangulation of any missing
        faces, as viewed from any direction found useful.
        
        :param (output):
        healedPolyface modified polyface. This is NOT constructed if no
        panels can be added.
        
        :returns:
        number of facets added
        """
        ...
    
    class IClipToPlaneSetOutput:
        """
        None
        """
    
        def __init__(*args, **kwargs):
            """
            Initialize self.  See help(type(self)) for accurate signature.
            """
            ...
        
    def IdentifyDuplicates(self: MSPyBentleyGeom.PolyfaceHeader, nonduplicatedFacetReadIndex: MSPyBentleyGeom.Int64Array, duplicatedFacetFirstReadIndex: MSPyBentleyGeom.Int64Array, duplicatedFacetAdditionalReadIndex: MSPyBentleyGeom.Int64Array, baseIndexForAdditionalReadIndex: MSPyBentleyGeom.Int64Array) -> None:
        ...
    
    def IlluminationName(self: MSPyBentleyGeom.PolyfaceHeader) -> MSPyBentley.WString:
        """
        Return a reference to the illumination name string.
        """
        ...
    
    def InspectFaces(self: MSPyBentleyGeom.PolyfaceQuery) -> tuple:
        ...
    
    def IntColor(self: MSPyBentleyGeom.PolyfaceHeader) -> MSPyBentleyGeom.BlockedVectorUInt32:
        """
        Return a reference to the array of color as integers.
        """
        ...
    
    def IsClosedByEdgePairing(self: MSPyBentleyGeom.PolyfaceQuery) -> bool:
        """
        Test if vertex indices around faces indicate watertight closure.
        """
        ...
    
    def IsPlanarWithinSuperfacets(self: MSPyBentleyGeom.PolyfaceHeader, tolerance: float = -1.0) -> bool:
        """
        Determines if each visible facet (a super facet) is planar within
        tolerance.
        
        :param (input):
        tolerance. If a negative number is provided, the tolerance used is
        a small fraction of the diagonal range.
        
        :returns:
        true iff each super facet is planar within tolerance.
        """
        ...
    
    def IsSameStructureAndGeometry(self: MSPyBentleyGeom.PolyfaceQuery, other: MSPyBentleyGeom.PolyfaceQuery, tolerance: float) -> bool:
        """
        Test for AlmostEqual () conditions.
        """
        ...
    
    def IsTriangulated(self: MSPyBentleyGeom.PolyfaceQuery) -> bool:
        """
        Test if all facets are 3 sided
        """
        ...
    
    def IsVariableSizeIndexed(self: MSPyBentleyGeom.PolyfaceQuery) -> bool:
        """
        Test if this mesh is vaiable sized indexed.
        """
        ...
    
    def LargestCoordinate(self: MSPyBentleyGeom.PolyfaceQuery) -> float:
        """
        Query largest absolute coordinate
        """
        ...
    
    def LocalDecimation(self: MSPyBentleyGeom.PolyfaceHeader, abstol: float, rangeFractionTol: float) -> int:
        """
        :returns:
        number of collapses.
        """
        ...
    
    def MarkAllEdgesVisible(self: MSPyBentleyGeom.PolyfaceHeader) -> None:
        """
        Mark all edges visible.
        """
        ...
    
    def MarkDiagonalEdgesInvisible(self: MSPyBentleyGeom.PolyfaceHeader, smoothAngle: float, edgeLengthFactor: float = 1.001, maxEdgesInFacetForDiagonalRules: int = 3) -> bool:
        """
        mark edges invisible by smoothAngle and silhoutte conditions, and
        additionally requrie them to be " diagonals ". The conditions for a
        diagonal are 1) longer than each other edge of the facet by at least
        edgeLengthFactor 2) at most maxEdgesInFacet This is specifically
        intended for civil road meshes which have slightly twisted quads that
        must be triangulated for calculations. If triangulated, both the
        transverse edges and diagonals would get hidden by usual dihedral
        angle rules. This hides the diagonals but leaves the simple transverse
        edges visible.
        """
        ...
    
    def MarkInvisibleEdges(*args, **kwargs):
        """
        Overloaded function.
        
        1. MarkInvisibleEdges(self: MSPyBentleyGeom.PolyfaceHeader, smoothAngle: float, silhouetteVector: MSPyBentleyGeom.DVec3d) -> bool
        
        Mark edges invisible (negative index) if dihedral angle between
        normals is small. If normals are present they are used. If not
        present, per-face normals are computed and used (but then removed)
        
        2. MarkInvisibleEdges(self: MSPyBentleyGeom.PolyfaceHeader, smoothAngle: float) -> bool
        
        Mark edges invisible (negative index) if dihedral angle between
        normals is small. If normals are present they are used. If not
        present, per-face normals are computed and used (but then removed)
        """
        ...
    
    def MarkTopologicalBoundariesVisible(self: MSPyBentleyGeom.PolyfaceHeader, preserveOtherVisibility: bool) -> bool:
        """
        Expose topological boundaries
        
        :returns:
        true if any edges were changed.
        """
        ...
    
    @property
    def MediumTolerance(arg0: MSPyBentleyGeom.PolyfaceQuery) -> float:
        ...
    
    def MergeAndCollectVolumes(*args, **kwargs):
        """
        Overloaded function.
        
        1. MergeAndCollectVolumes(meshA: MSPyBentleyGeom.PolyfaceQuery, meshB: MSPyBentleyGeom.PolyfaceQuery, enclosedVolumes: List[PolyfaceHeader]) -> None
        
        2. MergeAndCollectVolumes(inputMesh: List[PolyfaceHeader], enclosedVolumes: List[PolyfaceHeader]) -> None
        """
        ...
    
    @property
    def MeshStyle(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    def Normal(self: MSPyBentleyGeom.PolyfaceHeader) -> MSPyBentleyGeom.BlockedVectorDVec3d:
        """
        Return a reference to the normal vector.
        """
        ...
    
    @property
    def NormalCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    def NormalIndex(self: MSPyBentleyGeom.PolyfaceHeader) -> MSPyBentleyGeom.BlockedVectorInt:
        """
        Return a reference to the normal index vector.
        """
        ...
    
    @property
    def NumPerFace(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    @property
    def NumPerRow(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    class OffsetOptions:
        """
        None
        """
    
        def __init__(self: MSPyBentleyGeom.PolyfaceHeader.OffsetOptions) -> None:
            ...
        
        @property
        def maxAccumulatedAngle(self: MSPyBentleyGeom.PolyfaceHeader.OffsetOptions) -> MSPyBentleyGeom.Angle:
            ...
        @maxAccumulatedAngle.setter
        def maxAccumulatedAngle(self: MSPyBentleyGeom.PolyfaceHeader.OffsetOptions, arg0: MSPyBentleyGeom.Angle) -> None:
            ...
        
        @property
        def maxChamferAngle(self: MSPyBentleyGeom.PolyfaceHeader.OffsetOptions) -> MSPyBentleyGeom.Angle:
            ...
        @maxChamferAngle.setter
        def maxChamferAngle(self: MSPyBentleyGeom.PolyfaceHeader.OffsetOptions, arg0: MSPyBentleyGeom.Angle) -> None:
            ...
        
        @property
        def maxSingleEdgeAngle(self: MSPyBentleyGeom.PolyfaceHeader.OffsetOptions) -> MSPyBentleyGeom.Angle:
            ...
        @maxSingleEdgeAngle.setter
        def maxSingleEdgeAngle(self: MSPyBentleyGeom.PolyfaceHeader.OffsetOptions, arg0: MSPyBentleyGeom.Angle) -> None:
            ...
        
        @property
        def useStoredNormals(self: MSPyBentleyGeom.PolyfaceHeader.OffsetOptions) -> bool:
            ...
        @useStoredNormals.setter
        def useStoredNormals(self: MSPyBentleyGeom.PolyfaceHeader.OffsetOptions, arg0: bool) -> None:
            ...
        
    def OrientAndCollectManifoldComponents(self: MSPyBentleyGeom.PolyfaceHeader, componentReadIncices: MSPyBentleyGeom.UInt64VecArray, messages: MSPyBentleyGeom.MeshAnnotationVector) -> bool:
        """
        (output) arrays of read indices within components (output) array of status
        messages
        """
        ...
    
    def Param(self: MSPyBentleyGeom.PolyfaceHeader) -> MSPyBentleyGeom.BlockedVectorDPoint2d:
        """
        Return a reference to the param (texture space) coordinate vector.
        """
        ...
    
    @property
    def ParamCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    def ParamIndex(self: MSPyBentleyGeom.PolyfaceHeader) -> MSPyBentleyGeom.BlockedVectorInt:
        """
        Return a reference to the param index vector.
        """
        ...
    
    def ParamRange(self: MSPyBentleyGeom.PolyfaceQuery) -> MSPyBentleyGeom.DRange2d:
        """
        Return range of the parameters.
        """
        ...
    
    def PartitionByConnectivity(*args, **kwargs):
        """
        Overloaded function.
        
        1. PartitionByConnectivity(self: MSPyBentleyGeom.PolyfaceHeader, connectivityType: int, submeshArray: MSPyBentleyGeom.PolyfaceHeaderPtrArray) -> bool
        
        2. PartitionByConnectivity(self: MSPyBentleyGeom.PolyfaceHeader, connectivityType: int, submeshArray: MSPyBentleyGeom.Int64Array) -> bool
        """
        ...
    
    def PartitionByXYRange(*args, **kwargs):
        """
        Overloaded function.
        
        1. PartitionByXYRange(self: MSPyBentleyGeom.PolyfaceHeader, targetFaceCount: int, targetMeshCount: int, submeshArray: MSPyBentleyGeom.PolyfaceHeaderPtrArray) -> bool
        
        2. PartitionByXYRange(self: MSPyBentleyGeom.PolyfaceHeader, targetFaceCount: int, targetMeshCount: int, blockedReadIndexArray: MSPyBentleyGeom.Int64Array) -> bool
        """
        ...
    
    def PartitionMaintainFaceOrder(*args, **kwargs):
        """
        Overloaded function.
        
        1. PartitionMaintainFaceOrder(self: MSPyBentleyGeom.PolyfaceHeader, targetFaceCount: int, targetMeshCount: int, submeshArray: MSPyBentleyGeom.PolyfaceHeaderPtrArray) -> bool
        
        2. PartitionMaintainFaceOrder(self: MSPyBentleyGeom.PolyfaceHeader, targetFaceCount: int, targetMeshCount: int, blockedReadIndexArray: MSPyBentleyGeom.Int64Array) -> bool
        """
        ...
    
    def PartitionReadIndicesByNormal(self: MSPyBentleyGeom.PolyfaceHeader, vector: MSPyBentleyGeom.DVec3d, readIndices: MSPyBentleyGeom.Int64VecArray) -> bool:
        """
        Return indices of subsets with consistent forward and reverse
        visibility for given vector.
        
        :param (input):
        vector viewing direction vector
        
        :param (output):
        readIndices read indices for forward, reverse, and perpendicular
        facets
        
        :returns:
        false if vector is 000.
        """
        ...
    
    def PickFacetsByStroke(self: MSPyBentleyGeom.PolyfaceQuery, eyePoint: MSPyBentleyGeom.DPoint4d, point0: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d, pickDetail: MSPyBentleyGeom.FacetLocationDetailArray, exitAfterFirstPick: bool) -> bool:
        """
        Search for facets that are touched by a stroke. returns true if valid
        point data and one or more facets selected.
        """
        ...
    
    def PlaneSlice(*args, **kwargs):
        """
        Overloaded function.
        
        1. PlaneSlice(self: MSPyBentleyGeom.PolyfaceQuery, sectionPlane: MSPyBentleyGeom.DPlane3d, formRegions: bool, markEdgeFraction: bool = False) -> MSPyBentleyGeom.CurveVector
        
        Cut with a plane. (Prototype) Return as a curve vector. Optionally
        structure as area-bounding loops.
        
        :param (input):
        sectionPlane plane to cut the mesh.
        
        :param (input):
        formRegions true to look for closed loops and structure the return
        as a loop or parity CurveVector.
        
        :param (input):
        markEdgeFractions true to attache FacetEdgeLocationDetailVector to
        the linestrings.
        
        :param (input): skipOnPlaneFacets whether output lacks facets coplanar with sectionPlane.
        
        2. PlaneSlice(self: MSPyBentleyGeom.PolyfaceQuery, sectionPlane: MSPyBentleyGeom.DPlane3d, formRegions: bool, markEdgeFractions: bool, skipOnPlaneFacets: bool) -> MSPyBentleyGeom.CurveVector
        
        Cut with a plane. (Prototype) Return as a curve vector. Optionally
        structure as area-bounding loops.
        
        :param (input):
        sectionPlane plane to cut the mesh.
        
        :param (input):
        formRegions true to look for closed loops and structure the return
        as a loop or parity CurveVector.
        
        :param (input):
        markEdgeFractions true to attache FacetEdgeLocationDetailVector to
        the linestrings.
        
        :param (input): skipOnPlaneFacets whether output lacks facets coplanar with sectionPlane.
        """
        ...
    
    def Point(self: MSPyBentleyGeom.PolyfaceHeader) -> MSPyBentleyGeom.BlockedVectorDPoint3d:
        """
        Copy all contents to destination vectors Return a reference to the
        point (vertex) coordinate vector.
        """
        ...
    
    @property
    def PointCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    def PointIndex(self: MSPyBentleyGeom.PolyfaceHeader) -> MSPyBentleyGeom.BlockedVectorInt:
        """
        Return a reference to the point (vertex) index vector.
        """
        ...
    
    @property
    def PointIndexCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    def PointRange(self: MSPyBentleyGeom.PolyfaceQuery) -> MSPyBentleyGeom.DRange3d:
        """
        Return range of the points.
        """
        ...
    
    def RemoveTwoEdgeFacesFromVariableSizeOneBasedMesh(self: MSPyBentleyGeom.PolyfaceHeader) -> None:
        """
        Find and remove faces with 2 or fewer edges. This operates only on
        VariableSizeOneBasedMeshes -- caller responsible for converting to
        that if needed.
        """
        ...
    
    def ReplicateMissingIndexArrays(self: MSPyBentleyGeom.PolyfaceHeader) -> None:
        """
        If (1) param, normal, or color indices are missing and (2) their
        respective data arrays have size match with points, fill up the index
        array as duplicate of the pointIndex
        """
        ...
    
    def ReverseIndicesAllFaces(*args, **kwargs):
        """
        ReverseIndicesAllFaces(self: MSPyBentleyGeom.PolyfaceQuery, negateNormals: bool = True, flipMarked: bool = True, flipUnMarked: bool = True, normalIndexAction: MSPyBentleyGeom.BlockedVectorInt.IndexAction = <IndexAction.eNone: 0>) -> bool
        """
        ...
    
    def ReverseIndicesOneFace(*args, **kwargs):
        """
        ReverseIndicesOneFace(self: MSPyBentleyGeom.PolyfaceQuery, iFirst: int, iLast: int, normalArrayIndexAction: MSPyBentleyGeom.BlockedVectorInt.IndexAction = <IndexAction.eNone: 0>) -> None
        
        Reverse a single face loop in parallel index arrays.
        
        Remark:
        s A face loop is reversed after the 1st index:the 2nd/last
        indices are swapped, the 3rd/penultimate indices are swapped, etc.
        
        :param (input):
        iFirst 0-based offset to the first index in the face loop
        
        :param (input):
        iLast 0-based offset to the last index of the face loop.
        
        :param (input):
        normalArrayIndexAction selects action in normal array. This can be
        
        * IndexAction::None -- leave the index value unchanged
        
        * IndexAction::ForcePositive -- change to positive
        
        * IndexAction::ForceNegative -- change to negative
        
        * IndexAction::Negate -- change to negative of its current sign
        """
        ...
    
    def ReverseNormals(self: MSPyBentleyGeom.PolyfaceHeader) -> None:
        """
        Reverse (negate) all stored normals. Note that this does NOT change
        index order.
        """
        ...
    
    def SearchClosestApproach(*args, **kwargs):
        """
        Overloaded function.
        
        1. SearchClosestApproach(polyfaceA: MSPyBentleyGeom.PolyfaceQuery, polyfaceB: MSPyBentleyGeom.PolyfaceQuery, maxDistance: float, segment: MSPyBentleyGeom.DSegment3d) -> bool
        
        2. SearchClosestApproach(polyfaceA: MSPyBentleyGeom.PolyfaceQuery, maxDistance: float, segment: MSPyBentleyGeom.DSegment3d, normalTestRadius: float) -> bool
        
        3. SearchClosestApproach(polyfaceA: MSPyBentleyGeom.PolyfaceQuery, maxDistance: float, segment: MSPyBentleyGeom.DSegment3d) -> bool
        """
        ...
    
    def SearchClosestApproachToLinestring(polyfaceA: MSPyBentleyGeom.PolyfaceQuery, points: MSPyBentleyGeom.DPoint3dArray, segment: MSPyBentleyGeom.DSegment3d) -> bool:
        ...
    
    @staticmethod
    def SelectBlockedIndices(blockedReadIndex: MSPyBentleyGeom.Int64Array, selectedReadIndex: MSPyBentleyGeom.Int64Array, keepIfSelected: bool, blockedReadIndexOut: MSPyBentleyGeom.Int64Array) -> None:
        """
        Copy selected blocks of read indices to a new blocked index array.
        
        :param (input):
        blockedReadIndex Array of read indices with -1 as terminator
        between blocks that are to go to the same destination mesh.
        
        :param (input):
        selectedReadIndex Array of read indices for choosing blocks.
        
        :param (input):
        keepIfSelected indicates what to do with a block when it contains
        an index that is in the selectedReadIndexArray.
        
        * true means when a block contains a selected read index it is copied.
        
        * false means when a block contains a selected read indexc it is
        ignored.
        
        :param (output):
        blockedReadIndexOut array containing only the accepted blocks
        """
        ...
    
    def SelectMeshesByVolumeSign(inputVolumes: List[PolyfaceHeader], negativeVolumeMeshes: List[PolyfaceHeader], zeroVolumeMeshes: List[PolyfaceHeader], positiveVolumeMeshes: List[PolyfaceHeader]) -> None:
        ...
    
    def SetActiveFlagsByAvailableData(self: MSPyBentleyGeom.PolyfaceHeader) -> None:
        """
        Make each active flag true/false according to available data. Point,
        Normal, Param, DoubleColor, FloatColor, IntColor, and ColorTable,
        FaceIndex, FaceData look only at their own data. Indices look at their
        own size and that of respective indexed arrays.
        """
        ...
    
    def SetIlluminationName(self: MSPyBentleyGeom.PolyfaceHeader, name: str) -> None:
        """
        Set the illumination name string
        """
        ...
    
    def SetMeshStyle(self: MSPyBentleyGeom.PolyfaceVectors, meshStyle: int) -> None:
        """
        Set the facet data style.
        """
        ...
    
    def SetNewFaceData(self: MSPyBentleyGeom.PolyfaceHeader, faceData: MSPyBentleyGeom.FacetFaceData, endIndex: int = 0) -> None:
        """
        Set face data for all facets added since last call to SetNewFaceData.
        (endIndex = 0 for all facets).
        """
        ...
    
    def SetNumPerFace(self: MSPyBentleyGeom.PolyfaceVectors, numPerFace: int) -> None:
        """
        Set the index blocking count
        """
        ...
    
    def SetNumPerRow(self: MSPyBentleyGeom.PolyfaceVectors, numPerRow: int) -> None:
        """
        Set the row count for gridded facets.
        """
        ...
    
    def SetTextureId(self: MSPyBentleyGeom.PolyfaceHeader, id: int) -> None:
        """
        Set the texture id.
        """
        ...
    
    def SetTwoSided(self: MSPyBentleyGeom.PolyfaceVectors, twoSided: bool) -> None:
        """
        Set the flag for twosided facets
        """
        ...
    
    def SplitByFlood(self: MSPyBentleyGeom.PolyfaceHeader, optionsA: FacetSplitByFloodOptions, optionsB: FacetSplitByFloodOptions, blockedReadIndexArray: MSPyBentleyGeom.Int64VecArray) -> None:
        """
        Return blocks of read indices for " islands " of facets surrounded by
        " channels " The search process is:
        
        * choose any start facet.
        
        * expand outward from that facet to neighbors.
        
        * repeat the expansion to the level indicated by
        optionsA.m_layerThickness
        
        * treat all facets there as an " A " group.
        
        * expand outward from the fringe of the island by
        optionsB.m_layerThickness layers.
        
        * treat all facets in this (wide front) expansion there as a " B "
        group.
        
        * Seed the next round of " A " facets by a single facet beyond the
        fringe of the recent " B " step.
        
        Note that because the " optionsA " step starts with a single seed (plus
        its expanding layers) it produces compact " islands ". Becasue
        " optionsB " step starts with a wide front of facets it produces larger
        layered regions. The " A " and " B " groups are returned under control of
        the m_outputSelect part of its options.
        
        * m_outputSelect == 0:leave that group out completely.
        
        * m_outputSelect == 1:collect all groups as a single partition.
        
        * m_outputSelect == 2:collect each group as a small isolated
        partition.
        
        * BUT -- if both are zero, both are switched to 1.
        
        :param (output):
        blockedReadIndexArray read indices for individual faces, separated
        by (-1).
        """
        ...
    
    def SplitByMaxEdgeLength(self: MSPyBentleyGeom.PolyfaceHeader, splitLength: float, splits: MSPyBentleyGeom.PolyfaceHeaderPtrArray) -> bool:
        """
        * Find the maximum edge length of each facet.
        
        * Split into two sets of facets with that criteria.
        
        * Note that removal can happen anywhere in the mesh.
        
        * use ExcavateFacetsWithBoundaryEdges to remove only edges reachable
        by crossing long edges from a long starting edge on the boundary.
        """
        ...
    
    def SumDirectedAreas(self: MSPyBentleyGeom.PolyfaceQuery, vectorToEye: MSPyBentleyGeom.DVec3d) -> tuple:
        ...
    
    def SumDirectedAreasDetailed(self: MSPyBentleyGeom.PolyfaceQuery, vectorToEye: MSPyBentleyGeom.DVec3d) -> tuple:
        ...
    
    def SumFacetAreas(self: MSPyBentleyGeom.PolyfaceQuery) -> float:
        """
        Return the sum of facet areas. There is no check for planarity.
        """
        ...
    
    def SumFacetFirstAreaMoments(self: MSPyBentleyGeom.PolyfaceQuery, origin: MSPyBentleyGeom.DPoint3d, moments1: MSPyBentleyGeom.DVec3d) -> float:
        """
        Return the sum of facet areas. Return moment with respect to origin.
        """
        ...
    
    def SumFacetSecondAreaMomentProducts(self: MSPyBentleyGeom.PolyfaceQuery, origin: MSPyBentleyGeom.DPoint3d, products: MSPyBentleyGeom.DMatrix4d) -> float:
        """
        Return the sum of facet areas. Return moment products with respect to
        origin.
        """
        ...
    
    def SumTetrahedralFirstMoments(self: MSPyBentleyGeom.PolyfaceQuery, origin: MSPyBentleyGeom.DPoint3d, moments: MSPyBentleyGeom.DVec3d) -> float:
        """
        Return the sum of tetrahedral moments from the specified origin. If
        the mesh is closed and all facets are simply connected planar, this is
        the moment around the origin. (The facets and volume are not require
        to be convex.)
        
        :param (input):
        origin origin for tetrahedra.
        
        :param (output):
        moments sum of (x,y,z) dV
        
        :returns:
        summed volume
        """
        ...
    
    def SumTetrahedralMomentProducts(self: MSPyBentleyGeom.PolyfaceQuery, worldToLocal: MSPyBentleyGeom.Transform, moment1: MSPyBentleyGeom.DVec3d, products: MSPyBentleyGeom.RotMatrix) -> float:
        ...
    
    def SumTetrahedralVolumes(self: MSPyBentleyGeom.PolyfaceQuery, origin: MSPyBentleyGeom.DPoint3d) -> float:
        """
        Return the sum of tetrahedral volumes from the specified origin. If
        the mesh is closed and all facets are simply connected planar, this is
        the signed enclosed volume. (The facets and volume are not require to
        be convex.)
        """
        ...
    
    def SweepLinestringToMesh(self: MSPyBentleyGeom.PolyfaceQuery, xyzOut: MSPyBentleyGeom.DPoint3dArray, linestringIndexOut: MSPyBentleyGeom.Int32Array, meshIndexOut: MSPyBentleyGeom.Int32Array, linestringPoints: MSPyBentleyGeom.DPoint3dArray, sweepDirection: MSPyBentleyGeom.DVec3d) -> None:
        """
        @description Compute intersections (line strings) of this mesh with a
        swept linestring
        
        :param (output):
        xyzOut array of points on the intersection linestrings.
        DISCONNECTS separate multiple linestrings.
        
        :param (output):
        linestringIndexOut for each xyzOut[i], the index of the input
        segment that it came from.
        
        :param (output):
        meshIndexOut for each xyzOut[i], the mesh read index it came from.
        
        :param (input):
        linestringPoints points to sweep.
        
        :param (input):
        sweepDirection sweep direction
        """
        ...
    
    def SweepToSolid(self: MSPyBentleyGeom.PolyfaceHeader, sweepVector: MSPyBentleyGeom.DVec3d, triangulateSides: bool) -> bool:
        """
        Sweep the existing mesh promote to a solid
        
        :returns:
        false if the input mesh has inconsistent visibility -- i.e. side
        or mixture of forward and back facing facets.
        """
        ...
    
    def TerminateAllActiveIndexVectors(self: MSPyBentleyGeom.PolyfaceHeader) -> None:
        """
        Add terminator to all active index vectors.
        """
        ...
    
    @property
    def TextureId(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    @property
    def TightTolerance(arg0: MSPyBentleyGeom.PolyfaceQuery) -> float:
        ...
    
    def Transform(self: MSPyBentleyGeom.PolyfaceHeader, transform: MSPyBentleyGeom.Transform, reverseIndicesIfMirrored: bool = True) -> None:
        ...
    
    def TranslateSelectedFacets(self: MSPyBentleyGeom.PolyfaceHeader, activeReadIndex: MSPyBentleyGeom.UInt64Array, vector: MSPyBentleyGeom.DVec3d, mode: MSPyBentleyGeom.PolyfaceHeader.FacetTranslationMode) -> None:
        """
        Apply a translation to a subset of facets.
        """
        ...
    
    def Triangulate(*args, **kwargs):
        """
        Overloaded function.
        
        1. Triangulate(self: MSPyBentleyGeom.PolyfaceHeader) -> BentleyStatus
        
        Triangulate faces. return SUCCESS if all faces triangulated.
        
        Remark:
        this should return bool.
        
        2. Triangulate(self: MSPyBentleyGeom.PolyfaceHeader, maxEdge: int) -> bool
        
        Triangulate faces. return SUCCESS if all faces triangulated.
        
        Remark:
        this should return bool.
        
        3. Triangulate(self: MSPyBentleyGeom.PolyfaceHeader, maxEdge: int, hideNewEdges: bool, filter: IPolyfaceVisitorFilter) -> bool
        
        Triangulate faces. return SUCCESS if all faces triangulated.
        
        Remark:
        this should return bool.
        """
        ...
    
    def TryEvaluateEdge(self: MSPyBentleyGeom.PolyfaceQuery, position: MSPyBentleyGeom.FacetEdgeLocationDetail, xyz: MSPyBentleyGeom.DPoint3d) -> bool:
        """
        Try to convert the index and edge fraction of a
        FacetEdgeLocationDetail to a point.
        """
        ...
    
    def TryGetFacetFaceDataAtReadIndex(self: MSPyBentleyGeom.PolyfaceQuery, readIndex: int, data: MSPyBentleyGeom.FacetFaceData) -> tuple:
        ...
    
    def TryGetMaxSingleFacetLocalXYLength(self: MSPyBentleyGeom.PolyfaceHeader, xySize: MSPyBentleyGeom.DVec2d) -> bool:
        """
        Compute the lengths of the longest horizontal and vertical direction
        size of any single facet, using the local coordinate system along the
        first edge of the facet for directions.
        
        :param (output):
        xySize sizes in u, v directions.
        """
        ...
    
    def TryGetMaxSingleFacetParamLength(self: MSPyBentleyGeom.PolyfaceHeader, uvLength: MSPyBentleyGeom.DVec2d) -> bool:
        """
        Compute the lengths of the longest u and v direction size of any
        single facet, looking only at the stored param.
        
        :param (output):
        uvLength sizes in u, v directions.
        
        :returns:
        false if the facets do not have params
        """
        ...
    
    def TryGetNormalAtReadIndex(self: MSPyBentleyGeom.PolyfaceQuery, readIndex: int, data: MSPyBentleyGeom.DVec3d) -> bool:
        """
        Try to access normal coordinates through a readIndex in the
        normalIndex array.
        """
        ...
    
    def TryGetParamAtReadIndex(self: MSPyBentleyGeom.PolyfaceQuery, readIndex: int, data: MSPyBentleyGeom.DPoint2d) -> bool:
        """
        Try to access param coordinates through a readIndex in the paramIndex
        array.
        """
        ...
    
    def TryGetPointAtReadIndex(self: MSPyBentleyGeom.PolyfaceQuery, readIndex: int, data: MSPyBentleyGeom.DPoint3d) -> bool:
        """
        Try to access point coordinates through a readIndex in the pointIndex
        array.
        """
        ...
    
    @property
    def TwoSided(arg0: MSPyBentleyGeom.PolyfaceQuery) -> bool:
        ...
    
    def ValidatedVolume(self: MSPyBentleyGeom.PolyfaceQuery) -> MSPyBentleyGeom.ValidatedDouble:
        """
        Test if the mesh passes IsClosedByEdgePairing, and compute volume if
        so.
        """
        ...
    
    @staticmethod
    def VisibleParts(source: MSPyBentleyGeom.PolyfaceHeaderPtrArray, vectorToEye: MSPyBentleyGeom.DVec3d, dest: MSPyBentleyGeom.PolyfaceHeader, localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform) -> None:
        """
        Create a polyface containing all visible parts for a flat view of
        among multiple meshes.
        """
        ...
    
    @staticmethod
    def VolumeFromBoreData(segments: MSPyBentleyGeom.DSegment3dArray, topFacetReadIndex: MSPyBentleyGeom.Int64Array, bottomFacetReadIndex: MSPyBentleyGeom.Int64Array, sideFacetReadIndex: MSPyBentleyGeom.Int64Array) -> tuple:
        ...
    
    def __init__(*args, **kwargs):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    
    eBoth: ComputeSingleSheetOption
    
    eCutMeshOnly: ComputeSingleSheetOption
    
    eFillMeshOnly: ComputeSingleSheetOption
    
    eJustTranslatePoints: FacetTranslationMode
    
    eTranslatePointsAndAddSweepFaces: FacetTranslationMode
    
    eTranslatePointsAndTriangulateFringeFaces: FacetTranslationMode
    
class PolyfaceHeaderPtrArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.PolyfaceHeaderPtrArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.PolyfaceHeaderPtrArray, arg0: MSPyBentleyGeom.PolyfaceHeaderPtrArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.PolyfaceHeaderPtrArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.PolyfaceHeaderPtrArray, x: MSPyBentleyGeom.PolyfaceHeader) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.PolyfaceHeaderPtrArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def count(self: MSPyBentleyGeom.PolyfaceHeaderPtrArray, x: MSPyBentleyGeom.PolyfaceHeader) -> int:
        """
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.PolyfaceHeaderPtrArray, L: MSPyBentleyGeom.PolyfaceHeaderPtrArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.PolyfaceHeaderPtrArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.PolyfaceHeaderPtrArray, i: int, x: MSPyBentleyGeom.PolyfaceHeader) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.PolyfaceHeaderPtrArray) -> MSPyBentleyGeom.PolyfaceHeader
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.PolyfaceHeaderPtrArray, i: int) -> MSPyBentleyGeom.PolyfaceHeader
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(self: MSPyBentleyGeom.PolyfaceHeaderPtrArray, x: MSPyBentleyGeom.PolyfaceHeader) -> None:
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class PolyfaceQuery:
    """
    None
    """

    def AddToTaggedPolygons(*args, **kwargs):
        """
        Overloaded function.
        
        1. AddToTaggedPolygons(self: MSPyBentleyGeom.PolyfaceQuery, polygons: List[TaggedPolygon], indexA: int, numWrap: int, selectRange: MSPyBentleyGeom.DRange3d = None) -> None
        
        2. AddToTaggedPolygons(self: MSPyBentleyGeom.PolyfaceQuery, polygons: List[TaggedPolygon], indexA: int, numWrap: int, filer: IPolyfaceVisitorFilter) -> None
        """
        ...
    
    @staticmethod
    def ClipPolyfaceToClipPlanes(insideClip: PolyfaceHeader, outsideClip: PolyfaceHeader, targetMesh: MSPyBentleyGeom.PolyfaceQuery, clipPlanes: MSPyBentleyGeom.ClipPlaneSet, formNewFacesOnClipPlanes: bool) -> bool:
        ...
    
    def ClipToPlaneSetIntersection(self: MSPyBentleyGeom.PolyfaceQuery, planeSets: List[ClipPlaneSet], output: MSPyBentleyGeom.PolyfaceQuery.IClipToPlaneSetOutput, trangulateOutput: bool) -> int:
        """
        @description Clip polyface to intersection of an array of plane sets.
        """
        ...
    
    def Clone(self: MSPyBentleyGeom.PolyfaceQuery) -> PolyfaceHeader:
        """
        Return a PolyfaceHeader with the same contents.
        """
        ...
    
    def CloneAsVariableSizeIndexed(self: MSPyBentleyGeom.PolyfaceQuery) -> PolyfaceHeader:
        """
        Return a PolyfaceHeader, with variable length faces.
        """
        ...
    
    def ClusteredVertexDecimate(self: MSPyBentleyGeom.PolyfaceQuery, tolerance: float) -> PolyfaceHeader:
        """
        @description Fas clustered vertex decimator - used during tile
        generation.
        """
        ...
    
    def CollectCounts(self: MSPyBentleyGeom.PolyfaceQuery) -> tuple:
        ...
    
    def CollectPerFaceCounts(self: MSPyBentleyGeom.PolyfaceQuery) -> tuple:
        ...
    
    def CollectSegments(self: MSPyBentleyGeom.PolyfaceQuery, segments: MSPyBentleyGeom.DSegment3dArray, omitInvisible: bool) -> None:
        """
        Collect individual segments for each distinct edge.
        
        :param (output):
        segments array to receive segments.
        
        :param (input):
        omitInvisibles true to hide segments that are not visible (due to
        negated indices)
        """
        ...
    
    @property
    def ColorCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    @staticmethod
    def ComputeOverAndUnderXY(polyfaceA: PolyfaceHeader, filterA: IPolyfaceVisitorFilter, polyfaceB: PolyfaceHeader, filterB: IPolyfaceVisitorFilter, polyfaceAOverB: PolyfaceHeader, polyfaceBUnderA: PolyfaceHeader, computeAndApplyTransform: bool = True) -> None:
        ...
    
    def ComputePrincipalAreaMoments(self: MSPyBentleyGeom.PolyfaceQuery, centroid: MSPyBentleyGeom.DPoint3d, axes: MSPyBentleyGeom.RotMatrix, momentxyz: MSPyBentleyGeom.DVec3d) -> tuple:
        ...
    
    def ComputePrincipalMoments(self: MSPyBentleyGeom.PolyfaceQuery, centroid: MSPyBentleyGeom.DPoint3d, axes: MSPyBentleyGeom.RotMatrix, momentxyz: MSPyBentleyGeom.DVec3d, forcePositiveVolume: bool = False) -> tuple:
        ...
    
    def ComputePrincipalMomentsAllowMissingSideFacets(self: MSPyBentleyGeom.PolyfaceQuery, centroid: MSPyBentleyGeom.DPoint3d, axes: MSPyBentleyGeom.RotMatrix, momentxyz: MSPyBentleyGeom.DVec3d, forcePositiveVolume: bool, relativeTolerance: float = 1e-08) -> tuple:
        ...
    
    @staticmethod
    def ComputePunch(punch: MSPyBentleyGeom.PolyfaceQuery, target: MSPyBentleyGeom.PolyfaceQuery, keepInside: bool, result: List[PolyfaceHeader]) -> None:
        """
        @description " Punch " through target polygons.
        
        :param (input):
        punch punch polygons
        
        :param (input):
        target target polygons
        
        :param (input):
        keepInside true to return the target mesh parts that are inside
        the punch, false to return outside parts.
        
        :param (output):
        result punched mesh
        """
        ...
    
    @staticmethod
    def ComputePunchXYByPlaneSets(punch: MSPyBentleyGeom.PolyfaceQuery, target: MSPyBentleyGeom.PolyfaceQuery, inside: PolyfaceHeader, outside: PolyfaceHeader, debugMesh: PolyfaceHeader = None) -> None:
        """
        (input) each facet of this is used as a " punch " (input) facets to be split
        by the punch. (output) (target intersect punch) (output) (target outsideOf
        punch) (output) optional meshes for debugging
        """
        ...
    
    @staticmethod
    def ComputeUndercut(polyfaceA: PolyfaceHeader, filterA: IPolyfaceVisitorFilter, polyfaceB: PolyfaceHeader, filterB: IPolyfaceVisitorFilter, undercutPolyface: PolyfaceHeader) -> None:
        """
        @description Compute volumes where polyfaceB undercuts polyfaceA
        """
        ...
    
    def CountSharedEdges(self: MSPyBentleyGeom.PolyfaceQuery, ignoreSliverFaces: bool) -> tuple:
        ...
    
    def DirectionalAreaAndVolume(self: MSPyBentleyGeom.PolyfaceQuery, origin: MSPyBentleyGeom.DPoint3d, areaXYZ: MSPyBentleyGeom.DVec3d, volumeXYZ: MSPyBentleyGeom.DVec3d, centroidX: MSPyBentleyGeom.DVec3d, centroidY: MSPyBentleyGeom.DVec3d, centroidZ: MSPyBentleyGeom.DVec3d) -> None:
        """
        Compute areas, centroids, volumes of projections onto principal
        planes.
        """
        ...
    
    def DirectionalVolumeIntegrals(self: MSPyBentleyGeom.PolyfaceQuery, polyface: MSPyBentleyGeom.PolyfaceQuery, pData: MSPyBentleyGeom.DirectionalVolumeData, directionalProducts: MSPyBentleyGeom.DMatrix4d, origin: MSPyBentleyGeom.DPoint3d) -> None:
        """
        @description Compute (many) integrals of volume properties, using
        directional formulas that will give correct results (and confidence
        indicators) when " some " facets are missing
        
        :param (input):
        polyface facets for integration
        
        :param (output):
        pData array (allocated by caller) of various integrals:
        
        * pData[0], pData[1], pData[2] = view along respective axes. Use
        signed area, so result should be zero if all facets are present to
        cancel.
        
        * pData[0], pData[1], pData[2] = view along respective axes. Use
        absolute area, so result should be useful for setting tolerances.
        
        * pData[6] = full 3d area.
        
        :param (output):
        directionalProducts array of products integrals wrt origin.
        Allocated by caller.
        
        :param (output):
        origin origin used for directonal integrals. (Directional
        integrals are " from the principal " planes through this origin.)
        """
        ...
    
    def DrapeLinestring(self: MSPyBentleyGeom.PolyfaceQuery, spacePoints: MSPyBentleyGeom.DPoint3dArray, direction: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.CurveVector:
        """
        Project linestring in given direction to intersection with facets.
        Return as a curve vector.
        
        :param (input):
        spacePoints points to project onto the polyface
        
        :param (input):
        direction direction to project.
        """
        ...
    
    @property
    def EdgeChainCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    def EnsureFloatColor(self: MSPyBentleyGeom.PolyfaceQuery) -> bool:
        """
        If float colors are not already present, build them from double
        colors. Returns false if the implementing class is read only.
        """
        ...
    
    @property
    def FaceCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    @property
    def FaceIndexCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    def GetColorCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Return the number of colors.
        """
        ...
    
    def GetColorIndexAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int, resolveToDefaults: bool = False) -> tuple:
        ...
    
    def GetColorTableAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple:
        ...
    
    def GetDoubleColorAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple:
        ...
    
    def GetEdgeChainAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple:
        ...
    
    def GetEdgeChainCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Return the number of edge chains.
        """
        ...
    
    def GetFaceCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Return the number of faces. Note that this is not a " facet " count --
        many facets can reference the same containing face in the parent
        geometry.
        """
        ...
    
    def GetFaceDataAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple:
        ...
    
    def GetFaceIndexAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int, resolveToDefaults: bool = False) -> tuple:
        ...
    
    def GetFaceIndexCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Return the number of face data indices
        """
        ...
    
    def GetFloatColorAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple:
        ...
    
    def GetIlluminationName(self: MSPyBentleyGeom.PolyfaceQuery) -> str:
        ...
    
    def GetIntColorAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple:
        ...
    
    def GetMediumTolerance(self: MSPyBentleyGeom.PolyfaceQuery) -> float:
        """
        Return a tolerance appropriate for medium accuracy calculations (8
        digits relative)
        """
        ...
    
    def GetMeshStyle(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Query the mesh style (MESH_ELM_STYLE_INDEXED_FACE_LOOPS etc)
        """
        ...
    
    def GetNormalAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple:
        ...
    
    def GetNormalCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Return the number of normals.
        """
        ...
    
    def GetNormalIndexAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int, resolveToDefaults: bool = False) -> tuple:
        ...
    
    def GetNumFacet(self: MSPyBentleyGeom.PolyfaceQuery) -> tuple:
        ...
    
    def GetNumPerFace(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Query the nominal number of facets per face. If this is 0 or 1, facets
        are variable size and separated by 0 as terminator. If larger the
        indices are blocked (with 0 as pad if needed)
        """
        ...
    
    def GetNumPerRow(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Query the row size for gridded mesh (quad or triangular)
        """
        ...
    
    def GetParamAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple:
        ...
    
    def GetParamCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Return the number of parameters.
        """
        ...
    
    def GetParamIndexAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int, resolveToDefaults: bool = False) -> tuple:
        ...
    
    def GetPointAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple:
        ...
    
    def GetPointCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Return the number of points.
        """
        ...
    
    def GetPointIndexAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple:
        ...
    
    def GetPointIndexCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Return the number of point indices.
        """
        ...
    
    def GetTextureId(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Return a pointer to contiguous texture id.
        """
        ...
    
    def GetTightTolerance(self: MSPyBentleyGeom.PolyfaceQuery) -> float:
        """
        Return a tolerance appropriate for high accuracy calculations (12 or
        more digits relative)
        """
        ...
    
    def GetTwoSided(self: MSPyBentleyGeom.PolyfaceQuery) -> bool:
        """
        Query if facets are considered two sided. (If not, outward normal can
        be used to cull backfaces)
        """
        ...
    
    def HasConvexFacets(self: MSPyBentleyGeom.PolyfaceQuery) -> bool:
        """
        Check convexity
        """
        ...
    
    def HasFacets(self: MSPyBentleyGeom.PolyfaceQuery) -> bool:
        """
        Test if any facets are defined (Specifically, true if the point index
        set is nonempty).
        """
        ...
    
    def HasIndexErrors(*args, **kwargs):
        """
        Overloaded function.
        
        1. HasIndexErrors(self: MSPyBentleyGeom.PolyfaceQuery, descripton: MSPyBentleyGeom.MeshAnnotationVector) -> bool
        
        Apply various checks for indexing structure.
        
        :returns:
        true if any errors were found.
        
        2. HasIndexErrors(self: MSPyBentleyGeom.PolyfaceQuery) -> bool
        
        Apply various checks for indexing structure.
        
        :returns:
        true if any errors were found.
        """
        ...
    
    @staticmethod
    def HealVerticalPanels(polyface: MSPyBentleyGeom.PolyfaceQuery, tryVerticalPanels: bool, trySpaceTriangulation: bool, healedPolyface: PolyfaceHeader) -> int:
        """
        Attempt to heal vertical gaps in a mesh.
        
        :param (input):
        polyface original polyface
        
        :param (input):
        tryVerticalPanels true to seek pure vertical panels
        
        :param (input):
        trySpaceTriangulation true to seek triangulation of any missing
        faces, as viewed from any direction found useful.
        
        :param (output):
        healedPolyface modified polyface. This is NOT constructed if no
        panels can be added.
        
        :returns:
        number of facets added
        """
        ...
    
    class IClipToPlaneSetOutput:
        """
        None
        """
    
        def __init__(*args, **kwargs):
            """
            Initialize self.  See help(type(self)) for accurate signature.
            """
            ...
        
    def InspectFaces(self: MSPyBentleyGeom.PolyfaceQuery) -> tuple:
        ...
    
    def IsClosedByEdgePairing(self: MSPyBentleyGeom.PolyfaceQuery) -> bool:
        """
        Test if vertex indices around faces indicate watertight closure.
        """
        ...
    
    def IsSameStructureAndGeometry(self: MSPyBentleyGeom.PolyfaceQuery, other: MSPyBentleyGeom.PolyfaceQuery, tolerance: float) -> bool:
        """
        Test for AlmostEqual () conditions.
        """
        ...
    
    def IsTriangulated(self: MSPyBentleyGeom.PolyfaceQuery) -> bool:
        """
        Test if all facets are 3 sided
        """
        ...
    
    def IsVariableSizeIndexed(self: MSPyBentleyGeom.PolyfaceQuery) -> bool:
        """
        Test if this mesh is vaiable sized indexed.
        """
        ...
    
    def LargestCoordinate(self: MSPyBentleyGeom.PolyfaceQuery) -> float:
        """
        Query largest absolute coordinate
        """
        ...
    
    @property
    def MediumTolerance(arg0: MSPyBentleyGeom.PolyfaceQuery) -> float:
        ...
    
    @staticmethod
    def MergeAndCollectVolumes(*args, **kwargs):
        """
        Overloaded function.
        
        1. MergeAndCollectVolumes(meshA: MSPyBentleyGeom.PolyfaceQuery, meshB: MSPyBentleyGeom.PolyfaceQuery, enclosedVolumes: List[PolyfaceHeader]) -> None
        
        2. MergeAndCollectVolumes(inputMesh: List[PolyfaceHeader], enclosedVolumes: List[PolyfaceHeader]) -> None
        """
        ...
    
    @property
    def MeshStyle(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    @property
    def NormalCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    @property
    def NumPerFace(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    @property
    def NumPerRow(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    @property
    def ParamCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    def ParamRange(self: MSPyBentleyGeom.PolyfaceQuery) -> MSPyBentleyGeom.DRange2d:
        """
        Return range of the parameters.
        """
        ...
    
    def PickFacetsByStroke(self: MSPyBentleyGeom.PolyfaceQuery, eyePoint: MSPyBentleyGeom.DPoint4d, point0: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d, pickDetail: MSPyBentleyGeom.FacetLocationDetailArray, exitAfterFirstPick: bool) -> bool:
        """
        Search for facets that are touched by a stroke. returns true if valid
        point data and one or more facets selected.
        """
        ...
    
    def PlaneSlice(*args, **kwargs):
        """
        Overloaded function.
        
        1. PlaneSlice(self: MSPyBentleyGeom.PolyfaceQuery, sectionPlane: MSPyBentleyGeom.DPlane3d, formRegions: bool, markEdgeFraction: bool = False) -> MSPyBentleyGeom.CurveVector
        
        Cut with a plane. (Prototype) Return as a curve vector. Optionally
        structure as area-bounding loops.
        
        :param (input):
        sectionPlane plane to cut the mesh.
        
        :param (input):
        formRegions true to look for closed loops and structure the return
        as a loop or parity CurveVector.
        
        :param (input):
        markEdgeFractions true to attache FacetEdgeLocationDetailVector to
        the linestrings.
        
        :param (input): skipOnPlaneFacets whether output lacks facets coplanar with sectionPlane.
        
        2. PlaneSlice(self: MSPyBentleyGeom.PolyfaceQuery, sectionPlane: MSPyBentleyGeom.DPlane3d, formRegions: bool, markEdgeFractions: bool, skipOnPlaneFacets: bool) -> MSPyBentleyGeom.CurveVector
        
        Cut with a plane. (Prototype) Return as a curve vector. Optionally
        structure as area-bounding loops.
        
        :param (input):
        sectionPlane plane to cut the mesh.
        
        :param (input):
        formRegions true to look for closed loops and structure the return
        as a loop or parity CurveVector.
        
        :param (input):
        markEdgeFractions true to attache FacetEdgeLocationDetailVector to
        the linestrings.
        
        :param (input): skipOnPlaneFacets whether output lacks facets coplanar with sectionPlane.
        """
        ...
    
    @property
    def PointCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    @property
    def PointIndexCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    def PointRange(self: MSPyBentleyGeom.PolyfaceQuery) -> MSPyBentleyGeom.DRange3d:
        """
        Return range of the points.
        """
        ...
    
    def ReverseIndicesAllFaces(*args, **kwargs):
        """
        ReverseIndicesAllFaces(self: MSPyBentleyGeom.PolyfaceQuery, negateNormals: bool = True, flipMarked: bool = True, flipUnMarked: bool = True, normalIndexAction: MSPyBentleyGeom.BlockedVectorInt.IndexAction = <IndexAction.eNone: 0>) -> bool
        """
        ...
    
    def ReverseIndicesOneFace(*args, **kwargs):
        """
        ReverseIndicesOneFace(self: MSPyBentleyGeom.PolyfaceQuery, iFirst: int, iLast: int, normalArrayIndexAction: MSPyBentleyGeom.BlockedVectorInt.IndexAction = <IndexAction.eNone: 0>) -> None
        
        Reverse a single face loop in parallel index arrays.
        
        Remark:
        s A face loop is reversed after the 1st index:the 2nd/last
        indices are swapped, the 3rd/penultimate indices are swapped, etc.
        
        :param (input):
        iFirst 0-based offset to the first index in the face loop
        
        :param (input):
        iLast 0-based offset to the last index of the face loop.
        
        :param (input):
        normalArrayIndexAction selects action in normal array. This can be
        
        * IndexAction::None -- leave the index value unchanged
        
        * IndexAction::ForcePositive -- change to positive
        
        * IndexAction::ForceNegative -- change to negative
        
        * IndexAction::Negate -- change to negative of its current sign
        """
        ...
    
    @staticmethod
    def SearchClosestApproach(*args, **kwargs):
        """
        Overloaded function.
        
        1. SearchClosestApproach(polyfaceA: MSPyBentleyGeom.PolyfaceQuery, polyfaceB: MSPyBentleyGeom.PolyfaceQuery, maxDistance: float, segment: MSPyBentleyGeom.DSegment3d) -> bool
        
        2. SearchClosestApproach(polyfaceA: MSPyBentleyGeom.PolyfaceQuery, maxDistance: float, segment: MSPyBentleyGeom.DSegment3d, normalTestRadius: float) -> bool
        
        3. SearchClosestApproach(polyfaceA: MSPyBentleyGeom.PolyfaceQuery, maxDistance: float, segment: MSPyBentleyGeom.DSegment3d) -> bool
        """
        ...
    
    @staticmethod
    def SearchClosestApproachToLinestring(polyfaceA: MSPyBentleyGeom.PolyfaceQuery, points: MSPyBentleyGeom.DPoint3dArray, segment: MSPyBentleyGeom.DSegment3d) -> bool:
        ...
    
    @staticmethod
    def SelectMeshesByVolumeSign(inputVolumes: List[PolyfaceHeader], negativeVolumeMeshes: List[PolyfaceHeader], zeroVolumeMeshes: List[PolyfaceHeader], positiveVolumeMeshes: List[PolyfaceHeader]) -> None:
        ...
    
    def SumDirectedAreas(self: MSPyBentleyGeom.PolyfaceQuery, vectorToEye: MSPyBentleyGeom.DVec3d) -> tuple:
        ...
    
    def SumDirectedAreasDetailed(self: MSPyBentleyGeom.PolyfaceQuery, vectorToEye: MSPyBentleyGeom.DVec3d) -> tuple:
        ...
    
    def SumFacetAreas(self: MSPyBentleyGeom.PolyfaceQuery) -> float:
        """
        Return the sum of facet areas. There is no check for planarity.
        """
        ...
    
    def SumFacetFirstAreaMoments(self: MSPyBentleyGeom.PolyfaceQuery, origin: MSPyBentleyGeom.DPoint3d, moments1: MSPyBentleyGeom.DVec3d) -> float:
        """
        Return the sum of facet areas. Return moment with respect to origin.
        """
        ...
    
    def SumFacetSecondAreaMomentProducts(self: MSPyBentleyGeom.PolyfaceQuery, origin: MSPyBentleyGeom.DPoint3d, products: MSPyBentleyGeom.DMatrix4d) -> float:
        """
        Return the sum of facet areas. Return moment products with respect to
        origin.
        """
        ...
    
    def SumTetrahedralFirstMoments(self: MSPyBentleyGeom.PolyfaceQuery, origin: MSPyBentleyGeom.DPoint3d, moments: MSPyBentleyGeom.DVec3d) -> float:
        """
        Return the sum of tetrahedral moments from the specified origin. If
        the mesh is closed and all facets are simply connected planar, this is
        the moment around the origin. (The facets and volume are not require
        to be convex.)
        
        :param (input):
        origin origin for tetrahedra.
        
        :param (output):
        moments sum of (x,y,z) dV
        
        :returns:
        summed volume
        """
        ...
    
    def SumTetrahedralMomentProducts(self: MSPyBentleyGeom.PolyfaceQuery, worldToLocal: MSPyBentleyGeom.Transform, moment1: MSPyBentleyGeom.DVec3d, products: MSPyBentleyGeom.RotMatrix) -> float:
        ...
    
    def SumTetrahedralVolumes(self: MSPyBentleyGeom.PolyfaceQuery, origin: MSPyBentleyGeom.DPoint3d) -> float:
        """
        Return the sum of tetrahedral volumes from the specified origin. If
        the mesh is closed and all facets are simply connected planar, this is
        the signed enclosed volume. (The facets and volume are not require to
        be convex.)
        """
        ...
    
    def SweepLinestringToMesh(self: MSPyBentleyGeom.PolyfaceQuery, xyzOut: MSPyBentleyGeom.DPoint3dArray, linestringIndexOut: MSPyBentleyGeom.Int32Array, meshIndexOut: MSPyBentleyGeom.Int32Array, linestringPoints: MSPyBentleyGeom.DPoint3dArray, sweepDirection: MSPyBentleyGeom.DVec3d) -> None:
        """
        @description Compute intersections (line strings) of this mesh with a
        swept linestring
        
        :param (output):
        xyzOut array of points on the intersection linestrings.
        DISCONNECTS separate multiple linestrings.
        
        :param (output):
        linestringIndexOut for each xyzOut[i], the index of the input
        segment that it came from.
        
        :param (output):
        meshIndexOut for each xyzOut[i], the mesh read index it came from.
        
        :param (input):
        linestringPoints points to sweep.
        
        :param (input):
        sweepDirection sweep direction
        """
        ...
    
    @property
    def TextureId(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    @property
    def TightTolerance(arg0: MSPyBentleyGeom.PolyfaceQuery) -> float:
        ...
    
    def TryEvaluateEdge(self: MSPyBentleyGeom.PolyfaceQuery, position: MSPyBentleyGeom.FacetEdgeLocationDetail, xyz: MSPyBentleyGeom.DPoint3d) -> bool:
        """
        Try to convert the index and edge fraction of a
        FacetEdgeLocationDetail to a point.
        """
        ...
    
    def TryGetFacetFaceDataAtReadIndex(self: MSPyBentleyGeom.PolyfaceQuery, readIndex: int, data: MSPyBentleyGeom.FacetFaceData) -> tuple:
        ...
    
    def TryGetNormalAtReadIndex(self: MSPyBentleyGeom.PolyfaceQuery, readIndex: int, data: MSPyBentleyGeom.DVec3d) -> bool:
        """
        Try to access normal coordinates through a readIndex in the
        normalIndex array.
        """
        ...
    
    def TryGetParamAtReadIndex(self: MSPyBentleyGeom.PolyfaceQuery, readIndex: int, data: MSPyBentleyGeom.DPoint2d) -> bool:
        """
        Try to access param coordinates through a readIndex in the paramIndex
        array.
        """
        ...
    
    def TryGetPointAtReadIndex(self: MSPyBentleyGeom.PolyfaceQuery, readIndex: int, data: MSPyBentleyGeom.DPoint3d) -> bool:
        """
        Try to access point coordinates through a readIndex in the pointIndex
        array.
        """
        ...
    
    @property
    def TwoSided(arg0: MSPyBentleyGeom.PolyfaceQuery) -> bool:
        ...
    
    def ValidatedVolume(self: MSPyBentleyGeom.PolyfaceQuery) -> MSPyBentleyGeom.ValidatedDouble:
        """
        Test if the mesh passes IsClosedByEdgePairing, and compute volume if
        so.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    
class PolyfaceQueryCarrier:
    """
    None
    """

    def AddToTaggedPolygons(*args, **kwargs):
        """
        Overloaded function.
        
        1. AddToTaggedPolygons(self: MSPyBentleyGeom.PolyfaceQuery, polygons: List[TaggedPolygon], indexA: int, numWrap: int, selectRange: MSPyBentleyGeom.DRange3d = None) -> None
        
        2. AddToTaggedPolygons(self: MSPyBentleyGeom.PolyfaceQuery, polygons: List[TaggedPolygon], indexA: int, numWrap: int, filer: IPolyfaceVisitorFilter) -> None
        """
        ...
    
    def ClipPolyfaceToClipPlanes(insideClip: PolyfaceHeader, outsideClip: PolyfaceHeader, targetMesh: MSPyBentleyGeom.PolyfaceQuery, clipPlanes: MSPyBentleyGeom.ClipPlaneSet, formNewFacesOnClipPlanes: bool) -> bool:
        ...
    
    def ClipToPlaneSetIntersection(self: MSPyBentleyGeom.PolyfaceQuery, planeSets: List[ClipPlaneSet], output: MSPyBentleyGeom.PolyfaceQuery.IClipToPlaneSetOutput, trangulateOutput: bool) -> int:
        """
        @description Clip polyface to intersection of an array of plane sets.
        """
        ...
    
    def Clone(self: MSPyBentleyGeom.PolyfaceQuery) -> PolyfaceHeader:
        """
        Return a PolyfaceHeader with the same contents.
        """
        ...
    
    def CloneAsVariableSizeIndexed(self: MSPyBentleyGeom.PolyfaceQuery) -> PolyfaceHeader:
        """
        Return a PolyfaceHeader, with variable length faces.
        """
        ...
    
    def ClusteredVertexDecimate(self: MSPyBentleyGeom.PolyfaceQuery, tolerance: float) -> PolyfaceHeader:
        """
        @description Fas clustered vertex decimator - used during tile
        generation.
        """
        ...
    
    def CollectCounts(self: MSPyBentleyGeom.PolyfaceQuery) -> tuple:
        ...
    
    def CollectPerFaceCounts(self: MSPyBentleyGeom.PolyfaceQuery) -> tuple:
        ...
    
    def CollectSegments(self: MSPyBentleyGeom.PolyfaceQuery, segments: MSPyBentleyGeom.DSegment3dArray, omitInvisible: bool) -> None:
        """
        Collect individual segments for each distinct edge.
        
        :param (output):
        segments array to receive segments.
        
        :param (input):
        omitInvisibles true to hide segments that are not visible (due to
        negated indices)
        """
        ...
    
    @property
    def ColorCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    def ComputeOverAndUnderXY(polyfaceA: PolyfaceHeader, filterA: IPolyfaceVisitorFilter, polyfaceB: PolyfaceHeader, filterB: IPolyfaceVisitorFilter, polyfaceAOverB: PolyfaceHeader, polyfaceBUnderA: PolyfaceHeader, computeAndApplyTransform: bool = True) -> None:
        ...
    
    def ComputePrincipalAreaMoments(self: MSPyBentleyGeom.PolyfaceQuery, centroid: MSPyBentleyGeom.DPoint3d, axes: MSPyBentleyGeom.RotMatrix, momentxyz: MSPyBentleyGeom.DVec3d) -> tuple:
        ...
    
    def ComputePrincipalMoments(self: MSPyBentleyGeom.PolyfaceQuery, centroid: MSPyBentleyGeom.DPoint3d, axes: MSPyBentleyGeom.RotMatrix, momentxyz: MSPyBentleyGeom.DVec3d, forcePositiveVolume: bool = False) -> tuple:
        ...
    
    def ComputePrincipalMomentsAllowMissingSideFacets(self: MSPyBentleyGeom.PolyfaceQuery, centroid: MSPyBentleyGeom.DPoint3d, axes: MSPyBentleyGeom.RotMatrix, momentxyz: MSPyBentleyGeom.DVec3d, forcePositiveVolume: bool, relativeTolerance: float = 1e-08) -> tuple:
        ...
    
    def ComputePunch(punch: MSPyBentleyGeom.PolyfaceQuery, target: MSPyBentleyGeom.PolyfaceQuery, keepInside: bool, result: List[PolyfaceHeader]) -> None:
        """
        @description " Punch " through target polygons.
        
        :param (input):
        punch punch polygons
        
        :param (input):
        target target polygons
        
        :param (input):
        keepInside true to return the target mesh parts that are inside
        the punch, false to return outside parts.
        
        :param (output):
        result punched mesh
        """
        ...
    
    def ComputePunchXYByPlaneSets(punch: MSPyBentleyGeom.PolyfaceQuery, target: MSPyBentleyGeom.PolyfaceQuery, inside: PolyfaceHeader, outside: PolyfaceHeader, debugMesh: PolyfaceHeader = None) -> None:
        """
        (input) each facet of this is used as a " punch " (input) facets to be split
        by the punch. (output) (target intersect punch) (output) (target outsideOf
        punch) (output) optional meshes for debugging
        """
        ...
    
    def ComputeUndercut(polyfaceA: PolyfaceHeader, filterA: IPolyfaceVisitorFilter, polyfaceB: PolyfaceHeader, filterB: IPolyfaceVisitorFilter, undercutPolyface: PolyfaceHeader) -> None:
        """
        @description Compute volumes where polyfaceB undercuts polyfaceA
        """
        ...
    
    def CountSharedEdges(self: MSPyBentleyGeom.PolyfaceQuery, ignoreSliverFaces: bool) -> tuple:
        ...
    
    def DirectionalAreaAndVolume(self: MSPyBentleyGeom.PolyfaceQuery, origin: MSPyBentleyGeom.DPoint3d, areaXYZ: MSPyBentleyGeom.DVec3d, volumeXYZ: MSPyBentleyGeom.DVec3d, centroidX: MSPyBentleyGeom.DVec3d, centroidY: MSPyBentleyGeom.DVec3d, centroidZ: MSPyBentleyGeom.DVec3d) -> None:
        """
        Compute areas, centroids, volumes of projections onto principal
        planes.
        """
        ...
    
    def DirectionalVolumeIntegrals(self: MSPyBentleyGeom.PolyfaceQuery, polyface: MSPyBentleyGeom.PolyfaceQuery, pData: MSPyBentleyGeom.DirectionalVolumeData, directionalProducts: MSPyBentleyGeom.DMatrix4d, origin: MSPyBentleyGeom.DPoint3d) -> None:
        """
        @description Compute (many) integrals of volume properties, using
        directional formulas that will give correct results (and confidence
        indicators) when " some " facets are missing
        
        :param (input):
        polyface facets for integration
        
        :param (output):
        pData array (allocated by caller) of various integrals:
        
        * pData[0], pData[1], pData[2] = view along respective axes. Use
        signed area, so result should be zero if all facets are present to
        cancel.
        
        * pData[0], pData[1], pData[2] = view along respective axes. Use
        absolute area, so result should be useful for setting tolerances.
        
        * pData[6] = full 3d area.
        
        :param (output):
        directionalProducts array of products integrals wrt origin.
        Allocated by caller.
        
        :param (output):
        origin origin used for directonal integrals. (Directional
        integrals are " from the principal " planes through this origin.)
        """
        ...
    
    def DrapeLinestring(self: MSPyBentleyGeom.PolyfaceQuery, spacePoints: MSPyBentleyGeom.DPoint3dArray, direction: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.CurveVector:
        """
        Project linestring in given direction to intersection with facets.
        Return as a curve vector.
        
        :param (input):
        spacePoints points to project onto the polyface
        
        :param (input):
        direction direction to project.
        """
        ...
    
    @property
    def EdgeChainCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    def EnsureFloatColor(self: MSPyBentleyGeom.PolyfaceQuery) -> bool:
        """
        If float colors are not already present, build them from double
        colors. Returns false if the implementing class is read only.
        """
        ...
    
    @property
    def FaceCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    @property
    def FaceIndexCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    def GetColorCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Return the number of colors.
        """
        ...
    
    def GetColorIndexAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int, resolveToDefaults: bool = False) -> tuple:
        ...
    
    def GetColorTableAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple:
        ...
    
    def GetDoubleColorAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple:
        ...
    
    def GetEdgeChainAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple:
        ...
    
    def GetEdgeChainCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Return the number of edge chains.
        """
        ...
    
    def GetFaceCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Return the number of faces. Note that this is not a " facet " count --
        many facets can reference the same containing face in the parent
        geometry.
        """
        ...
    
    def GetFaceDataAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple:
        ...
    
    def GetFaceIndexAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int, resolveToDefaults: bool = False) -> tuple:
        ...
    
    def GetFaceIndexCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Return the number of face data indices
        """
        ...
    
    def GetFloatColorAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple:
        ...
    
    def GetIlluminationName(self: MSPyBentleyGeom.PolyfaceQuery) -> str:
        ...
    
    def GetIntColorAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple:
        ...
    
    def GetMediumTolerance(self: MSPyBentleyGeom.PolyfaceQuery) -> float:
        """
        Return a tolerance appropriate for medium accuracy calculations (8
        digits relative)
        """
        ...
    
    def GetMeshStyle(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Query the mesh style (MESH_ELM_STYLE_INDEXED_FACE_LOOPS etc)
        """
        ...
    
    def GetNormalAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple:
        ...
    
    def GetNormalCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Return the number of normals.
        """
        ...
    
    def GetNormalIndexAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int, resolveToDefaults: bool = False) -> tuple:
        ...
    
    def GetNumFacet(self: MSPyBentleyGeom.PolyfaceQuery) -> tuple:
        ...
    
    def GetNumPerFace(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Query the nominal number of facets per face. If this is 0 or 1, facets
        are variable size and separated by 0 as terminator. If larger the
        indices are blocked (with 0 as pad if needed)
        """
        ...
    
    def GetNumPerRow(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Query the row size for gridded mesh (quad or triangular)
        """
        ...
    
    def GetParamAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple:
        ...
    
    def GetParamCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Return the number of parameters.
        """
        ...
    
    def GetParamIndexAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int, resolveToDefaults: bool = False) -> tuple:
        ...
    
    def GetPointAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple:
        ...
    
    def GetPointCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Return the number of points.
        """
        ...
    
    def GetPointIndexAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple:
        ...
    
    def GetPointIndexCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Return the number of point indices.
        """
        ...
    
    def GetTextureId(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Return a pointer to contiguous texture id.
        """
        ...
    
    def GetTightTolerance(self: MSPyBentleyGeom.PolyfaceQuery) -> float:
        """
        Return a tolerance appropriate for high accuracy calculations (12 or
        more digits relative)
        """
        ...
    
    def GetTwoSided(self: MSPyBentleyGeom.PolyfaceQuery) -> bool:
        """
        Query if facets are considered two sided. (If not, outward normal can
        be used to cull backfaces)
        """
        ...
    
    def HasConvexFacets(self: MSPyBentleyGeom.PolyfaceQuery) -> bool:
        """
        Check convexity
        """
        ...
    
    def HasFacets(self: MSPyBentleyGeom.PolyfaceQuery) -> bool:
        """
        Test if any facets are defined (Specifically, true if the point index
        set is nonempty).
        """
        ...
    
    def HasIndexErrors(*args, **kwargs):
        """
        Overloaded function.
        
        1. HasIndexErrors(self: MSPyBentleyGeom.PolyfaceQuery, descripton: MSPyBentleyGeom.MeshAnnotationVector) -> bool
        
        Apply various checks for indexing structure.
        
        :returns:
        true if any errors were found.
        
        2. HasIndexErrors(self: MSPyBentleyGeom.PolyfaceQuery) -> bool
        
        Apply various checks for indexing structure.
        
        :returns:
        true if any errors were found.
        """
        ...
    
    def HealVerticalPanels(polyface: MSPyBentleyGeom.PolyfaceQuery, tryVerticalPanels: bool, trySpaceTriangulation: bool, healedPolyface: PolyfaceHeader) -> int:
        """
        Attempt to heal vertical gaps in a mesh.
        
        :param (input):
        polyface original polyface
        
        :param (input):
        tryVerticalPanels true to seek pure vertical panels
        
        :param (input):
        trySpaceTriangulation true to seek triangulation of any missing
        faces, as viewed from any direction found useful.
        
        :param (output):
        healedPolyface modified polyface. This is NOT constructed if no
        panels can be added.
        
        :returns:
        number of facets added
        """
        ...
    
    class IClipToPlaneSetOutput:
        """
        None
        """
    
        def __init__(*args, **kwargs):
            """
            Initialize self.  See help(type(self)) for accurate signature.
            """
            ...
        
    def InspectFaces(self: MSPyBentleyGeom.PolyfaceQuery) -> tuple:
        ...
    
    def IsClosedByEdgePairing(self: MSPyBentleyGeom.PolyfaceQuery) -> bool:
        """
        Test if vertex indices around faces indicate watertight closure.
        """
        ...
    
    def IsSameStructureAndGeometry(self: MSPyBentleyGeom.PolyfaceQuery, other: MSPyBentleyGeom.PolyfaceQuery, tolerance: float) -> bool:
        """
        Test for AlmostEqual () conditions.
        """
        ...
    
    def IsTriangulated(self: MSPyBentleyGeom.PolyfaceQuery) -> bool:
        """
        Test if all facets are 3 sided
        """
        ...
    
    def IsVariableSizeIndexed(self: MSPyBentleyGeom.PolyfaceQuery) -> bool:
        """
        Test if this mesh is vaiable sized indexed.
        """
        ...
    
    def LargestCoordinate(self: MSPyBentleyGeom.PolyfaceQuery) -> float:
        """
        Query largest absolute coordinate
        """
        ...
    
    @property
    def MediumTolerance(arg0: MSPyBentleyGeom.PolyfaceQuery) -> float:
        ...
    
    def MergeAndCollectVolumes(*args, **kwargs):
        """
        Overloaded function.
        
        1. MergeAndCollectVolumes(meshA: MSPyBentleyGeom.PolyfaceQuery, meshB: MSPyBentleyGeom.PolyfaceQuery, enclosedVolumes: List[PolyfaceHeader]) -> None
        
        2. MergeAndCollectVolumes(inputMesh: List[PolyfaceHeader], enclosedVolumes: List[PolyfaceHeader]) -> None
        """
        ...
    
    @property
    def MeshStyle(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    @property
    def NormalCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    @property
    def NumPerFace(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    @property
    def NumPerRow(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    @property
    def ParamCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    def ParamRange(self: MSPyBentleyGeom.PolyfaceQuery) -> MSPyBentleyGeom.DRange2d:
        """
        Return range of the parameters.
        """
        ...
    
    def PickFacetsByStroke(self: MSPyBentleyGeom.PolyfaceQuery, eyePoint: MSPyBentleyGeom.DPoint4d, point0: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d, pickDetail: MSPyBentleyGeom.FacetLocationDetailArray, exitAfterFirstPick: bool) -> bool:
        """
        Search for facets that are touched by a stroke. returns true if valid
        point data and one or more facets selected.
        """
        ...
    
    def PlaneSlice(*args, **kwargs):
        """
        Overloaded function.
        
        1. PlaneSlice(self: MSPyBentleyGeom.PolyfaceQuery, sectionPlane: MSPyBentleyGeom.DPlane3d, formRegions: bool, markEdgeFraction: bool = False) -> MSPyBentleyGeom.CurveVector
        
        Cut with a plane. (Prototype) Return as a curve vector. Optionally
        structure as area-bounding loops.
        
        :param (input):
        sectionPlane plane to cut the mesh.
        
        :param (input):
        formRegions true to look for closed loops and structure the return
        as a loop or parity CurveVector.
        
        :param (input):
        markEdgeFractions true to attache FacetEdgeLocationDetailVector to
        the linestrings.
        
        :param (input): skipOnPlaneFacets whether output lacks facets coplanar with sectionPlane.
        
        2. PlaneSlice(self: MSPyBentleyGeom.PolyfaceQuery, sectionPlane: MSPyBentleyGeom.DPlane3d, formRegions: bool, markEdgeFractions: bool, skipOnPlaneFacets: bool) -> MSPyBentleyGeom.CurveVector
        
        Cut with a plane. (Prototype) Return as a curve vector. Optionally
        structure as area-bounding loops.
        
        :param (input):
        sectionPlane plane to cut the mesh.
        
        :param (input):
        formRegions true to look for closed loops and structure the return
        as a loop or parity CurveVector.
        
        :param (input):
        markEdgeFractions true to attache FacetEdgeLocationDetailVector to
        the linestrings.
        
        :param (input): skipOnPlaneFacets whether output lacks facets coplanar with sectionPlane.
        """
        ...
    
    @property
    def PointCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    @property
    def PointIndexCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    def PointRange(self: MSPyBentleyGeom.PolyfaceQuery) -> MSPyBentleyGeom.DRange3d:
        """
        Return range of the points.
        """
        ...
    
    def ReverseIndicesAllFaces(*args, **kwargs):
        """
        ReverseIndicesAllFaces(self: MSPyBentleyGeom.PolyfaceQuery, negateNormals: bool = True, flipMarked: bool = True, flipUnMarked: bool = True, normalIndexAction: MSPyBentleyGeom.BlockedVectorInt.IndexAction = <IndexAction.eNone: 0>) -> bool
        """
        ...
    
    def ReverseIndicesOneFace(*args, **kwargs):
        """
        ReverseIndicesOneFace(self: MSPyBentleyGeom.PolyfaceQuery, iFirst: int, iLast: int, normalArrayIndexAction: MSPyBentleyGeom.BlockedVectorInt.IndexAction = <IndexAction.eNone: 0>) -> None
        
        Reverse a single face loop in parallel index arrays.
        
        Remark:
        s A face loop is reversed after the 1st index:the 2nd/last
        indices are swapped, the 3rd/penultimate indices are swapped, etc.
        
        :param (input):
        iFirst 0-based offset to the first index in the face loop
        
        :param (input):
        iLast 0-based offset to the last index of the face loop.
        
        :param (input):
        normalArrayIndexAction selects action in normal array. This can be
        
        * IndexAction::None -- leave the index value unchanged
        
        * IndexAction::ForcePositive -- change to positive
        
        * IndexAction::ForceNegative -- change to negative
        
        * IndexAction::Negate -- change to negative of its current sign
        """
        ...
    
    def SearchClosestApproach(*args, **kwargs):
        """
        Overloaded function.
        
        1. SearchClosestApproach(polyfaceA: MSPyBentleyGeom.PolyfaceQuery, polyfaceB: MSPyBentleyGeom.PolyfaceQuery, maxDistance: float, segment: MSPyBentleyGeom.DSegment3d) -> bool
        
        2. SearchClosestApproach(polyfaceA: MSPyBentleyGeom.PolyfaceQuery, maxDistance: float, segment: MSPyBentleyGeom.DSegment3d, normalTestRadius: float) -> bool
        
        3. SearchClosestApproach(polyfaceA: MSPyBentleyGeom.PolyfaceQuery, maxDistance: float, segment: MSPyBentleyGeom.DSegment3d) -> bool
        """
        ...
    
    def SearchClosestApproachToLinestring(polyfaceA: MSPyBentleyGeom.PolyfaceQuery, points: MSPyBentleyGeom.DPoint3dArray, segment: MSPyBentleyGeom.DSegment3d) -> bool:
        ...
    
    def SelectMeshesByVolumeSign(inputVolumes: List[PolyfaceHeader], negativeVolumeMeshes: List[PolyfaceHeader], zeroVolumeMeshes: List[PolyfaceHeader], positiveVolumeMeshes: List[PolyfaceHeader]) -> None:
        ...
    
    def SumDirectedAreas(self: MSPyBentleyGeom.PolyfaceQuery, vectorToEye: MSPyBentleyGeom.DVec3d) -> tuple:
        ...
    
    def SumDirectedAreasDetailed(self: MSPyBentleyGeom.PolyfaceQuery, vectorToEye: MSPyBentleyGeom.DVec3d) -> tuple:
        ...
    
    def SumFacetAreas(self: MSPyBentleyGeom.PolyfaceQuery) -> float:
        """
        Return the sum of facet areas. There is no check for planarity.
        """
        ...
    
    def SumFacetFirstAreaMoments(self: MSPyBentleyGeom.PolyfaceQuery, origin: MSPyBentleyGeom.DPoint3d, moments1: MSPyBentleyGeom.DVec3d) -> float:
        """
        Return the sum of facet areas. Return moment with respect to origin.
        """
        ...
    
    def SumFacetSecondAreaMomentProducts(self: MSPyBentleyGeom.PolyfaceQuery, origin: MSPyBentleyGeom.DPoint3d, products: MSPyBentleyGeom.DMatrix4d) -> float:
        """
        Return the sum of facet areas. Return moment products with respect to
        origin.
        """
        ...
    
    def SumTetrahedralFirstMoments(self: MSPyBentleyGeom.PolyfaceQuery, origin: MSPyBentleyGeom.DPoint3d, moments: MSPyBentleyGeom.DVec3d) -> float:
        """
        Return the sum of tetrahedral moments from the specified origin. If
        the mesh is closed and all facets are simply connected planar, this is
        the moment around the origin. (The facets and volume are not require
        to be convex.)
        
        :param (input):
        origin origin for tetrahedra.
        
        :param (output):
        moments sum of (x,y,z) dV
        
        :returns:
        summed volume
        """
        ...
    
    def SumTetrahedralMomentProducts(self: MSPyBentleyGeom.PolyfaceQuery, worldToLocal: MSPyBentleyGeom.Transform, moment1: MSPyBentleyGeom.DVec3d, products: MSPyBentleyGeom.RotMatrix) -> float:
        ...
    
    def SumTetrahedralVolumes(self: MSPyBentleyGeom.PolyfaceQuery, origin: MSPyBentleyGeom.DPoint3d) -> float:
        """
        Return the sum of tetrahedral volumes from the specified origin. If
        the mesh is closed and all facets are simply connected planar, this is
        the signed enclosed volume. (The facets and volume are not require to
        be convex.)
        """
        ...
    
    def SweepLinestringToMesh(self: MSPyBentleyGeom.PolyfaceQuery, xyzOut: MSPyBentleyGeom.DPoint3dArray, linestringIndexOut: MSPyBentleyGeom.Int32Array, meshIndexOut: MSPyBentleyGeom.Int32Array, linestringPoints: MSPyBentleyGeom.DPoint3dArray, sweepDirection: MSPyBentleyGeom.DVec3d) -> None:
        """
        @description Compute intersections (line strings) of this mesh with a
        swept linestring
        
        :param (output):
        xyzOut array of points on the intersection linestrings.
        DISCONNECTS separate multiple linestrings.
        
        :param (output):
        linestringIndexOut for each xyzOut[i], the index of the input
        segment that it came from.
        
        :param (output):
        meshIndexOut for each xyzOut[i], the mesh read index it came from.
        
        :param (input):
        linestringPoints points to sweep.
        
        :param (input):
        sweepDirection sweep direction
        """
        ...
    
    @property
    def TextureId(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    @property
    def TightTolerance(arg0: MSPyBentleyGeom.PolyfaceQuery) -> float:
        ...
    
    def TryEvaluateEdge(self: MSPyBentleyGeom.PolyfaceQuery, position: MSPyBentleyGeom.FacetEdgeLocationDetail, xyz: MSPyBentleyGeom.DPoint3d) -> bool:
        """
        Try to convert the index and edge fraction of a
        FacetEdgeLocationDetail to a point.
        """
        ...
    
    def TryGetFacetFaceDataAtReadIndex(self: MSPyBentleyGeom.PolyfaceQuery, readIndex: int, data: MSPyBentleyGeom.FacetFaceData) -> tuple:
        ...
    
    def TryGetNormalAtReadIndex(self: MSPyBentleyGeom.PolyfaceQuery, readIndex: int, data: MSPyBentleyGeom.DVec3d) -> bool:
        """
        Try to access normal coordinates through a readIndex in the
        normalIndex array.
        """
        ...
    
    def TryGetParamAtReadIndex(self: MSPyBentleyGeom.PolyfaceQuery, readIndex: int, data: MSPyBentleyGeom.DPoint2d) -> bool:
        """
        Try to access param coordinates through a readIndex in the paramIndex
        array.
        """
        ...
    
    def TryGetPointAtReadIndex(self: MSPyBentleyGeom.PolyfaceQuery, readIndex: int, data: MSPyBentleyGeom.DPoint3d) -> bool:
        """
        Try to access point coordinates through a readIndex in the pointIndex
        array.
        """
        ...
    
    @property
    def TwoSided(arg0: MSPyBentleyGeom.PolyfaceQuery) -> bool:
        ...
    
    def ValidatedVolume(self: MSPyBentleyGeom.PolyfaceQuery) -> MSPyBentleyGeom.ValidatedDouble:
        """
        Test if the mesh passes IsClosedByEdgePairing, and compute volume if
        so.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    
class PolyfaceVectors:
    """
    None
    """

    def AddToTaggedPolygons(*args, **kwargs):
        """
        Overloaded function.
        
        1. AddToTaggedPolygons(self: MSPyBentleyGeom.PolyfaceQuery, polygons: List[TaggedPolygon], indexA: int, numWrap: int, selectRange: MSPyBentleyGeom.DRange3d = None) -> None
        
        2. AddToTaggedPolygons(self: MSPyBentleyGeom.PolyfaceQuery, polygons: List[TaggedPolygon], indexA: int, numWrap: int, filer: IPolyfaceVisitorFilter) -> None
        """
        ...
    
    def ClearAllArrays(self: MSPyBentleyGeom.PolyfaceVectors) -> None:
        """
        clear all arrays (but flags stay unchanged)
        """
        ...
    
    def ClipPolyfaceToClipPlanes(insideClip: PolyfaceHeader, outsideClip: PolyfaceHeader, targetMesh: MSPyBentleyGeom.PolyfaceQuery, clipPlanes: MSPyBentleyGeom.ClipPlaneSet, formNewFacesOnClipPlanes: bool) -> bool:
        ...
    
    def ClipToPlaneSetIntersection(self: MSPyBentleyGeom.PolyfaceQuery, planeSets: List[ClipPlaneSet], output: MSPyBentleyGeom.PolyfaceQuery.IClipToPlaneSetOutput, trangulateOutput: bool) -> int:
        """
        @description Clip polyface to intersection of an array of plane sets.
        """
        ...
    
    def Clone(self: MSPyBentleyGeom.PolyfaceQuery) -> PolyfaceHeader:
        """
        Return a PolyfaceHeader with the same contents.
        """
        ...
    
    def CloneAsVariableSizeIndexed(self: MSPyBentleyGeom.PolyfaceQuery) -> PolyfaceHeader:
        """
        Return a PolyfaceHeader, with variable length faces.
        """
        ...
    
    def ClusteredVertexDecimate(self: MSPyBentleyGeom.PolyfaceQuery, tolerance: float) -> PolyfaceHeader:
        """
        @description Fas clustered vertex decimator - used during tile
        generation.
        """
        ...
    
    def CollectCounts(self: MSPyBentleyGeom.PolyfaceQuery) -> tuple:
        ...
    
    def CollectPerFaceCounts(self: MSPyBentleyGeom.PolyfaceQuery) -> tuple:
        ...
    
    def CollectSegments(self: MSPyBentleyGeom.PolyfaceQuery, segments: MSPyBentleyGeom.DSegment3dArray, omitInvisible: bool) -> None:
        """
        Collect individual segments for each distinct edge.
        
        :param (output):
        segments array to receive segments.
        
        :param (input):
        omitInvisibles true to hide segments that are not visible (due to
        negated indices)
        """
        ...
    
    @property
    def ColorCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    def ComputeOverAndUnderXY(polyfaceA: PolyfaceHeader, filterA: IPolyfaceVisitorFilter, polyfaceB: PolyfaceHeader, filterB: IPolyfaceVisitorFilter, polyfaceAOverB: PolyfaceHeader, polyfaceBUnderA: PolyfaceHeader, computeAndApplyTransform: bool = True) -> None:
        ...
    
    def ComputePrincipalAreaMoments(self: MSPyBentleyGeom.PolyfaceQuery, centroid: MSPyBentleyGeom.DPoint3d, axes: MSPyBentleyGeom.RotMatrix, momentxyz: MSPyBentleyGeom.DVec3d) -> tuple:
        ...
    
    def ComputePrincipalMoments(self: MSPyBentleyGeom.PolyfaceQuery, centroid: MSPyBentleyGeom.DPoint3d, axes: MSPyBentleyGeom.RotMatrix, momentxyz: MSPyBentleyGeom.DVec3d, forcePositiveVolume: bool = False) -> tuple:
        ...
    
    def ComputePrincipalMomentsAllowMissingSideFacets(self: MSPyBentleyGeom.PolyfaceQuery, centroid: MSPyBentleyGeom.DPoint3d, axes: MSPyBentleyGeom.RotMatrix, momentxyz: MSPyBentleyGeom.DVec3d, forcePositiveVolume: bool, relativeTolerance: float = 1e-08) -> tuple:
        ...
    
    def ComputePunch(punch: MSPyBentleyGeom.PolyfaceQuery, target: MSPyBentleyGeom.PolyfaceQuery, keepInside: bool, result: List[PolyfaceHeader]) -> None:
        """
        @description " Punch " through target polygons.
        
        :param (input):
        punch punch polygons
        
        :param (input):
        target target polygons
        
        :param (input):
        keepInside true to return the target mesh parts that are inside
        the punch, false to return outside parts.
        
        :param (output):
        result punched mesh
        """
        ...
    
    def ComputePunchXYByPlaneSets(punch: MSPyBentleyGeom.PolyfaceQuery, target: MSPyBentleyGeom.PolyfaceQuery, inside: PolyfaceHeader, outside: PolyfaceHeader, debugMesh: PolyfaceHeader = None) -> None:
        """
        (input) each facet of this is used as a " punch " (input) facets to be split
        by the punch. (output) (target intersect punch) (output) (target outsideOf
        punch) (output) optional meshes for debugging
        """
        ...
    
    def ComputeUndercut(polyfaceA: PolyfaceHeader, filterA: IPolyfaceVisitorFilter, polyfaceB: PolyfaceHeader, filterB: IPolyfaceVisitorFilter, undercutPolyface: PolyfaceHeader) -> None:
        """
        @description Compute volumes where polyfaceB undercuts polyfaceA
        """
        ...
    
    def CopyAllActiveFlagsFrom(self: MSPyBentleyGeom.PolyfaceVectors, source: MSPyBentleyGeom.PolyfaceVectors) -> None:
        """
        Copy active flags from the various arrays of the source.
        """
        ...
    
    def CopyAllActiveFlagsFromQuery(self: MSPyBentleyGeom.PolyfaceVectors, source: MSPyBentleyGeom.PolyfaceQuery) -> None:
        """
        In PolyfaceQuery, determine active status from pointers. This is only
        valid if the PolyfaceQuery has already been filled !!!
        """
        ...
    
    def CountSharedEdges(self: MSPyBentleyGeom.PolyfaceQuery, ignoreSliverFaces: bool) -> tuple:
        ...
    
    def DirectionalAreaAndVolume(self: MSPyBentleyGeom.PolyfaceQuery, origin: MSPyBentleyGeom.DPoint3d, areaXYZ: MSPyBentleyGeom.DVec3d, volumeXYZ: MSPyBentleyGeom.DVec3d, centroidX: MSPyBentleyGeom.DVec3d, centroidY: MSPyBentleyGeom.DVec3d, centroidZ: MSPyBentleyGeom.DVec3d) -> None:
        """
        Compute areas, centroids, volumes of projections onto principal
        planes.
        """
        ...
    
    def DirectionalVolumeIntegrals(self: MSPyBentleyGeom.PolyfaceQuery, polyface: MSPyBentleyGeom.PolyfaceQuery, pData: MSPyBentleyGeom.DirectionalVolumeData, directionalProducts: MSPyBentleyGeom.DMatrix4d, origin: MSPyBentleyGeom.DPoint3d) -> None:
        """
        @description Compute (many) integrals of volume properties, using
        directional formulas that will give correct results (and confidence
        indicators) when " some " facets are missing
        
        :param (input):
        polyface facets for integration
        
        :param (output):
        pData array (allocated by caller) of various integrals:
        
        * pData[0], pData[1], pData[2] = view along respective axes. Use
        signed area, so result should be zero if all facets are present to
        cancel.
        
        * pData[0], pData[1], pData[2] = view along respective axes. Use
        absolute area, so result should be useful for setting tolerances.
        
        * pData[6] = full 3d area.
        
        :param (output):
        directionalProducts array of products integrals wrt origin.
        Allocated by caller.
        
        :param (output):
        origin origin used for directonal integrals. (Directional
        integrals are " from the principal " planes through this origin.)
        """
        ...
    
    def DrapeLinestring(self: MSPyBentleyGeom.PolyfaceQuery, spacePoints: MSPyBentleyGeom.DPoint3dArray, direction: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.CurveVector:
        """
        Project linestring in given direction to intersection with facets.
        Return as a curve vector.
        
        :param (input):
        spacePoints points to project onto the polyface
        
        :param (input):
        direction direction to project.
        """
        ...
    
    @property
    def EdgeChainCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    def EnsureFloatColor(self: MSPyBentleyGeom.PolyfaceQuery) -> bool:
        """
        If float colors are not already present, build them from double
        colors. Returns false if the implementing class is read only.
        """
        ...
    
    @property
    def FaceCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    @property
    def FaceIndexCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    def FindOrAddColorTable(self: MSPyBentleyGeom.PolyfaceVectors, tableIndex: int) -> int:
        """
        Find or add a color table. * Activate if needed. * This is a linear
        search !
        """
        ...
    
    def GetColorCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Return the number of colors.
        """
        ...
    
    def GetColorIndexAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int, resolveToDefaults: bool = False) -> tuple:
        ...
    
    def GetColorTableAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple:
        ...
    
    def GetDoubleColorAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple:
        ...
    
    def GetEdgeChainAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple:
        ...
    
    def GetEdgeChainCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Return the number of edge chains.
        """
        ...
    
    def GetFaceCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Return the number of faces. Note that this is not a " facet " count --
        many facets can reference the same containing face in the parent
        geometry.
        """
        ...
    
    def GetFaceDataAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple:
        ...
    
    def GetFaceIndexAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int, resolveToDefaults: bool = False) -> tuple:
        ...
    
    def GetFaceIndexCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Return the number of face data indices
        """
        ...
    
    def GetFloatColorAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple:
        ...
    
    def GetIlluminationName(self: MSPyBentleyGeom.PolyfaceQuery) -> str:
        ...
    
    def GetIntColorAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple:
        ...
    
    def GetMediumTolerance(self: MSPyBentleyGeom.PolyfaceQuery) -> float:
        """
        Return a tolerance appropriate for medium accuracy calculations (8
        digits relative)
        """
        ...
    
    def GetMeshStyle(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Query the mesh style (MESH_ELM_STYLE_INDEXED_FACE_LOOPS etc)
        """
        ...
    
    def GetNormalAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple:
        ...
    
    def GetNormalCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Return the number of normals.
        """
        ...
    
    def GetNormalIndexAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int, resolveToDefaults: bool = False) -> tuple:
        ...
    
    def GetNumFacet(self: MSPyBentleyGeom.PolyfaceQuery) -> tuple:
        ...
    
    def GetNumPerFace(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Query the nominal number of facets per face. If this is 0 or 1, facets
        are variable size and separated by 0 as terminator. If larger the
        indices are blocked (with 0 as pad if needed)
        """
        ...
    
    def GetNumPerRow(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Query the row size for gridded mesh (quad or triangular)
        """
        ...
    
    def GetParamAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple:
        ...
    
    def GetParamCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Return the number of parameters.
        """
        ...
    
    def GetParamIndexAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int, resolveToDefaults: bool = False) -> tuple:
        ...
    
    def GetPointAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple:
        ...
    
    def GetPointCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Return the number of points.
        """
        ...
    
    def GetPointIndexAt(self: MSPyBentleyGeom.PolyfaceQuery, index: int) -> tuple:
        ...
    
    def GetPointIndexCount(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Return the number of point indices.
        """
        ...
    
    def GetTextureId(self: MSPyBentleyGeom.PolyfaceQuery) -> int:
        """
        Return a pointer to contiguous texture id.
        """
        ...
    
    def GetTightTolerance(self: MSPyBentleyGeom.PolyfaceQuery) -> float:
        """
        Return a tolerance appropriate for high accuracy calculations (12 or
        more digits relative)
        """
        ...
    
    def GetTwoSided(self: MSPyBentleyGeom.PolyfaceQuery) -> bool:
        """
        Query if facets are considered two sided. (If not, outward normal can
        be used to cull backfaces)
        """
        ...
    
    def HasConvexFacets(self: MSPyBentleyGeom.PolyfaceQuery) -> bool:
        """
        Check convexity
        """
        ...
    
    def HasFacets(self: MSPyBentleyGeom.PolyfaceQuery) -> bool:
        """
        Test if any facets are defined (Specifically, true if the point index
        set is nonempty).
        """
        ...
    
    def HasIndexErrors(*args, **kwargs):
        """
        Overloaded function.
        
        1. HasIndexErrors(self: MSPyBentleyGeom.PolyfaceQuery, descripton: MSPyBentleyGeom.MeshAnnotationVector) -> bool
        
        Apply various checks for indexing structure.
        
        :returns:
        true if any errors were found.
        
        2. HasIndexErrors(self: MSPyBentleyGeom.PolyfaceQuery) -> bool
        
        Apply various checks for indexing structure.
        
        :returns:
        true if any errors were found.
        """
        ...
    
    def HealVerticalPanels(polyface: MSPyBentleyGeom.PolyfaceQuery, tryVerticalPanels: bool, trySpaceTriangulation: bool, healedPolyface: PolyfaceHeader) -> int:
        """
        Attempt to heal vertical gaps in a mesh.
        
        :param (input):
        polyface original polyface
        
        :param (input):
        tryVerticalPanels true to seek pure vertical panels
        
        :param (input):
        trySpaceTriangulation true to seek triangulation of any missing
        faces, as viewed from any direction found useful.
        
        :param (output):
        healedPolyface modified polyface. This is NOT constructed if no
        panels can be added.
        
        :returns:
        number of facets added
        """
        ...
    
    class IClipToPlaneSetOutput:
        """
        None
        """
    
        def __init__(*args, **kwargs):
            """
            Initialize self.  See help(type(self)) for accurate signature.
            """
            ...
        
    def InspectFaces(self: MSPyBentleyGeom.PolyfaceQuery) -> tuple:
        ...
    
    def IsClosedByEdgePairing(self: MSPyBentleyGeom.PolyfaceQuery) -> bool:
        """
        Test if vertex indices around faces indicate watertight closure.
        """
        ...
    
    def IsSameStructureAndGeometry(self: MSPyBentleyGeom.PolyfaceQuery, other: MSPyBentleyGeom.PolyfaceQuery, tolerance: float) -> bool:
        """
        Test for AlmostEqual () conditions.
        """
        ...
    
    def IsTriangulated(self: MSPyBentleyGeom.PolyfaceQuery) -> bool:
        """
        Test if all facets are 3 sided
        """
        ...
    
    def IsVariableSizeIndexed(self: MSPyBentleyGeom.PolyfaceQuery) -> bool:
        """
        Test if this mesh is vaiable sized indexed.
        """
        ...
    
    def LargestCoordinate(self: MSPyBentleyGeom.PolyfaceQuery) -> float:
        """
        Query largest absolute coordinate
        """
        ...
    
    @property
    def MediumTolerance(arg0: MSPyBentleyGeom.PolyfaceQuery) -> float:
        ...
    
    def MergeAndCollectVolumes(*args, **kwargs):
        """
        Overloaded function.
        
        1. MergeAndCollectVolumes(meshA: MSPyBentleyGeom.PolyfaceQuery, meshB: MSPyBentleyGeom.PolyfaceQuery, enclosedVolumes: List[PolyfaceHeader]) -> None
        
        2. MergeAndCollectVolumes(inputMesh: List[PolyfaceHeader], enclosedVolumes: List[PolyfaceHeader]) -> None
        """
        ...
    
    @property
    def MeshStyle(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    @property
    def NormalCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    @property
    def NumPerFace(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    @property
    def NumPerRow(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    @property
    def ParamCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    def ParamRange(self: MSPyBentleyGeom.PolyfaceQuery) -> MSPyBentleyGeom.DRange2d:
        """
        Return range of the parameters.
        """
        ...
    
    def PickFacetsByStroke(self: MSPyBentleyGeom.PolyfaceQuery, eyePoint: MSPyBentleyGeom.DPoint4d, point0: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d, pickDetail: MSPyBentleyGeom.FacetLocationDetailArray, exitAfterFirstPick: bool) -> bool:
        """
        Search for facets that are touched by a stroke. returns true if valid
        point data and one or more facets selected.
        """
        ...
    
    def PlaneSlice(*args, **kwargs):
        """
        Overloaded function.
        
        1. PlaneSlice(self: MSPyBentleyGeom.PolyfaceQuery, sectionPlane: MSPyBentleyGeom.DPlane3d, formRegions: bool, markEdgeFraction: bool = False) -> MSPyBentleyGeom.CurveVector
        
        Cut with a plane. (Prototype) Return as a curve vector. Optionally
        structure as area-bounding loops.
        
        :param (input):
        sectionPlane plane to cut the mesh.
        
        :param (input):
        formRegions true to look for closed loops and structure the return
        as a loop or parity CurveVector.
        
        :param (input):
        markEdgeFractions true to attache FacetEdgeLocationDetailVector to
        the linestrings.
        
        :param (input): skipOnPlaneFacets whether output lacks facets coplanar with sectionPlane.
        
        2. PlaneSlice(self: MSPyBentleyGeom.PolyfaceQuery, sectionPlane: MSPyBentleyGeom.DPlane3d, formRegions: bool, markEdgeFractions: bool, skipOnPlaneFacets: bool) -> MSPyBentleyGeom.CurveVector
        
        Cut with a plane. (Prototype) Return as a curve vector. Optionally
        structure as area-bounding loops.
        
        :param (input):
        sectionPlane plane to cut the mesh.
        
        :param (input):
        formRegions true to look for closed loops and structure the return
        as a loop or parity CurveVector.
        
        :param (input):
        markEdgeFractions true to attache FacetEdgeLocationDetailVector to
        the linestrings.
        
        :param (input): skipOnPlaneFacets whether output lacks facets coplanar with sectionPlane.
        """
        ...
    
    @property
    def PointCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    @property
    def PointIndexCount(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    def PointRange(self: MSPyBentleyGeom.PolyfaceQuery) -> MSPyBentleyGeom.DRange3d:
        """
        Return range of the points.
        """
        ...
    
    def ReverseIndicesAllFaces(*args, **kwargs):
        """
        ReverseIndicesAllFaces(self: MSPyBentleyGeom.PolyfaceQuery, negateNormals: bool = True, flipMarked: bool = True, flipUnMarked: bool = True, normalIndexAction: MSPyBentleyGeom.BlockedVectorInt.IndexAction = <IndexAction.eNone: 0>) -> bool
        """
        ...
    
    def ReverseIndicesOneFace(*args, **kwargs):
        """
        ReverseIndicesOneFace(self: MSPyBentleyGeom.PolyfaceQuery, iFirst: int, iLast: int, normalArrayIndexAction: MSPyBentleyGeom.BlockedVectorInt.IndexAction = <IndexAction.eNone: 0>) -> None
        
        Reverse a single face loop in parallel index arrays.
        
        Remark:
        s A face loop is reversed after the 1st index:the 2nd/last
        indices are swapped, the 3rd/penultimate indices are swapped, etc.
        
        :param (input):
        iFirst 0-based offset to the first index in the face loop
        
        :param (input):
        iLast 0-based offset to the last index of the face loop.
        
        :param (input):
        normalArrayIndexAction selects action in normal array. This can be
        
        * IndexAction::None -- leave the index value unchanged
        
        * IndexAction::ForcePositive -- change to positive
        
        * IndexAction::ForceNegative -- change to negative
        
        * IndexAction::Negate -- change to negative of its current sign
        """
        ...
    
    def SearchClosestApproach(*args, **kwargs):
        """
        Overloaded function.
        
        1. SearchClosestApproach(polyfaceA: MSPyBentleyGeom.PolyfaceQuery, polyfaceB: MSPyBentleyGeom.PolyfaceQuery, maxDistance: float, segment: MSPyBentleyGeom.DSegment3d) -> bool
        
        2. SearchClosestApproach(polyfaceA: MSPyBentleyGeom.PolyfaceQuery, maxDistance: float, segment: MSPyBentleyGeom.DSegment3d, normalTestRadius: float) -> bool
        
        3. SearchClosestApproach(polyfaceA: MSPyBentleyGeom.PolyfaceQuery, maxDistance: float, segment: MSPyBentleyGeom.DSegment3d) -> bool
        """
        ...
    
    def SearchClosestApproachToLinestring(polyfaceA: MSPyBentleyGeom.PolyfaceQuery, points: MSPyBentleyGeom.DPoint3dArray, segment: MSPyBentleyGeom.DSegment3d) -> bool:
        ...
    
    def SelectMeshesByVolumeSign(inputVolumes: List[PolyfaceHeader], negativeVolumeMeshes: List[PolyfaceHeader], zeroVolumeMeshes: List[PolyfaceHeader], positiveVolumeMeshes: List[PolyfaceHeader]) -> None:
        ...
    
    def SetMeshStyle(self: MSPyBentleyGeom.PolyfaceVectors, meshStyle: int) -> None:
        """
        Set the facet data style.
        """
        ...
    
    def SetNumPerFace(self: MSPyBentleyGeom.PolyfaceVectors, numPerFace: int) -> None:
        """
        Set the index blocking count
        """
        ...
    
    def SetNumPerRow(self: MSPyBentleyGeom.PolyfaceVectors, numPerRow: int) -> None:
        """
        Set the row count for gridded facets.
        """
        ...
    
    def SetTwoSided(self: MSPyBentleyGeom.PolyfaceVectors, twoSided: bool) -> None:
        """
        Set the flag for twosided facets
        """
        ...
    
    def SumDirectedAreas(self: MSPyBentleyGeom.PolyfaceQuery, vectorToEye: MSPyBentleyGeom.DVec3d) -> tuple:
        ...
    
    def SumDirectedAreasDetailed(self: MSPyBentleyGeom.PolyfaceQuery, vectorToEye: MSPyBentleyGeom.DVec3d) -> tuple:
        ...
    
    def SumFacetAreas(self: MSPyBentleyGeom.PolyfaceQuery) -> float:
        """
        Return the sum of facet areas. There is no check for planarity.
        """
        ...
    
    def SumFacetFirstAreaMoments(self: MSPyBentleyGeom.PolyfaceQuery, origin: MSPyBentleyGeom.DPoint3d, moments1: MSPyBentleyGeom.DVec3d) -> float:
        """
        Return the sum of facet areas. Return moment with respect to origin.
        """
        ...
    
    def SumFacetSecondAreaMomentProducts(self: MSPyBentleyGeom.PolyfaceQuery, origin: MSPyBentleyGeom.DPoint3d, products: MSPyBentleyGeom.DMatrix4d) -> float:
        """
        Return the sum of facet areas. Return moment products with respect to
        origin.
        """
        ...
    
    def SumTetrahedralFirstMoments(self: MSPyBentleyGeom.PolyfaceQuery, origin: MSPyBentleyGeom.DPoint3d, moments: MSPyBentleyGeom.DVec3d) -> float:
        """
        Return the sum of tetrahedral moments from the specified origin. If
        the mesh is closed and all facets are simply connected planar, this is
        the moment around the origin. (The facets and volume are not require
        to be convex.)
        
        :param (input):
        origin origin for tetrahedra.
        
        :param (output):
        moments sum of (x,y,z) dV
        
        :returns:
        summed volume
        """
        ...
    
    def SumTetrahedralMomentProducts(self: MSPyBentleyGeom.PolyfaceQuery, worldToLocal: MSPyBentleyGeom.Transform, moment1: MSPyBentleyGeom.DVec3d, products: MSPyBentleyGeom.RotMatrix) -> float:
        ...
    
    def SumTetrahedralVolumes(self: MSPyBentleyGeom.PolyfaceQuery, origin: MSPyBentleyGeom.DPoint3d) -> float:
        """
        Return the sum of tetrahedral volumes from the specified origin. If
        the mesh is closed and all facets are simply connected planar, this is
        the signed enclosed volume. (The facets and volume are not require to
        be convex.)
        """
        ...
    
    def SweepLinestringToMesh(self: MSPyBentleyGeom.PolyfaceQuery, xyzOut: MSPyBentleyGeom.DPoint3dArray, linestringIndexOut: MSPyBentleyGeom.Int32Array, meshIndexOut: MSPyBentleyGeom.Int32Array, linestringPoints: MSPyBentleyGeom.DPoint3dArray, sweepDirection: MSPyBentleyGeom.DVec3d) -> None:
        """
        @description Compute intersections (line strings) of this mesh with a
        swept linestring
        
        :param (output):
        xyzOut array of points on the intersection linestrings.
        DISCONNECTS separate multiple linestrings.
        
        :param (output):
        linestringIndexOut for each xyzOut[i], the index of the input
        segment that it came from.
        
        :param (output):
        meshIndexOut for each xyzOut[i], the mesh read index it came from.
        
        :param (input):
        linestringPoints points to sweep.
        
        :param (input):
        sweepDirection sweep direction
        """
        ...
    
    @property
    def TextureId(arg0: MSPyBentleyGeom.PolyfaceQuery) -> int:
        ...
    
    @property
    def TightTolerance(arg0: MSPyBentleyGeom.PolyfaceQuery) -> float:
        ...
    
    def TryEvaluateEdge(self: MSPyBentleyGeom.PolyfaceQuery, position: MSPyBentleyGeom.FacetEdgeLocationDetail, xyz: MSPyBentleyGeom.DPoint3d) -> bool:
        """
        Try to convert the index and edge fraction of a
        FacetEdgeLocationDetail to a point.
        """
        ...
    
    def TryGetFacetFaceDataAtReadIndex(self: MSPyBentleyGeom.PolyfaceQuery, readIndex: int, data: MSPyBentleyGeom.FacetFaceData) -> tuple:
        ...
    
    def TryGetNormalAtReadIndex(self: MSPyBentleyGeom.PolyfaceQuery, readIndex: int, data: MSPyBentleyGeom.DVec3d) -> bool:
        """
        Try to access normal coordinates through a readIndex in the
        normalIndex array.
        """
        ...
    
    def TryGetParamAtReadIndex(self: MSPyBentleyGeom.PolyfaceQuery, readIndex: int, data: MSPyBentleyGeom.DPoint2d) -> bool:
        """
        Try to access param coordinates through a readIndex in the paramIndex
        array.
        """
        ...
    
    def TryGetPointAtReadIndex(self: MSPyBentleyGeom.PolyfaceQuery, readIndex: int, data: MSPyBentleyGeom.DPoint3d) -> bool:
        """
        Try to access point coordinates through a readIndex in the pointIndex
        array.
        """
        ...
    
    @property
    def TwoSided(arg0: MSPyBentleyGeom.PolyfaceQuery) -> bool:
        ...
    
    def ValidatedVolume(self: MSPyBentleyGeom.PolyfaceQuery) -> MSPyBentleyGeom.ValidatedDouble:
        """
        Test if the mesh passes IsClosedByEdgePairing, and compute volume if
        so.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    
class PolyfaceVisitor:
    """
    None
    """

    def AccumulateScaledData(self: MSPyBentleyGeom.PolyfaceVisitor, detail: MSPyBentleyGeom.FacetLocationDetail, vertexIndex: int, fraction: float) -> bool:
        """
        accumualted a (multiple of) all numeric data to a detail. Copy integer
        color and table number unchanged.
        """
        ...
    
    def AddCoordinatesFromFacetLocationDetail(self: MSPyBentleyGeom.PolyfaceVisitor, detail: MSPyBentleyGeom.FacetLocationDetail) -> bool:
        """
        add coordinate data from a vertex described by a facet location
        detail.
        """
        ...
    
    def AdvanceToFacetBySearchPoint(*args, **kwargs):
        """
        Overloaded function.
        
        1. AdvanceToFacetBySearchPoint(self: MSPyBentleyGeom.PolyfaceVisitor, xyz: MSPyBentleyGeom.DPoint3d, tolerance: float, facetPoint: MSPyBentleyGeom.DPoint3d) -> bool
        
        Call AdvanceToNextFace repeatedly, returning when a face is found
        within tolerance of search point.
        
        :param (input):
        xyz search point
        
        :param (input):
        tolerance proximity tolerance.
        
        :param (output):
        facetPoint nearest point on facet
        
        return false if all faces have been visited.
        
        2. AdvanceToFacetBySearchPoint(self: MSPyBentleyGeom.PolyfaceVisitor, xyz: MSPyBentleyGeom.DPoint3d, tolerance: float, facetPoint: MSPyBentleyGeom.DPoint3d) -> tuple
        
        Call AdvanceToNextFace repeatedly, returning when a face is found
        within tolerance of search point.
        
        :param (input):
        xyz search point
        
        :param (input):
        tolerance proximity tolerance.
        
        :param (output):
        facetPoint nearest point on facet
        
        return false if all faces have been visited.
        """
        ...
    
    def AdvanceToFacetBySearchRay(*args, **kwargs):
        """
        Overloaded function.
        
        1. AdvanceToFacetBySearchRay(self: MSPyBentleyGeom.PolyfaceVisitor, ray: MSPyBentleyGeom.DRay3d, tolerance: float, facetPoint: MSPyBentleyGeom.DPoint3d) -> tuple
        
        Call AdvanceToNextFace repeatedly, returning when a face is found
        within tolerance of a pick ray.
        
        :param (input):
        ray ray
        
        :param (input):
        tolerance proximity tolerance.
        
        :param (output):
        facetPoint pierce point on facet.
        
        :param (output):
        rayFraction parameter along ray. return false if all faces have
        been visited.
        
        2. AdvanceToFacetBySearchRay(self: MSPyBentleyGeom.PolyfaceVisitor, ray: MSPyBentleyGeom.DRay3d, tolerance: float, facetPoint: MSPyBentleyGeom.DPoint3d, edgePoint: MSPyBentleyGeom.DPoint3d) -> tuple
        
        Call AdvanceToNextFace repeatedly, returning when a face is found
        within tolerance of a pick ray.
        
        :param (input):
        ray ray
        
        :param (input):
        tolerance proximity tolerance.
        
        :param (output):
        facetPoint pierce point on facet.
        
        :param (output):
        rayFraction parameter along ray. return false if all faces have
        been visited.
        
        3. AdvanceToFacetBySearchRay(self: MSPyBentleyGeom.PolyfaceVisitor, ray: MSPyBentleyGeom.DRay3d, detail: MSPyBentleyGeom.FacetLocationDetail) -> bool
        
        Call AdvanceToNextFace repeatedly, returning when a face is found
        within tolerance of a pick ray.
        
        :param (input):
        ray ray
        
        :param (input):
        tolerance proximity tolerance.
        
        :param (output):
        facetPoint pierce point on facet.
        
        :param (output):
        rayFraction parameter along ray. return false if all faces have
        been visited.
        """
        ...
    
    def AdvanceToNextFace(self: MSPyBentleyGeom.PolyfaceVisitor) -> bool:
        """
        Read the next face from the attached mesh. return false if all faces
        have been visited.
        """
        ...
    
    @staticmethod
    def Attach(parentMesh: MSPyBentleyGeom.PolyfaceQuery, allData: bool = True) -> MSPyBentleyGeom.PolyfaceVisitor:
        """
        Save data for traversing the given parentMesh
        """
        ...
    
    def ClearAllArrays(self: MSPyBentleyGeom.PolyfaceVisitor) -> None:
        """
        Clear all arrays in the visitor.
        """
        ...
    
    def ClearFacet(self: MSPyBentleyGeom.PolyfaceVisitor) -> None:
        """
        Clear all arrays in the visitor. This is used before
        AddVertexByReadIndex.
        """
        ...
    
    def ClientColorIndex(self: MSPyBentleyGeom.PolyfaceVisitor) -> MSPyBentleyGeom.BlockedVectorInt:
        """
        Get reference to the blocked array of zero-based indices into client
        mesh colors
        """
        ...
    
    def ClientFaceIndex(self: MSPyBentleyGeom.PolyfaceVisitor) -> MSPyBentleyGeom.BlockedVectorInt:
        """
        Get reference to the blocked array of zero-based indices into client
        mesh faces.
        """
        ...
    
    def ClientNormalIndex(self: MSPyBentleyGeom.PolyfaceVisitor) -> MSPyBentleyGeom.BlockedVectorInt:
        """
        Get reference to the blocked array of zero-based indices into client
        mesh normals.
        """
        ...
    
    def ClientParamIndex(self: MSPyBentleyGeom.PolyfaceVisitor) -> MSPyBentleyGeom.BlockedVectorInt:
        """
        Get reference to the blocked array of zero-based indices into client
        mesh params.
        """
        ...
    
    def ClientPointIndex(self: MSPyBentleyGeom.PolyfaceVisitor) -> MSPyBentleyGeom.BlockedVectorInt:
        """
        The client indices are zero-based indices into the client mesh data.
        Get reference to the blocked array of zero-based indices into client
        mesh points.
        """
        ...
    
    def ColorTable(self: MSPyBentleyGeom.PolyfaceVisitor) -> MSPyBentleyGeom.BlockedVectorUInt32:
        """
        Get reference to the Point array with blocking data.
        """
        ...
    
    def CompressClosePoints(self: MSPyBentleyGeom.PolyfaceVisitor, tolerance: float) -> None:
        """
        Compress adjacent points (including last/first) within tolerance.
        """
        ...
    
    def CopyData(self: MSPyBentleyGeom.PolyfaceVisitor, fromIndex: int, toIndex: int) -> None:
        """
        Copy all data from one index to another.
        """
        ...
    
    def DoubleColor(self: MSPyBentleyGeom.PolyfaceVisitor) -> MSPyBentleyGeom.BlockedVectorRgbFactor:
        """
        Get reference to the double color array with blocking data.
        """
        ...
    
    def FloatColor(self: MSPyBentleyGeom.PolyfaceVisitor) -> MSPyBentleyGeom.BlockedVectorFloatRgb:
        """
        Get reference to the FloatRbg array with blocking data.
        """
        ...
    
    def GetClientPolyfaceQuery(self: MSPyBentleyGeom.PolyfaceVisitor) -> MSPyBentleyGeom.PolyfaceQuery:
        ...
    
    def GetNumWrap(self: MSPyBentleyGeom.PolyfaceVisitor) -> int:
        """
        return the number or wraparound vertices that are added to the arrays.
        """
        ...
    
    def GetReadIndex(self: MSPyBentleyGeom.PolyfaceVisitor) -> int:
        """
        Return the readIndex (current position within client facets). This
        value can be used to return here via MoveToFacetByReadIndex
        
        :returns:
        readIndex in facet.
        """
        ...
    
    def IlluminationName(self: MSPyBentleyGeom.PolyfaceVisitor) -> MSPyBentley.WString:
        """
        Get reference to the illumination name
        """
        ...
    
    def IndexPosition(self: MSPyBentleyGeom.PolyfaceVisitor) -> MSPyBentleyGeom.UInt64Array:
        """
        return the (reference to) the array indicating where vertex indices
        were read from the attached mesh.
        """
        ...
    
    def IntColor(self: MSPyBentleyGeom.PolyfaceVisitor) -> MSPyBentleyGeom.BlockedVectorUInt32:
        """
        Get reference to the integer color array with blocking data.
        """
        ...
    
    def IntepolateDataOnEdge(self: MSPyBentleyGeom.PolyfaceVisitor, detail: MSPyBentleyGeom.FacetLocationDetail, vertexIndex: int, edgeFraction: float = 0.0, a: float = 0.0) -> bool:
        """
        interpolate all possible data along an edge of the current facet.
        """
        ...
    
    def LoadCyclicVertexData(self: MSPyBentleyGeom.PolyfaceVisitor, detail: MSPyBentleyGeom.FacetLocationDetail, index: int) -> bool:
        ...
    
    def LoadVertexData(self: MSPyBentleyGeom.PolyfaceVisitor, detail: MSPyBentleyGeom.FacetLocationDetail, index: int) -> bool:
        """
        Copy all data from a particular vertex (indexed within the visitor)
        into a facet location detail.
        
        :param (output):
        detail destination for copied data.
        
        :param (input):
        index index within data arrays for the visitor.
        """
        ...
    
    def MoveToFacetByReadIndex(self: MSPyBentleyGeom.PolyfaceVisitor, readIndex: int) -> bool:
        """
        Focus on facet with specified readIndex.
        
        :param (input):
        readIndex readIndex in facet.
        """
        ...
    
    def Normal(self: MSPyBentleyGeom.PolyfaceVisitor) -> MSPyBentleyGeom.BlockedVectorDVec3d:
        """
        Get reference to the normal array with blocking data.
        """
        ...
    
    def NumEdgesThisFace(self: MSPyBentleyGeom.PolyfaceVisitor) -> int:
        """
        return the number of edges on the current face.
        """
        ...
    
    @property
    def NumWrap(arg0: MSPyBentleyGeom.PolyfaceVisitor) -> int:
        ...
    @NumWrap.setter
    def NumWrap(arg0: MSPyBentleyGeom.PolyfaceVisitor, arg1: int) -> None:
        ...
    
    def Param(self: MSPyBentleyGeom.PolyfaceVisitor) -> MSPyBentleyGeom.BlockedVectorDPoint2d:
        """
        Get reference to the param array with blocking data.
        """
        ...
    
    def Point(self: MSPyBentleyGeom.PolyfaceVisitor) -> MSPyBentleyGeom.BlockedVectorDPoint3d:
        """
        Get reference to the Point array with blocking data.
        """
        ...
    
    def PushFaceData(self: MSPyBentleyGeom.PolyfaceVisitor, source: MSPyBentleyGeom.PolyfaceVisitor, i0: int) -> int:
        """
        Copy face data (point, normal, param, color, visible) from specified
        index of source. Active state is checked in receiver. Index is not
        checked.
        
        return the index of new point.
        """
        ...
    
    def PushIndexData(self: MSPyBentleyGeom.PolyfaceVisitor, source: MSPyBentleyGeom.PolyfaceVisitor, i0: int) -> None:
        """
        In source, copy index data (point, normal, param, color) from
        specified index of source. Active state is checked in receiver. Index
        is not checked.
        """
        ...
    
    def PushInterpolatedFaceData(self: MSPyBentleyGeom.PolyfaceVisitor, source: MSPyBentleyGeom.PolyfaceVisitor, i0: int, fraction: float, i1: int, suppressVisibility: bool = False) -> int:
        """
        In source, interpolate between specified indices of face data. Active
        state is checked in receiver. Index is not checked.
        
        return the index of new point.
        """
        ...
    
    def Reset(self: MSPyBentleyGeom.PolyfaceVisitor) -> None:
        """
        Reset to beginning of attached mesh, i.e. to read facets again.
        """
        ...
    
    def SetNumWrap(self: MSPyBentleyGeom.PolyfaceVisitor, numWrap: int) -> None:
        """
        Set the number of wraparound vertices to be added to faces when they
        are read.
        """
        ...
    
    def TrimData(self: MSPyBentleyGeom.PolyfaceVisitor, newSize: int) -> None:
        """
        Trim all arrays to newSize.
        """
        ...
    
    def TrimFaceData(self: MSPyBentleyGeom.PolyfaceVisitor, index0: int, count: int) -> None:
        """
        Trim all face data arrays, retaining{count} values starting at
        {index0}
        """
        ...
    
    def TryAddVertexByReadIndex(self: MSPyBentleyGeom.PolyfaceVisitor, readIndex: int) -> bool:
        """
        Go to the source mesh at specified readIndex. Bring all it's data into
        a new vertex in the visitor.
        
        :returns:
        false if not a valid readIndex for the client array, or if the
        client array has a zero (terminator) there, or if the client is
        not fully indexed.
        """
        ...
    
    def TryDRay3dIntersectionToFacetLocationDetail(self: MSPyBentleyGeom.PolyfaceVisitor, ray: MSPyBentleyGeom.DRay3d, detail: MSPyBentleyGeom.FacetLocationDetail) -> bool:
        """
        Find a uv location within the facet. Compute all available data there.
        returns false if the facet does not have params or if there are not
        edges on both sides along the scan lines.
        
        :param (input):
        ray ray to intersect with facet.
        
        :param (input):
        detail all coordinate data at this parametric coordinate.
        """
        ...
    
    def TryFindCloseFacetPoint(self: MSPyBentleyGeom.PolyfaceVisitor, spacePoint: MSPyBentleyGeom.DPoint3d, tolerance: float, fractionPoint: MSPyBentleyGeom.DPoint3d) -> bool:
        """
        Test if a point is close to a facet.
        
        :param (input):
        spacePoint test point.
        
        :param (input):
        tolerance tolerance for identifying a hit.
        
        :param (output):
        facetPoint point on facet.
        
        return true if a hit was found.
        """
        ...
    
    def TryFindFacetRayIntersection(self: MSPyBentleyGeom.PolyfaceVisitor, ray: MSPyBentleyGeom.DRay3d, tolerance: float, facetPoint: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        Test if ray pierces facet or come close to an edge or vertex.
        
        :param (input):
        ray test ray.
        
        :param (input):
        tolerance tolerance for edge/vertex passby
        
        :param (output):
        facetPoint point on facet.
        
        :param (output):
        rayFraction parameter along ray
        
        return true if a hit was found.
        """
        ...
    
    def TryGetClientZeroBasedColorIndex(self: MSPyBentleyGeom.PolyfaceVisitor, zeroBasedVisitorIndex: int) -> tuple:
        """
        access zero-based color index for an vertex within the curent face.
        """
        ...
    
    def TryGetClientZeroBasedNormalIndex(self: MSPyBentleyGeom.PolyfaceVisitor, zeroBasedVisitorIndex: int) -> tuple:
        """
        access zero-based normal index for an vertex within the curent face.
        """
        ...
    
    def TryGetClientZeroBasedParamIndex(self: MSPyBentleyGeom.PolyfaceVisitor, zeroBasedVisitorIndex: int) -> tuple:
        """
        access zero-based param index for an vertex within the curent face.
        """
        ...
    
    def TryGetClientZeroBasedPointIndex(self: MSPyBentleyGeom.PolyfaceVisitor, zeroBasedVisitorIndex: int) -> tuple:
        """
        access zero-based point index and visibility flag for an vertex within
        the current face.
        """
        ...
    
    def TryGetDistanceParameter(self: MSPyBentleyGeom.PolyfaceVisitor, index: int, distanceParam: MSPyBentleyGeom.DPoint2d) -> bool:
        """
        get a distance based parameter at an index within the current facet
        """
        ...
    
    def TryGetEdgePoint(self: MSPyBentleyGeom.PolyfaceVisitor, edgeIndex: int, f: float, xyz: MSPyBentleyGeom.DPoint3d) -> bool:
        """
        interpolate a point on an edge. Edge index is interpretted cyclically
        (within the current face)
        """
        ...
    
    def TryGetFacetAreaMomentProducts(self: MSPyBentleyGeom.PolyfaceVisitor, origin: MSPyBentleyGeom.DPoint3d, products: MSPyBentleyGeom.DMatrix4d) -> bool:
        """
        return true if products of inertia for an AREA integral over the facet
        can be computed.
        """
        ...
    
    def TryGetFacetCentroidNormalAndArea(self: MSPyBentleyGeom.PolyfaceVisitor, centroid: MSPyBentleyGeom.DPoint3d, normal: MSPyBentleyGeom.DVec3d) -> tuple:
        """
        return true if centroid, area, and normal can be calculated for the
        current facet.
        """
        ...
    
    def TryGetLocalFrame(*args, **kwargs):
        """
        TryGetLocalFrame(self: MSPyBentleyGeom.PolyfaceVisitor, localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform, selector: MSPyBentleyGeom.LocalCoordinateSelect = <LocalCoordinateSelect.eLOCAL_COORDINATE_SCALE_01RangeBothAxes: 2>) -> bool
        
        Interogate the xy coordinates (NOT THE STORED Param() ARRAY !!!) to
        determine a local coordinate frame for the current facet. This is the
        same logic used for CurveVector::CloneInLocalCoordinates and
        PolygonOps::CoordinateFrame. That is:ul> li>The prefered x axis
        direction is parallel to the first edge. li>The prefered z direction
        is the outward normal of the xyz loop with CCW direction. li>The
        selector parameter chooses among 4 options:
        
        * LOCAL_COORDINATE_SCALE_UnitAxesAtStart -- origin at first point
        (even if not lower left!!), local axes have unit length, so local
        coordinates are real distances.
        
        * LOCAL_COORDINATE_SCALE_UnitAxesAtLowerLeft -- origin at lower left.
        All xy local coordinates are 0 or positive, and local coordinates are
        real distances along the local directions
        
        * LOCAL_COORDINATE_SCALE_01RangeBothAxes -- Shift to lower left and
        scale to both directions go 0 to 1
        
        * LOCAL_COORDINATE_SCALE_01RangeBothAxes -- Shift to lower left and
        scale so one direction goes 0 to 1, the other direction has same scale
        and its largest coordinate is positive and 1 or less.
        
        ul> Prefered x axis is parallel to the first edge.
        
        :param (output):
        localToWorld transform from local to world
        
        :param (output):
        worldToLocal transform from world to local
        
        :param (input):
        selector indicates preference for origin and scaling.
        """
        ...
    
    def TryGetLocalFrameAndRank(*args, **kwargs):
        """
        TryGetLocalFrameAndRank(self: MSPyBentleyGeom.PolyfaceVisitor, localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform, selector: MSPyBentleyGeom.LocalCoordinateSelect = <LocalCoordinateSelect.eLOCAL_COORDINATE_SCALE_01RangeBothAxes: 2>) -> int
        
        Like TryGetLocalFrame, but with integer return type to distinguish
        
        * 0 -- really degenerate data -- single point?
        
        * 1 -- degenerate to a line
        
        * 2 -- usual full-rank case.
        """
        ...
    
    def TryGetNormalizedParameter(self: MSPyBentleyGeom.PolyfaceVisitor, index: int, normalizedParam: MSPyBentleyGeom.DPoint2d) -> bool:
        """
        get a normalized (0-1) parameter at an index within the current facet
        """
        ...
    
    def TryParamToFacetLocationDetail(self: MSPyBentleyGeom.PolyfaceVisitor, uvParam: MSPyBentleyGeom.DPoint2d, detail: MSPyBentleyGeom.FacetLocationDetail) -> bool:
        """
        Find a uv location within the facet. Compute all available data there.
        returns false if the facet does not have params or if there are not
        edges on both sides along the scan lines.
        
        :param (input):
        uvParam pick parameter.
        
        :param (input):
        detail all coordinate data at this parametric coordinate.
        """
        ...
    
    def TryParamToScanBrackets(self: MSPyBentleyGeom.PolyfaceVisitor, uvParam: MSPyBentleyGeom.DPoint2d, horizontalScanBracket: MSPyBentleyGeom.FacetLocationDetailPair, verticalScanBracket: MSPyBentleyGeom.FacetLocationDetailPair) -> bool:
        """
        Try to locate facet edges before and after a specified param in a
        facet. returns false if the facet does not have params or if there are
        not edges on both sides along the scan lines.
        
        :param (input):
        uvParam pick parameter.
        
        :param (input):
        horizontalScanBracket edge crossing data to left and right of uv.
        
        :param (input):
        verticalScanBracket edge crossign data below and above.
        """
        ...
    
    def TryRecomputeNormals(self: MSPyBentleyGeom.PolyfaceVisitor) -> bool:
        """
        Recompute the (coordinate) normal data based on the point coordinates.
        """
        ...
    
    def TwoSided(self: MSPyBentleyGeom.PolyfaceVisitor) -> bool:
        ...
    
    def Visible(self: MSPyBentleyGeom.PolyfaceVisitor) -> MSPyBentleyGeom.BoolArray:
        """
        return the (reference to) the array of per-edge visibility flags.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    
class PolygonOps:
    """
    None
    """

    @staticmethod
    def Area(xy: MSPyBentleyGeom.DPoint2dArray) -> float:
        ...
    
    @staticmethod
    def AreaNormal(*args, **kwargs):
        """
        Overloaded function.
        
        1. AreaNormal(xyz: MSPyBentleyGeom.DPoint3dArray) -> MSPyBentleyGeom.DVec3d
        
        2. AreaNormal(xyz: MSPyBentleyGeom.DPoint3dArray, n: int) -> MSPyBentleyGeom.DVec3d
        """
        ...
    
    @staticmethod
    def AreaPerpendicularToUpVector(xyz: MSPyBentleyGeom.DPoint3dArray, unitPerpendicular: MSPyBentleyGeom.DVec3d) -> float:
        ...
    
    @staticmethod
    def AreaXY(xyz: MSPyBentleyGeom.DPoint3dArray) -> float:
        ...
    
    @staticmethod
    def CentroidNormalAndArea(xyz: MSPyBentleyGeom.DPoint3dArray, centroid: MSPyBentleyGeom.DPoint3d, normal: MSPyBentleyGeom.DVec3d) -> tuple:
        ...
    
    @staticmethod
    def CoordinateFrame(*args, **kwargs):
        """
        Overloaded function.
        
        1. CoordinateFrame(pXYZIn: MSPyBentleyGeom.DPoint3dArray, localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform) -> bool
        
        2. CoordinateFrame(pXYZIn: MSPyBentleyGeom.DPoint3dArray, localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform, selector: MSPyBentleyGeom.LocalCoordinateSelect) -> bool
        """
        ...
    
    @staticmethod
    def CoordinateFrameAndRank(pXYZIn: MSPyBentleyGeom.DPoint3dArray, localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform, selector: MSPyBentleyGeom.LocalCoordinateSelect) -> int:
        ...
    
    @staticmethod
    def FixupAndTriangulateLoopsXY(pIndices: MSPyBentleyGeom.Int32Array, pExteriorLoopIndices: MSPyBentleyGeom.Int32Array, pXYZOut: MSPyBentleyGeom.DPoint3dArray, pXYZIn: MSPyBentleyGeom.DPoint3dArray, xyTolerance: float, maxPerFace: int, signedOneBasedIndices: bool, addVerticesAtCrossings: bool) -> bool:
        ...
    
    @staticmethod
    def FixupAndTriangulateProjectedLoops(*args, **kwargs):
        """
        Overloaded function.
        
        1. FixupAndTriangulateProjectedLoops(pIndices: MSPyBentleyGeom.Int32Array, pExteriorLoopIndices: MSPyBentleyGeom.Int32Array, pXYZOut: MSPyBentleyGeom.DPoint3dArray, localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform, pXYZIn: MSPyBentleyGeom.DPoint3dArray, xyTolerance: float, bSignedOneBasedIndices: bool) -> bool
        
        2. FixupAndTriangulateProjectedLoops(loops: MSPyBentleyGeom.DPoint3dVecArray, extraPoints: MSPyBentleyGeom.DPoint3dArray, extraChains: MSPyBentleyGeom.DPoint3dVecArray, localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform, triangles: MSPyBentleyGeom.DTriangle3dArray) -> bool
        
        3. FixupAndTriangulateProjectedLoops(loops: MSPyBentleyGeom.DPoint3dVecArray, localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform, triangles: MSPyBentleyGeom.DTriangle3dArray) -> bool
        """
        ...
    
    @staticmethod
    def FixupAndTriangulateProjectedLoopsWithSplits(masterLoop: MSPyBentleyGeom.DPoint3dArray, extraSegments: MSPyBentleyGeom.DSegment3dArray, localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform, triangulate: bool, leftOfSplit: MSPyBentleyGeom.PolyfaceHeader, leftOfSplitReversed: MSPyBentleyGeom.PolyfaceHeader, rightOfSplit: MSPyBentleyGeom.PolyfaceHeader, rightOfSplitReversed: MSPyBentleyGeom.PolyfaceHeader, ambiguous: MSPyBentleyGeom.PolyfaceHeader) -> bool:
        ...
    
    @staticmethod
    def FixupAndTriangulateSpaceLoops(*args, **kwargs):
        """
        Overloaded function.
        
        1. FixupAndTriangulateSpaceLoops(pIndices: MSPyBentleyGeom.Int32Array, pExteriorLoopIndices: MSPyBentleyGeom.Int32Array, pXYZOut: MSPyBentleyGeom.DPoint3dArray, localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform, pXYZIn: MSPyBentleyGeom.DPoint3dArray, xyTolerance: float, bSignedOneBasedIndices: bool) -> bool
        
        2. FixupAndTriangulateSpaceLoops(triangleIndices: MSPyBentleyGeom.Int32Array, exteriorLoopIndices: MSPyBentleyGeom.Int32Array, xyzOut: MSPyBentleyGeom.DPoint3dArray, localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform, loops: MSPyBentleyGeom.DPoint3dVecArray) -> bool
        
        3. FixupAndTriangulateSpaceLoops(loops: MSPyBentleyGeom.DPoint3dVecArray, triangles: MSPyBentleyGeom.DTriangle3dArray) -> bool
        """
        ...
    
    @staticmethod
    def IsConvex(xyz: MSPyBentleyGeom.DPoint3dArray) -> bool:
        ...
    
    @staticmethod
    def IsPointInConvexPolygon(xy: MSPyBentleyGeom.DPoint2d, points: MSPyBentleyGeom.DPoint2dArray, sense: int = 0) -> bool:
        ...
    
    @staticmethod
    def IsPointInOrOnXYTriangle(xyz: MSPyBentleyGeom.DPoint3d, point0: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d) -> bool:
        ...
    
    @staticmethod
    def PickTriangleFromStart(*args, **kwargs):
        """
        Overloaded function.
        
        1. PickTriangleFromStart(pXYZ: MSPyBentleyGeom.DPoint3dArray, ray: MSPyBentleyGeom.DRay3d, xyz: MSPyBentleyGeom.DPoint3d, triangleFractions: MSPyBentleyGeom.DPoint3d) -> tuple
        
        2. PickTriangleFromStart(xyPoints: MSPyBentleyGeom.DPoint2dArray, xy: MSPyBentleyGeom.DPoint2d, edgeBaseIndex: int, uvw: MSPyBentleyGeom.DPoint3d, duvwdX: MSPyBentleyGeom.DPoint3d, duvwdY: MSPyBentleyGeom.DPoint3d) -> bool
        """
        ...
    
    @staticmethod
    def PlaneIntersectionPoints(points: MSPyBentleyGeom.DPoint3dArray, plane: MSPyBentleyGeom.DPlane3d, touchTolerance: float, trueCrossings: MSPyBentleyGeom.CurveLocationDetailArray, touchData: MSPyBentleyGeom.CurveLocationDetailArray, altitudeLimits: MSPyBentleyGeom.DRange1d) -> PlanePolygonSSICode:
        ...
    
    @staticmethod
    def PointPolygonParity(point: MSPyBentleyGeom.DPoint2d, polygonPoints: MSPyBentleyGeom.DPoint2dArray, tol: float) -> int:
        ...
    
    @staticmethod
    def ReorientTriangulationIndices(indices: MSPyBentleyGeom.Int32Array, bSignedOneBasedIndices: bool) -> tuple:
        ...
    
    @staticmethod
    def ReverseForPreferedNormal(xyz: MSPyBentleyGeom.DPoint3dArray, positiveDirection: MSPyBentleyGeom.DVec3d) -> bool:
        ...
    
    @staticmethod
    def SplitToConvexPartsXY(indices: MSPyBentleyGeom.Int32Array, xyzOut: MSPyBentleyGeom.DPoint3dArray, xyzIn: MSPyBentleyGeom.DPoint3dArray, xyTol: float = -1.0) -> int:
        ...
    
    def __init__(*args, **kwargs):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    
class PolylineOps:
    """
    None
    """

    @staticmethod
    def AddStrokes(points: MSPyBentleyGeom.DPoint3dArray, strokes: MSPyBentleyGeom.DPoint3dArray, options: MSPyBentleyGeom.IFacetOptions, includeStartPoint: bool = True, startFraction: float = 0.0, endFraction: float = 1.0) -> bool:
        ...
    
    @staticmethod
    def CollectIntersectionsAndCloseApproachesXY(xyzA: MSPyBentleyGeom.DPoint3dArray, paramA: MSPyBentleyGeom.DoubleArray, xyzB: MSPyBentleyGeom.DPoint3dArray, paramB: MSPyBentleyGeom.DoubleArray, locationA: MSPyBentleyGeom.CurveLocationDetailArray, locationB: MSPyBentleyGeom.CurveLocationDetailArray, maxDist: float) -> bool:
        ...
    
    @staticmethod
    def CompressByChordError(result: MSPyBentleyGeom.DPoint3dArray, source: MSPyBentleyGeom.DPoint3dArray, chordTolerance: float) -> None:
        ...
    
    @staticmethod
    def GreedyTriangulationBetweenLinestrings(*args, **kwargs):
        """
        Overloaded function.
        
        1. GreedyTriangulationBetweenLinestrings(linestringA: MSPyBentleyGeom.DPoint3dArray, lingstringB: MSPyBentleyGeom.DPoint3dArray, triangles: MSPyBentleyGeom.DTriangle3dArray, oneBasedABIndex: MSPyBentleyGeom.Int32Array = None) -> None
        
        2. GreedyTriangulationBetweenLinestrings(linestringA: MSPyBentleyGeom.DPoint3dArray, lingstringB: MSPyBentleyGeom.DPoint3dArray, triangles: MSPyBentleyGeom.DTriangle3dArray, oneBasedABIndex: MSPyBentleyGeom.Int32Array, planarityAngle: MSPyBentleyGeom.Angle) -> None
        """
        ...
    
    @staticmethod
    def IsColinear(points: MSPyBentleyGeom.DPoint3dArray, absTol: float = 0, relTol: float = 0) -> bool:
        ...
    
    @staticmethod
    def Length(*args, **kwargs):
        """
        Overloaded function.
        
        1. Length(xyz: MSPyBentleyGeom.DPoint3dArray, addClosure: bool = False) -> float
        
        2. Length(worldToLocal: MSPyBentleyGeom.RotMatrix, xyz: MSPyBentleyGeom.DPoint3dArray, addClosure: bool = False) -> float
        """
        ...
    
    @staticmethod
    def SetPolylinePolylineHeapTrigger(mn: int) -> None:
        ...
    
    def __init__(*args, **kwargs):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    
class RefCountedMSBsplineCurve:
    """
    None
    """

    def AddArcIntersectionsXY(self: MSPyBentleyGeom.MSBsplineCurve, curvePoints: MSPyBentleyGeom.DPoint3dArray, curveFractions: MSPyBentleyGeom.DoubleArray, ellipsePoints: MSPyBentleyGeom.DPoint3dArray, ellipseFractions: MSPyBentleyGeom.DoubleArray, arc: MSPyBentleyGeom.DEllipse3d, extendConic: bool, matrix: MSPyBentleyGeom.DMatrix4d) -> None:
        ...
    
    def AddCurveIntersectionsXY(self: MSPyBentleyGeom.MSBsplineCurve, curveAPoints: MSPyBentleyGeom.DPoint3dArray, curveAFractions: MSPyBentleyGeom.DoubleArray, curveBPoints: MSPyBentleyGeom.DPoint3dArray, curveBFractions: MSPyBentleyGeom.DoubleArray, curveB: MSPyBentleyGeom.MSBsplineCurve, matrix: MSPyBentleyGeom.DMatrix4d) -> None:
        ...
    
    def AddCusps(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, fractionParameters: MSPyBentleyGeom.DoubleArray) -> None:
        """
        Find full 3d cusps.
        
        :param (output):
        points array to receive xyz of cusps.
        
        :param (output):
        fractionParameters array to receive fraction parameters of cusps.
        """
        ...
    
    def AddCuspsXY(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, fractionParameters: MSPyBentleyGeom.DoubleArray, matrix: MSPyBentleyGeom.DMatrix4d) -> None:
        """
        Find full cusps as viewed in xy.
        
        :param (output):
        points array to receive xyz of cusps.
        
        :param (output):
        fractionParameters array to receive fraction parameters of cusps.
        
        :param (input):
        matrix optional transformation into viewing space.
        """
        ...
    
    def AddKnot(self: MSPyBentleyGeom.MSBsplineCurve, unnormalizedKnotValue: float, newMultiplicity: int) -> int:
        """
        Add a given knot value to the B-spline curve. that newMultiplicity is
        the desired final multiplicity of a knot that may already exist.
        """
        ...
    
    def AddLineIntersectionsXY(*args, **kwargs):
        """
        Overloaded function.
        
        1. AddLineIntersectionsXY(self: MSPyBentleyGeom.MSBsplineCurve, curvePoints: MSPyBentleyGeom.DPoint3dArray, curveFractions: MSPyBentleyGeom.DoubleArray, linePoints: MSPyBentleyGeom.DPoint3dArray, lineFractions: MSPyBentleyGeom.DoubleArray, segment: MSPyBentleyGeom.DSegment3d, extendSegment: bool, matrix: MSPyBentleyGeom.DMatrix4d) -> None
        
        2. AddLineIntersectionsXY(self: MSPyBentleyGeom.MSBsplineCurve, curvePoints: MSPyBentleyGeom.DPoint3dArray, curveFractions: MSPyBentleyGeom.DoubleArray, linePoints: MSPyBentleyGeom.DPoint3dArray, lineFractions: MSPyBentleyGeom.DoubleArray, segment: MSPyBentleyGeom.DSegment3d, extendSegment0: bool, extendSegment1: bool, matrix: MSPyBentleyGeom.DMatrix4d) -> None
        """
        ...
    
    def AddLinestringIntersectionsXY(*args, **kwargs):
        """
        Overloaded function.
        
        1. AddLinestringIntersectionsXY(self: MSPyBentleyGeom.MSBsplineCurve, curveAPoints: MSPyBentleyGeom.DPoint3dArray, curveAFractions: MSPyBentleyGeom.DoubleArray, curveBPoints: MSPyBentleyGeom.DPoint3dArray, curveBFractions: MSPyBentleyGeom.DoubleArray, lineString: MSPyBentleyGeom.DPoint3dArray, matrix: MSPyBentleyGeom.DMatrix4d) -> None
        
        2. AddLinestringIntersectionsXY(self: MSPyBentleyGeom.MSBsplineCurve, curveAPoints: MSPyBentleyGeom.DPoint3dArray, curveAFractions: MSPyBentleyGeom.DoubleArray, curveBPoints: MSPyBentleyGeom.DPoint3dArray, curveBFractions: MSPyBentleyGeom.DoubleArray, lineString: MSPyBentleyGeom.DPoint3dArray, extendLineString: bool, matrix: MSPyBentleyGeom.DMatrix4d) -> None
        """
        ...
    
    def AddPlaneIntersections(*args, **kwargs):
        """
        Overloaded function.
        
        1. AddPlaneIntersections(self: MSPyBentleyGeom.MSBsplineCurve, point: MSPyBentleyGeom.DPoint3dArray, fractionParameters: MSPyBentleyGeom.DoubleArray, plane: MSPyBentleyGeom.DPlane3d) -> None
        
        2. AddPlaneIntersections(self: MSPyBentleyGeom.MSBsplineCurve, point: MSPyBentleyGeom.DPoint3dArray, fractionParameters: MSPyBentleyGeom.DoubleArray, planeCoeffs: MSPyBentleyGeom.DPoint4d) -> None
        """
        ...
    
    def AddRuleSurfaceRayIntersections(pickData: MSPyBentleyGeom.SolidLocationDetailArray, curveA: MSPyBentleyGeom.MSBsplineCurve, curveB: MSPyBentleyGeom.MSBsplineCurve, ray: MSPyBentleyGeom.DRay3d) -> bool:
        ...
    
    def AddStrokes(*args, **kwargs):
        """
        Overloaded function.
        
        1. AddStrokes(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, chordTol: float = 0.0, angleTol: float = 0.2, maxEdgeLength: float = 0.0, includeStartPoint: bool = True) -> None
        
        2. AddStrokes(self: MSPyBentleyGeom.MSBsplineCurve, points: list, chordTol: float = 0.0, angleTol: float = 0.2, maxEdgeLength: float = 0.0, includeStartPoint: bool = True) -> None
        
        3. AddStrokes(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, derivatives: MSPyBentleyGeom.DVec3dArray = None, params: MSPyBentleyGeom.DoubleArray = None, chordTol: float = 0.0, angleTol: float = 0.2, maxEdgeLength: float = 0.0, includeStartPoint: bool = True, parameterSelect: MSPyBentleyGeom.CurveParameterMapping = <CurveParameterMapping.eCURVE_PARAMETER_MAPPING_CurveKnot: 1>) -> None
        
        4. AddStrokes(self: MSPyBentleyGeom.MSBsplineCurve, points: list, derivatives: MSPyBentleyGeom.DVec3dArray = None, params: MSPyBentleyGeom.DoubleArray = None, chordTol: float = 0.0, angleTol: float = 0.2, c: float = 0.0, includeStartPoint: bool = True, parameterSelect: MSPyBentleyGeom.CurveParameterMapping = <CurveParameterMapping.eCURVE_PARAMETER_MAPPING_CurveKnot: 1>) -> None
        
        5. AddStrokes(self: MSPyBentleyGeom.MSBsplineCurve, options: MSPyBentleyGeom.IFacetOptions, points: MSPyBentleyGeom.DPoint3dArray, derivatives: MSPyBentleyGeom.DVec3dArray = None, params: MSPyBentleyGeom.DoubleArray = None, includeStart: bool = True) -> None
        
        6. AddStrokes(self: MSPyBentleyGeom.MSBsplineCurve, options: MSPyBentleyGeom.IFacetOptions, points: list, derivatives: MSPyBentleyGeom.DVec3dArray = None, params: MSPyBentleyGeom.DoubleArray = None, includeStart: bool = True) -> None
        
        7. AddStrokes(self: MSPyBentleyGeom.MSBsplineCurve, numPoints: int, points: MSPyBentleyGeom.DPoint3dArray, derivatives: MSPyBentleyGeom.DVec3dArray = None, params: MSPyBentleyGeom.DoubleArray = None, includeStartPoint: bool = True, parameterSelect: MSPyBentleyGeom.CurveParameterMapping = <CurveParameterMapping.eCURVE_PARAMETER_MAPPING_CurveKnot: 1>) -> None
        
        8. AddStrokes(self: MSPyBentleyGeom.MSBsplineCurve, numPoints: int, points: list, derivatives: MSPyBentleyGeom.DVec3dArray = None, params: MSPyBentleyGeom.DoubleArray = None, includeStartPoint: bool = True, parameterSelect: MSPyBentleyGeom.CurveParameterMapping = <CurveParameterMapping.eCURVE_PARAMETER_MAPPING_CurveKnot: 1>) -> None
        """
        ...
    
    def AdvanceToBezierInFractionInterval(self: MSPyBentleyGeom.MSBsplineCurve, segment: MSPyBentleyGeom.BCurveSegment, interval: MSPyBentleyGeom.DRange1d) -> tuple:
        ...
    
    def AdvanceToBezierInKnotInterval(self: MSPyBentleyGeom.MSBsplineCurve, segment: MSPyBentleyGeom.BCurveSegment, bezierSelect: int, interval: MSPyBentleyGeom.DRange1d) -> tuple:
        ...
    
    def AllParallellTangentsXY(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, fractions: MSPyBentleyGeom.DoubleArray, vector: MSPyBentleyGeom.DVec3d) -> None:
        """
        Find all curve points X where the tangents is parallel to the given
        vector.
        
        :param (output):
        points array to receive points.
        
        :param (output):
        fractions array to receive fraction parameters.
        
        :param (input):
        vector given direction.
        """
        ...
    
    def AllTangents(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, fractions: MSPyBentleyGeom.DoubleArray, spacePoint: MSPyBentleyGeom.DPoint3d) -> None:
        """
        For space point Q, find all curve points X where line XQ is tangent to
        the curve.
        
        :param (output):
        points array to receive points.
        
        :param (output):
        fractions array to receive fraction parameters.
        
        :param (input):
        spacePoint space point.
        """
        ...
    
    def AllTangentsXY(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, fractions: MSPyBentleyGeom.DoubleArray, spacePoint: MSPyBentleyGeom.DPoint3d, matrix: MSPyBentleyGeom.DMatrix4d) -> None:
        """
        For space point Q (spacePoint), find all curve points X where line XQ
        is tangent to the curve.
        
        :param (output):
        points array to receive points.
        
        :param (output):
        fractions array to receive fraction parameters.
        
        :param (input):
        spacePoint space point.
        
        :param (input):
        matrix optional transformation into viewing space.
        """
        ...
    
    def Allocate(*args, **kwargs):
        """
        Overloaded function.
        
        1. Allocate(self: MSPyBentleyGeom.MSBsplineCurve) -> int
        
        Allocate memory arrays to match the current counts.
        
        2. Allocate(self: MSPyBentleyGeom.MSBsplineCurve, numPoles: int, order: int, closed: bool, rational: bool) -> int
        
        Allocate memory arrays to match the current counts.
        """
        ...
    
    def AllocateKnots(self: MSPyBentleyGeom.MSBsplineCurve, count: int, data: float = None) -> int:
        """
        <summary>Allocate knot pointer to specified count. (Optionally)copy
        data from callers buffer</summary
        """
        ...
    
    def AllocatePoles(self: MSPyBentleyGeom.MSBsplineCurve, count: int, data: MSPyBentleyGeom.DPoint3d = None) -> int:
        """
        <summary>Allocate pole pointer to specified count. (Optionally)copy
        data from callers buffer</summary
        """
        ...
    
    def AllocateWeights(self: MSPyBentleyGeom.MSBsplineCurve, count: int, data: float = None) -> int:
        """
        <summary>Allocate weight pointer to specified count. (Optionally)copy
        data from callers buffer</summary
        """
        ...
    
    def AlmostEqual(*args, **kwargs):
        """
        Overloaded function.
        
        1. AlmostEqual(self: MSPyBentleyGeom.MSBsplineCurve, other: MSPyBentleyGeom.MSBsplineCurve) -> bool
        
        Compare curves.
        
        2. AlmostEqual(self: MSPyBentleyGeom.MSBsplineCurve, other: MSPyBentleyGeom.MSBsplineCurve, tolerance: float) -> bool
        
        Compare curves.
        """
        ...
    
    def AppendCurve(self: MSPyBentleyGeom.MSBsplineCurve, inCurve: MSPyBentleyGeom.MSBsplineCurve) -> int:
        """
        Change the B-spline curve by appending a given curve.
        """
        ...
    
    def AppendCurves(self: MSPyBentleyGeom.MSBsplineCurve, inCurve1: MSPyBentleyGeom.MSBsplineCurve, inCurve2: MSPyBentleyGeom.MSBsplineCurve, forceContinuity: bool, reparam: bool) -> int:
        """
        Create the B-spline curve by appending two input curves with
        continuity and reparameterization constraints.
        """
        ...
    
    def ApproximateAnyCurve(self: MSPyBentleyGeom.MSBsplineCurve, inCurve: MSPyBentleyGeom.MSBsplineCurve, tolerance: float, order: int, parameterization: int, bMaintainEndTangents: bool) -> int:
        """
        This routine computes a B-spline curve approximated the old one.
        return ERROR if no results.
        
        :param (input):
        pIn Input G1 curve.
        
        :param (input):
        tolerance Geometric tolerance, this should be in general the chord
        height tol.
        
        :param (input):
        order Desired degree of the pOut, 4 is recommended.
        
        :param (input):
        parametrization CHORDLENGTH = 2, CENTRIPETAL = 3.
        
        :param (input):
        bMaintainEndTangents true to maintain the end tangents.
        """
        ...
    
    def ApproximateG1Curve(outCurve: MSPyBentleyGeom.MSBsplineCurve, inCurve: MSPyBentleyGeom.MSBsplineCurve, degree: int, keepTangent: bool, parametrization: int, geomTol: float, paramTol: float, pointTol: float) -> int:
        ...
    
    def ApproximateNurbsCurve(outCurve: MSPyBentleyGeom.MSBsplineCurve, inCurve: MSPyBentleyGeom.MSBsplineCurve, degree: int, keepTangent: bool, parametrization: int, tol: float) -> int:
        ...
    
    def AreCompatible(curveA: MSPyBentleyGeom.MSBsplineCurve, curveB: MSPyBentleyGeom.MSBsplineCurve) -> bool:
        """
        <summary>Test if two curves have compatible knots, order, and pole
        count</summary
        """
        ...
    
    def AreKnotsValid(self: MSPyBentleyGeom.MSBsplineCurve, clampingRequired: bool = True) -> bool:
        """
        Return false if knot counts or values are invalid.
        """
        ...
    
    def AreSameKnots(knot0: float, knot1: float) -> bool:
        """
        Compare knots. Absolute tolerance 1e-8 for knots in -1..1. Relative
        tolerance 1e-8 outside.
        """
        ...
    
    def AreSameWeights(w0: float, w1: float) -> bool:
        """
        Compare weights with arbitrary but consistent tolerance.
        """
        ...
    
    def CleanKnots(self: MSPyBentleyGeom.MSBsplineCurve) -> int:
        """
        Clean all unnecessary knots.
        """
        ...
    
    def ClosestPoint(self: MSPyBentleyGeom.MSBsplineCurve, curvePoint: MSPyBentleyGeom.DPoint3d, spacePoint: MSPyBentleyGeom.DPoint3d) -> float:
        ...
    
    def ClosestPointXY(self: MSPyBentleyGeom.MSBsplineCurve, curvePoint: MSPyBentleyGeom.DPoint3d, spacePoint: MSPyBentleyGeom.DPoint3d, viewMatrix: MSPyBentleyGeom.DMatrix4d) -> tuple:
        ...
    
    def ClosestTangent(self: MSPyBentleyGeom.MSBsplineCurve, curvePoint: MSPyBentleyGeom.DPoint3d, spacePoint: MSPyBentleyGeom.DPoint3d, biasPoint: MSPyBentleyGeom.DPoint3d) -> tuple:
        ...
    
    def ClosestTangentXY(self: MSPyBentleyGeom.MSBsplineCurve, curvePoint: MSPyBentleyGeom.DPoint3d, spacePoint: MSPyBentleyGeom.DPoint3d, biasPoint: MSPyBentleyGeom.DPoint3d, matrix: MSPyBentleyGeom.DMatrix4d) -> tuple:
        ...
    
    def CompressKnots(inKnot: MSPyBentleyGeom.DoubleArray, order: int, outKnot: MSPyBentleyGeom.DoubleArray, multiplicities: MSPyBentleyGeom.UInt64Array) -> tuple:
        ...
    
    def ComputeDerivatives(self: MSPyBentleyGeom.MSBsplineCurve, arg0: MSPyBentleyGeom.DVec3dArray, arg1: int, arg2: float) -> None:
        ...
    
    def ComputeGrevilleAbscissa(self: MSPyBentleyGeom.MSBsplineCurve, averageKnots: MSPyBentleyGeom.DoubleArray = True) -> None:
        ...
    
    def ComputeInflectionPoints(*args, **kwargs):
        """
        Overloaded function.
        
        1. ComputeInflectionPoints(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, params: MSPyBentleyGeom.DoubleArray) -> int
        
        Calculate the parameters and location of the all inflection points of
        a B-spline curve. @DotNetMethodExclude
        
        2. ComputeInflectionPoints(self: MSPyBentleyGeom.MSBsplineCurve, points: list, params: MSPyBentleyGeom.DoubleArray) -> None
        
        Calculate the parameters and location of the all inflection points of
        a B-spline curve. @DotNetMethodExclude
        """
        ...
    
    def ComputeInflectionPointsXY(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, params: MSPyBentleyGeom.DoubleArray, transform: RotMatrix) -> int:
        """
        Calculate the parameters and location of the all inflection points of
        a B-spline curve.
        """
        ...
    
    def ComputeUniformKnotGrevilleAbscissa(averageKnots: MSPyBentleyGeom.DoubleArray, numInterval: int, order: int) -> None:
        ...
    
    def ComputeUniformKnots(self: MSPyBentleyGeom.MSBsplineCurve) -> bool:
        """
        Compute uniformly spaced knots. This uses counts from params.
        
        :returns:
        false if param counts are not set.
        """
        ...
    
    def CopyClosed(self: MSPyBentleyGeom.MSBsplineCurve, source: MSPyBentleyGeom.MSBsplineCurve) -> int:
        """
        Create B-spline curve by closing a open B-spline curve.
        """
        ...
    
    def CopyFractionSegment(self: MSPyBentleyGeom.MSBsplineCurve, source: MSPyBentleyGeom.MSBsplineCurve, fractionA: float, fractionB: float) -> int:
        """
        Create B-spline curve by extracting a part of a B-spline curve.
        """
        ...
    
    def CopyFrom(self: MSPyBentleyGeom.MSBsplineCurve, source: MSPyBentleyGeom.MSBsplineCurve) -> int:
        ...
    
    def CopyOpen(self: MSPyBentleyGeom.MSBsplineCurve, source: MSPyBentleyGeom.MSBsplineCurve, unnormalizedKnot: float) -> int:
        """
        Create B-spline curve by opening a closed B-spline curve.
        """
        ...
    
    def CopyReversed(self: MSPyBentleyGeom.MSBsplineCurve, source: MSPyBentleyGeom.MSBsplineCurve) -> int:
        """
        Create B-spline curve by reserving the direction of a B-spline curve.
        """
        ...
    
    def CopySegment(self: MSPyBentleyGeom.MSBsplineCurve, source: MSPyBentleyGeom.MSBsplineCurve, unnormalizedKnotA: float, unnormalizedKnotB: float) -> int:
        """
        Create B-spline curve by extracting a part of a B-spline curve.
        """
        ...
    
    def CopyTransformed(self: MSPyBentleyGeom.MSBsplineCurve, source: MSPyBentleyGeom.MSBsplineCurve, transform: Transform) -> int:
        """
        Create B-spline curve by transforming a B-spline curve.
        """
        ...
    
    def CountDistinctBeziers(self: MSPyBentleyGeom.MSBsplineCurve) -> int:
        """
        Count the number of beziers that have non-null knot intervals.
        """
        ...
    
    def Create() -> MSPyBentleyGeom.RefCountedMSBsplineCurve:
        ...
    
    def CreateCapture(self: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.RefCountedMSBsplineCurve:
        """
        <summary>Copy bits into smart pointer. Caller instance zeroed
        out.<summary
        """
        ...
    
    def CreateCopy(self: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.RefCountedMSBsplineCurve:
        """
        <summary>Return copy as smart pointer target.</summary
        """
        ...
    
    def CreateCopyBetweenFractions(self: MSPyBentleyGeom.MSBsplineCurve, fraction0: float, fraction1: float) -> MSPyBentleyGeom.RefCountedMSBsplineCurve:
        """
        <summary>Copy the portion between specified fractions.</summary
        """
        ...
    
    def CreateCopyBetweenKnots(self: MSPyBentleyGeom.MSBsplineCurve, konot0: float, knot1: float) -> MSPyBentleyGeom.RefCountedMSBsplineCurve:
        """
        <summary>Copy the portion between specified knots.</summary
        """
        ...
    
    def CreateCopyBezier(self: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.RefCountedMSBsplineCurve:
        """
        <summary>Copy with all knots saturated.</summary
        """
        ...
    
    def CreateCopyClosed(self: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.RefCountedMSBsplineCurve:
        """
        <summary>Return copy as smart pointer target; if physically closed
        revise poles to be a closed bspline</summary
        """
        ...
    
    def CreateCopyOffsetXY(self: MSPyBentleyGeom.MSBsplineCurve, offset0: float, offset1: float, options: MSPyBentleyGeom.CurveOffsetOptions) -> MSPyBentleyGeom.RefCountedMSBsplineCurve:
        """
        <summary>Copy with offset in XY plane.</summary
        """
        ...
    
    def CreateCopyOpenAtFraction(self: MSPyBentleyGeom.MSBsplineCurve, fraction: float) -> MSPyBentleyGeom.RefCountedMSBsplineCurve:
        """
        <summary>Return copy as smart pointer target; if closed, open it at
        fraction.</summary
        """
        ...
    
    def CreateCopyOpenAtKnot(self: MSPyBentleyGeom.MSBsplineCurve, knot: float) -> MSPyBentleyGeom.RefCountedMSBsplineCurve:
        """
        <summary>Return copy as smart pointer target; if closed, open it at
        knot.</summary
        """
        ...
    
    def CreateCopyReversed(self: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.RefCountedMSBsplineCurve:
        """
        <summary>Complete copy with reversed parameterization.</summary
        """
        ...
    
    def CreateCopyTransformed(self: MSPyBentleyGeom.MSBsplineCurve, transform: Transform) -> MSPyBentleyGeom.RefCountedMSBsplineCurve:
        """
        <summary>Copy with transform applied to poles.</summary
        """
        ...
    
    def CreateFromInterpolationAtBasisFunctionPeaks(xyz: MSPyBentleyGeom.DPoint3dArray, order: int, selector: int = 0) -> MSPyBentleyGeom.RefCountedMSBsplineCurve:
        ...
    
    def CreateFromInterpolationAtGrevilleKnots(curve: MSPyBentleyGeom.ICurvePrimitive, numPoles: int, order: int, normalizeKnots: bool, knotSelector: int = 0) -> MSPyBentleyGeom.RefCountedMSBsplineCurve:
        ...
    
    def CreateFromInterpolationPointsWithKnots(xyz: MSPyBentleyGeom.DPoint3dArray, interpolationKnots: MSPyBentleyGeom.DoubleArray, curveKnots: MSPyBentleyGeom.DoubleArray, order: int) -> MSPyBentleyGeom.RefCountedMSBsplineCurve:
        ...
    
    def CreateFromPointsAndOrder(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateFromPointsAndOrder(self: MSPyBentleyGeom.MSBsplineCurve, pointArray: MSPyBentleyGeom.DPoint3dArray, order: int, closed: bool = False) -> int
        
        Create the B-spline curve from point array and order.
        
        2. CreateFromPointsAndOrder(self: MSPyBentleyGeom.MSBsplineCurve, pointArray: list, order: int, closed: bool = False) -> int
        
        Create the B-spline curve from point array and order.
        """
        ...
    
    def CreateFromPolesAndOrder(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateFromPolesAndOrder(poles: MSPyBentleyGeom.DPoint3dArray, weights: MSPyBentleyGeom.DoubleArray, knots: MSPyBentleyGeom.DoubleArray, order: int, closed: bool, inputPolesAlreadyWeighted: bool = True) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        
        2. CreateFromPolesAndOrder(poles: list, weights: MSPyBentleyGeom.DoubleArray, knots: MSPyBentleyGeom.DoubleArray, order: int, closed: bool, inputPolesAlreadyWeighted: bool = True) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        
        3. CreateFromPolesAndOrder(poles: MSPyBentleyGeom.DPoint3dArray, order: int, closed: bool = True) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        
        4. CreateFromPolesAndOrder(poles: list, order: int, closed: bool = True) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        
        5. CreateFromPolesAndOrder(poles: MSPyBentleyGeom.DPoint2dArray, order: int, closed: bool = True) -> MSPyBentleyGeom.RefCountedMSBsplineCurve
        """
        ...
    
    def CreateInterpolationBetweenCurves(curveA: MSPyBentleyGeom.MSBsplineCurve, fraction: float, curveB: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.RefCountedMSBsplineCurve:
        """
        <summary>Create a curve whose poles are interpolated between the poles
        of two curves.</summary> <remarks>This will only succeed if the curves
        have the same pole, knot, and order structure</remarks
        """
        ...
    
    @property
    def CurveDisplay(arg0: MSPyBentleyGeom.MSBsplineCurve) -> bool:
        ...
    @CurveDisplay.setter
    def CurveDisplay(arg0: MSPyBentleyGeom.MSBsplineCurve, arg1: bool) -> None:
        ...
    
    def ElevateDegree(self: MSPyBentleyGeom.MSBsplineCurve, newDegree: int) -> int:
        """
        Elevate the degree (increases the order) of the B-spline curve.
        """
        ...
    
    def ExtractCurveNormal(self: MSPyBentleyGeom.MSBsplineCurve, normal: MSPyBentleyGeom.DVec3d, position: MSPyBentleyGeom.DPoint3d) -> tuple:
        ...
    
    def ExtractEndPoints(self: MSPyBentleyGeom.MSBsplineCurve, start: MSPyBentleyGeom.DPoint3d, end: MSPyBentleyGeom.DPoint3d) -> None:
        """
        Extract the start or end point of the B-spline curve.
        """
        ...
    
    def ExtractSegmentBetweenKnots(self: MSPyBentleyGeom.MSBsplineCurve, target: MSPyBentleyGeom.MSBsplineCurve, unnormalizedKnotA: float, unnormalizedKnotB: float) -> int:
        """
        Exteact the curve from the B-spline curve at the interval
        [unnormalizedKnotA, unnormalizedKnotB].
        """
        ...
    
    def ExtractTo(self: MSPyBentleyGeom.MSBsplineCurve, dest: MSPyBentleyGeom.MSBsplineCurve) -> None:
        """
        Copy bits into simple structure. Caller instance zeroed.
        """
        ...
    
    def FindKnotInterval(self: MSPyBentleyGeom.MSBsplineCurve, knotValue: float) -> int:
        """
        Return the index of the knot at the left of the interval containing
        specified knot. When knotValue exactly matches a knot, the returned
        index is of the knot to the left - i.e. knotValue appears at the RIGHT
        of the returned interval. (favor knot[index]<knotValue <= knot[index
        + 1])
        """
        ...
    
    def FractionAtSignedDistance(*args, **kwargs):
        """
        Overloaded function.
        
        1. FractionAtSignedDistance(self: MSPyBentleyGeom.MSBsplineCurve, startParam: float, signedDistance: float) -> tuple
        
        2. FractionAtSignedDistance(self: MSPyBentleyGeom.MSBsplineCurve, worldToLocal: RotMatrix, startParam: float, signedDistance: float) -> tuple
        """
        ...
    
    def FractionToKnot(self: MSPyBentleyGeom.MSBsplineCurve, f: float) -> float:
        """
        Return the knot value at a fractional parameter ...
        """
        ...
    
    def FractionToPoint(*args, **kwargs):
        """
        Overloaded function.
        
        1. FractionToPoint(self: MSPyBentleyGeom.MSBsplineCurve, xyz: MSPyBentleyGeom.DPoint3d, f: float) -> None
        
        2. FractionToPoint(self: MSPyBentleyGeom.MSBsplineCurve, xyz: MSPyBentleyGeom.DPoint3d, tangent: MSPyBentleyGeom.DVec3d, f: float) -> None
        
        3. FractionToPoint(self: MSPyBentleyGeom.MSBsplineCurve, xyz: MSPyBentleyGeom.DPoint3d, tangent: MSPyBentleyGeom.DVec3d, f: float) -> float
        
        4. FractionToPoint(self: MSPyBentleyGeom.MSBsplineCurve, xyz: MSPyBentleyGeom.DPoint3d, dXYZ: MSPyBentleyGeom.DVec3d, ddXYZ: MSPyBentleyGeom.DVec3d, f: float) -> None
        
        5. FractionToPoint(self: MSPyBentleyGeom.MSBsplineCurve, points: list, numPoints: int) -> None
        
        6. FractionToPoint(self: MSPyBentleyGeom.MSBsplineCurve, points: list, fractions: MSPyBentleyGeom.DoubleArray) -> None
        """
        ...
    
    def FractionToPoints(*args, **kwargs):
        """
        Overloaded function.
        
        1. FractionToPoints(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, numPoints: int) -> None
        
        2. FractionToPoints(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, fractions: MSPyBentleyGeom.DoubleArray) -> None
        """
        ...
    
    def GeneralLeastSquaresApproximation(outCurve: MSPyBentleyGeom.MSBsplineCurve, Q: MSPyBentleyGeom.DPoint3dArray, u: MSPyBentleyGeom.DoubleArray, knots: MSPyBentleyGeom.DoubleArray, numPoles: int, order: int) -> int:
        ...
    
    def GetBezier(self: MSPyBentleyGeom.MSBsplineCurve, segment: MSPyBentleyGeom.BCurveSegment, bezierSelect: int) -> bool:
        """
        Get poles for a single bezier poles from the curve. return false if
        invalid bezierSelect. Note that the bezierSelect for a high
        multiplicity knot returns true for the function but marks the interval
        as null. Normal usage is to loop over all beziers in a bspline but
        skip processing the null intervals.
        
        :param (output):
        segment a filled BCurveSegment.
        
        :param (input):
        bezierSelect selects a bezier interval within the bspline
        @DotNetMethodExclude
        """
        ...
    
    def GetC1DiscontinuousCurves(self: MSPyBentleyGeom.MSBsplineCurve, fractions: MSPyBentleyGeom.DoubleArray, curves: MSPyBentleyGeom.MSBsplineCurvePtrArray) -> None:
        """
        Create copies of each segment with breaks at point or tangent changes.
        """
        ...
    
    def GetC1DiscontinuousFractions(self: MSPyBentleyGeom.MSBsplineCurve, fractions: MSPyBentleyGeom.DoubleArray) -> None:
        """
        Get all C1 fractional Discontinuities. This inspects xyz and tangent
        at each knot break. (It does not look for intraknot cusps)
        @DotNetMethodExclude
        """
        ...
    
    def GetCurveDisplay(self: MSPyBentleyGeom.MSBsplineCurve) -> bool:
        """
        Return curve display flag.
        """
        ...
    
    def GetDisjointCurves(self: MSPyBentleyGeom.MSBsplineCurve, curves: MSPyBentleyGeom.MSBsplineCurvePtrArray) -> None:
        """
        Create copies of each segment with breaks at disjoint knot points.
        """
        ...
    
    def GetFrenetFrame(*args, **kwargs):
        """
        Overloaded function.
        
        1. GetFrenetFrame(self: MSPyBentleyGeom.MSBsplineCurve, frame: MSPyBentleyGeom.DVec3dArray, point: MSPyBentleyGeom.DPoint3d, u: float) -> tuple
        
        2. GetFrenetFrame(self: MSPyBentleyGeom.MSBsplineCurve, frame: Transform, u: float) -> int
        """
        ...
    
    def GetKnot(self: MSPyBentleyGeom.MSBsplineCurve, index: int) -> float:
        """
        return knot by index. returns 0 if out of range. (Use
        NumberAllocatedKnots to determine index range).
        """
        ...
    
    def GetKnotP(self: MSPyBentleyGeom.MSBsplineCurve) -> float:
        """
        return pointer to contiguous knots. @DotNetMethodExclude
        """
        ...
    
    def GetKnotRange(*args, **kwargs):
        """
        Overloaded function.
        
        1. GetKnotRange(self: MSPyBentleyGeom.MSBsplineCurve) -> tuple
        
        2. GetKnotRange(self: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.DSegment1d
        
        Return the knot values corresponding to fraction 0 and fraction 1 ...
        """
        ...
    
    def GetKnots(*args, **kwargs):
        """
        Overloaded function.
        
        1. GetKnots(self: MSPyBentleyGeom.MSBsplineCurve, outData: MSPyBentleyGeom.DoubleArray) -> None
        
        Copy all knots out into caller array.
        
        2. GetKnots(self: MSPyBentleyGeom.MSBsplineCurve, outData: MSPyBentleyGeom.DPoint4dArray) -> None
        
        Copy all knots out into caller array.
        """
        ...
    
    def GetNumKnots(self: MSPyBentleyGeom.MSBsplineCurve) -> int:
        ...
    
    def GetNumPoles(self: MSPyBentleyGeom.MSBsplineCurve) -> int:
        ...
    
    def GetOrder(self: MSPyBentleyGeom.MSBsplineCurve) -> int:
        ...
    
    def GetPole(self: MSPyBentleyGeom.MSBsplineCurve, index: int) -> MSPyBentleyGeom.DPoint3d:
        ...
    
    def GetPoleDPoint4d(self: MSPyBentleyGeom.MSBsplineCurve, index: int) -> MSPyBentleyGeom.DPoint4d:
        """
        return pole by index. returns 0 point if out of range. (Use
        NumberAllocatedPoles to determine index range). @DotNetMethodExclude
        """
        ...
    
    def GetPoleP(self: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.DPoint3d:
        """
        return pointer to contiguous poles. @DotNetMethodExclude
        """
        ...
    
    def GetPoleRange(self: MSPyBentleyGeom.MSBsplineCurve, range: MSPyBentleyGeom.DRange3d) -> None:
        """
        Get the range of the poles of the B-spline curve.
        """
        ...
    
    def GetPoles(self: MSPyBentleyGeom.MSBsplineCurve, outData: MSPyBentleyGeom.DPoint3dArray) -> None:
        """
        Copy all poles out into caller array.
        """
        ...
    
    def GetPolygonDisplay(self: MSPyBentleyGeom.MSBsplineCurve) -> bool:
        """
        Return polygon display flag.
        """
        ...
    
    def GetRange(self: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.DRange3d:
        """
        Get the range of the B-spline curve.
        """
        ...
    
    def GetRangeOfProjectionOnRay(self: MSPyBentleyGeom.MSBsplineCurve, ray: MSPyBentleyGeom.DRay3d, fraction0: float = 0.0, fraction1: float = 1.0) -> MSPyBentleyGeom.DRange1d:
        """
        Get the range of parameters of the projection of (a fractional portion
        of the curve onto a ray return range whose low and high values are the
        extreme parameters (in ray fractions) of the projection of the curve
        onto the ray.
        
        :param (input):
        ray ray to project to
        
        :param (input):
        fraction0 start of active part of the curve
        
        :param (input):
        fraction1 end of active part of the curve
        """
        ...
    
    def GetRemovalKnotBound(curve: MSPyBentleyGeom.MSBsplineCurve, r: int, s: int) -> float:
        """
        Compute the bound of remove r-th knot s times
        """
        ...
    
    def GetReversePole(self: MSPyBentleyGeom.MSBsplineCurve, index: int) -> MSPyBentleyGeom.DPoint3d:
        """
        return pole by index, counting from the last pole . (i.e. index 0 is
        the final weight) Returns 0 point if out of range. (Use
        NumberAllocatedPoles to determine index range). @DotNetMethodExclude
        """
        ...
    
    def GetReverseWeight(self: MSPyBentleyGeom.MSBsplineCurve, index: int) -> float:
        """
        return weight by index, counting from the last weight. (i.e. index 0
        is the final weight) Returns 1.0 if out of range. (Use
        NumberAllocatedPoles to determine index range). @DotNetMethodExclude
        """
        ...
    
    def GetStrokeCount(self: MSPyBentleyGeom.MSBsplineCurve, chordTol: float, angleTol: float, maxEdgeLength: float) -> int:
        """
        Compute stroke count
        """
        ...
    
    def GetTailBezierSelect(self: MSPyBentleyGeom.MSBsplineCurve) -> int:
        """
        return an index to use to start " Retreat " order bezier access.
        """
        ...
    
    def GetUnWeightedPole(self: MSPyBentleyGeom.MSBsplineCurve, index: int, reverse: bool = False) -> MSPyBentleyGeom.DPoint3d:
        """
        return pole by index. returns 0 point if out of range. If spline is
        weighted, the weight is divided out. If weight zero, no division
        happens. (Use NumberAllocatedPoles to determine index range).
        @DotNetMethodExclude
        """
        ...
    
    def GetUnWeightedPoles(self: MSPyBentleyGeom.MSBsplineCurve, outData: MSPyBentleyGeom.DPoint3dArray) -> None:
        """
        Copy all poles out into caller array, dividing each by its weight
        """
        ...
    
    def GetWeight(self: MSPyBentleyGeom.MSBsplineCurve, arg0: int) -> float:
        """
        index
        """
        ...
    
    def GetWeightP(self: MSPyBentleyGeom.MSBsplineCurve) -> float:
        """
        return pointer to contiguous weights @DotNetMethodExclude
        """
        ...
    
    def GetWeightRange(self: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.DRange1d:
        ...
    
    def GetWeights(self: MSPyBentleyGeom.MSBsplineCurve, outData: MSPyBentleyGeom.DoubleArray) -> None:
        """
        Copy all weights out into caller array.
        """
        ...
    
    def HasValidCountsAndAllocations(self: MSPyBentleyGeom.MSBsplineCurve) -> bool:
        ...
    
    def HasValidKnotAllocation(self: MSPyBentleyGeom.MSBsplineCurve) -> bool:
        ...
    
    def HasValidOrder(self: MSPyBentleyGeom.MSBsplineCurve) -> bool:
        ...
    
    def HasValidPoleAllocation(self: MSPyBentleyGeom.MSBsplineCurve) -> bool:
        ...
    
    def HasValidPoleCounts(self: MSPyBentleyGeom.MSBsplineCurve) -> bool:
        ...
    
    def HasValidWeightAllocation(self: MSPyBentleyGeom.MSBsplineCurve) -> bool:
        ...
    
    def HasWeights(self: MSPyBentleyGeom.MSBsplineCurve) -> bool:
        """
        Check whether the B-spline curve has stored weights (This does not
        check if any are other than 1.0)
        """
        ...
    
    def InitAkima(*args, **kwargs):
        """
        Overloaded function.
        
        1. InitAkima(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, compressPoints: bool) -> None
        
        2. InitAkima(self: MSPyBentleyGeom.MSBsplineCurve, points: list, compressPoints: bool) -> None
        """
        ...
    
    def InitEllipticArc(self: MSPyBentleyGeom.MSBsplineCurve, center: MSPyBentleyGeom.DPoint3d, rX: float, rY: float, startRadians: float = 0.0, sweepRadians: float = 6.283185307179586, axes: RotMatrix = None) -> int:
        ...
    
    def InitFromBeziers(self: MSPyBentleyGeom.MSBsplineCurve, beziers: MSPyBentleyGeom.MSBsplineCurveArray) -> int:
        """
        Create a B-spline curve from a series of Bezier curve.
        """
        ...
    
    def InitFromDEllipse3d(self: MSPyBentleyGeom.MSBsplineCurve, ellipse: MSPyBentleyGeom.DEllipse3d) -> int:
        """
        Initialize the B-spline curve for an ellipse.
        """
        ...
    
    def InitFromDPoint4dArray(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint4dArray, order: int) -> None:
        ...
    
    def InitFromGeneralLeastSquares(self: MSPyBentleyGeom.MSBsplineCurve, avgDistance: float, maxDistance: float, info: MSPyBentleyGeom.BsplineParam, knts: MSPyBentleyGeom.DoubleArray, pnts: MSPyBentleyGeom.DPoint3d, uValues: float, numPnts: int) -> int:
        ...
    
    def InitFromInterpolatePoints(*args, **kwargs):
        """
        Overloaded function.
        
        1. InitFromInterpolatePoints(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, parameterization: int, endControl: bool, sTangent: MSPyBentleyGeom.DVec3d, eTangent: MSPyBentleyGeom.DVec3d, keepTanMag: bool, order: int) -> None
        
        2. InitFromInterpolatePoints(self: MSPyBentleyGeom.MSBsplineCurve, points: list, parameterization: int, endControl: bool, sTangent: MSPyBentleyGeom.DVec3d, eTangent: MSPyBentleyGeom.DVec3d, keepTanMag: bool, order: int) -> None
        """
        ...
    
    def InitFromLeastSquaresFit(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3d, numPoints: int, endControl: bool, sTangent: MSPyBentleyGeom.DVec3d, eTangent: MSPyBentleyGeom.DVec3d, keepTanMag: bool, iterDegree: int, reqDegree: int, singleKnot: bool, tolerance: float) -> int:
        ...
    
    def InitFromPoints(*args, **kwargs):
        """
        Overloaded function.
        
        1. InitFromPoints(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray) -> None
        
        2. InitFromPoints(self: MSPyBentleyGeom.MSBsplineCurve, points: list) -> None
        """
        ...
    
    def IsClosed(self: MSPyBentleyGeom.MSBsplineCurve) -> bool:
        """
        Check whether the B-spline curve is periodic.
        """
        ...
    
    def IsParabola(self: MSPyBentleyGeom.MSBsplineCurve, localToWorld: Transform, worldToLocal: Transform, localStart: MSPyBentleyGeom.DPoint3d, localEnd: MSPyBentleyGeom.DPoint3d) -> tuple:
        ...
    
    def IsPhysicallyClosed(self: MSPyBentleyGeom.MSBsplineCurve, tolerance: float) -> bool:
        """
        Check whether the B-spline curve is physically closed. A B-spline
        curve may be non-periodic, but still return true if its first and last
        poles coincide.
        """
        ...
    
    def IsSameGeometry(self: MSPyBentleyGeom.MSBsplineCurve, other: MSPyBentleyGeom.MSBsplineCurve) -> bool:
        """
        Check if the B-spline curves has same parameters with the given curve.
        """
        ...
    
    class KnotPosition:
        """
        Members:
        
        eKNOTPOS_BEFORE_START
        
        eKNOTPOS_START
        
        eKNOTPOS_INTERVAL
        
        eKNOTPOS_INTERIOR
        
        eKNOTPOS_FINAL
        
        eKNOTPOS_AFTER_FINAL
        """
    
        def __init__(self: MSPyBentleyGeom.MSBsplineCurve.KnotPosition, value: int) -> None:
            ...
        
        eKNOTPOS_AFTER_FINAL: KnotPosition
        
        eKNOTPOS_BEFORE_START: KnotPosition
        
        eKNOTPOS_FINAL: KnotPosition
        
        eKNOTPOS_INTERIOR: KnotPosition
        
        eKNOTPOS_INTERVAL: KnotPosition
        
        eKNOTPOS_START: KnotPosition
        
        @property
        def name(self: handle) -> str:
            ...
        
        @property
        def value(arg0: MSPyBentleyGeom.MSBsplineCurve.KnotPosition) -> int:
            ...
        
    def KnotRefinement(X: MSPyBentleyGeom.DoubleArray, curve: MSPyBentleyGeom.MSBsplineCurve) -> int:
        ...
    
    def KnotToBlendFunctions(self: MSPyBentleyGeom.MSBsplineCurve, blend: float, blendDerivatives: float, u: float) -> int:
        ...
    
    def KnotToFraction(self: MSPyBentleyGeom.MSBsplineCurve, knot: float) -> float:
        """
        Return the fractional parameter corresponding to a knot value ...
        """
        ...
    
    def Length(*args, **kwargs):
        """
        Overloaded function.
        
        1. Length(self: MSPyBentleyGeom.MSBsplineCurve) -> float
        
        compute the length of the B-spline curve.
        
        2. Length(self: MSPyBentleyGeom.MSBsplineCurve, worldToLocal: RotMatrix) -> float
        
        compute the length of the B-spline curve.
        """
        ...
    
    def LengthBetweenFractions(*args, **kwargs):
        """
        Overloaded function.
        
        1. LengthBetweenFractions(self: MSPyBentleyGeom.MSBsplineCurve, startKnot: float, endKnot: float) -> float
        
        2. LengthBetweenFractions(self: MSPyBentleyGeom.MSBsplineCurve, worldToLocal: RotMatrix, startKnot: float, endKnot: float) -> float
        """
        ...
    
    def LengthBetweenKnots(*args, **kwargs):
        """
        Overloaded function.
        
        1. LengthBetweenKnots(self: MSPyBentleyGeom.MSBsplineCurve, startKnot: float, endKnot: float) -> float
        
        2. LengthBetweenKnots(self: MSPyBentleyGeom.MSBsplineCurve, worldToLocal: RotMatrix, startKnot: float, endKnot: float) -> float
        """
        ...
    
    def MakeBezier(self: MSPyBentleyGeom.MSBsplineCurve, bezierCurve: MSPyBentleyGeom.MSBsplineCurve) -> int:
        """
        Create equivalent Bezier curve for the B-spline curve.
        """
        ...
    
    def MakeBeziers(self: MSPyBentleyGeom.MSBsplineCurve, beziers: MSPyBentleyGeom.MSBsplineCurveArray) -> int:
        """
        Create a series of Bezier curve for the B-spline curve.
        @DotNetMethodExclude
        """
        ...
    
    def MakeClosed(self: MSPyBentleyGeom.MSBsplineCurve) -> int:
        """
        Close the open B-spline curve.
        """
        ...
    
    def MakeOpen(self: MSPyBentleyGeom.MSBsplineCurve, u: float) -> int:
        """
        Open the closed B-spline curve.
        """
        ...
    
    def MakeRational(self: MSPyBentleyGeom.MSBsplineCurve) -> int:
        """
        Make an equivalent rational B-spline curve.
        """
        ...
    
    def MakeReversed(self: MSPyBentleyGeom.MSBsplineCurve) -> int:
        """
        Reverse the direction of the B-spline curve.
        """
        ...
    
    def MapFractions(params: MSPyBentleyGeom.DoubleArray, derivatives: MSPyBentleyGeom.DVec3dArray, i0: int, knot0: float, knot1: float, select: MSPyBentleyGeom.CurveParameterMapping, curve: MSPyBentleyGeom.MSBsplineCurve) -> None:
        ...
    
    def MapKnots(self: MSPyBentleyGeom.MSBsplineCurve, a: float, b: float) -> bool:
        """
        rewrite knot values in a..b. Return true if a,b and current start,end
        define a valid scale factor
        """
        ...
    
    def NormalizeKnots(self: MSPyBentleyGeom.MSBsplineCurve) -> None:
        """
        Normalize knots to 01
        """
        ...
    
    def PointsAtUniformArcLength(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, fractions: MSPyBentleyGeom.DoubleArray, numPoints: int) -> bool:
        """
        Compute points at uniform arclength steps.
        
        :param (output):
        points array to receive points.
        
        :param (output):
        fractions array to receive fractions.
        
        :param (input):
        numPoints number of points.
        """
        ...
    
    def PointsAtUniformFractions(self: MSPyBentleyGeom.MSBsplineCurve, points: MSPyBentleyGeom.DPoint3dArray, fractions: MSPyBentleyGeom.DoubleArray, numPoints: int) -> None:
        """
        Compute strokes at uniform fraction step.
        
        :param (output):
        points array to receive points.
        
        :param (output):
        fractions array to receive fractions.
        
        :param (input):
        numPoints number of points.
        """
        ...
    
    @property
    def PolygonDisplay(arg0: MSPyBentleyGeom.MSBsplineCurve) -> bool:
        ...
    @PolygonDisplay.setter
    def PolygonDisplay(arg0: MSPyBentleyGeom.MSBsplineCurve, arg1: bool) -> None:
        ...
    
    def PolygonLength(self: MSPyBentleyGeom.MSBsplineCurve) -> float:
        """
        Compute the length of the control polygon of the B-spline curve.
        """
        ...
    
    def Populate(*args, **kwargs):
        """
        Overloaded function.
        
        1. Populate(self: MSPyBentleyGeom.MSBsplineCurve, pointVector: MSPyBentleyGeom.DPoint3dArray, weightVector: MSPyBentleyGeom.DoubleArray, knotVector: MSPyBentleyGeom.DoubleArray, order: int, closed: bool, inputPolesAlreadyWeighted: bool) -> int
        
        2. Populate(self: MSPyBentleyGeom.MSBsplineCurve, pointVector: list, weightVector: MSPyBentleyGeom.DoubleArray, knotVector: MSPyBentleyGeom.DoubleArray, order: int, closed: bool, inputPolesAlreadyWeighted: bool) -> int
        """
        ...
    
    def ProjectToZFocalPlane(self: MSPyBentleyGeom.MSBsplineCurve, focalLength: float) -> None:
        """
        convert to a weighted curve whose normalized points fall on a focal
        plane
        """
        ...
    
    @property
    def Range(arg0: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.DRange3d:
        ...
    
    def ReleaseMem(self: MSPyBentleyGeom.MSBsplineCurve) -> None:
        """
        Free memory allocated for the poles, weights and knot vector of a
        B-spline curve.
        """
        ...
    
    def RemoveKnotsBounded(self: MSPyBentleyGeom.MSBsplineCurve, tol: float, startPreservation: int, endPreservation: int) -> int:
        """
        Remove all removable knots with the tolerance and end condition
        constraints.
        """
        ...
    
    def Resolution(*args, **kwargs):
        """
        Overloaded function.
        
        1. Resolution(self: MSPyBentleyGeom.MSBsplineCurve) -> float
        
        Get a (fairly tight) tolerance for the B-spline curve.
        
        2. Resolution(self: MSPyBentleyGeom.MSBsplineCurve, abstol: float, reltol: float) -> float
        
        Get a (fairly tight) tolerance for the B-spline curve.
        """
        ...
    
    def RetreatToBezierInKnotInterval(self: MSPyBentleyGeom.MSBsplineCurve, segment: MSPyBentleyGeom.BCurveSegment, bezierSelect: int, interval: MSPyBentleyGeom.DRange1d) -> tuple:
        ...
    
    def RotateCurve(self: MSPyBentleyGeom.MSBsplineCurve, rMatrix: RotMatrix) -> int:
        """
        Rotate the B-spline curve.
        """
        ...
    
    def RuledSurfaceClosestPoint(pickData: MSPyBentleyGeom.SolidLocationDetail, curveA: MSPyBentleyGeom.MSBsplineCurve, curveB: MSPyBentleyGeom.MSBsplineCurve, spacePoint: MSPyBentleyGeom.DPoint3d) -> bool:
        ...
    
    def SampleG1CurveByPoints(P: MSPyBentleyGeom.DPoint3dArray, up: MSPyBentleyGeom.DoubleArray, uq: MSPyBentleyGeom.DoubleArray, curve: MSPyBentleyGeom.MSBsplineCurve, par: int, Eg: float, ptol: float) -> int:
        ...
    
    def SearchKnot(self: MSPyBentleyGeom.MSBsplineCurve, unnormalizedKnotValue: float) -> tuple:
        ...
    
    def SegmentAkimaCurve(self: MSPyBentleyGeom.MSBsplineCurve, segment: MSPyBentleyGeom.DPoint3dArray, akimaCurve: MSPyBentleyGeom.DPoint3dArray, transform: Transform, param0: float, param1: float, tolerance: float = -1.0) -> bool:
        ...
    
    def SetCurveDisplay(self: MSPyBentleyGeom.MSBsplineCurve, value: bool) -> None:
        """
        Set the curve display flag.
        """
        ...
    
    def SetKnot(self: MSPyBentleyGeom.MSBsplineCurve, index: int, value: float) -> bool:
        """
        set weight by index. returns false if index out of range.
        @DotNetMethodExclude
        """
        ...
    
    def SetKnots(self: MSPyBentleyGeom.MSBsplineCurve, index: int, value: float, n: int) -> bool:
        """
        set weight by index. returns false if index out of range.
        @DotNetMethodExclude
        """
        ...
    
    def SetPole(*args, **kwargs):
        """
        Overloaded function.
        
        1. SetPole(self: MSPyBentleyGeom.MSBsplineCurve, index: int, value: MSPyBentleyGeom.DPoint3d) -> bool
        
        set pole by index. returns false if index out of range.
        @DotNetMethodExclude
        
        2. SetPole(self: MSPyBentleyGeom.MSBsplineCurve, index: int, x: float, y: float, z: float) -> bool
        
        set pole by index. returns false if index out of range.
        @DotNetMethodExclude
        """
        ...
    
    def SetPoles(self: MSPyBentleyGeom.MSBsplineCurve, index: int, value: MSPyBentleyGeom.DPoint3d, n: int) -> bool:
        """
        set pole by index. returns false if index out of range.
        @DotNetMethodExclude
        """
        ...
    
    def SetPolygonDisplay(self: MSPyBentleyGeom.MSBsplineCurve, value: bool) -> None:
        """
        Set the polygon display flag.
        """
        ...
    
    def SetReWeightedPole(self: MSPyBentleyGeom.MSBsplineCurve, index: int, value: MSPyBentleyGeom.DPoint3d, reverse: bool = False) -> bool:
        """
        set pole by index. returns false if index out of range. If the curve
        is weighted, the current weight is multiplied into the input pole.
        @DotNetMethodExclude
        """
        ...
    
    def SetWeight(self: MSPyBentleyGeom.MSBsplineCurve, index: int, value: float) -> bool:
        """
        set weight by index. returns false if index out of range.
        @DotNetMethodExclude
        """
        ...
    
    def SetWeights(self: MSPyBentleyGeom.MSBsplineCurve, index: int, value: float, n: int) -> bool:
        """
        set weight by index. returns false if index out of range.
        @DotNetMethodExclude
        """
        ...
    
    def SwapContents(self: MSPyBentleyGeom.MSBsplineCurve, other: MSPyBentleyGeom.MSBsplineCurve) -> None:
        """
        Exchange all bits with other. Usually used to transfer poles etc and
        leave zeros behind.
        """
        ...
    
    def TransformCurve(self: MSPyBentleyGeom.MSBsplineCurve, transform: Transform) -> int:
        """
        Transform the B-spline curve.
        """
        ...
    
    def TransformCurve4d(self: MSPyBentleyGeom.MSBsplineCurve, transform4d: MSPyBentleyGeom.DMatrix4d) -> int:
        """
        Transform the B-spline curve using a 4d transformation.
        """
        ...
    
    def TransformPoles(*args, **kwargs):
        """
        Overloaded function.
        
        1. TransformPoles(self: MSPyBentleyGeom.MSBsplineCurve, transform: Transform, index: int, n: int) -> None
        
        Apply a transform to a single pole.
        
        2. TransformPoles(self: MSPyBentleyGeom.MSBsplineCurve, transform: Transform, index: int, n: int) -> None
        
        Apply a transform to a single pole.
        """
        ...
    
    def UnWeightPoles(self: MSPyBentleyGeom.MSBsplineCurve) -> None:
        """
        if the curve is rational, divide (wx,wy,wz) style poles by the weights
        """
        ...
    
    def WeightPoles(self: MSPyBentleyGeom.MSBsplineCurve) -> None:
        """
        if the curve is rational, multiply (wx,wy,wz) style poles by the
        weights
        """
        ...
    
    def WeightedLeastSquaresFit(outCurve: MSPyBentleyGeom.MSBsplineCurve, Q: MSPyBentleyGeom.DPoint3dArray, u: MSPyBentleyGeom.DoubleArray, endControl: bool, sTangent: MSPyBentleyGeom.DVec3d, eTangent: MSPyBentleyGeom.DVec3d, numPoles: int, order: int) -> int:
        ...
    
    def WireCentroid(self: MSPyBentleyGeom.MSBsplineCurve, centroid: MSPyBentleyGeom.DPoint3d, fraction0: float, fraction1: float) -> float:
        ...
    
    def Zero(self: MSPyBentleyGeom.MSBsplineCurve) -> None:
        """
        <summary>Zero out the curve. This is customarily applied immediately
        after allocation on stack or heap. This does NOT free memory from
        prior contents. </summary
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    
    @property
    def display(self: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.BsplineDisplay:
        ...
    @display.setter
    def display(self: MSPyBentleyGeom.MSBsplineCurve, arg0: MSPyBentleyGeom.BsplineDisplay) -> None:
        ...
    
    eKNOTPOS_AFTER_FINAL: KnotPosition
    
    eKNOTPOS_BEFORE_START: KnotPosition
    
    eKNOTPOS_FINAL: KnotPosition
    
    eKNOTPOS_INTERIOR: KnotPosition
    
    eKNOTPOS_INTERVAL: KnotPosition
    
    eKNOTPOS_START: KnotPosition
    
    @property
    def knots(arg0: MSPyBentleyGeom.MSBsplineCurve) -> list:
        ...
    
    @property
    def params(self: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.BsplineParam:
        ...
    @params.setter
    def params(self: MSPyBentleyGeom.MSBsplineCurve, arg0: MSPyBentleyGeom.BsplineParam) -> None:
        ...
    
    @property
    def poles(arg0: MSPyBentleyGeom.MSBsplineCurve) -> list:
        ...
    
    @property
    def rational(self: MSPyBentleyGeom.MSBsplineCurve) -> int:
        ...
    @rational.setter
    def rational(self: MSPyBentleyGeom.MSBsplineCurve, arg0: int) -> None:
        ...
    
    @property
    def type(self: MSPyBentleyGeom.MSBsplineCurve) -> int:
        ...
    @type.setter
    def type(self: MSPyBentleyGeom.MSBsplineCurve, arg0: int) -> None:
        ...
    
    @property
    def weights(arg0: MSPyBentleyGeom.MSBsplineCurve) -> list:
        ...
    
class RefCountedMSBsplineSurface:
    """
    None
    """

    def AddKnot(self: MSPyBentleyGeom.MSBsplineSurface, unnormalizedKnotValue: float, newMultiplicity: int, direction: int) -> int:
        """
        Add a given knot value to the B-spline surface in given direction.
        newMultiplicity is the desired final multiplicity of a knot that may
        already exist.
        """
        ...
    
    def AddTrimBoundary(*args, **kwargs):
        """
        Overloaded function.
        
        1. AddTrimBoundary(self: MSPyBentleyGeom.MSBsplineSurface, uvPoints: MSPyBentleyGeom.DPoint2dArray) -> bool
        
        Add a uv polyline trim boundary.
        
        2. AddTrimBoundary(self: MSPyBentleyGeom.MSBsplineSurface, xyzPoints: MSPyBentleyGeom.DPoint3dArray) -> bool
        
        Add a uv polyline trim boundary.
        
        3. AddTrimBoundary(self: MSPyBentleyGeom.MSBsplineSurface, xyzPoints: list) -> bool
        
        Add a uv polyline trim boundary.
        """
        ...
    
    def Allocate(self: MSPyBentleyGeom.MSBsplineSurface) -> int:
        """
        Allocate memory arrays to match the current counts.
        """
        ...
    
    def AllocateUKnots(self: MSPyBentleyGeom.MSBsplineSurface) -> int:
        """
        Allocate uKnots. Prior knot buffer is freed if present (do not call on
        pre-zeroed surface!!)
        """
        ...
    
    def AllocateVKnots(self: MSPyBentleyGeom.MSBsplineSurface) -> int:
        """
        Allocate vKnots. Prior knot buffer is freed if present (do not call on
        pre-zeroed surface!!)
        """
        ...
    
    def AreUKnotsValid(self: MSPyBentleyGeom.MSBsplineSurface, clampingRequired: bool) -> bool:
        """
        Return the true allocated size of the pole array....
        """
        ...
    
    def AreVKnotsValid(self: MSPyBentleyGeom.MSBsplineSurface, clampingRequired: bool) -> bool:
        ...
    
    def BoundaryLoopArea(self: MSPyBentleyGeom.MSBsplineSurface, boundaryIndex: int) -> float:
        """
        Return the area of a single boundary loop ..
        """
        ...
    
    def CleanKnots(self: MSPyBentleyGeom.MSBsplineSurface) -> int:
        """
        Clean all unnecessary knots.
        """
        ...
    
    def Clone(self: MSPyBentleyGeom.MSBsplineSurface) -> MSPyBentleyGeom.RefCountedMSBsplineSurface:
        ...
    
    def ClosestPoint(self: MSPyBentleyGeom.MSBsplineSurface, surfacePoint: MSPyBentleyGeom.DPoint3d, surfaceUV: MSPyBentleyGeom.DPoint2d, spacePoint: MSPyBentleyGeom.DPoint3d) -> None:
        """
        Find closest point on surface
        """
        ...
    
    def ComputePrincipalAreaMoments(self: MSPyBentleyGeom.MSBsplineSurface, centroid: MSPyBentleyGeom.DVec3d, axes: RotMatrix, momentxyz: MSPyBentleyGeom.DVec3d) -> tuple:
        ...
    
    def ComputeSecondMomentAreaProducts(self: MSPyBentleyGeom.MSBsplineSurface, products: MSPyBentleyGeom.DMatrix4d) -> bool:
        """
        Return the integrals of products of inertia [xx xy xz x; xy yy yz y;
        xz yz zz 1] * dA
        """
        ...
    
    def ComputeUniformUKnots(self: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        """
        Compute uniformly spaced knots. This uses counts from params.
        
        :returns:
        false if param counts are not set.
        """
        ...
    
    def ComputeUniformVKnots(self: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        """
        Compute uniformly spaced knots. This uses counts from params.
        
        :returns:
        false if param counts are not set.
        """
        ...
    
    def ControlPolygonFractionToControlPolygonDPoint3d(self: MSPyBentleyGeom.MSBsplineSurface, i: int, j: int, u: float, v: float) -> MSPyBentleyGeom.ValidatedDPoint3d:
        """
        Calculate the control polygon point at fractional position within a
        control polygon quad.
        """
        ...
    
    def ControlPolygonFractionToControlPolygonDPoint4d(self: MSPyBentleyGeom.MSBsplineSurface, i: int, j: int, u: float, v: float) -> MSPyBentleyGeom.ValidatedDPoint4d:
        """
        Calculate the control polygon point at fractional position within a
        control polygon quad.
        """
        ...
    
    def ControlPolygonFractionToKnot(self: MSPyBentleyGeom.MSBsplineSurface, i: int, j: int, u: float, v: float) -> MSPyBentleyGeom.ValidatedDPoint2d:
        """
        Calculate the knot values at fractional position within a control
        polygon quad.
        """
        ...
    
    def CopyClosed(self: MSPyBentleyGeom.MSBsplineSurface, source: MSPyBentleyGeom.MSBsplineSurface, edge: int) -> int:
        """
        Create B-spline surface by closing a open B-spline surface.
        """
        ...
    
    def CopyFrom(self: MSPyBentleyGeom.MSBsplineSurface, source: MSPyBentleyGeom.MSBsplineSurface) -> int:
        """
        Allocate memory for the B-spline surface and copies all data from the
        input B-spline surface.
        """
        ...
    
    def CopyOpen(self: MSPyBentleyGeom.MSBsplineSurface, source: MSPyBentleyGeom.MSBsplineSurface, unnormalizedKnot: float, edge: int) -> int:
        """
        Create B-spline surface by opening a closed B-spline surface about
        given direction.
        """
        ...
    
    def CopyReversed(self: MSPyBentleyGeom.MSBsplineSurface, source: MSPyBentleyGeom.MSBsplineSurface, edge: int) -> int:
        """
        Create B-spline surface by reversing the given direction of surface.
        """
        ...
    
    def Create() -> MSPyBentleyGeom.RefCountedMSBsplineSurface:
        ...
    
    def CreateCapture(self: MSPyBentleyGeom.MSBsplineSurface) -> MSPyBentleyGeom.RefCountedMSBsplineSurface:
        """
        Returns a smart pointer to an MSBsplineSurface on the heap. Copy bits
        from instance, zero the instance.
        """
        ...
    
    def CreateCatmullRom(points: MSPyBentleyGeom.DPoint3dArray, numU: int, numV: int, uv: MSPyBentleyGeom.DPoint2dArray) -> MSPyBentleyGeom.RefCountedMSBsplineSurface:
        ...
    
    def CreateCopyTransformed(self: MSPyBentleyGeom.MSBsplineSurface, transform: Transform) -> MSPyBentleyGeom.RefCountedMSBsplineSurface:
        """
        Clone as new refcounted pointer.
        """
        ...
    
    def CreateFromPolesAndOrder(pointVector: MSPyBentleyGeom.DPoint3dArray, weightVector: MSPyBentleyGeom.DoubleArray, uKnotVector: MSPyBentleyGeom.DoubleArray, uOrder: int, numUPoints: int, uClosed: bool, vKnotVector: MSPyBentleyGeom.DoubleArray, vOrder: int, numVPoints: int, vClosed: bool, inputPolesAlreadyWeighted: bool) -> MSPyBentleyGeom.RefCountedMSBsplineSurface:
        ...
    
    def CreateLinearSweep(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateLinearSweep(primitive: MSPyBentleyGeom.ICurvePrimitive, delta: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.RefCountedMSBsplineSurface
        
        Create a linear sweep from a (single) base curve. Fails (i.e. returns
        NULL) if the primitive has children.
        
        :param (input):
        primitive base curve to be swept
        
        :param (input):
        delta sweep direction.
        
        2. CreateLinearSweep(primitive: MSPyBentleyGeom.MSBsplineCurve, delta: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.RefCountedMSBsplineSurface
        
        Create a linear sweep from a (single) base curve. Fails (i.e. returns
        NULL) if the primitive has children.
        
        :param (input):
        primitive base curve to be swept
        
        :param (input):
        delta sweep direction.
        
        3. CreateLinearSweep(surfaces: MSPyBentleyGeom.MSBsplineSurfacePtrArray, baseCurves: MSPyBentleyGeom.CurveVector, delta: MSPyBentleyGeom.DVec3d) -> bool
        
        Create a linear sweep from a (single) base curve. Fails (i.e. returns
        NULL) if the primitive has children.
        
        :param (input):
        primitive base curve to be swept
        
        :param (input):
        delta sweep direction.
        """
        ...
    
    def CreateRotationalSweep(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateRotationalSweep(primitive: MSPyBentleyGeom.ICurvePrimitive, center: MSPyBentleyGeom.DPoint3d, axis: MSPyBentleyGeom.DVec3d, sweepRadians: float) -> MSPyBentleyGeom.RefCountedMSBsplineSurface
        
        2. CreateRotationalSweep(primitive: MSPyBentleyGeom.MSBsplineCurve, center: MSPyBentleyGeom.DPoint3d, axis: MSPyBentleyGeom.DVec3d, sweepRadians: float) -> MSPyBentleyGeom.RefCountedMSBsplineSurface
        
        3. CreateRotationalSweep(surfaces: MSPyBentleyGeom.MSBsplineSurfacePtrArray, baseCurves: MSPyBentleyGeom.CurveVector, center: MSPyBentleyGeom.DPoint3d, axis: MSPyBentleyGeom.DVec3d, sweepRadians: float) -> bool
        """
        ...
    
    def CreateRuled(curveA: MSPyBentleyGeom.ICurvePrimitive, curveB: MSPyBentleyGeom.ICurvePrimitive) -> MSPyBentleyGeom.RefCountedMSBsplineSurface:
        """
        Create a linear sweep from a ruled surface between two curves. Fails
        (i.e. returns NULL) if the primitives have children or are not
        compatible.
        
        :param (input):
        curveA first curve
        
        :param (input):
        curveB second curve
        """
        ...
    
    def CreateTrimmedDisk(ellipse: MSPyBentleyGeom.DEllipse3d) -> MSPyBentleyGeom.RefCountedMSBsplineSurface:
        """
        Create a planar (bilinear) surface for the parallelogram around the
        ellipse. Insert a trim curve for the ellipse.
        
        :param (input):
        ellipse space ellipse
        """
        ...
    
    def CreateTrimmedSurfaces(*args, **kwargs):
        """
        Overloaded function.
        
        1. CreateTrimmedSurfaces(surfaces: MSPyBentleyGeom.MSBsplineSurfacePtrArray, source: MSPyBentleyGeom.CurveVector, options: MSPyBentleyGeom.IFacetOptions = None) -> bool
        
        2. CreateTrimmedSurfaces(surfaces: MSPyBentleyGeom.MSBsplineSurfacePtrArray, source: ISolidPrimitive, options: MSPyBentleyGeom.IFacetOptions = None) -> bool
        """
        ...
    
    def CreateTubeSurface(baseCurve: MSPyBentleyGeom.MSBsplineCurve, translateBaseCurve: bool, traceCurve: MSPyBentleyGeom.MSBsplineCurve) -> MSPyBentleyGeom.RefCountedMSBsplineSurface:
        """
        Create a surface swept along a trace curve.
        
        :param (input):
        baseCurve base contour
        
        :param (input):
        translateBaseCurve true to translate section, false to rotate with
        trace
        
        :param (input):
        traceCurve path to sweep
        """
        ...
    
    def DeleteBoundaries(self: MSPyBentleyGeom.MSBsplineSurface) -> None:
        """
        Remove all trim boundaries.
        """
        ...
    
    def ElevateDegree(self: MSPyBentleyGeom.MSBsplineSurface, newDegree: int, edge: int) -> int:
        """
        Elevate the degree (increases the order) of the B-spline surface in
        given direction.
        """
        ...
    
    def EvaluateAllPartials(self: MSPyBentleyGeom.MSBsplineSurface, xyz: MSPyBentleyGeom.DPoint3d, dPdU: MSPyBentleyGeom.DVec3d, dPdV: MSPyBentleyGeom.DVec3d, dPdUU: MSPyBentleyGeom.DVec3d, dPdVV: MSPyBentleyGeom.DVec3d, dPdUv: MSPyBentleyGeom.DVec3d, normal: MSPyBentleyGeom.DVec3d, u: float, v: float) -> None:
        ...
    
    def EvaluateNormalizedFrame(self: MSPyBentleyGeom.MSBsplineSurface, transform: Transform, u: float, v: float) -> bool:
        """
        Calculate a coordinate frame on the surface.
        
        :param (input):
        u u parameter
        
        :param (input):
        v v parameter.
        
        :param (output):
        transform transform with (a) origin at surface point, (b) x axis
        in u direction, (c) y axis perpendicular to x and in the surface
        tangent plane, (d) z axis normal to surface. Return false if
        tangent vectors are parallel or zero.
        """
        ...
    
    def EvaluatePoint(*args, **kwargs):
        """
        Overloaded function.
        
        1. EvaluatePoint(self: MSPyBentleyGeom.MSBsplineSurface, xyz: MSPyBentleyGeom.DPoint3d, u: float, v: float) -> None
        
        2. EvaluatePoint(self: MSPyBentleyGeom.MSBsplineSurface, xyz: MSPyBentleyGeom.DPoint3d, dPdU: MSPyBentleyGeom.DVec3d, dPdV: MSPyBentleyGeom.DVec3d, u: float, v: float) -> None
        """
        ...
    
    def EvaluatePointAndUnitNormal(self: MSPyBentleyGeom.MSBsplineSurface, ray: MSPyBentleyGeom.DRay3d, u: float, v: float) -> bool:
        """
        Calculate the point and unit normal on the B-spline surface at the
        input u and v parameter values. Return false if tangent vectors are
        parallel or zero.
        """
        ...
    
    def EvaluatePrincipalCurvature(self: MSPyBentleyGeom.MSBsplineSurface, xyz: MSPyBentleyGeom.DPoint3d, unitA: MSPyBentleyGeom.DVec3d, unitB: MSPyBentleyGeom.DVec3d, u: float, v: float) -> tuple:
        ...
    
    def EvaluateUniformGrid(*args, **kwargs):
        """
        Overloaded function.
        
        1. EvaluateUniformGrid(self: MSPyBentleyGeom.MSBsplineSurface, numUPoint: int, numVPoint: int, uParams: MSPyBentleyGeom.DoubleArray, vParams: MSPyBentleyGeom.DoubleArray, gridPoints: MSPyBentleyGeom.DPoint3dArray) -> None
        
        2. EvaluateUniformGrid(self: MSPyBentleyGeom.MSBsplineSurface, numUPoint: int, numVPoint: int, uParams: MSPyBentleyGeom.DoubleArray, vParams: MSPyBentleyGeom.DoubleArray, gridPoints: list) -> None
        
        3. EvaluateUniformGrid(self: MSPyBentleyGeom.MSBsplineSurface, numUPoint: int, numVPoint: int, uvParams: MSPyBentleyGeom.DPoint2dArray, gridPoints: MSPyBentleyGeom.DPoint3dArray) -> None
        
        4. EvaluateUniformGrid(self: MSPyBentleyGeom.MSBsplineSurface, numUPoint: int, numVPoint: int, uvParams: MSPyBentleyGeom.DPoint2dArray, gridPoints: list) -> None
        """
        ...
    
    def ExtractTo(self: MSPyBentleyGeom.MSBsplineSurface, dest: MSPyBentleyGeom.MSBsplineSurface) -> None:
        """
        Copy bits into simple structure. Caller instance zeroed.
        """
        ...
    
    def FindKnotInterval(self: MSPyBentleyGeom.MSBsplineSurface, knotValue: float, direction: int) -> int:
        ...
    
    def FixupBoundaryLoopParity(self: MSPyBentleyGeom.MSBsplineSurface) -> None:
        """
        Analyze loop parity among all boundary loops. Replace as " complete "
        loop set -- no implicit 01 outer boundary.
        """
        ...
    
    def FractionToKnot(self: MSPyBentleyGeom.MSBsplineSurface, f: float, direction: int) -> float:
        """
        Return the knot value at a fractional parameter about given
        direction...
        """
        ...
    
    def GetBoundaryUV(self: MSPyBentleyGeom.MSBsplineSurface, boundaryIndex: int, pointIndex: int) -> MSPyBentleyGeom.DPoint2d:
        ...
    
    def GetIntervalCounts(self: MSPyBentleyGeom.MSBsplineSurface) -> tuple:
        ...
    
    def GetIsUClosed(self: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        """
        return the u direction periodic state.
        """
        ...
    
    def GetIsVClosed(self: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        """
        return the v direction periodic state.
        """
        ...
    
    def GetIsoUCurve(self: MSPyBentleyGeom.MSBsplineSurface, u: float) -> MSPyBentleyGeom.RefCountedMSBsplineCurve:
        """
        Get the (untrimmed) v-direction curve at u
        """
        ...
    
    def GetIsoUCurveSegments(self: MSPyBentleyGeom.MSBsplineSurface, u: float, segments: MSPyBentleyGeom.MSBsplineCurvePtrArray) -> None:
        """
        Get scan line intersections at constant u.
        """
        ...
    
    def GetIsoULineVIntersections(self: MSPyBentleyGeom.MSBsplineSurface, u: float, vParams: MSPyBentleyGeom.DoubleArray) -> None:
        """
        Get scan line intersections at constant u.
        """
        ...
    
    def GetIsoVCurve(self: MSPyBentleyGeom.MSBsplineSurface, v: float) -> MSPyBentleyGeom.RefCountedMSBsplineCurve:
        """
        Get the (untrimmed) u-direction curve at v
        """
        ...
    
    def GetIsoVCurveSegments(self: MSPyBentleyGeom.MSBsplineSurface, v: float, segments: MSPyBentleyGeom.MSBsplineCurvePtrArray) -> None:
        """
        Get scan line intersections at constant v.
        """
        ...
    
    def GetIsoVLineUIntersections(self: MSPyBentleyGeom.MSBsplineSurface, v: float, uParams: MSPyBentleyGeom.DoubleArray) -> None:
        """
        Get scan line intersections at constant v.
        """
        ...
    
    def GetKnotRange(self: MSPyBentleyGeom.MSBsplineSurface, direction: int) -> tuple:
        ...
    
    def GetNumBounds(self: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    
    def GetNumPointsInBoundary(self: MSPyBentleyGeom.MSBsplineSurface, boundaryIndex: int) -> int:
        """
        return the number of ponits in a boundary.
        """
        ...
    
    def GetNumPoles(self: MSPyBentleyGeom.MSBsplineSurface) -> int:
        """
        return the product of u and v direction poles counts.
        """
        ...
    
    def GetNumUKnots(self: MSPyBentleyGeom.MSBsplineSurface) -> int:
        """
        return the u direction knot count.
        """
        ...
    
    def GetNumUPoles(self: MSPyBentleyGeom.MSBsplineSurface) -> int:
        """
        return the u direction pole count.
        """
        ...
    
    def GetNumVKnots(self: MSPyBentleyGeom.MSBsplineSurface) -> int:
        """
        return the v direction knot count.
        """
        ...
    
    def GetNumVPoles(self: MSPyBentleyGeom.MSBsplineSurface) -> int:
        """
        return the v direction pole count.
        """
        ...
    
    def GetParameterRegion(self: MSPyBentleyGeom.MSBsplineSurface) -> tuple:
        ...
    
    def GetPole(*args, **kwargs):
        """
        Overloaded function.
        
        1. GetPole(self: MSPyBentleyGeom.MSBsplineSurface, i: int) -> MSPyBentleyGeom.DPoint3d
        
        2. GetPole(self: MSPyBentleyGeom.MSBsplineSurface, i: int, j: int) -> MSPyBentleyGeom.DPoint3d
        """
        ...
    
    def GetPoleDPoint4d(*args, **kwargs):
        """
        Overloaded function.
        
        1. GetPoleDPoint4d(self: MSPyBentleyGeom.MSBsplineSurface, i: int) -> MSPyBentleyGeom.DPoint4d
        
        2. GetPoleDPoint4d(self: MSPyBentleyGeom.MSBsplineSurface, i: int, j: int) -> MSPyBentleyGeom.DPoint4d
        """
        ...
    
    def GetPoleRange(*args, **kwargs):
        """
        Overloaded function.
        
        1. GetPoleRange(self: MSPyBentleyGeom.MSBsplineSurface, range: MSPyBentleyGeom.DRange3d) -> None
        
        Get the range of the poles of the B-spline surface.
        
        2. GetPoleRange(self: MSPyBentleyGeom.MSBsplineSurface, range: MSPyBentleyGeom.DRange3d, transform: Transform) -> None
        
        Get the range of the poles of the B-spline surface.
        """
        ...
    
    def GetPoles(self: MSPyBentleyGeom.MSBsplineSurface, outData: MSPyBentleyGeom.DPoint3dArray) -> None:
        """
        Copy all poles out into caller array.
        """
        ...
    
    def GetPolygonColumnAsCurve(self: MSPyBentleyGeom.MSBsplineSurface, index: int) -> MSPyBentleyGeom.RefCountedMSBsplineCurve:
        """
        Copy poles from a column into a curve structure. index -1 is
        understood as " end "
        """
        ...
    
    def GetPolygonDisplay(self: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        ...
    
    def GetPolygonRowAsCurve(self: MSPyBentleyGeom.MSBsplineSurface, index: int) -> MSPyBentleyGeom.RefCountedMSBsplineCurve:
        """
        Copy poles from a row into a curve structure. index -1 is understood
        as " end "
        """
        ...
    
    def GetPrincipalExtents(self: MSPyBentleyGeom.MSBsplineSurface, extends: Transform) -> bool:
        """
        Return a transform whose columns are along edges parallel to the
        principal axes and sized to include the poles from the translation
        point.
        """
        ...
    
    def GetSupport(self: MSPyBentleyGeom.MSBsplineSurface, outPoles: MSPyBentleyGeom.DPoint4dArray, outUKnots: MSPyBentleyGeom.DoubleArray, outVKnots: MSPyBentleyGeom.DoubleArray, uIndex: int, vIndex: int) -> bool:
        """
        Extract the poles and knots that support a single bezier patch ...
        
        :param (output):
        outPoles{uOrder X vOrder} poles
        
        :param (output):
        outUKnots{2*(uOrder-1)} knots
        
        :param (output):
        outVKnots{2*(vOrder-1)} knots
        
        :param (input):
        uIndex index of bezier to extract.
        
        :param (input):
        vIndex index of bezier to extract. @DotNetMethodExclude
        """
        ...
    
    def GetSurfaceDisplay(self: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        ...
    
    def GetUKnot(self: MSPyBentleyGeom.MSBsplineSurface, outData: int) -> float:
        ...
    
    def GetUKnots(self: MSPyBentleyGeom.MSBsplineSurface, knots: MSPyBentleyGeom.DoubleArray) -> None:
        ...
    
    def GetUOrder(self: MSPyBentleyGeom.MSBsplineSurface) -> int:
        """
        return the u direction order.
        """
        ...
    
    def GetUVBoundaryCurves(self: MSPyBentleyGeom.MSBsplineSurface, addOuterLoopsIfActive: bool, preferCurves: bool) -> MSPyBentleyGeom.CurveVector:
        """
        Return current uv boundary data. This returns a parity region.
        """
        ...
    
    def GetUVBoundaryLoops(*args, **kwargs):
        """
        Overloaded function.
        
        1. GetUVBoundaryLoops(self: MSPyBentleyGeom.MSBsplineSurface, uvBoundaries: MSPyBentleyGeom.DPoint2dVecArray, addOuterLoopsIfActive: bool) -> None
        
        2. GetUVBoundaryLoops(self: MSPyBentleyGeom.MSBsplineSurface, uvBoundaries: MSPyBentleyGeom.DPoint2dVecArray, addOuterLoopsIfActive: bool, cleanupParity: bool) -> None
        """
        ...
    
    def GetUnWeightedPole(*args, **kwargs):
        """
        Overloaded function.
        
        1. GetUnWeightedPole(self: MSPyBentleyGeom.MSBsplineSurface, i: int, j: int) -> MSPyBentleyGeom.DPoint3d
        
        2. GetUnWeightedPole(self: MSPyBentleyGeom.MSBsplineSurface, i: int) -> MSPyBentleyGeom.DPoint3d
        """
        ...
    
    def GetUnWeightedPoles(self: MSPyBentleyGeom.MSBsplineSurface, outData: MSPyBentleyGeom.DPoint3dArray) -> None:
        """
        Copy all poles out into caller array, dividing each by its weight
        """
        ...
    
    def GetUnstructuredBoundaryCurves(*args, **kwargs):
        """
        Overloaded function.
        
        1. GetUnstructuredBoundaryCurves(self: MSPyBentleyGeom.MSBsplineSurface, tolerance: float, cubicFit: bool) -> MSPyBentleyGeom.CurveVector
        
        2. GetUnstructuredBoundaryCurves(self: MSPyBentleyGeom.MSBsplineSurface, tolerance: float, cubicFit: bool, addOuterLoopIfActive: bool) -> MSPyBentleyGeom.CurveVector
        """
        ...
    
    def GetVKnot(self: MSPyBentleyGeom.MSBsplineSurface, outData: int) -> float:
        ...
    
    def GetVKnots(self: MSPyBentleyGeom.MSBsplineSurface, knots: MSPyBentleyGeom.DoubleArray) -> None:
        ...
    
    def GetVOrder(self: MSPyBentleyGeom.MSBsplineSurface) -> int:
        """
        return the v direction order.
        """
        ...
    
    def GetWeight(*args, **kwargs):
        """
        Overloaded function.
        
        1. GetWeight(self: MSPyBentleyGeom.MSBsplineSurface, i: int) -> float
        
        2. GetWeight(self: MSPyBentleyGeom.MSBsplineSurface, i: int, j: int) -> float
        """
        ...
    
    def GetWeights(self: MSPyBentleyGeom.MSBsplineSurface, outData: MSPyBentleyGeom.DoubleArray) -> None:
        """
        Copy all weights out into caller array.
        """
        ...
    
    def HasValidBoundaryAllocation(self: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        ...
    
    def HasValidCountsAndAllocations(self: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        ...
    
    def HasValidOrder(self: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        ...
    
    def HasValidPoleAllocation(self: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        ...
    
    def HasValidPoleCounts(self: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        ...
    
    def HasValidWeightAllocation(self: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        ...
    
    def HasWeights(self: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        """
        ask if this is a " rational " (weighted) surface.
        """
        ...
    
    def InitFromPointsAndOrder(self: MSPyBentleyGeom.MSBsplineSurface, uOrder: int, vOrder: int, uNumPoles: int, vNumPoles: int, points: MSPyBentleyGeom.DPoint3d) -> int:
        """
        Initialize the B-spline surface from point array and U/V order.
        """
        ...
    
    def IntersectRay(*args, **kwargs):
        """
        Overloaded function.
        
        1. IntersectRay(self: MSPyBentleyGeom.MSBsplineSurface, intersectionPoints: MSPyBentleyGeom.DPoint3dArray, rayParameters: MSPyBentleyGeom.DoubleArray, surfaceParameters: MSPyBentleyGeom.DPoint2dArray, ray: MSPyBentleyGeom.DRay3d) -> None
        
        2. IntersectRay(self: MSPyBentleyGeom.MSBsplineSurface, intersectionPoints: list, rayParameters: MSPyBentleyGeom.DoubleArray, surfaceParameters: MSPyBentleyGeom.DPoint2dArray, ray: MSPyBentleyGeom.DRay3d) -> None
        
        3. IntersectRay(self: MSPyBentleyGeom.MSBsplineSurface, intersectionPoints: MSPyBentleyGeom.DPoint3dArray, rayParameters: MSPyBentleyGeom.DoubleArray, surfaceParameters: MSPyBentleyGeom.DPoint2dArray, ray: MSPyBentleyGeom.DRay3d, rayInterval: MSPyBentleyGeom.DRange1d) -> None
        
        4. IntersectRay(self: MSPyBentleyGeom.MSBsplineSurface, intersectionPoints: list, rayParameters: MSPyBentleyGeom.DoubleArray, surfaceParameters: MSPyBentleyGeom.DPoint2dArray, ray: MSPyBentleyGeom.DRay3d, rayInterval: MSPyBentleyGeom.DRange1d) -> None
        """
        ...
    
    def IsBidirectionalTranslation(self: MSPyBentleyGeom.MSBsplineSurface, relativeTolerance: float = 0.0) -> bool:
        """
        Check whether the u curves are all translations of the first u curve.
        (If this is true, the v curves are also translations of the first v
        curve0)
        
        :param (input):
        relativeTolerance tolerance as a fraction of the largest
        coordinate.
        """
        ...
    
    def IsDegenerateEdge(self: MSPyBentleyGeom.MSBsplineSurface, edgeCode: int, tolerance: float) -> bool:
        """
        Check whether an edge of the surface degenerates to a single point.
        """
        ...
    
    def IsOuterBoundaryActive(self: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        """
        :returns:
        the state of the outer boundary flag.
        """
        ...
    
    def IsPhysicallyClosed(self: MSPyBentleyGeom.MSBsplineSurface) -> tuple:
        ...
    
    def IsPlanarBilinear(*args, **kwargs):
        """
        Overloaded function.
        
        1. IsPlanarBilinear(self: MSPyBentleyGeom.MSBsplineSurface) -> bool
        
        Check whether the B-spline surface is bilinear and each face of the
        control polygon is planar, with tight system tolerance
        (Angle.SmallAngle (
        
        2. IsPlanarBilinear(self: MSPyBentleyGeom.MSBsplineSurface, angleTol: float) -> bool
        
        Check whether the B-spline surface is bilinear and each face of the
        control polygon is planar, with tight system tolerance
        (Angle.SmallAngle (
        """
        ...
    
    def IsPlane(self: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        """
        Check whether the poles are entirely within a plane. This does not
        check for goofy direction changes -- just planarity.
        """
        ...
    
    def IsSameStructure(self: MSPyBentleyGeom.MSBsplineSurface, other: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        """
        Compare all non-coordinate data.
        """
        ...
    
    def IsSameStructureAndGeometry(self: MSPyBentleyGeom.MSBsplineSurface, other: MSPyBentleyGeom.MSBsplineSurface, tolerance: float) -> bool:
        """
        Compare all data.
        """
        ...
    
    def IsSolid(self: MSPyBentleyGeom.MSBsplineSurface, tolerance: float) -> bool:
        """
        Check whether the B-spline surface encloses a valid space.
        """
        ...
    
    @property
    def IsUClosed(arg0: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        ...
    
    @property
    def IsVClosed(arg0: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        ...
    
    def KnotToBlendFunctions(self: MSPyBentleyGeom.MSBsplineSurface, blend: float, blendDerivatives: float, u: float, direction: int) -> int:
        ...
    
    def KnotToFraction(self: MSPyBentleyGeom.MSBsplineSurface, knot: float, direction: int) -> float:
        """
        Return the fractional parameter corresponding to a knot value ...
        """
        ...
    
    def LoftingSurface(self: MSPyBentleyGeom.MSBsplineSurface, pCurves: MSPyBentleyGeom.MSBsplineCurve, pStartNormal: MSPyBentleyGeom.DVec3d, pEndNormal: MSPyBentleyGeom.DVec3d, numCurves: int, approxComp: bool, closed: bool, smoothStart: bool, smoothEnd: bool, chordLength: bool, applyComp: bool, tolerance: float) -> int:
        ...
    
    def MakeBezier(self: MSPyBentleyGeom.MSBsplineSurface, outSurface: MSPyBentleyGeom.MSBsplineSurface) -> int:
        """
        Create equivalent Bezier surface for the B-spline surface.
        """
        ...
    
    def MakeBeziers(self: MSPyBentleyGeom.MSBsplineSurface, beziers: List[MSBsplineSurface]) -> int:
        """
        Create a series of Bezier surfaces for the B-spline surface.
        """
        ...
    
    def MakeClosed(self: MSPyBentleyGeom.MSBsplineSurface, direction: int) -> int:
        """
        Close the open B-spline surface about the given direction.
        """
        ...
    
    def MakeOpen(self: MSPyBentleyGeom.MSBsplineSurface, uv: float, direction: int) -> int:
        """
        Open the closed B-spline surface about the given direction.
        """
        ...
    
    def MakeRational(self: MSPyBentleyGeom.MSBsplineSurface) -> int:
        """
        Make an equivalent rational B-spline surface.
        """
        ...
    
    def MakeReversed(self: MSPyBentleyGeom.MSBsplineSurface, direction: int) -> int:
        """
        Reserve the given direction of the surface.
        """
        ...
    
    def NormalizeKnots(self: MSPyBentleyGeom.MSBsplineSurface) -> None:
        """
        Normalize knots to 01 (both directions)
        """
        ...
    
    def NormalizeSurface(self: MSPyBentleyGeom.MSBsplineSurface) -> None:
        """
        Scale and translate the parameter range of the surface and its
        boundary loops so all parameters are between 0 and 1.
        """
        ...
    
    @property
    def NumBounds(arg0: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    
    @property
    def NumPoles(arg0: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    
    @property
    def NumUKnots(arg0: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    
    @property
    def NumUPoles(arg0: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    
    @property
    def NumVKnots(arg0: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    
    @property
    def NumVPoles(arg0: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    
    @property
    def PolygonDisplay(arg0: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        ...
    @PolygonDisplay.setter
    def PolygonDisplay(arg0: MSPyBentleyGeom.MSBsplineSurface, arg1: bool) -> None:
        ...
    
    def Populate(self: MSPyBentleyGeom.MSBsplineSurface, pointVector: MSPyBentleyGeom.DPoint3dArray, weightVector: MSPyBentleyGeom.DoubleArray, uKnotVector: MSPyBentleyGeom.DoubleArray, uOrder: int, numUPoints: int, uClosed: bool, vKnotVector: MSPyBentleyGeom.DoubleArray, vOrder: int, numVPoints: int, vClosed: bool, inputPolesAlreadyWeighted: bool) -> int:
        ...
    
    def ReleaseMem(self: MSPyBentleyGeom.MSBsplineSurface) -> None:
        """
        Free memory allocated for the poles, weights and knot vector of a
        B-spline surface.
        """
        ...
    
    def RemoveKnotsBounded(self: MSPyBentleyGeom.MSBsplineSurface, dir: int, tol: float) -> int:
        """
        Remove all removable knots with the tolerance constraint.
        """
        ...
    
    def Resolution(*args, **kwargs):
        """
        Overloaded function.
        
        1. Resolution(self: MSPyBentleyGeom.MSBsplineSurface) -> float
        
        Get the resolution of the B-spline surface.
        
        2. Resolution(self: MSPyBentleyGeom.MSBsplineSurface, abstol: float, reltol: float) -> float
        
        Get the resolution of the B-spline surface.
        """
        ...
    
    def SetNumRules(self: MSPyBentleyGeom.MSBsplineSurface, numU: int, numV: int) -> None:
        ...
    
    def SetOuterBoundaryActive(self: MSPyBentleyGeom.MSBsplineSurface, active: bool) -> None:
        """
        :param (input):
        active If true, the outer boundary is active as an (implicit) trim
        boundary, so the outermost explict boundary acts as a hole.
        """
        ...
    
    def SetPole(*args, **kwargs):
        """
        Overloaded function.
        
        1. SetPole(self: MSPyBentleyGeom.MSBsplineSurface, index: int, value: MSPyBentleyGeom.DPoint3d) -> bool
        
        set pole by index. returns false if index out of range.
        @DotNetMethodExclude
        
        2. SetPole(self: MSPyBentleyGeom.MSBsplineSurface, i: int, j: int, value: MSPyBentleyGeom.DPoint3d) -> bool
        
        set pole by index. returns false if index out of range.
        @DotNetMethodExclude
        
        3. SetPole(self: MSPyBentleyGeom.MSBsplineSurface, i: int, x: float, y: float, z: float) -> bool
        
        set pole by index. returns false if index out of range.
        @DotNetMethodExclude
        """
        ...
    
    def SetPolygonDisplay(self: MSPyBentleyGeom.MSBsplineSurface, display: bool) -> None:
        ...
    
    def SetReWeightedPole(*args, **kwargs):
        """
        Overloaded function.
        
        1. SetReWeightedPole(self: MSPyBentleyGeom.MSBsplineSurface, index: int, value: MSPyBentleyGeom.DPoint3d) -> bool
        
        set pole by index. returns false if index out of range. If the surface
        is weighted, the current weight is multiplied into the input pole.
        
        2. SetReWeightedPole(self: MSPyBentleyGeom.MSBsplineSurface, i: int, j: int, value: MSPyBentleyGeom.DPoint3d) -> bool
        
        set pole by index. returns false if index out of range. If the surface
        is weighted, the current weight is multiplied into the input pole.
        """
        ...
    
    def SetSurfaceDisplay(self: MSPyBentleyGeom.MSBsplineSurface, display: bool) -> None:
        ...
    
    def SetTrim(self: MSPyBentleyGeom.MSBsplineSurface, cruves: MSPyBentleyGeom.CurveVector) -> None:
        """
        Delete previous trim and add new trim.
        """
        ...
    
    def SetUKnots(self: MSPyBentleyGeom.MSBsplineSurface, index: int, value: float, n: int) -> bool:
        """
        set uKnotw by index. returns false if any index out of range.
        @DotNetMethodExclude
        """
        ...
    
    def SetUParamsWithUniformKnots(self: MSPyBentleyGeom.MSBsplineSurface, numPoles: int, order: int, closed: bool) -> bool:
        """
        Install counts and set up uniform knots in u direction.
        """
        ...
    
    def SetVKnots(self: MSPyBentleyGeom.MSBsplineSurface, index: int, value: float, n: int) -> bool:
        """
        set vKnotw by index. returns false if any index out of range.
        @DotNetMethodExclude
        """
        ...
    
    def SetVParamsWithUniformKnots(self: MSPyBentleyGeom.MSBsplineSurface, numPoles: int, order: int, closed: bool) -> bool:
        """
        Install counts and set up uniform knots in v direction.
        """
        ...
    
    def SetWeight(self: MSPyBentleyGeom.MSBsplineSurface, index: int, w: float) -> bool:
        """
        set weight by index. returns false if index out of range.
        @DotNetMethodExclude
        """
        ...
    
    def SetWeights(self: MSPyBentleyGeom.MSBsplineSurface, index: int, value: float, n: int) -> bool:
        """
        set weight by index. returns false if any index out of range.
        @DotNetMethodExclude
        """
        ...
    
    @property
    def SurfaceDisplay(arg0: MSPyBentleyGeom.MSBsplineSurface) -> bool:
        ...
    @SurfaceDisplay.setter
    def SurfaceDisplay(arg0: MSPyBentleyGeom.MSBsplineSurface, arg1: bool) -> None:
        ...
    
    def SwapUV(self: MSPyBentleyGeom.MSBsplineSurface) -> int:
        """
        Swap the U/V direction of the surface.
        """
        ...
    
    def TransformPoles(self: MSPyBentleyGeom.MSBsplineSurface, transform: Transform, i0: int, j0: int, numI: int, numJ: int) -> None:
        """
        Transform a block of poles wtih start index i0,j0
        """
        ...
    
    def TransformSurface(self: MSPyBentleyGeom.MSBsplineSurface, transform: Transform) -> int:
        """
        Transform the B-spline surface.
        """
        ...
    
    def TryGetBoundaryUV(self: MSPyBentleyGeom.MSBsplineSurface, boundaryIndex: int, pointIndex: int, uv: MSPyBentleyGeom.DPoint2d) -> bool:
        ...
    
    def TryGetUnWeightedPole(*args, **kwargs):
        """
        Overloaded function.
        
        1. TryGetUnWeightedPole(self: MSPyBentleyGeom.MSBsplineSurface, i: int, i: int, xyz: MSPyBentleyGeom.DPoint3d) -> bool
        
        Try to dereference index i,j.
        
        2. TryGetUnWeightedPole(self: MSPyBentleyGeom.MSBsplineSurface, i: int, xyz: MSPyBentleyGeom.DPoint3d) -> bool
        
        Try to dereference index i,j.
        """
        ...
    
    @property
    def UOrder(arg0: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    
    def UnWeightPoles(self: MSPyBentleyGeom.MSBsplineSurface) -> None:
        """
        if the surface is rational, divide (wx,wy,wz) style poles by the
        weights
        """
        ...
    
    @property
    def VOrder(arg0: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    
    def WeightPoles(self: MSPyBentleyGeom.MSBsplineSurface) -> None:
        """
        if the surface is rational, multiply (wx,wy,wz) style poles by the
        weights
        """
        ...
    
    def Zero(self: MSPyBentleyGeom.MSBsplineSurface) -> None:
        """
        zero out the surface
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    
    @property
    def display(self: MSPyBentleyGeom.MSBsplineSurface) -> MSPyBentleyGeom.BsplineDisplay:
        ...
    @display.setter
    def display(self: MSPyBentleyGeom.MSBsplineSurface, arg0: MSPyBentleyGeom.BsplineDisplay) -> None:
        ...
    
    @property
    def holeOrigin(self: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    @holeOrigin.setter
    def holeOrigin(self: MSPyBentleyGeom.MSBsplineSurface, arg0: int) -> None:
        ...
    
    @property
    def numBounds(self: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    @numBounds.setter
    def numBounds(self: MSPyBentleyGeom.MSBsplineSurface, arg0: int) -> None:
        ...
    
    @property
    def poles(arg0: MSPyBentleyGeom.MSBsplineSurface) -> numpy.typing.NDArray:
        ...
    @poles.setter
    def poles(arg0: MSPyBentleyGeom.MSBsplineSurface, arg1: numpy.typing.NDArray) -> None:
        ...
    
    @property
    def rational(self: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    @rational.setter
    def rational(self: MSPyBentleyGeom.MSBsplineSurface, arg0: int) -> None:
        ...
    
    @property
    def type(self: MSPyBentleyGeom.MSBsplineSurface) -> int:
        ...
    @type.setter
    def type(self: MSPyBentleyGeom.MSBsplineSurface, arg0: int) -> None:
        ...
    
    @property
    def uKnots(arg0: MSPyBentleyGeom.MSBsplineSurface) -> numpy.typing.NDArray:
        ...
    @uKnots.setter
    def uKnots(arg0: MSPyBentleyGeom.MSBsplineSurface, arg1: numpy.typing.NDArray) -> None:
        ...
    
    @property
    def uParams(self: MSPyBentleyGeom.MSBsplineSurface) -> MSPyBentleyGeom.BsplineParam:
        ...
    @uParams.setter
    def uParams(self: MSPyBentleyGeom.MSBsplineSurface, arg0: MSPyBentleyGeom.BsplineParam) -> None:
        ...
    
    @property
    def vKnots(arg0: MSPyBentleyGeom.MSBsplineSurface) -> numpy.typing.NDArray:
        ...
    @vKnots.setter
    def vKnots(arg0: MSPyBentleyGeom.MSBsplineSurface, arg1: numpy.typing.NDArray) -> None:
        ...
    
    @property
    def vParams(self: MSPyBentleyGeom.MSBsplineSurface) -> MSPyBentleyGeom.BsplineParam:
        ...
    @vParams.setter
    def vParams(self: MSPyBentleyGeom.MSBsplineSurface, arg0: MSPyBentleyGeom.BsplineParam) -> None:
        ...
    
    @property
    def weights(arg0: MSPyBentleyGeom.MSBsplineSurface) -> numpy.typing.NDArray:
        ...
    @weights.setter
    def weights(arg0: MSPyBentleyGeom.MSBsplineSurface, arg1: numpy.typing.NDArray) -> None:
        ...
    
class RefCountedMSInterpolationCurve:
    """
    None
    """

    def AllocateFitPoints(self: MSPyBentleyGeom.MSInterpolationCurve, count: int, data: MSPyBentleyGeom.DPoint3d = None) -> int:
        """
        Allocate specified number of fit points. Optionally copy in points
        from buffer.
        """
        ...
    
    def AllocateKnots(self: MSPyBentleyGeom.MSInterpolationCurve, count: int, data: float = None) -> int:
        """
        Allocate specified number of knots. Optionally copy in knots from
        buffer.
        """
        ...
    
    def AlmostEqual(self: MSPyBentleyGeom.MSInterpolationCurve, other: MSPyBentleyGeom.MSInterpolationCurve, tolerance: float) -> bool:
        ...
    
    def CopyFrom(self: MSPyBentleyGeom.MSInterpolationCurve, source: MSPyBentleyGeom.MSInterpolationCurve) -> int:
        """
        Allocate memory for the B-spline curve and copies all data from the
        input inerpolation curve.
        """
        ...
    
    def Create() -> MSPyBentleyGeom.RefCountedMSInterpolationCurve:
        ...
    
    def GetOrder(self: MSPyBentleyGeom.MSInterpolationCurve) -> int:
        ...
    
    def InitFromPointsAndEndTangents(*args, **kwargs):
        """
        Overloaded function.
        
        1. InitFromPointsAndEndTangents(self: MSPyBentleyGeom.MSInterpolationCurve, inPoints: MSPyBentleyGeom.DPoint3dArray, removeData: bool, removeTol: float, endTangents: MSPyBentleyGeom.DPoint3d, closedCurve: bool, colinearTangents: bool, chordLenTangents: bool, naturalTangents: bool) -> int
        
        2. InitFromPointsAndEndTangents(self: MSPyBentleyGeom.MSInterpolationCurve, inPoints: list, removeData: bool, removeTol: float, endTangents: MSPyBentleyGeom.DPoint3d, closedCurve: bool, colinearTangents: bool, chordLenTangents: bool, naturalTangents: bool) -> int
        """
        ...
    
    @property
    def Order(arg0: MSPyBentleyGeom.MSInterpolationCurve) -> int:
        ...
    
    def Populate(*args, **kwargs):
        """
        Overloaded function.
        
        1. Populate(self: MSPyBentleyGeom.MSInterpolationCurve, order: int, periodic: bool, isChordLenKnots: int, isColinearTangents: int, isChordLenTangents: int, isNaturalTangents: int, fitPoints: MSPyBentleyGeom.DPoint3dArray, knots: MSPyBentleyGeom.DoubleArray, startTangent: MSPyBentleyGeom.DVec3d, endTangent: MSPyBentleyGeom.DVec3d) -> int
        
        2. Populate(self: MSPyBentleyGeom.MSInterpolationCurve, order: int, periodic: bool, isChordLenKnots: int, isColinearTangents: int, isChordLenTangents: int, isNaturalTangents: int, fitPoints: list, knots: MSPyBentleyGeom.DoubleArray, startTangent: MSPyBentleyGeom.DVec3d, endTangent: MSPyBentleyGeom.DVec3d) -> int
        
        3. Populate(self: MSPyBentleyGeom.MSInterpolationCurve, order: int, periodic: bool, isChordLenKnots: int, isColinearTangents: int, isChordLenTangents: int, isNaturalTangents: int, fitPoints: List[MSPyBentleyGeom.DPoint3d], knots: List[float]) -> int
        """
        ...
    
    def ReleaseMem(self: MSPyBentleyGeom.MSInterpolationCurve) -> None:
        """
        Free the memory allocated to the poles of the interpolation curve.
        """
        ...
    
    def Zero(self: MSPyBentleyGeom.MSInterpolationCurve) -> None:
        """
        Clear to zero state. DOES NOT RELEASE MEMORY.
        """
        ...
    
    def __init__(*args, **kwargs):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    
class ReprojectStatus:
    """
    Members:
    
    eREPROJECT_Success
    
    eREPROJECT_CSMAPERR_OutOfUsefulRange
    
    eREPROJECT_CSMAPERR_OutOfMathematicalDomain
    
    eREPROJECT_CSMAPERR_DatumConverterNotSet
    
    eREPROJECT_CSMAPERR_VerticalDatumConversionError
    
    eREPROJECT_CSMAPERR_Error
    
    eREPROJECT_BadArgument
    
    eREPROJECT_NoChange
    
    eREPROJECT_StrokeError
    
    eREPROJECT_DataError
    
    eREPROJECT_DontValidateRange
    
    eREPROJECT_GeoCoordNotInitialized
    
    eREPROJECT_InvalidCoordSys
    """

    def __init__(self: MSPyBentleyGeom.ReprojectStatus, value: int) -> None:
        ...
    
    eREPROJECT_BadArgument: ReprojectStatus
    
    eREPROJECT_CSMAPERR_DatumConverterNotSet: ReprojectStatus
    
    eREPROJECT_CSMAPERR_Error: ReprojectStatus
    
    eREPROJECT_CSMAPERR_OutOfMathematicalDomain: ReprojectStatus
    
    eREPROJECT_CSMAPERR_OutOfUsefulRange: ReprojectStatus
    
    eREPROJECT_CSMAPERR_VerticalDatumConversionError: ReprojectStatus
    
    eREPROJECT_DataError: ReprojectStatus
    
    eREPROJECT_DontValidateRange: ReprojectStatus
    
    eREPROJECT_GeoCoordNotInitialized: ReprojectStatus
    
    eREPROJECT_InvalidCoordSys: ReprojectStatus
    
    eREPROJECT_NoChange: ReprojectStatus
    
    eREPROJECT_StrokeError: ReprojectStatus
    
    eREPROJECT_Success: ReprojectStatus
    
    @property
    def name(self: handle) -> str:
        ...
    
    @property
    def value(arg0: MSPyBentleyGeom.ReprojectStatus) -> int:
        ...
    
class RgbFactor:
    """
    None
    """

    def AddInPlace(self: MSPyBentleyGeom.RgbFactor, other: MSPyBentleyGeom.RgbFactor) -> None:
        ...
    
    @staticmethod
    def From(*args, **kwargs):
        """
        Overloaded function.
        
        1. From(data: MSPyBentleyGeom.DPoint3d) -> MSPyBentleyGeom.RgbFactor
        
        2. From(r: float, g: float, b: float) -> MSPyBentleyGeom.RgbFactor
        """
        ...
    
    @staticmethod
    def FromIntColor(intColor: int) -> MSPyBentleyGeom.RgbFactor:
        ...
    
    def ScaleInPlace(self: MSPyBentleyGeom.RgbFactor, a: float) -> None:
        ...
    
    def __init__(self: MSPyBentleyGeom.RgbFactor) -> None:
        ...
    
    @property
    def blue(self: MSPyBentleyGeom.RgbFactor) -> float:
        ...
    @blue.setter
    def blue(self: MSPyBentleyGeom.RgbFactor, arg0: float) -> None:
        ...
    
    @property
    def green(self: MSPyBentleyGeom.RgbFactor) -> float:
        ...
    @green.setter
    def green(self: MSPyBentleyGeom.RgbFactor, arg0: float) -> None:
        ...
    
    @property
    def red(self: MSPyBentleyGeom.RgbFactor) -> float:
        ...
    @red.setter
    def red(self: MSPyBentleyGeom.RgbFactor, arg0: float) -> None:
        ...
    
class RgbFactorArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.RgbFactorArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.RgbFactorArray, arg0: MSPyBentleyGeom.RgbFactorArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.RgbFactorArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.RgbFactorArray, x: MSPyBentleyGeom.RgbFactor) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.RgbFactorArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.RgbFactorArray, L: MSPyBentleyGeom.RgbFactorArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.RgbFactorArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.RgbFactorArray, i: int, x: MSPyBentleyGeom.RgbFactor) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.RgbFactorArray) -> MSPyBentleyGeom.RgbFactor
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.RgbFactorArray, i: int) -> MSPyBentleyGeom.RgbFactor
        
        Remove and return the item at index ``i``
        """
        ...
    
class RotMatrix:
    """
    None
    """

    def Add(self: MSPyBentleyGeom.RotMatrix, delta: MSPyBentleyGeom.RotMatrix) -> None:
        """
        Add a matrix (componentwise, in place).
        
        :param (input):
        delta The matrix to add
        """
        ...
    
    def AddScaledOuterProductInPlace(self: MSPyBentleyGeom.RotMatrix, vectorU: MSPyBentleyGeom.DVec3d, vectorV: MSPyBentleyGeom.DVec3d, scale: float) -> None:
        """
        Accumulates a 'rank one' matrix defined as a scale factor
        times the 'vector outer product' of two vectors, i.e. as the matrix
        {s*U*V^T}
        
        :param (input):
        vectorU The column vector U
        
        :param (input):
        vectorV The row vector V
        
        :param (input):
        scale The scale factor
        """
        ...
    
    def ColumnXAngleXY(self: MSPyBentleyGeom.RotMatrix) -> float:
        """
        Returns the (0 or positive) angle from (1,0) to the XY vector in the
        first column.
        
        :returns:
        rotation angle (in radians) between 0 and 2Pi
        """
        ...
    
    def ConditionNumber(self: MSPyBentleyGeom.RotMatrix) -> float:
        """
        Computes an estimate of the condition of this instance matrix. Values
        near 0 are bad.
        
        :returns:
        estimated condition number.
        """
        ...
    
    def Copy(self: MSPyBentleyGeom.RotMatrix, arg0: MSPyBentleyGeom.RotMatrix) -> None:
        """
        Sets this instance matrix by copying from the matrix
        parameter.
        
        :param (input):
        in The source matrix
        """
        ...
    
    def Determinant(self: MSPyBentleyGeom.RotMatrix) -> float:
        """
        Returns the determinant of the matrix.
        
        :returns:
        determinant of the matrix.
        """
        ...
    
    def DiagonalAbsRange(*args, **kwargs):
        """
        Overloaded function.
        
        1. DiagonalAbsRange(self: MSPyBentleyGeom.RotMatrix) -> tuple
        
        Return the (absolute value) range of entries on the
        diagonal.
        
        :param (output):
        minValue smallest absolute value
        
        :param (output):
        maxValue largest absolute value
        
        2. DiagonalAbsRange(self: MSPyBentleyGeom.RotMatrix) -> MSPyBentleyGeom.DRange1d
        
        Return the (absolute value) range of entries on the
        diagonal.
        
        :param (output):
        minValue smallest absolute value
        
        :param (output):
        maxValue largest absolute value
        """
        ...
    
    def DiagonalMaxAbs(self: MSPyBentleyGeom.RotMatrix) -> float:
        """
        return the largest absolute value on the diagonal
        """
        ...
    
    def DiagonalSignedRange(self: MSPyBentleyGeom.RotMatrix) -> tuple:
        """
        Return the (signed) range of entries on the diagonal.
        
        :param (output):
        minValue smallest signed value
        
        :param (output):
        maxValue largest signed value
        """
        ...
    
    def FactorOrthogonalColumns(self: MSPyBentleyGeom.RotMatrix, matrixB: MSPyBentleyGeom.RotMatrix, maxtrixV: MSPyBentleyGeom.RotMatrix) -> bool:
        """
        Factor the instance as a product B*V^ where B has mutually
        perpendicular columns and V is orthogonal.
        
        :param (output):
        matrixB orthogonal columns
        
        :param (output):
        matrixV transpose of right factor. (I.e. B = A*V)
        """
        ...
    
    def FactorRotateScaleRotate(self: MSPyBentleyGeom.RotMatrix, rotation1: MSPyBentleyGeom.RotMatrix, scalePoint: MSPyBentleyGeom.DPoint3d, rotation2: MSPyBentleyGeom.RotMatrix) -> int:
        """
        Factor as{rotation1 * scale * rotation2}
        
        :returns:
        number of nonzero scales (independent columns).
        
        :param (output):
        rotation1 pure rotation
        
        :param (output):
        scalePoint scale factors, largest first.
        
        :param (output):
        rotation2 pure rotation
        """
        ...
    
    @staticmethod
    def From(transform: MSPyBentleyGeom.Transform) -> MSPyBentleyGeom.RotMatrix:
        """
        Returns a matrix copying the matrix part of the
        trasnform.
        
        :param (input):
        transform The transformation whose matrix part is returned
        """
        ...
    
    @staticmethod
    def From1Vector(dir: MSPyBentleyGeom.DVec3d, axis: int, normalize: bool) -> MSPyBentleyGeom.RotMatrix:
        """
        Initializes this instance matrix so that the indicated
        axis (axis = 0,1,or 2) is aligned with the vector dir. The normalize
        flag selects between normalized axes (all matrix columns of unit
        length) and unnormalized axes (all matrix columns of same length as
        the dir vector).
        
        :param (input):
        dir The fixed direction vector
        
        :param (input):
        axis The axis column to be aligned with direction
        
        :param (input):
        normalize true to have normalized columns
        
        :returns:
        true if the direction vector is nonzero.
        """
        ...
    
    @staticmethod
    def From2Vector(xVector: MSPyBentleyGeom.DVec3d, yVector: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.RotMatrix:
        ...
    
    @staticmethod
    def FromAxisAndRotationAngle(axis: int, radians: float) -> MSPyBentleyGeom.RotMatrix:
        """
        Returns a matrix of rotation about the x,y, or z axis
        (indicated by axis = 0,1, or 2) by an angle in radians.
        
        :param (input):
        axis The axis index 0=x, 1=y, 2=z
        
        :param (input):
        radians The rotation angle in radians
        """
        ...
    
    @staticmethod
    def FromColumnVectors(vectorU: MSPyBentleyGeom.DVec3d, vectorV: MSPyBentleyGeom.DVec3d, vectorW: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.RotMatrix:
        """
        Returns a matrix with 3 vectors copied to respective
        columns.
        
        :param (input):
        vectorU The vector to insert in column 0
        
        :param (input):
        vectorV The vector to insert in column 1
        
        :param (input):
        vectorW The vector to insert in column 2
        """
        ...
    
    @staticmethod
    def FromDirectionAndScale(vector: MSPyBentleyGeom.DVec3d, scale: float) -> MSPyBentleyGeom.RotMatrix:
        """
        Returns a matrix which scales along a vector direction.
        
        :param (input):
        vector The scaling direction
        
        :param (input):
        scale The scale factor
        """
        ...
    
    @staticmethod
    def FromPrincipleAxisRotations(inMatrix: MSPyBentleyGeom.RotMatrix, xrot: float, yrot: float, zrot: float) -> MSPyBentleyGeom.RotMatrix:
        """
        Returns the product{RX*RY*RZ*M} where RX, RY, and RZ are
        rotations (in radians) around X, Y, and Z axes, and M is the input
        matrix.
        
        :param (input):
        inMatrix The prior matrix
        
        :param (input):
        xrot The x axis rotation
        
        :param (input):
        yrot The y axis rotation
        
        :param (input):
        zrot The z axis rotation
        """
        ...
    
    @staticmethod
    def FromQuaternion(quat: MSPyBentleyGeom.DPoint4d) -> MSPyBentleyGeom.RotMatrix:
        """
        :param (input):
        quat The quaternion, stored as (xyzw)
        """
        ...
    
    @staticmethod
    def FromRotate90(axis: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.RotMatrix:
        """
        Return a matrix for retation of 90 degrees about a vector.
        """
        ...
    
    @staticmethod
    def FromRowValues(x00: float, x01: float, x02: float, x10: float, x11: float, x12: float, x20: float, x21: float, x22: float) -> MSPyBentleyGeom.RotMatrix:
        """
        Returns a matrix with the 9 specified coefficients given
        in " row major " order.
        
        :param (input):
        x00 The 00 entry
        
        :param (input):
        x01 The 01 entry
        
        :param (input):
        x02 The 02 entry
        
        :param (input):
        x10 The 10 entry
        
        :param (input):
        x11 The 11 entry
        
        :param (input):
        x12 The 12 entry
        
        :param (input):
        x20 The 20 entry
        
        :param (input):
        x21 The 21 entry
        
        :param (input):
        x22 The 22 entry
        """
        ...
    
    @staticmethod
    def FromRowVectors(vectorU: MSPyBentleyGeom.DVec3d, vectorV: MSPyBentleyGeom.DVec3d, vectorW: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.RotMatrix:
        """
        Returns a matrix with 3 vectors copied to respective
        rows.
        
        :param (input):
        vectorU The vector to insert in row 0
        
        :param (input):
        vectorV The vector to insert in row 1
        
        :param (input):
        vectorW The vector to insert in row 2
        """
        ...
    
    @staticmethod
    def FromScale(scale: float) -> MSPyBentleyGeom.RotMatrix:
        """
        Returns a uniform scaling matrix.
        
        :param (input):
        scale The scale factor.
        """
        ...
    
    @staticmethod
    def FromScaleFactors(xscale: float, yscale: float, zscale: float) -> MSPyBentleyGeom.RotMatrix:
        """
        Returns a scaling matrix with respective x, y, and z
        scaling factors.
        
        :param (input):
        xscale The x direction scale factor (00 diagonal)
        
        :param (input):
        yscale The y direction scale factor (11 diagonal)
        
        :param (input):
        zscale The z direction scale factor (22 diagonal)
        """
        ...
    
    @staticmethod
    def FromScaledOuterProduct(vectorU: MSPyBentleyGeom.DVec3d, vectorV: MSPyBentleyGeom.DVec3d, scale: float) -> MSPyBentleyGeom.RotMatrix:
        """
        Returns a 'rank one' matrix defined as a scale factor
        times the 'vector outer product' of two vectors, i.e. as the matrix
        {s*U*V^T}
        
        :param (input):
        vectorU The column vector U
        
        :param (input):
        vectorV The row vector V
        
        :param (input):
        scale The scale factor
        """
        ...
    
    @staticmethod
    def FromTransposeOf(matrix: MSPyBentleyGeom.RotMatrix) -> MSPyBentleyGeom.RotMatrix:
        """
        Return (as function value) the transpose of a matrix.
        
        :param (input):
        matrix The input matrix
        """
        ...
    
    @staticmethod
    def FromVectorAndRotationAngle(*args, **kwargs):
        """
        Overloaded function.
        
        1. FromVectorAndRotationAngle(axis: MSPyBentleyGeom.DVec3d, radians: float) -> MSPyBentleyGeom.RotMatrix
        
        Returns a matrix representing rotation around a vector.
        
        :param (input):
        axis The axis of rotation
        
        :param (input):
        radians The rotation angle
        
        2. FromVectorAndRotationAngle(axis: MSPyBentleyGeom.DVec3d, radians: float, deriviativeMatrix: MSPyBentleyGeom.RotMatrix) -> MSPyBentleyGeom.RotMatrix
        
        Returns a matrix representing rotation around a vector.
        
        :param (input):
        axis The axis of rotation
        
        :param (input):
        radians The rotation angle
        """
        ...
    
    def GetColumn(self: MSPyBentleyGeom.RotMatrix, vector: MSPyBentleyGeom.DVec3d, col: int) -> None:
        """
        Returns a point taken from a column of a matrix.
        
        :param (output):
        vector filled vector
        
        :param (input):
        col The index of column to extract. Column indices are 0, 1, 2.
        """
        ...
    
    def GetColumns(self: MSPyBentleyGeom.RotMatrix, vectorU: MSPyBentleyGeom.DVec3d, vectorV: MSPyBentleyGeom.DVec3d, vectorW: MSPyBentleyGeom.DVec3d) -> None:
        """
        Copies from columns of this instance matrix to
        corresponding points.
        
        :param (output):
        vectorU first column
        
        :param (output):
        vectorV second column
        
        :param (output):
        vectorW third column
        """
        ...
    
    def GetComponentByRowAndColumn(self: MSPyBentleyGeom.RotMatrix, row: int, col: int) -> float:
        """
        Returns a value from a specified row and column of the
        matrix.
        
        :param (input):
        row The index of row to read. Row indices are 0, 1, 2.
        
        :param (input):
        col The index of column to read. Column indices are 0, 1, 2.
        """
        ...
    
    def GetQuaternion(*args, **kwargs):
        """
        Overloaded function.
        
        1. GetQuaternion(self: MSPyBentleyGeom.RotMatrix, quat: MSPyBentleyGeom.DPoint4d, transpose: bool) -> None
        
        :param (output):
        quat quaternion, stored as xyzw
        
        :param (input):
        transpose true if matrix is stored transposed
        
        2. GetQuaternion(self: MSPyBentleyGeom.RotMatrix, wxyzQuat: MSPyBentleyGeom.DoubleArray, transpose: bool) -> None
        
        :param (output):
        quat quaternion, stored as xyzw
        
        :param (input):
        transpose true if matrix is stored transposed
        """
        ...
    
    def GetRotationAngleAndVector(self: MSPyBentleyGeom.RotMatrix, axis: MSPyBentleyGeom.DVec3d) -> float:
        """
        Returns the angle of rotation of this instance and sets axis to be the
        normalized vector about which this instance rotates. NOTE:this
        instance is assumed to be a (rigid body, i.e. orthogonal) rotation
        matrix. Since negating both angle and axis produces an identical
        rotation, calculations are simplified by assuming (and returning) the
        angle in [0,Pi].
        
        :param (output):
        axis normalized axis of rotation
        
        :returns:
        rotation angle (in radians) between 0 and Pi, inclusive
        """
        ...
    
    def GetRow(self: MSPyBentleyGeom.RotMatrix, vector: MSPyBentleyGeom.DVec3d, row: int) -> None:
        """
        Returns a vector taken from a column of a matrix.
        
        :param (output):
        vector filled vector
        
        :param (input):
        row The index of row to extract. Row indices are 0, 1, and 2.
        """
        ...
    
    def GetRowValues(self: MSPyBentleyGeom.RotMatrix) -> List[float[9]]:
        """
        Get all contents as individual doubles, moving along rows
        """
        ...
    
    def GetRowValuesXY(self: MSPyBentleyGeom.RotMatrix, arg0: MSPyBentleyGeom.DoubleArray) -> None:
        """
        Copies 4 doubles from xx,xy,yx,yy positions into an
        array.
        
        :param (output):
        data returned data -- first 2 entries in row 0, then first 2 in
        row 1.
        """
        ...
    
    def GetRows(self: MSPyBentleyGeom.RotMatrix, vectorU: MSPyBentleyGeom.DVec3d, vectorV: MSPyBentleyGeom.DVec3d, vectorW: MSPyBentleyGeom.DVec3d) -> None:
        """
        Copies from rows of this instance matrix to corresponding
        points.
        
        :param (output):
        vectorU first row
        
        :param (output):
        vectorV second row
        
        :param (output):
        vectorW third row
        """
        ...
    
    def GivensColumnOp(self: MSPyBentleyGeom.RotMatrix, c: float, s: float, i0: int, i1: int) -> None:
        """
        Apply a Givens " column operation ", i.e. post-multiply by a Givens
        rotation matrix. The Givens matrix is an identity except for the 4
        rotational entries, viz R(i0,i0)=R(i1,i1)=c R(i0,i1)=-s R(i1,i0)=s
        
        :param (input):
        c The cosine of givens rotation.
        
        :param (input):
        s The sine of givens rotation.
        
        :param (input):
        i0 The index of the first affected row.
        
        :param (input):
        i1 The index of the second affected row.
        """
        ...
    
    def GivensRowOp(self: MSPyBentleyGeom.RotMatrix, c: float, s: float, i0: int, i1: int) -> None:
        """
        Apply a Givens " row operation ", i.e. pre-multiply by a Givens rotation
        matrix. The Givens matrix is an identity except for the 4 rotational
        entries, viz R(i0,i0)=R(i1,i1)=c R(i0,i1)=s R(i1,i0)=-s
        
        :param (input):
        c The cosine of givens rotation.
        
        :param (input):
        s The sine of givens rotation.
        
        :param (input):
        i0 The index of the first affected row.
        
        :param (input):
        i1 The index of the second affected row.
        """
        ...
    
    def HyperbolicColumnOp(self: MSPyBentleyGeom.RotMatrix, secant: float, tangent: float, i0: int, i1: int) -> None:
        """
        Apply a hyperbolic " column operation ", i.e. pre-multiply by a
        hyperbolic reflection matrix The matrix is an identity except for the
        4 entries R(i0,i0)=R(i1,i1)=secant R(i0,i1)=R(i1,i0)=tangent
        
        :param (input):
        secant The cosine of reflection.
        
        :param (input):
        tangent The sine of reflection.
        
        :param (input):
        i0 The index of the first affected row.
        
        :param (input):
        i1 The index of the second affected row.
        """
        ...
    
    def HyperbolicRowOp(self: MSPyBentleyGeom.RotMatrix, secant: float, tangent: float, i0: int, i1: int) -> None:
        """
        Apply a hyperbolic " row operation ", i.e. pre-multiply by a hyperbolic
        reflection matrix The matrix is an identity except for the 4 entries
        R(i0,i0)=R(i1,i1)=secant R(i0,i1)=R(i1,i0)=tangent
        
        :param (input):
        secant The cosine of reflection.
        
        :param (input):
        tangent The sine of reflection.
        
        :param (input):
        i0 The index of the first affected row.
        
        :param (input):
        i1 The index of the second affected row.
        """
        ...
    
    def InitFrom(self: MSPyBentleyGeom.RotMatrix, transform: MSPyBentleyGeom.Transform) -> None:
        """
        Sets this instance matrix by copying the matrix part of the trasnform.
        
        :param (input):
        transform The transformation whose matrix part is returned
        """
        ...
    
    def InitFrom1Vector(self: MSPyBentleyGeom.RotMatrix, dir: MSPyBentleyGeom.DVec3d, axis: int, normalize: bool) -> bool:
        """
        Initializes this instance matrix so that the indicated
        axis (axis = 0,1,or 2) is aligned with the vector dir. The normalize
        flag selects between normalized axes (all matrix columns of unit
        length) and unnormalized axes (all matrix columns of same length as
        the dir vector).
        
        :param (input):
        dir The fixed direction vector
        
        :param (input):
        axis The axis column to be aligned with direction
        
        :param (input):
        normalize true to have normalized columns
        
        :returns:
        true if the direction vector is nonzero.
        """
        ...
    
    def InitFrom2Vector(self: MSPyBentleyGeom.RotMatrix, xVector: MSPyBentleyGeom.DVec3d, yVector: MSPyBentleyGeom.DVec3d) -> None:
        ...
    
    def InitFromAxisAndRotationAngle(self: MSPyBentleyGeom.RotMatrix, axis: int, radians: float) -> None:
        """
        Returns a matrix of rotation about the x,y, or z axis
        (indicated by axis = 0,1, or 2) by an angle in radians.
        
        :param (input):
        axis The axis index 0=x, 1=y, 2=z
        
        :param (input):
        radians The rotation angle in radians
        """
        ...
    
    def InitFromColumnVectors(self: MSPyBentleyGeom.RotMatrix, vectorU: MSPyBentleyGeom.DVec3d, vectorV: MSPyBentleyGeom.DVec3d, vectorW: MSPyBentleyGeom.DVec3d) -> None:
        """
        Returns a matrix with 3 points copied to respective
        columns.
        
        :param (input):
        vectorU The vector to insert in column 0
        
        :param (input):
        vectorV The vector to insert in column 1
        
        :param (input):
        vectorW The vector to insert in column 2
        """
        ...
    
    def InitFromDirectionAndScale(self: MSPyBentleyGeom.RotMatrix, vector: MSPyBentleyGeom.DVec3d, scale: float) -> None:
        """
        Initializes a matrix which scales along a vector
        direction.
        
        :param (input):
        vector The scaling direction
        
        :param (input):
        scale The scale factor
        """
        ...
    
    def InitFromPrincipleAxisRotations(self: MSPyBentleyGeom.RotMatrix, inMatrix: MSPyBentleyGeom.RotMatrix, xrot: float, yrot: float, zrot: float) -> None:
        """
        Returns the product{RX*RY*RZ*M} where RX, RY, and RZ are
        rotations (in radians) around X, Y, and Z axes, and M is the input
        matrix.
        
        :param (input):
        inMatrix The prior matrix
        
        :param (input):
        xrot The x axis rotation
        
        :param (input):
        yrot The y axis rotation
        
        :param (input):
        zrot The z axis rotation
        """
        ...
    
    def InitFromQuaternion(*args, **kwargs):
        """
        Overloaded function.
        
        1. InitFromQuaternion(self: MSPyBentleyGeom.RotMatrix, quat: MSPyBentleyGeom.DPoint4d) -> None
        
        :param (input):
        quat The quaternion, stored as (xyzw)
        
        2. InitFromQuaternion(self: MSPyBentleyGeom.RotMatrix, wxyzQuat: List[float[4]]) -> None
        """
        ...
    
    def InitFromRowValues(self: MSPyBentleyGeom.RotMatrix, x00: float, x01: float, x02: float, x10: float, x11: float, x12: float, x20: float, x21: float, x22: float) -> None:
        """
        Initializes a matrix with the 9 specified coefficients
        given in " row major " order.
        
        :param (input):
        x00 The 00 entry
        
        :param (input):
        x01 The 01 entry
        
        :param (input):
        x02 The 02 entry
        
        :param (input):
        x10 The 10 entry
        
        :param (input):
        x11 The 11 entry
        
        :param (input):
        x12 The 12 entry
        
        :param (input):
        x20 The 20 entry
        
        :param (input):
        x21 The 21 entry
        
        :param (input):
        x22 The 22 entry
        """
        ...
    
    def InitFromRowValuesXY(*args, **kwargs):
        """
        Overloaded function.
        
        1. InitFromRowValuesXY(self: MSPyBentleyGeom.RotMatrix, x00: float, x01: float, x10: float, x11: float) -> None
        
        Initializes a matrix with the 4 specified coefficients in
        xx,xy,yx,yy positions, and 1 in zz in " row major " order.
        
        :param (input):
        x00 The 00 entry
        
        :param (input):
        x01 The 01 entry
        
        :param (input):
        x10 The 10 entry
        
        :param (input):
        x11 The 11 entry
        
        2. InitFromRowValuesXY(self: MSPyBentleyGeom.RotMatrix, value: List[float[4]]) -> None
        """
        ...
    
    def InitFromRowVectors(self: MSPyBentleyGeom.RotMatrix, vectorU: MSPyBentleyGeom.DVec3d, vectorV: MSPyBentleyGeom.DVec3d, vectorW: MSPyBentleyGeom.DVec3d) -> None:
        """
        Initializes a matrix with 3 points copied to respective
        rows.
        
        :param (input):
        vectorU The vector to insert in row 0
        
        :param (input):
        vectorV The vector to insert in row 1
        
        :param (input):
        vectorW The vector to insert in row 2
        """
        ...
    
    def InitFromScale(self: MSPyBentleyGeom.RotMatrix, arg0: float) -> None:
        """
        scale_a
        """
        ...
    
    def InitFromScaleFactors(self: MSPyBentleyGeom.RotMatrix, xscale: float, yscale: float, zscale: float) -> None:
        """
        Returns a scaling matrix with respective x, y, and z
        scaling factors.
        
        :param (input):
        xscale The x direction scale factor
        
        :param (input):
        yscale The y direction scale factor
        
        :param (input):
        zscale The z direction scale factor
        """
        ...
    
    def InitFromScaledOuterProduct(self: MSPyBentleyGeom.RotMatrix, vectorU: MSPyBentleyGeom.DVec3d, vectorV: MSPyBentleyGeom.DVec3d, scale: float) -> None:
        """
        Returns a 'rank one' matrix defined as a scale factor
        times the 'vector outer product' of two vectors, i.e. as the matrix
        {s*U*V^T}
        
        :param (input):
        vectorU The column vector U
        
        :param (input):
        vectorV The row vector V
        
        :param (input):
        scale The scale factor
        """
        ...
    
    def InitFromVectorAndRotationAngle(self: MSPyBentleyGeom.RotMatrix, axis: MSPyBentleyGeom.DVec3d, radians: float) -> None:
        ...
    
    def InitIdentity(self: MSPyBentleyGeom.RotMatrix) -> None:
        """
        Initialize an identity matrix.
        """
        ...
    
    def InitProduct(*args, **kwargs):
        """
        Overloaded function.
        
        1. InitProduct(self: MSPyBentleyGeom.RotMatrix, rotMatrixA: MSPyBentleyGeom.RotMatrix, rotMatrixB: MSPyBentleyGeom.RotMatrix) -> None
        
        Returns the product{A*B} of two matrices.
        
        :param (input):
        rotMatrixA The first factor
        
        :param (input):
        rotMatrixB The second factor
        
        2. InitProduct(self: MSPyBentleyGeom.RotMatrix, rotMatrixA: MSPyBentleyGeom.RotMatrix, rotMatrixB: MSPyBentleyGeom.RotMatrix, rotMatrixC: MSPyBentleyGeom.RotMatrix) -> None
        
        Returns the product{A*B} of two matrices.
        
        :param (input):
        rotMatrixA The first factor
        
        :param (input):
        rotMatrixB The second factor
        
        3. InitProduct(self: MSPyBentleyGeom.RotMatrix, rotMatrixA: MSPyBentleyGeom.RotMatrix, transformB: MSPyBentleyGeom.Transform) -> None
        
        Returns the product{A*B} of two matrices.
        
        :param (input):
        rotMatrixA The first factor
        
        :param (input):
        rotMatrixB The second factor
        
        4. InitProduct(self: MSPyBentleyGeom.RotMatrix, transformA: MSPyBentleyGeom.Transform, rotMatrixB: MSPyBentleyGeom.RotMatrix) -> None
        
        Returns the product{A*B} of two matrices.
        
        :param (input):
        rotMatrixA The first factor
        
        :param (input):
        rotMatrixB The second factor
        """
        ...
    
    def InitProductRotMatrixRotMatrixTranspose(self: MSPyBentleyGeom.RotMatrix, rotMatrixA: MSPyBentleyGeom.RotMatrix, rotMatrixB: MSPyBentleyGeom.RotMatrix) -> None:
        """
        Returns the product of rotMatrixA times the transpose of
        rotMatrixB
        
        :param (input):
        rotMatrixA The first factor
        
        :param (input):
        rotMatrixB The second factor (to be transposed)
        """
        ...
    
    def InitProductRotMatrixTransposeRotMatrix(self: MSPyBentleyGeom.RotMatrix, rotMatrixA: MSPyBentleyGeom.RotMatrix, rotMatrixB: MSPyBentleyGeom.RotMatrix) -> None:
        """
        Returns the product of the transpose of rotMatrixA times
        rotMatrixB
        
        :param (input):
        rotMatrixA The first factor (to be transposed)
        
        :param (input):
        rotMatrixB The second factor
        """
        ...
    
    def InitRotationFromOriginXY(self: MSPyBentleyGeom.RotMatrix, origin: MSPyBentleyGeom.DPoint3d, xPoint: MSPyBentleyGeom.DPoint3d, yPoint: MSPyBentleyGeom.DPoint3d) -> bool:
        """
        Set this instance matrix to be an orthogonal (rotation)
        matrix with column 0 in the direction from the origin to the x point,
        column 1 in the plane of the 3 points, directed so the Y point on the
        positive side, and column 2 as their cross product.
        
        :param (input):
        origin The reference point
        
        :param (input):
        xPoint The x axis target point
        
        :param (input):
        yPoint The 3rd point defining xy plane.
        """
        ...
    
    def InitRotationFromVectorToVector(self: MSPyBentleyGeom.RotMatrix, startVector: MSPyBentleyGeom.DVec3d, endVector: MSPyBentleyGeom.DVec3d) -> bool:
        """
        (conditionally) initialize the instance as the (smallest)
        rotation that moves startVector so it is in the direction of
        endVector. In the normal case where the vectors are not parallel or
        antiparallel, this is a rotation around their cross product.
        
        :returns:
        false if one or both are zero vectors.
        
        Remark:
        if the vectors are direction opposite, the rotation is around an
        arbitrarily
        """
        ...
    
    def InitTransposedFromQuaternionWXYZ(self: MSPyBentleyGeom.RotMatrix, wxyzQuat: float) -> None:
        """
        Initialization, compatible with mdlRMatrix_fromQuat.
        
        :param (input):
        pQuatAsDoubleArray The quaternion, stored as (w,x,y,z) in an array
        of doubles.
        """
        ...
    
    def InverseOf(self: MSPyBentleyGeom.RotMatrix, forward: MSPyBentleyGeom.RotMatrix) -> bool:
        """
        Returns the inverse of the a matrix.
        
        :param (input):
        forward The input matrix
        
        :returns:
        true if the matrix is invertible.
        """
        ...
    
    def Invert(self: MSPyBentleyGeom.RotMatrix) -> bool:
        """
        Inverts this instance matrix in place.
        
        :returns:
        true if the matrix is invertible.
        """
        ...
    
    def IsDiagonal(self: MSPyBentleyGeom.RotMatrix) -> bool:
        """
        Tests if a matrix has small offdiagonal entries compared
        to diagonals. The specific test condition is that the largest off
        diagonal absolute value is less than a tight tolerance fraction times
        the largest diagonal entry.
        
        :returns:
        true if matrix is approximately diagonal
        """
        ...
    
    def IsEqual(*args, **kwargs):
        """
        Overloaded function.
        
        1. IsEqual(self: MSPyBentleyGeom.RotMatrix, maxtrix2: MSPyBentleyGeom.RotMatrix) -> bool
        
        Tests for equality between two matrices " Equality " means
        relative error less than 1.0e-12, in the sense that each component-
        wise difference is less than 1.0e-12 times the largest absolute value
        of the components of one matrix.
        
        :param (input):
        matrix2 The second matrix
        
        :returns:
        true if the matrices are identical.
        
        2. IsEqual(self: MSPyBentleyGeom.RotMatrix, maxtrix2: MSPyBentleyGeom.RotMatrix, tolerance: float) -> bool
        
        Tests for equality between two matrices " Equality " means
        relative error less than 1.0e-12, in the sense that each component-
        wise difference is less than 1.0e-12 times the largest absolute value
        of the components of one matrix.
        
        :param (input):
        matrix2 The second matrix
        
        :returns:
        true if the matrices are identical.
        """
        ...
    
    def IsIdentity(self: MSPyBentleyGeom.RotMatrix) -> bool:
        """
        Tests if a matrix is the identity matrix.
        
        :returns:
        true if matrix is approximately an identity.
        """
        ...
    
    def IsNearRigidScale(self: MSPyBentleyGeom.RotMatrix, dest: MSPyBentleyGeom.RotMatrix, primaryAxis: int = 0, tolerance: float = 1e-06) -> bool:
        """
        Determine if a matrix is close to a pure rotate and scale. If source
        is not near rigid, return false and copy to the output. If near an
        identity return identity. If nearly perpendicular with scales other
        than 1, clean preserving the length and direction of the primary axis.
        This is intended to be used with a crude (e.g. 1.0e-6) reltol to
        identify old DGN file matrices that are " dirty " by modern standards
        but were meant to be identity, rotation, or scaled rotations in the
        UOR era.
        
        :param (input):
        dest result matrix
        
        :param (input):
        primaryAxis axis whose orientation and direction is preserved.
        
        :param (input):
        tolerance relative tolerance for recognizing near-perpendicular
        conditions.
        """
        ...
    
    def IsNearSignedPermutation(self: MSPyBentleyGeom.RotMatrix, result: MSPyBentleyGeom.RotMatrix, tolerance: float) -> bool:
        """
        Test if this instance matrix does nothing more than
        exchange and possibly negate principle axes, within a tolerance.
        
        :param (output):
        result the nearby permutation, or the orignal matrix if none near.
        
        :param (input):
        tolerance tolerance for comparison to the permutation
        
        :returns:
        true if the matrix is a near permutation of the principle axes.
        """
        ...
    
    def IsOrthogonal(self: MSPyBentleyGeom.RotMatrix) -> bool:
        """
        Test if this instance matrix is orthogonal, i.e. its
        transpose is its inverse. This class of matrices includes both rigid
        body rotations and reflections.
        
        :returns:
        true if the matrix is orthogonal.
        """
        ...
    
    def IsOrthonormal(self: MSPyBentleyGeom.RotMatrix, arg0: MSPyBentleyGeom.RotMatrix, arg1: MSPyBentleyGeom.DVec3d) -> tuple:
        """
        Test if this instance matrix has orthonormal columns,
        i.e. its columns are all perpendicular to one another.
        
        :param (output):
        columns matrix containing the unit vectors along the columns.
        
        :param (output):
        axisScales point whose x, y, and z components are the magnitudes
        of the original columns.
        
        :param (output):
        axisRatio smallest axis length divided by largest.
        
        :returns:
        true if the matrix is orthonormal.
        """
        ...
    
    def IsPlanar(self: MSPyBentleyGeom.RotMatrix, normal: MSPyBentleyGeom.DVec3d) -> bool:
        """
        Tests if this instance matrix has no effects
        perpendicular to any plane with the given normal. This will be true if
        the matrix represents a combination of (a) scaling perpencicular to
        the normal and (b) rotation around the normal.
        
        :param (input):
        normal The plane normal
        
        :returns:
        true if the matrix has no effects perpendicular to any plane with
        the given normal.
        """
        ...
    
    def IsRigid(self: MSPyBentleyGeom.RotMatrix) -> bool:
        """
        Test if a matrix is a rigid body rotation, i.e. its
        transpose is its inverse and it has a positive determinant.
        
        :returns:
        true if the matrix is a rigid body rotation.
        """
        ...
    
    def IsRigidScale(self: MSPyBentleyGeom.RotMatrix, arg0: MSPyBentleyGeom.RotMatrix) -> tuple:
        """
        Test if this instance matrix is composed of only rigid
        rotation and scaling.
        
        :param (output):
        columns matrix containing the unit vectors along the columns.
        
        :param (output):
        scale largest axis scale factor. If function value is true, the
        min scale is the same. Use areColumnsOrthonormal to get separate
        column scales.
        
        :returns:
        true if the matrix is orthonormal.
        """
        ...
    
    def IsSignedPermutation(self: MSPyBentleyGeom.RotMatrix) -> bool:
        """
        Test if this instance matrix does nothing more than
        exchange and possibly negate principle axes.
        
        :returns:
        true if the matrix is a permutation of the principle axes.
        """
        ...
    
    def IsUniformScale(self: MSPyBentleyGeom.RotMatrix) -> tuple:
        """
        Tests if a matrix has (nearly) equal diagaonal entries
        and (nearly) zero off diagonals. Tests use a tight relative tolerance.
        
        :param (output):
        maxScale the largest diagaonal entry
        
        :returns:
        true if matrix is approximately diagonal
        """
        ...
    
    def LowerTriangleAbsRange(self: MSPyBentleyGeom.RotMatrix) -> MSPyBentleyGeom.DRange1d:
        """
        return the range of absolute values strictly below the
        diagonal.
        """
        ...
    
    def LowerTriangleMaxAbs(self: MSPyBentleyGeom.RotMatrix) -> float:
        """
        return the largest absolute value in the lower triangle.
        """
        ...
    
    def MaxAbs(self: MSPyBentleyGeom.RotMatrix) -> float:
        """
        Find the largest absolute value of entries in the matrix.
        
        :returns:
        largest absolute value in matrix
        """
        ...
    
    def MaxDiff(self: MSPyBentleyGeom.RotMatrix, matrix2: MSPyBentleyGeom.RotMatrix) -> float:
        """
        Returns the largest absolute value difference between
        corresponding coefficients in Matrix1 and Matrix2.
        
        :param (input):
        matrix2 The matrix to compare to
        
        :returns:
        largest absolute difference between the two matrices.
        """
        ...
    
    def Multiply(*args, **kwargs):
        """
        Overloaded function.
        
        1. Multiply(self: MSPyBentleyGeom.RotMatrix, outRange: MSPyBentleyGeom.DRange3d, inRange: MSPyBentleyGeom.DRange3d) -> None
        
        Computes{M*P[i]} where M is this instance matrix and each P[i] is a
        point in the input array point. Each result is placed in the
        corresponding entry in the output array result. The same array may be
        named for the input and output arrays.
        
        :param (output):
        result output points
        
        :param (input):
        point The input points
        
        :param (input):
        numPoint The number of points
        
        2. Multiply(self: MSPyBentleyGeom.RotMatrix, point: MSPyBentleyGeom.DPoint3d) -> None
        
        Computes{M*P[i]} where M is this instance matrix and each P[i] is a
        point in the input array point. Each result is placed in the
        corresponding entry in the output array result. The same array may be
        named for the input and output arrays.
        
        :param (output):
        result output points
        
        :param (input):
        point The input points
        
        :param (input):
        numPoint The number of points
        
        3. Multiply(self: MSPyBentleyGeom.RotMatrix, result: MSPyBentleyGeom.DPoint3d, point: MSPyBentleyGeom.DPoint3d) -> None
        
        Computes{M*P[i]} where M is this instance matrix and each P[i] is a
        point in the input array point. Each result is placed in the
        corresponding entry in the output array result. The same array may be
        named for the input and output arrays.
        
        :param (output):
        result output points
        
        :param (input):
        point The input points
        
        :param (input):
        numPoint The number of points
        
        4. Multiply(self: MSPyBentleyGeom.RotMatrix, xyzwOut: MSPyBentleyGeom.DPoint4dArray, xyzwIn: MSPyBentleyGeom.DPoint4dArray) -> None
        
        Computes{M*P[i]} where M is this instance matrix and each P[i] is a
        point in the input array point. Each result is placed in the
        corresponding entry in the output array result. The same array may be
        named for the input and output arrays.
        
        :param (output):
        result output points
        
        :param (input):
        point The input points
        
        :param (input):
        numPoint The number of points
        
        5. Multiply(self: MSPyBentleyGeom.RotMatrix, xyzOut: MSPyBentleyGeom.DPoint3dArray, xyzIn: MSPyBentleyGeom.DPoint3dArray) -> None
        
        Computes{M*P[i]} where M is this instance matrix and each P[i] is a
        point in the input array point. Each result is placed in the
        corresponding entry in the output array result. The same array may be
        named for the input and output arrays.
        
        :param (output):
        result output points
        
        :param (input):
        point The input points
        
        :param (input):
        numPoint The number of points
        
        6. Multiply(self: MSPyBentleyGeom.RotMatrix, xyzOut: list, xyzIn: list) -> None
        
        Computes{M*P[i]} where M is this instance matrix and each P[i] is a
        point in the input array point. Each result is placed in the
        corresponding entry in the output array result. The same array may be
        named for the input and output arrays.
        
        :param (output):
        result output points
        
        :param (input):
        point The input points
        
        :param (input):
        numPoint The number of points
        
        7. Multiply(self: MSPyBentleyGeom.RotMatrix, xyOut: MSPyBentleyGeom.DPoint2dArray, xyIn: MSPyBentleyGeom.DPoint2dArray) -> None
        
        Computes{M*P[i]} where M is this instance matrix and each P[i] is a
        point in the input array point. Each result is placed in the
        corresponding entry in the output array result. The same array may be
        named for the input and output arrays.
        
        :param (output):
        result output points
        
        :param (input):
        point The input points
        
        :param (input):
        numPoint The number of points
        """
        ...
    
    def MultiplyComponents(self: MSPyBentleyGeom.RotMatrix, result: MSPyBentleyGeom.DPoint3d, x: float, y: float, z: float) -> None:
        """
        Returns the product of a matrix times a point, with the
        point given as separate components.
        
        :param (output):
        result result of multiplication
        
        :param (input):
        x The x component of input point
        
        :param (input):
        y The y component of input point
        
        :param (input):
        z The z component of input point
        """
        ...
    
    def MultiplyTranspose(*args, **kwargs):
        """
        Overloaded function.
        
        1. MultiplyTranspose(self: MSPyBentleyGeom.RotMatrix, result: MSPyBentleyGeom.DPoint3d, point: MSPyBentleyGeom.DPoint3d) -> None
        
        Returns the product of a matrix transpose times a point.
        
        :param (output):
        result result of the multiplication.
        
        :param (input):
        point The known point.
        
        2. MultiplyTranspose(self: MSPyBentleyGeom.RotMatrix, point: MSPyBentleyGeom.DPoint3d) -> None
        
        Returns the product of a matrix transpose times a point.
        
        :param (output):
        result result of the multiplication.
        
        :param (input):
        point The known point.
        
        3. MultiplyTranspose(self: MSPyBentleyGeom.RotMatrix, outXYZ: MSPyBentleyGeom.DPoint3dArray, inXYZ: MSPyBentleyGeom.DPoint3dArray) -> None
        
        Returns the product of a matrix transpose times a point.
        
        :param (output):
        result result of the multiplication.
        
        :param (input):
        point The known point.
        
        4. MultiplyTranspose(self: MSPyBentleyGeom.RotMatrix, outXYZ: list, inXYZ: list) -> None
        
        Returns the product of a matrix transpose times a point.
        
        :param (output):
        result result of the multiplication.
        
        :param (input):
        point The known point.
        """
        ...
    
    def MultiplyTransposeComponents(self: MSPyBentleyGeom.RotMatrix, result: MSPyBentleyGeom.DPoint3d, x: float, y: float, z: float) -> None:
        """
        Returns the product P = [x,y,z]*M where M is the input
        matrix and P is the product point.
        
        :param (output):
        result product point
        
        :param (input):
        x The x component
        
        :param (input):
        y The y component
        
        :param (input):
        z The z component
        """
        ...
    
    def NormalizeColumnsOf(self: MSPyBentleyGeom.RotMatrix, inMatrix: MSPyBentleyGeom.RotMatrix, scaleVector: MSPyBentleyGeom.DVec3d) -> None:
        """
        Returns a matrix whose rows are unit vectors in the same
        drection as corresponding columns of the input matrix. Also
        (optionally) stores the original column magnitudes as components of
        the point.
        
        :param (input):
        inMatrix The input matrix
        
        :param (output):
        scaleVector length of original columns
        """
        ...
    
    def NormalizeRowsOf(self: MSPyBentleyGeom.RotMatrix, inMatrix: MSPyBentleyGeom.RotMatrix, scaleVector: MSPyBentleyGeom.DVec3d) -> None:
        """
        Returns a matrix whose rows are unit vectors in the same
        drection as corresponding rows of the input matrix. Also (optionally)
        stores the original row magnitudes as components of the point.
        
        :param (input):
        inMatrix The input matrix
        
        :param (output):
        scaleVector length of original rows
        """
        ...
    
    def OffDiagonalAbsRange(self: MSPyBentleyGeom.RotMatrix) -> tuple:
        """
        Return the (absolute value) range of entries off the
        diagonal.
        
        :param (output):
        minValue smallest absolute value
        
        :param (output):
        maxValue largest absolute value
        """
        ...
    
    def OffDiagonalSignedRange(self: MSPyBentleyGeom.RotMatrix) -> tuple:
        """
        Return the (signed) range of entries off the diagonal.
        
        :param (output):
        minValue smallest signed value
        
        :param (output):
        maxValue largest signed value
        """
        ...
    
    def RotateAndSkewFactors(*args, **kwargs):
        """
        RotateAndSkewFactors(self: MSPyBentleyGeom.RotMatrix, rotation: MSPyBentleyGeom.RotMatrix, skewFactor: MSPyBentleyGeom.RotMatrix = 0, primiaryAxis: int, secondaryAxis: int) -> bool
        
        Factor as{rotation*skewFactor} where the rotation favors indicated
        primary and secondary axes.
        
        :param (output):
        rotation the (orthogonal, right handed) rotation.
        
        :param (output):
        skewFactor the scale and skew parts.
        
        :param (input):
        primaryAxis selects column whose direction is preserved.
        
        :param (input):
        secondaryAxis selects columns that defines plane (with
        primaryAxis)
        
        :returns:
        true if primary and secondary are independent.
        """
        ...
    
    @staticmethod
    def RotationFromOriginXY(origin: MSPyBentleyGeom.DPoint3d, xPoint: MSPyBentleyGeom.DPoint3d, yPoint: MSPyBentleyGeom.DPoint3d) -> MSPyBentleyGeom.RotMatrix:
        """
        Set this instance matrix to be an orthogonal (rotation)
        matrix with column 0 in the direction from the origin to the x point,
        column 1 in the plane of the 3 points, directed so the Y point on the
        positive side, and column 2 as their cross product.
        
        :param (input):
        origin The reference point
        
        :param (input):
        xPoint The x axis target point
        
        :param (input):
        yPoint The 3rd point defining xy plane.
        """
        ...
    
    def Scale(self: MSPyBentleyGeom.RotMatrix, leftMatrix: MSPyBentleyGeom.RotMatrix, xs: float, ys: float, zs: float, rightMatrix: MSPyBentleyGeom.RotMatrix) -> None:
        """
        Returns a matrix formed from a scaling matrix which is
        multiplied on the left and/or right with other matrices. That is, form
        LeftMatrix * ScaleMatrix * RightMatrix where the ScaleMatrix is
        constructed from the given scale factors.
        
        :param (input):
        leftMatrix The matrix on left of product
        
        :param (input):
        xs The x scale factor
        
        :param (input):
        ys The y scale factor
        
        :param (input):
        zs The z scale factor
        
        :param (input):
        rightMatrix The matrix on right of product
        """
        ...
    
    def ScaleColumns(*args, **kwargs):
        """
        Overloaded function.
        
        1. ScaleColumns(self: MSPyBentleyGeom.RotMatrix, inMatrix: MSPyBentleyGeom.RotMatrix, xScale: float, yScale: float, zScale: float) -> None
        
        Applies scale factors to corresponding columns of the
        input matrix, and places the result in this instance matrix.
        
        :param (input):
        in The initial matrix
        
        :param (input):
        xs The scale factor for column 0
        
        :param (input):
        ys The scale factor for column 1
        
        :param (input):
        zs The scale factor for column 2
        
        2. ScaleColumns(self: MSPyBentleyGeom.RotMatrix, xScale: float, yScale: float, zScale: float) -> None
        
        Applies scale factors to corresponding columns of the
        input matrix, and places the result in this instance matrix.
        
        :param (input):
        in The initial matrix
        
        :param (input):
        xs The scale factor for column 0
        
        :param (input):
        ys The scale factor for column 1
        
        :param (input):
        zs The scale factor for column 2
        """
        ...
    
    def ScaleRows(self: MSPyBentleyGeom.RotMatrix, inMatrix: MSPyBentleyGeom.RotMatrix, xScale: float, yScale: float, zScale: float) -> None:
        """
        Applies scale factors to corresponding rows of the input
        matrix, and places the result in this instance matrix.
        
        :param (input):
        inMatrix The initial matrix
        
        :param (input):
        xScale The scale factor for row 0
        
        :param (input):
        yScale The scale factor for row 1
        
        :param (input):
        zScale The scale factor for row 2
        """
        ...
    
    def SetColumn(self: MSPyBentleyGeom.RotMatrix, vector: MSPyBentleyGeom.DVec3d, col: int) -> None:
        """
        Set the components in a column.
        
        :param (input):
        vector new values
        
        :param (input):
        col The index of column to change. Column indices are 0, 1, 2.
        """
        ...
    
    def SetRow(self: MSPyBentleyGeom.RotMatrix, vector: MSPyBentleyGeom.DVec3d, row: int) -> None:
        """
        Set the components in a row.
        
        :param (input):
        vector new values
        
        :param (input):
        row The index of row to change. Row indices are 0, 1, 2.
        """
        ...
    
    def ShuffleColumnsOf(self: MSPyBentleyGeom.RotMatrix, inMatrix: MSPyBentleyGeom.RotMatrix, i0: int, i1: int, i2: int) -> None:
        """
        Moves columns 0, 1, 2 of the input matrix into columns
        i0, i1, i2 of the instance.
        
        :param (input):
        inMatrix The input matrix
        
        :param (input):
        i0 The column to receive input column 0
        
        :param (input):
        i1 The column to receive input column 1
        
        :param (input):
        i2 The column to receive input column 2
        """
        ...
    
    def Solve(self: MSPyBentleyGeom.RotMatrix, result: MSPyBentleyGeom.DPoint3d, point: MSPyBentleyGeom.DPoint3d) -> bool:
        """
        Return the product of a matrix inverse and a point.
        
        :param (output):
        result the unknown point
        
        :param (input):
        point The The known point
        
        :returns:
        false if this instance is singular.
        """
        ...
    
    def SolveArray(*args, **kwargs):
        """
        Overloaded function.
        
        1. SolveArray(self: MSPyBentleyGeom.RotMatrix, xyzOut: MSPyBentleyGeom.DPoint3dArray, xyzIn: MSPyBentleyGeom.DPoint3dArray) -> bool
        
        Solve M*xyzOut[i] = xyzIn[i] for array of points.
        (Equivalent to multiplying by the matrix inverse)
        
        2. SolveArray(self: MSPyBentleyGeom.RotMatrix, xyzOut: list, xyzIn: list) -> None
        
        Solve M*xyzOut[i] = xyzIn[i] for array of points.
        (Equivalent to multiplying by the matrix inverse)
        """
        ...
    
    def SolveTranspose(self: MSPyBentleyGeom.RotMatrix, result: MSPyBentleyGeom.DPoint3d, point: MSPyBentleyGeom.DPoint3d) -> bool:
        """
        Return the product of a matrix inverse transpose and a
        point.
        
        :param (output):
        result result of the multiplication
        
        :param (input):
        point The known point multipled by the matrix inverse.
        
        :returns:
        false if this instance is singular.
        """
        ...
    
    def SquareAndNormalizeColumns(*args, **kwargs):
        """
        Overloaded function.
        
        1. SquareAndNormalizeColumns(self: MSPyBentleyGeom.RotMatrix, inMatrix: MSPyBentleyGeom.RotMatrix, primaryAxis: int, secondaryAxis: int) -> bool
        
        Adjust the direction and length of columns of the input
        matrix to produce an instance matrix which has perpendicular, unit
        length columns. The column whose index is primaryAxis (i.e. 0,1,2 for
        x,y,z axis of coordinate frame) is normalized to unit length in its
        current direction. The column whose index is secondaryAxis is unit
        length and perpendicular to the primaryAxis column, and lies in the
        same plane as that defined by the original primary and secondary
        columns. To preserve X axis and XY plane, call with axis id's 0 and 1.
        To preserve Z axis and ZX plane, call with axis id's 2 and 0. inMatrix
        and pMatrix may be the same address.
        
        :param (input):
        inMatrix The input matrix
        
        :param (input):
        primaryAxis The axis id (0, 1, 2) which is to be normalized but
        left in its current direction
        
        :param (input):
        secondaryAxis The axis id (0, 1, 2) which is to be kept within the
        plane of the primary and secondary axis.
        
        :returns:
        false if primaryAxis and secondaryAxis are the same, or either
        axis has zero length
        
        2. SquareAndNormalizeColumns(self: MSPyBentleyGeom.RotMatrix, inMatrix: MSPyBentleyGeom.RotMatrix, primaryAxis: int, secondaryAxis: int, preferredOrientation: int) -> bool
        
        Adjust the direction and length of columns of the input
        matrix to produce an instance matrix which has perpendicular, unit
        length columns. The column whose index is primaryAxis (i.e. 0,1,2 for
        x,y,z axis of coordinate frame) is normalized to unit length in its
        current direction. The column whose index is secondaryAxis is unit
        length and perpendicular to the primaryAxis column, and lies in the
        same plane as that defined by the original primary and secondary
        columns. To preserve X axis and XY plane, call with axis id's 0 and 1.
        To preserve Z axis and ZX plane, call with axis id's 2 and 0. inMatrix
        and pMatrix may be the same address.
        
        :param (input):
        inMatrix The input matrix
        
        :param (input):
        primaryAxis The axis id (0, 1, 2) which is to be normalized but
        left in its current direction
        
        :param (input):
        secondaryAxis The axis id (0, 1, 2) which is to be kept within the
        plane of the primary and secondary axis.
        
        :returns:
        false if primaryAxis and secondaryAxis are the same, or either
        axis has zero length
        """
        ...
    
    def SquareAndNormalizeColumnsAnyOrder(*args, **kwargs):
        """
        Overloaded function.
        
        1. SquareAndNormalizeColumnsAnyOrder(self: MSPyBentleyGeom.RotMatrix, inMatrix: MSPyBentleyGeom.RotMatrix, preferredOrientation: int) -> bool
        
        Returns an orthogonal matrix that preserves aligns with
        the columns of inMatrix. This is done by trying various combinations
        of primary and secondary axes until one succeeds in
        squareAndNormalizeColumns.
        
        :param (input):
        inMatrix The input matrix
        
        :param (input):
        preferredOrientation
        
        * 1 for right handed system
        
        
        * -1 for left handed system
        
        
        * 0 to match orientation of input (but default to right handed if input is singular)
        
        
        2. SquareAndNormalizeColumnsAnyOrder(self: MSPyBentleyGeom.RotMatrix, inMatrix: MSPyBentleyGeom.RotMatrix) -> bool
        
        Returns an orthogonal matrix that preserves aligns with
        the columns of inMatrix. This is done by trying various combinations
        of primary and secondary axes until one succeeds in
        squareAndNormalizeColumns.
        
        :param (input):
        inMatrix The input matrix
        
        :param (input):
        preferredOrientation
        
        * 1 for right handed system
        
        
        * -1 for left handed system
        
        
        * 0 to match orientation of input (but default to right handed if input is singular)
        """
        ...
    
    def Subtract(self: MSPyBentleyGeom.RotMatrix, delta: MSPyBentleyGeom.RotMatrix) -> None:
        """
        Subtract a matrix (componentwise, in place).
        
        :param (input):
        delta The matrix to subtract
        """
        ...
    
    def SumDiagonalSquares(self: MSPyBentleyGeom.RotMatrix) -> float:
        """
        Computes the sum of the squares of the diagonal entries
        of this instance matrix.
        
        :returns:
        Sum of squares of diagonal entries
        """
        ...
    
    def SumOf(self: MSPyBentleyGeom.RotMatrix, matrix0: MSPyBentleyGeom.RotMatrix, matrix1: MSPyBentleyGeom.RotMatrix, scale1: float, matrix2: MSPyBentleyGeom.RotMatrix, scale2: float) -> None:
        """
        Returns{Matrix0 + Matrix1*s1+Matrix2*s2}, i.e. the sum
        of matrix M0, matrix M1 multiplied by scale s1, and matrix M2
        multiplied by scale s2. Any combination of the matrix pointers may
        have identical addresses.
        
        :param (input):
        matrix0 The matrix0 of formula
        
        :param (input):
        matrix1 The matrix1 of formula
        
        :param (input):
        scale1 The scale factor to apply to Matrix1
        
        :param (input):
        matrix2 The matrix2 of formula
        
        :param (input):
        scale2 The scale factor to apply to Matrix2
        """
        ...
    
    def SumOffDiagonalSquares(self: MSPyBentleyGeom.RotMatrix) -> float:
        """
        Computes the sum of the squares of the off-diagonal
        entries of this instance matrix.
        
        :returns:
        sum of square of off-diagonal entries of the matrix.
        """
        ...
    
    def SumSquares(self: MSPyBentleyGeom.RotMatrix) -> float:
        """
        Return the sum of squares of coefficients in a matrix.
        
        :returns:
        Sum of squares of all entries in matrix
        """
        ...
    
    def Transpose(self: MSPyBentleyGeom.RotMatrix) -> None:
        """
        Transposes a matrix in place.
        """
        ...
    
    def TransposeOf(self: MSPyBentleyGeom.RotMatrix, matrix: MSPyBentleyGeom.RotMatrix) -> None:
        """
        Initializes this instance as the transpose of a matrix.
        
        :param (input):
        matrix The input matrix
        """
        ...
    
    def UpperTriangleAbsRange(self: MSPyBentleyGeom.RotMatrix) -> MSPyBentleyGeom.DRange1d:
        """
        return the range of absolute values strictly above the
        diagonal.
        """
        ...
    
    def UpperTriangleMaxAbs(self: MSPyBentleyGeom.RotMatrix) -> float:
        """
        return the largest absolute value in the upper triangle.
        """
        ...
    
    def Zero(self: MSPyBentleyGeom.RotMatrix) -> None:
        ...
    
    def __init__(self: MSPyBentleyGeom.RotMatrix) -> None:
        ...
    
    @property
    def form3d(arg0: MSPyBentleyGeom.RotMatrix) -> numpy.typing.NDArray:
        ...
    @form3d.setter
    def form3d(arg0: MSPyBentleyGeom.RotMatrix, arg1: numpy.typing.NDArray) -> None:
        ...
    
class RotMatrixArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.RotMatrixArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.RotMatrixArray, arg0: MSPyBentleyGeom.RotMatrixArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.RotMatrixArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.RotMatrixArray, x: MSPyBentleyGeom.RotMatrix) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.RotMatrixArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.RotMatrixArray, L: MSPyBentleyGeom.RotMatrixArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.RotMatrixArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.RotMatrixArray, i: int, x: MSPyBentleyGeom.RotMatrix) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.RotMatrixArray) -> MSPyBentleyGeom.RotMatrix
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.RotMatrixArray, i: int) -> MSPyBentleyGeom.RotMatrix
        
        Remove and return the item at index ``i``
        """
        ...
    
SILHBND_BOTH: int

SILHBND_NONE: int

SILHBND_U: int

SILHBND_V: int

class SolidLocationDetail:
    """
    None
    """

    @property
    def A(arg0: MSPyBentleyGeom.SolidLocationDetail) -> float:
        ...
    @A.setter
    def A(arg0: MSPyBentleyGeom.SolidLocationDetail, arg1: float) -> None:
        ...
    
    @property
    def FaceIndices(arg0: MSPyBentleyGeom.SolidLocationDetail) -> MSPyBentleyGeom.SolidLocationDetail.FaceIndices:
        ...
    
    def GetA(self: MSPyBentleyGeom.SolidLocationDetail) -> float:
        """
        query the a parameter
        """
        ...
    
    def GetFaceIndices(self: MSPyBentleyGeom.SolidLocationDetail) -> MSPyBentleyGeom.SolidLocationDetail.FaceIndices:
        """
        return a structure with all selector indices.
        """
        ...
    
    def GetParentId(self: MSPyBentleyGeom.SolidLocationDetail) -> int:
        """
        Return the parent id.
        """
        ...
    
    def GetPickParameter(self: MSPyBentleyGeom.SolidLocationDetail) -> float:
        """
        Return the parameter along the pick ray.
        """
        ...
    
    def GetPrimarySelector(self: MSPyBentleyGeom.SolidLocationDetail) -> int:
        """
        Return the primary selector.
        """
        ...
    
    def GetSecondarySelector(self: MSPyBentleyGeom.SolidLocationDetail) -> int:
        """
        Return the secondary selector
        """
        ...
    
    def GetU(self: MSPyBentleyGeom.SolidLocationDetail) -> float:
        """
        query the u parameter
        """
        ...
    
    def GetUDirection(self: MSPyBentleyGeom.SolidLocationDetail) -> DVec3d:
        """
        Return u direction vector.
        """
        ...
    
    def GetUV(self: MSPyBentleyGeom.SolidLocationDetail) -> DPoint2d:
        """
        Return u,v parameter information
        """
        ...
    
    def GetV(self: MSPyBentleyGeom.SolidLocationDetail) -> float:
        """
        query the v parameter
        """
        ...
    
    def GetVDirection(self: MSPyBentleyGeom.SolidLocationDetail) -> DVec3d:
        """
        Return v direction vector.
        """
        ...
    
    def GetXYZ(self: MSPyBentleyGeom.SolidLocationDetail) -> DPoint3d:
        """
        Return the pick coordinates
        """
        ...
    
    def Init(self: MSPyBentleyGeom.SolidLocationDetail) -> None:
        """
        Initialize to zeroed state.
        """
        ...
    
    @staticmethod
    def IsCap0(selector0: int, selector1: int) -> bool:
        """
        Ask if a selector pair is the start cap.
        """
        ...
    
    @staticmethod
    def IsCap1(selector0: int, selector1: int) -> bool:
        """
        Ask if a selector pair is the end cap.
        """
        ...
    
    def IsCapSelect(self: MSPyBentleyGeom.SolidLocationDetail) -> tuple:
        ...
    
    def MapPickParameterFractionToRange(self: MSPyBentleyGeom.SolidLocationDetail, range: DRange1d) -> bool:
        """
        Treat current pick parameter as fractions in new interval. return
        false (and leave the pick parameter unchanged) if the range is
        undefined.
        """
        ...
    
    @property
    def ParentId(arg0: MSPyBentleyGeom.SolidLocationDetail) -> int:
        ...
    @ParentId.setter
    def ParentId(arg0: MSPyBentleyGeom.SolidLocationDetail, arg1: int) -> None:
        ...
    
    @property
    def PickParameter(arg0: MSPyBentleyGeom.SolidLocationDetail) -> float:
        ...
    @PickParameter.setter
    def PickParameter(arg0: MSPyBentleyGeom.SolidLocationDetail, arg1: float) -> None:
        ...
    
    PrimaryIdCap: int
    
    @property
    def PrimarySelector(arg0: MSPyBentleyGeom.SolidLocationDetail) -> int:
        ...
    
    @property
    def SecondarySelector(arg0: MSPyBentleyGeom.SolidLocationDetail) -> int:
        ...
    
    def SetA(self: MSPyBentleyGeom.SolidLocationDetail, a: float) -> None:
        """
        Set a.
        """
        ...
    
    def SetCapSelector(self: MSPyBentleyGeom.SolidLocationDetail, id: int) -> None:
        """
        Set selectors for cap id (typically 0 or 1)
        """
        ...
    
    def SetFaceIndices(*args, **kwargs):
        """
        Overloaded function.
        
        1. SetFaceIndices(self: MSPyBentleyGeom.SolidLocationDetail, id0: int, id1: int, id2: int) -> None
        
        Set all face selectors
        
        2. SetFaceIndices(self: MSPyBentleyGeom.SolidLocationDetail, indices: MSPyBentleyGeom.SolidLocationDetail.FaceIndices) -> None
        
        Set all face selectors
        """
        ...
    
    def SetFaceIndices01(self: MSPyBentleyGeom.SolidLocationDetail, id0: int, id1: int) -> None:
        """
        Set all face selectors
        """
        ...
    
    def SetParentId(self: MSPyBentleyGeom.SolidLocationDetail, id: int) -> None:
        """
        Set the parent id.
        """
        ...
    
    def SetPickParameter(self: MSPyBentleyGeom.SolidLocationDetail, f: float) -> None:
        """
        set the pick fraction.
        """
        ...
    
    def SetU(self: MSPyBentleyGeom.SolidLocationDetail, u: float) -> None:
        """
        Set u
        """
        ...
    
    def SetUDirection(self: MSPyBentleyGeom.SolidLocationDetail, dXdv: DVec3d) -> None:
        """
        Set the u direction vector
        """
        ...
    
    def SetUV(*args, **kwargs):
        """
        Overloaded function.
        
        1. SetUV(self: MSPyBentleyGeom.SolidLocationDetail, uv: DPoint2d) -> None
        
        Set the u,v, and direction vectors.
        
        2. SetUV(self: MSPyBentleyGeom.SolidLocationDetail, u: float, v: float, uDirection: DVec3d, vDirection: DVec3d) -> None
        
        Set the u,v, and direction vectors.
        """
        ...
    
    def SetV(self: MSPyBentleyGeom.SolidLocationDetail, v: float) -> None:
        """
        Set v.
        """
        ...
    
    def SetVDirection(self: MSPyBentleyGeom.SolidLocationDetail, dXdv: DVec3d) -> None:
        """
        Set the v direction vector
        """
        ...
    
    def SetXYZ(self: MSPyBentleyGeom.SolidLocationDetail, arg0: DPoint3d) -> None:
        """
        Set the point coordinates.
        """
        ...
    
    def TransformInPlace(self: MSPyBentleyGeom.SolidLocationDetail, transform: Transform) -> None:
        """
        TransformInPlace points and vectors by the transform.
        """
        ...
    
    @property
    def U(arg0: MSPyBentleyGeom.SolidLocationDetail) -> float:
        ...
    @U.setter
    def U(arg0: MSPyBentleyGeom.SolidLocationDetail, arg1: float) -> None:
        ...
    
    @property
    def UDirection(arg0: MSPyBentleyGeom.SolidLocationDetail) -> DVec3d:
        ...
    @UDirection.setter
    def UDirection(arg0: MSPyBentleyGeom.SolidLocationDetail, arg1: DVec3d) -> None:
        ...
    
    @property
    def UV(arg0: MSPyBentleyGeom.SolidLocationDetail) -> DPoint2d:
        ...
    @UV.setter
    def UV(arg0: MSPyBentleyGeom.SolidLocationDetail, arg1: DPoint2d) -> None:
        ...
    
    def UpdateIfSmallerA(self: MSPyBentleyGeom.SolidLocationDetail, source: MSPyBentleyGeom.SolidLocationDetail) -> bool:
        ...
    
    @property
    def V(arg0: MSPyBentleyGeom.SolidLocationDetail) -> float:
        ...
    @V.setter
    def V(arg0: MSPyBentleyGeom.SolidLocationDetail, arg1: float) -> None:
        ...
    
    @property
    def VDirection(arg0: MSPyBentleyGeom.SolidLocationDetail) -> DVec3d:
        ...
    @VDirection.setter
    def VDirection(arg0: MSPyBentleyGeom.SolidLocationDetail, arg1: DVec3d) -> None:
        ...
    
    @property
    def XYZ(arg0: MSPyBentleyGeom.SolidLocationDetail) -> DPoint3d:
        ...
    @XYZ.setter
    def XYZ(arg0: MSPyBentleyGeom.SolidLocationDetail, arg1: DPoint3d) -> None:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.SolidLocationDetail) -> None
        
        2. __init__(self: MSPyBentleyGeom.SolidLocationDetail, parentId: int, s: float) -> None
        
        3. __init__(self: MSPyBentleyGeom.SolidLocationDetail, parentId: int, s: float, xyz: DPoint3d) -> None
        
        4. __init__(self: MSPyBentleyGeom.SolidLocationDetail, parentId: int, s: float, xyz: DPoint3d, u: float, v: float, uVector: DVec3d, vVector: DVec3d) -> None
        """
        ...
    
class SolidLocationDetailArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.SolidLocationDetailArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.SolidLocationDetailArray, arg0: MSPyBentleyGeom.SolidLocationDetailArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.SolidLocationDetailArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.SolidLocationDetailArray, x: MSPyBentleyGeom.SolidLocationDetail) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.SolidLocationDetailArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.SolidLocationDetailArray, L: MSPyBentleyGeom.SolidLocationDetailArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.SolidLocationDetailArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.SolidLocationDetailArray, i: int, x: MSPyBentleyGeom.SolidLocationDetail) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.SolidLocationDetailArray) -> MSPyBentleyGeom.SolidLocationDetail
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.SolidLocationDetailArray, i: int) -> MSPyBentleyGeom.SolidLocationDetail
        
        Remove and return the item at index ``i``
        """
        ...
    
class SolidPrimitiveType:
    """
    Members:
    
    eSolidPrimitiveType_None
    
    eSolidPrimitiveType_DgnTorusPipe
    
    eSolidPrimitiveType_DgnCone
    
    eSolidPrimitiveType_DgnBox
    
    eSolidPrimitiveType_DgnSphere
    
    eSolidPrimitiveType_DgnExtrusion
    
    eSolidPrimitiveType_DgnRotationalSweep
    
    eSolidPrimitiveType_DgnRuledSweep
    """

    def __init__(self: MSPyBentleyGeom.SolidPrimitiveType, value: int) -> None:
        ...
    
    eSolidPrimitiveType_DgnBox: SolidPrimitiveType
    
    eSolidPrimitiveType_DgnCone: SolidPrimitiveType
    
    eSolidPrimitiveType_DgnExtrusion: SolidPrimitiveType
    
    eSolidPrimitiveType_DgnRotationalSweep: SolidPrimitiveType
    
    eSolidPrimitiveType_DgnRuledSweep: SolidPrimitiveType
    
    eSolidPrimitiveType_DgnSphere: SolidPrimitiveType
    
    eSolidPrimitiveType_DgnTorusPipe: SolidPrimitiveType
    
    eSolidPrimitiveType_None: SolidPrimitiveType
    
    @property
    def name(self: handle) -> str:
        ...
    
    @property
    def value(arg0: MSPyBentleyGeom.SolidPrimitiveType) -> int:
        ...
    
TANGENT_CONTINUITY: int

TRUNCATE_BOTH: int

TRUNCATE_NONE: int

TRUNCATE_SINGLE: int

class TaggedLocalRange:
    """
    None
    """

    def DistanceOutside(self: MSPyBentleyGeom.LocalRange, spacePoint: DPoint3d) -> float:
        ...
    
    def InitFromPrincipalAxesOfPoints(*args, **kwargs):
        """
        Overloaded function.
        
        1. InitFromPrincipalAxesOfPoints(self: MSPyBentleyGeom.LocalRange, xyz: List[DPoint3d]) -> bool
        
        2. InitFromPrincipalAxesOfPoints(self: MSPyBentleyGeom.LocalRange, xyzw: List[DPoint4d]) -> bool
        
        3. InitFromPrincipalAxesOfPoints(self: MSPyBentleyGeom.LocalRange, xyz: list) -> bool
        """
        ...
    
    def InitNullRange(self: MSPyBentleyGeom.LocalRange) -> None:
        """
        Initialize with identity transforms and an empty range. Initialize
        with identity transforms and an empty range.
        """
        ...
    
    def SetDistanceOutside(self: MSPyBentleyGeom.TaggedLocalRange, spacePoint: DPoint3d) -> None:
        ...
    
    @staticmethod
    def SortByA(data: List[TaggedLocalRange]) -> None:
        ...
    
    def __init__(self: MSPyBentleyGeom.TaggedLocalRange, indexA: int, indexB: int, a: float = 0.0) -> None:
        ...
    
    @property
    def a(self: MSPyBentleyGeom.TaggedLocalRange) -> float:
        ...
    @a.setter
    def a(self: MSPyBentleyGeom.TaggedLocalRange, arg0: float) -> None:
        ...
    
    @property
    def indexA(self: MSPyBentleyGeom.TaggedLocalRange) -> int:
        ...
    @indexA.setter
    def indexA(self: MSPyBentleyGeom.TaggedLocalRange, arg0: int) -> None:
        ...
    
    @property
    def indexB(self: MSPyBentleyGeom.TaggedLocalRange) -> int:
        ...
    @indexB.setter
    def indexB(self: MSPyBentleyGeom.TaggedLocalRange, arg0: int) -> None:
        ...
    
    @property
    def localRange(self: MSPyBentleyGeom.LocalRange) -> DRange3d:
        ...
    @localRange.setter
    def localRange(self: MSPyBentleyGeom.LocalRange, arg0: DRange3d) -> None:
        ...
    
    @property
    def localToWorld(self: MSPyBentleyGeom.LocalRange) -> Transform:
        ...
    @localToWorld.setter
    def localToWorld(self: MSPyBentleyGeom.LocalRange, arg0: Transform) -> None:
        ...
    
    @property
    def worldRange(self: MSPyBentleyGeom.LocalRange) -> DRange3d:
        ...
    @worldRange.setter
    def worldRange(self: MSPyBentleyGeom.LocalRange, arg0: DRange3d) -> None:
        ...
    
    @property
    def worldToLocal(self: MSPyBentleyGeom.LocalRange) -> Transform:
        ...
    @worldToLocal.setter
    def worldToLocal(self: MSPyBentleyGeom.LocalRange, arg0: Transform) -> None:
        ...
    
class Transform:
    """
    None
    """

    def ColumnXMagnitude(self: MSPyBentleyGeom.Transform) -> float:
        """
        Return magnitude of X column. This is commonly considered as the scale
        factor of the transform.
        """
        ...
    
    def Copy(self: MSPyBentleyGeom.Transform, source: MSPyBentleyGeom.Transform) -> None:
        """
        Returns a copy of a transformation.
        
        :param (input):
        source The source transform
        """
        ...
    
    @staticmethod
    def CorrectCoordinateFrameXYRange(localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform, localRange: MSPyBentleyGeom.DRange3d, frameType: MSPyBentleyGeom.LocalCoordinateSelect, appliedTransformOldLocalToNewLocal: MSPyBentleyGeom.Transform = None) -> None:
        """
        Input transforms placed " within " caller's geoemtry so that the
        geometry range satisfies origin and scaling requirements indicatd by
        frame type. Expected usage is that a local coordinate frame is placed
        on some geometry and the range of the geometry is them computed within
        that local system. The coordinate frame then needs some combination of
        (a) move origin to lower left of the range, (b) rescale axes so that
        one or both of x,y directions scale to 01.
        
        :param [in,out]:
        localToWorld local to world transformation to modify.
        
        :param [in,out]:
        worldToLocal world to lcoal transformation to modify.
        
        :param [in,out]:
        localRange range of subject data.
        
        :param (input):
        frameType identifies target scaling and origin.
        
        :param (output):
        appliedTransformOldLocalToNewLocal (optional) the transfrom
        applied to modify initial local geometry to final local geometry
        """
        ...
    
    def Determinant(self: MSPyBentleyGeom.Transform) -> float:
        """
        Return the determinant of the matrix part.
        """
        ...
    
    @staticmethod
    def From(*args, **kwargs):
        """
        Overloaded function.
        
        1. From(matrix: RotMatrix) -> MSPyBentleyGeom.Transform
        
        Returns a transformation with the given matrix part and a
        zero translation part.
        
        :param (input):
        matrix The matrix part
        
        2. From(matrix: RotMatrix, translation: MSPyBentleyGeom.DPoint3d) -> MSPyBentleyGeom.Transform
        
        Returns a transformation with the given matrix part and a
        zero translation part.
        
        :param (input):
        matrix The matrix part
        
        3. From(translation: MSPyBentleyGeom.DPoint3d) -> MSPyBentleyGeom.Transform
        
        Returns a transformation with the given matrix part and a
        zero translation part.
        
        :param (input):
        matrix The matrix part
        
        4. From(x: float, y: float, z: float) -> MSPyBentleyGeom.Transform
        
        Returns a transformation with the given matrix part and a
        zero translation part.
        
        :param (input):
        matrix The matrix part
        """
        ...
    
    @staticmethod
    def From2Points(origin: MSPyBentleyGeom.DPoint2d, xPoint: MSPyBentleyGeom.DPoint2d, axisId: int, normalize: bool) -> MSPyBentleyGeom.Transform:
        """
        Returns a transformation in the xy-plane with origin
        origin, axis axisId towards xPoint, and the other axis perpendicular.
        If normalize is false, both axes have length equal to the distance
        between origin and xPoint.
        
        :param (input):
        origin
        
        :param (input):
        xPoint The target point of axis axisId of coordinate system
        
        :param (input):
        axisId The axis (x=0, y=1) that points from origin to xPoint
        
        :param (input):
        normalize true to have coordinate system normalized
        """
        ...
    
    @staticmethod
    def From4Points(origin: MSPyBentleyGeom.DPoint3d, xPoint: MSPyBentleyGeom.DPoint3d, yPoint: MSPyBentleyGeom.DPoint3d, zPoint: MSPyBentleyGeom.DPoint3d) -> MSPyBentleyGeom.Transform:
        """
        Returns a transformation with origin at origin, x-axis
        from origin to xPoint, y-axis from origin to yPoint, and z-axis from
        origin to zPoint. All axes are unnormalized. There is no effort to
        detect zero length axes or degenerate points that define only a line
        or plane but not a full coordinate system. The axes may be skewed.
        
        :param (input):
        origin The origin of transformed coordinates
        
        :param (input):
        xPoint The 100 point of transformed coordinates
        
        :param (input):
        yPoint The 010 point of transformed coordinates
        
        :param (input):
        zPoint The 001 point of transformed coordinates
        """
        ...
    
    @staticmethod
    def FromAxisAndRotationAngle(*args, **kwargs):
        """
        Overloaded function.
        
        1. FromAxisAndRotationAngle(axis: MSPyBentleyGeom.DRay3d, radians: float, derivativeTransform: MSPyBentleyGeom.Transform) -> MSPyBentleyGeom.Transform
        
        Returns a transformation of rotation about a specified
        ray, and also its derivative with respect to the angle.
        
        :param (input):
        axis axis of rotation
        
        :param (input):
        radians The rotation angle
        
        :param derivativeTransform:
        transform mapping rotated point (anywhere) to direction vector at
        its destination.
        
        2. FromAxisAndRotationAngle(axis: MSPyBentleyGeom.DRay3d, radians: float) -> MSPyBentleyGeom.Transform
        
        Returns a transformation of rotation about a specified
        ray, and also its derivative with respect to the angle.
        
        :param (input):
        axis axis of rotation
        
        :param (input):
        radians The rotation angle
        
        :param derivativeTransform:
        transform mapping rotated point (anywhere) to direction vector at
        its destination.
        """
        ...
    
    @staticmethod
    def FromFixedPointAndScaleFactors(origin: MSPyBentleyGeom.DPoint3d, xScale: float, yScale: float, zScale: float) -> MSPyBentleyGeom.Transform:
        """
        Returns a transformation with x,y,z scales around a fixed
        point.
        
        :param (input):
        origin The fixed point.
        
        :param (input):
        xScale x direction scale factor.
        
        :param (input):
        yScale y direction scale factor.
        
        :param (input):
        zScale z direction scale factor.
        """
        ...
    
    @staticmethod
    def FromLineAndRotationAngle(point0: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d, radians: float) -> MSPyBentleyGeom.Transform:
        """
        Returns a transformation of rotation about a specified
        line.
        
        :param (input):
        point0 The start point of the line
        
        :param (input):
        point1 The end point of the line
        
        :param (input):
        radians The rotation angle
        """
        ...
    
    @staticmethod
    def FromMatrixAndFixedPoint(matrix: RotMatrix, origin: MSPyBentleyGeom.DPoint3d) -> MSPyBentleyGeom.Transform:
        """
        Returns a transformation with given matrix part, and
        translation part computed from the matrix and a given fixed point.
        This translation part is generally different from the fixed point
        itself. The resulting transformation will leave the fixed point
        unchanged and apply whatever effects are contained in the matrix as if
        the fixed point is the origin.
        
        :param (input):
        matrix The matrix part
        
        :param (input):
        origin The point that is to remain fixed when multiplied by the
        transformation.
        """
        ...
    
    @staticmethod
    def FromOriginAndBearingXY(origin: MSPyBentleyGeom.DPoint3d, bearingRadians: float) -> MSPyBentleyGeom.Transform:
        """
        Returns a transformation with ul> li>translation xyz are
        the origin li>xAxis in direction of bearing radians (parallel to xy
        plane) li>yAxis perpenedicular to xAxis and also parallel to the xy
        plane. li>zAxis is global (0,0,1) ul
        """
        ...
    
    @staticmethod
    def FromOriginAndVectors(origin: MSPyBentleyGeom.DPoint3d, xVector: MSPyBentleyGeom.DVec3d, yVector: MSPyBentleyGeom.DVec3d, zVector: MSPyBentleyGeom.DVec3d) -> MSPyBentleyGeom.Transform:
        """
        Returns a transformation with origin at origin, x-axis
        xVector, y-axis yVector, and z-axis zVector. All axes are
        unnormalized. There is no effort to detect zero length axes or
        degenerate points that define only a line or plane but not a full
        coordinate system. The axes may be skewed.
        
        :param (input):
        origin The origin of transformed coordinates
        
        :param (input):
        xVector The 100 point of transformed coordinates
        
        :param (input):
        yVector The 010 point of transformed coordinates
        
        :param (input):
        zVector The 001 point of transformed coordinates
        """
        ...
    
    @staticmethod
    def FromOriginAndXVector(origin: MSPyBentleyGeom.DPoint2d, xVector: MSPyBentleyGeom.DVec2d) -> MSPyBentleyGeom.Transform:
        """
        Returns a transform with given origin and xVector. The yVector is a
        CCW perpendicular to the xVector (with the same length) The zVecotor
        is a unitZ.
        """
        ...
    
    @staticmethod
    def FromPlaneNormalToLine(origin: MSPyBentleyGeom.DPoint3d, xPoint: MSPyBentleyGeom.DPoint3d, axisId: int, normalize: bool) -> MSPyBentleyGeom.Transform:
        """
        Returns a (possibly skewed) transformation with origin
        origin, the axis axisId towards xPoint, and other axes perpendicular.
        If normalize is false, all axes have length equal to the distance
        between the two origin and xPoint. The axes may be skewed.
        
        :param (input):
        origin The origin of coordinate system
        
        :param (input):
        xPoint The target point of axis axisId of coordinate system
        
        :param (input):
        axisId The axis that points from origin to xPoint
        
        :param (input):
        normalize true to have coordinate system normalized
        """
        ...
    
    @staticmethod
    def FromPlaneOf3Points(origin: MSPyBentleyGeom.DPoint3d, xPoint: MSPyBentleyGeom.DPoint3d, yPoint: MSPyBentleyGeom.DPoint3d) -> MSPyBentleyGeom.Transform:
        """
        Returns a transformation with origin at origin, x-axis
        from origin to xPoint, y-axis from origin to yPoint, and z-axis equal
        to the cross product of x and y axes. All axes are unnormalized. There
        is no effort to detect zero length axes or degenerate points that
        define only a line or plane but not a full coordinate system.
        
        :param (input):
        origin The origin of coordinate system
        
        :param (input):
        xPoint The 100 point of coordinate system
        
        :param (input):
        yPoint The 010 point of coordinate system
        """
        ...
    
    @staticmethod
    def FromPlaneOf3PointsZeroZ(origin: MSPyBentleyGeom.DPoint3d, xPoint: MSPyBentleyGeom.DPoint3d, yPoint: MSPyBentleyGeom.DPoint3d) -> MSPyBentleyGeom.Transform:
        """
        Returns a transformation with origin at origin, x-axis
        from origin to xPoint, y-axis from origin to yPoint, and z-axis all
        zeros. All axes are unnormalized. There is no effort to detect zero
        length axes or degenerate points that define only a line or plane but
        not a full plane.
        
        :param (input):
        origin The origin of coordinate system
        
        :param (input):
        xPoint The 100 point of coordinate system
        
        :param (input):
        yPoint The 010 point of coordinate system
        """
        ...
    
    @staticmethod
    def FromPrincipleAxisRotations(inTransform: MSPyBentleyGeom.Transform, xrot: float, yrot: float, zrot: float) -> MSPyBentleyGeom.Transform:
        """
        Sets this instance to the transformation obtained by premultiplying
        inTransform by 3 matrix rotations about principle axes, given by the
        angles xrot, yrot and zrot. inTransform may be the same as this
        instance. Symbolically, given transform M and rotation matrices X,Y,Z,
        the resulting transform is X*Y*Z*M
        
        :param (input):
        inTransform The base transformation
        
        :param (input):
        xrot The x axis rotation, in radians
        
        :param (input):
        yrot The y axis rotation, in radians
        
        :param (input):
        zrot The z axis rotation, in radians
        """
        ...
    
    @staticmethod
    def FromProduct(*args, **kwargs):
        """
        Overloaded function.
        
        1. FromProduct(transformA: MSPyBentleyGeom.Transform, transformB: MSPyBentleyGeom.Transform) -> MSPyBentleyGeom.Transform
        
        Returns the product of two transforms.
        
        2. FromProduct(transformA: MSPyBentleyGeom.Transform, transformB: MSPyBentleyGeom.Transform, transformC: MSPyBentleyGeom.Transform) -> MSPyBentleyGeom.Transform
        
        Returns the product of two transforms.
        
        3. FromProduct(matrixA: RotMatrix, transformB: MSPyBentleyGeom.Transform) -> MSPyBentleyGeom.Transform
        
        Returns the product of two transforms.
        
        4. FromProduct(transformA: MSPyBentleyGeom.Transform, matrixB: RotMatrix) -> MSPyBentleyGeom.Transform
        
        Returns the product of two transforms.
        """
        ...
    
    @staticmethod
    def FromRowValues(x00: float, x01: float, x02: float, tx: float, x10: float, x11: float, x12: float, ty: float, x20: float, x21: float, x22: float, tz: float) -> MSPyBentleyGeom.Transform:
        """
        Returns a transformation copying the double values
        directly into the rows of this instance.
        
        :param (input):
        x00 The (0,0) entry of the matrix (row, column)
        
        :param (input):
        x01 The (0,1) entry
        
        :param (input):
        x02 The (0,2) entry
        
        :param (input):
        tx The x-coordinate of the translation part
        
        :param (input):
        x10 The (1,0) entry
        
        :param (input):
        x11 The (1,1) entry
        
        :param (input):
        x12 The (1,2) entry
        
        :param (input):
        ty The y-coordinate of the translation part
        
        :param (input):
        x20 The (2,0) entry
        
        :param (input):
        x21 The (2,1) entry
        
        :param (input):
        x22 The (2,2) entry
        
        :param (input):
        tz The z-coordinate of the translation part
        """
        ...
    
    def Get4Points(self: MSPyBentleyGeom.Transform, point0: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d, point2: MSPyBentleyGeom.DPoint3d, point3: MSPyBentleyGeom.DPoint3d) -> None:
        """
        Sets point0 to the origin (translation part), and sets point1, point2
        point3 to the x, y and z points (translations of columns of matrix
        part by origin) from this instance.
        
        :param (output):
        point0 origin of transform coordinates
        
        :param (output):
        point1 100 point of transform coordinates
        
        :param (output):
        point2 010 point of transform coordinates
        
        :param (output):
        point3 001 point of transform coordinates
        """
        ...
    
    def GetAnyFixedPoint(self: MSPyBentleyGeom.Transform, fixedPoint: MSPyBentleyGeom.DPoint3d) -> bool:
        """
        Compute any single point that remains unchanged by action
        of a transform. Note that a pure translation has no fixed points,
        while any other transformation does.
        
        :param (output):
        fixedPoint Point that is not changed by the transformation.
        
        :returns:
        true if the transformation has a fixed point.
        """
        ...
    
    def GetFixedLine(self: MSPyBentleyGeom.Transform, fixedPoint: MSPyBentleyGeom.DPoint3d, directionVector: MSPyBentleyGeom.DVec3d) -> bool:
        """
        Compute the line (if any) of points that are not affected
        by this transformation. Returns false if the fixed point set for the
        transform is empty, a single point, a plane, or all points.
        
        :param (output):
        fixedPoint A point on the line.
        
        :param (output):
        directionVector vector along the line.
        
        :returns:
        true if the transformation has a fixed point.
        """
        ...
    
    def GetFixedPlane(*args, **kwargs):
        """
        Overloaded function.
        
        1. GetFixedPlane(self: MSPyBentleyGeom.Transform, fixedPoint: MSPyBentleyGeom.DPoint3d, planeVectorX: MSPyBentleyGeom.DVec3d, planeVectorY: MSPyBentleyGeom.DVec3d) -> bool
        
        Compute the plane (if any) of points that are not
        affected by this transformation. Returns false if the fixed point set
        for the transform is empty, a single point, a line, or all points.
        
        :param (output):
        fixedPoint A point on the line.
        
        :param (output):
        planeVectorX a unit vector in the plane.
        
        :param (output):
        planeVectorY another unit vector in the plane, perpendicular to
        pDirectionVectorX.
        
        :returns:
        true if the transformation has a fixed point.
        
        2. GetFixedPlane(self: MSPyBentleyGeom.Transform, residualTransform: MSPyBentleyGeom.Transform, mirrorTransform: MSPyBentleyGeom.Transform, planePoint: MSPyBentleyGeom.DPoint3d, planeNormal: MSPyBentleyGeom.DVec3d) -> bool
        
        Compute the plane (if any) of points that are not
        affected by this transformation. Returns false if the fixed point set
        for the transform is empty, a single point, a line, or all points.
        
        :param (output):
        fixedPoint A point on the line.
        
        :param (output):
        planeVectorX a unit vector in the plane.
        
        :param (output):
        planeVectorY another unit vector in the plane, perpendicular to
        pDirectionVectorX.
        
        :returns:
        true if the transformation has a fixed point.
        """
        ...
    
    def GetFromMatrixByRowAndColumn(self: MSPyBentleyGeom.Transform, row: int, col: int) -> float:
        """
        Returns a value from a specified row and column of the
        matrix part of the transformation.
        
        :param (input):
        row The index of row to read. Row indices are 0, 1, 2.
        
        :param (input):
        col The index of column to read. Column indices are 0, 1, 2.
        """
        ...
    
    def GetMatrixColumn(self: MSPyBentleyGeom.Transform, column: MSPyBentleyGeom.DVec3d, index: int) -> None:
        """
        Returns a column from the matrix part of the
        transformation.
        
        :param (output):
        column column of matrix part.
        
        :param (input):
        index column index
        """
        ...
    
    def GetMatrixRow(self: MSPyBentleyGeom.Transform, row: MSPyBentleyGeom.DVec3d, index: int) -> None:
        """
        Returns a row from the matrix part of the transformation.
        
        :param (output):
        row row of matrix part.
        
        :param (input):
        index column index
        """
        ...
    
    def GetOriginAndVectors(*args, **kwargs):
        """
        Overloaded function.
        
        1. GetOriginAndVectors(self: MSPyBentleyGeom.Transform, origin: MSPyBentleyGeom.DPoint3d, vector0: MSPyBentleyGeom.DVec3d, vector1: MSPyBentleyGeom.DVec3d, vector2: MSPyBentleyGeom.DVec3d) -> None
        
        Sets origin to the translation part, and sets vector0, vector1 vector2
        to the columns of this instance.
        
        :param (output):
        origin origin of transform coordinates
        
        :param (output):
        vector0 100 vector of transform coordinates
        
        :param (output):
        vector1 010 vector of transform coordinates
        
        :param (output):
        vector2 001 vector of transform coordinates
        
        2. GetOriginAndVectors(self: MSPyBentleyGeom.Transform, origin: MSPyBentleyGeom.DPoint2d, vector0: MSPyBentleyGeom.DVec2d, vector1: MSPyBentleyGeom.DVec2d) -> None
        
        Sets origin to the translation part, and sets vector0, vector1 vector2
        to the columns of this instance.
        
        :param (output):
        origin origin of transform coordinates
        
        :param (output):
        vector0 100 vector of transform coordinates
        
        :param (output):
        vector1 010 vector of transform coordinates
        
        :param (output):
        vector2 001 vector of transform coordinates
        """
        ...
    
    def GetPointComponent(self: MSPyBentleyGeom.Transform, row: int) -> float:
        """
        Returns a value from a specified component of the point
        (translation) part of the transformation.
        
        :param (input):
        row The index of point component to read. Indices are 0, 1, 2 for
        x, y, z
        """
        ...
    
    def GetTranslation(*args, **kwargs):
        """
        Overloaded function.
        
        1. GetTranslation(self: MSPyBentleyGeom.Transform, point: MSPyBentleyGeom.DPoint3d) -> None
        
        Returns the translation (point) part of a transformation.
        
        :param (output):
        point vector part of transformation
        
        2. GetTranslation(self: MSPyBentleyGeom.Transform, point: MSPyBentleyGeom.DPoint2d) -> None
        
        Returns the translation (point) part of a transformation.
        
        :param (output):
        point vector part of transformation
        """
        ...
    
    @staticmethod
    def InitForwardAndInverseFromAxesAndOrigin(localToWorld: MSPyBentleyGeom.Transform, worldToLocal: MSPyBentleyGeom.Transform, axes: RotMatrix, origin: MSPyBentleyGeom.DPoint3d) -> bool:
        """
        Construct transforms between local and world for given origin and axis
        directions.
        
        :param (output):
        localToWorld transform from local system to world.
        
        :param (output):
        worldToLocal transform from world to local system.
        
        :param (input):
        axes coordinate directions of local system (relative to world)
        
        :param (input):
        origin origin of local system (in world)
        
        :returns:
        true if axes were independent
        """
        ...
    
    def InitFrom(*args, **kwargs):
        """
        Overloaded function.
        
        1. InitFrom(self: MSPyBentleyGeom.Transform, matrix: RotMatrix) -> None
        
        Returns a transformation with the given matrix part and a
        zero translation part.
        
        :param (input):
        matrix The matrix part
        
        2. InitFrom(self: MSPyBentleyGeom.Transform, matrix: RotMatrix, translation: MSPyBentleyGeom.DPoint3d) -> None
        
        Returns a transformation with the given matrix part and a
        zero translation part.
        
        :param (input):
        matrix The matrix part
        
        3. InitFrom(self: MSPyBentleyGeom.Transform, translation: MSPyBentleyGeom.DPoint3d) -> None
        
        Returns a transformation with the given matrix part and a
        zero translation part.
        
        :param (input):
        matrix The matrix part
        
        4. InitFrom(self: MSPyBentleyGeom.Transform, arg0: MSPyBentleyGeom.DVec3d) -> None
        
        5. InitFrom(self: MSPyBentleyGeom.Transform, x: float, y: float, z: float) -> None
        
        Returns a transformation with the given matrix part and a
        zero translation part.
        
        :param (input):
        matrix The matrix part
        
        6. InitFrom(self: MSPyBentleyGeom.Transform, x00: float, x01: float, x02: float, tx: float, x10: float, x11: float, x12: float, ty: float, x20: float, x21: float, x22: float, tz: float) -> None
        
        Returns a transformation with the given matrix part and a
        zero translation part.
        
        :param (input):
        matrix The matrix part
        
        7. InitFrom(self: MSPyBentleyGeom.Transform, hMap: MSPyBentleyGeom.DMap4d, inverse: int) -> bool
        
        Returns a transformation with the given matrix part and a
        zero translation part.
        
        :param (input):
        matrix The matrix part
        
        8. InitFrom(self: MSPyBentleyGeom.Transform, matrix: MSPyBentleyGeom.DMatrix4d) -> bool
        
        Returns a transformation with the given matrix part and a
        zero translation part.
        
        :param (input):
        matrix The matrix part
        """
        ...
    
    def InitFrom2Points(self: MSPyBentleyGeom.Transform, origin: MSPyBentleyGeom.DPoint2d, xPoint: MSPyBentleyGeom.DPoint2d, axisId: int, normalize: bool) -> None:
        """
        Returns a transformation in the xy-plane with origin
        origin, axis axisId towards xPoint, and the other axis perpendicular.
        If normalize is false, both axes have length equal to the distance
        between origin and xPoint. //! //!
        
        :param (input):
        origin The origin of coordinate system
        
        :param (input):
        xPoint The target point of axis axisId of coordinate system
        
        :param (input):
        axisId The axis (x=0, y=1) that points from origin to xPoint
        
        :param (input):
        normalize true to have coordinate system normalized
        """
        ...
    
    def InitFrom3Points(self: MSPyBentleyGeom.Transform, origin: MSPyBentleyGeom.DPoint2d, xPoint: MSPyBentleyGeom.DPoint2d, yPoint: MSPyBentleyGeom.DPoint2d) -> None:
        """
        Sets this instance to a transformation in the xy-plane with origin at
        origin, x-axis from origin to xPoint and y-axis from origin to yPoint.
        All axes are unnormalized. There is no effort to detect zero length
        axes or degenerate points that define a line but not a full coordinate
        system. The axes may be skewed.
        
        :param (input):
        origin The origin of transformed coordinates
        
        :param (input):
        xPoint The 10 point of transformed coordinates
        
        :param (input):
        yPoint The 01 point of transformed coordinates
        """
        ...
    
    def InitFrom4Points(self: MSPyBentleyGeom.Transform, origin: MSPyBentleyGeom.DPoint3d, xPoint: MSPyBentleyGeom.DPoint3d, yPoint: MSPyBentleyGeom.DPoint3d, zPoint: MSPyBentleyGeom.DPoint3d) -> None:
        """
        Returns a transformation with origin at origin, x-axis
        from origin to xPoint, y-axis from origin to yPoint, and z-axis from
        origin to zPoint. All axes are unnormalized. There is no effort to
        detect zero length axes or degenerate points that define only a line
        or plane but not a full coordinate system. The axes may be skewed.
        
        :param (input):
        origin The origin of transformed coordinates
        
        :param (input):
        xPoint The 100 point of transformed coordinates
        
        :param (input):
        yPoint The 010 point of transformed coordinates
        
        :param (input):
        zPoint The 001 point of transformed coordinates
        """
        ...
    
    def InitFromLineAndRotationAngle(self: MSPyBentleyGeom.Transform, point0: MSPyBentleyGeom.DPoint3d, point1: MSPyBentleyGeom.DPoint3d, radians: float) -> None:
        """
        Returns a transformation of rotation about a specified
        line.
        
        :param (input):
        point0 The start point of the line
        
        :param (input):
        point1 The end point of the line
        
        :param (input):
        radians The rotation angle
        """
        ...
    
    def InitFromMirrorPlane(self: MSPyBentleyGeom.Transform, origin: MSPyBentleyGeom.DPoint3d, normal: MSPyBentleyGeom.DVec3d) -> bool:
        """
        Initialize a transform that mirrors about a plane.
        
        :param (input):
        origin any point on the mirror plane.
        
        :param (input):
        normal vector perpendicular to mirror plane
        """
        ...
    
    def InitFromOriginAndLengths(self: MSPyBentleyGeom.Transform, origin: MSPyBentleyGeom.DPoint2d, xAxisLength: float, yAxisLength: float) -> None:
        """
        Returns a transformation in the xy-plane with origin
        origin and x,y-axes of given lengths. The z-coordinate of the origin
        is zero and the z-axis is unscaled.
        
        :param (input):
        origin origin of coordinate system
        
        :param (input):
        xAxisLength The length of x-axis
        
        :param (input):
        yAxisLength The length of y-axis
        """
        ...
    
    def InitFromOriginAndVectors(*args, **kwargs):
        """
        Overloaded function.
        
        1. InitFromOriginAndVectors(self: MSPyBentleyGeom.Transform, origin: MSPyBentleyGeom.DPoint3d, xVector: MSPyBentleyGeom.DVec3d, yVector: MSPyBentleyGeom.DVec3d, zVector: MSPyBentleyGeom.DVec3d) -> None
        
        Returns a transformation with origin at origin, x-axis
        xVector, y-axis yVector, and z-axis zVector. All axes are
        unnormalized. There is no effort to detect zero length axes or
        degenerate points that define only a line or plane but not a full
        coordinate system. The axes may be skewed.
        
        :param (input):
        origin The origin of transformed coordinates
        
        :param (input):
        xVector The 100 vector of transformed coordinates
        
        :param (input):
        yVector The 010 vector of transformed coordinates
        
        :param (input):
        zVector The 001 vector of transformed coordinates
        
        2. InitFromOriginAndVectors(self: MSPyBentleyGeom.Transform, origin: MSPyBentleyGeom.DPoint2d, xVector: MSPyBentleyGeom.DVec2d, yVector: MSPyBentleyGeom.DVec2d) -> None
        
        Returns a transformation with origin at origin, x-axis
        xVector, y-axis yVector, and z-axis zVector. All axes are
        unnormalized. There is no effort to detect zero length axes or
        degenerate points that define only a line or plane but not a full
        coordinate system. The axes may be skewed.
        
        :param (input):
        origin The origin of transformed coordinates
        
        :param (input):
        xVector The 100 vector of transformed coordinates
        
        :param (input):
        yVector The 010 vector of transformed coordinates
        
        :param (input):
        zVector The 001 vector of transformed coordinates
        """
        ...
    
    def InitFromOriginAngleAndLengths(self: MSPyBentleyGeom.Transform, origin: MSPyBentleyGeom.DPoint2d, xAxisAngleRadians: float, xAxisLength: float, yAxisLength: float) -> None:
        """
        Returns a transformation in the xy-plane with origin
        origin and x,y-axes of the given lengths rotated counter-clockwise
        from standard position by the given angle. The z-coordinate of the
        origin is zero and the z-axis is unscaled.
        
        :param (input):
        origin origin of coordinate system
        
        :param (input):
        xAxisAngleRadians The ccw angle separating x-axis from its
        standard position
        
        :param (input):
        xAxisLength The length of x-axis
        
        :param (input):
        yAxisLength The length of y-axis
        """
        ...
    
    def InitFromOriginXVectorYVectorSquareAndNormalize(self: MSPyBentleyGeom.Transform, origin: MSPyBentleyGeom.DPoint3d, xVector: MSPyBentleyGeom.DVec3d, yVector: MSPyBentleyGeom.DVec3d) -> bool:
        """
        Returns a transformation with origin, x axis direction,
        and xy plane All axes are normalized and perpendicular.
        
        :param (input):
        origin The origin of transformed coordinates
        
        :param (input):
        xVector direction for x axis
        
        :param (input):
        yVector " In plane " direction for y axis. <returns>true if
        SquareAndOrthogonalizeColumns succeeds</returns
        """
        ...
    
    def InitFromPlaneNormalToLine(self: MSPyBentleyGeom.Transform, origin: MSPyBentleyGeom.DPoint3d, xPoint: MSPyBentleyGeom.DPoint3d, axisId: int, normalize: bool) -> None:
        """
        Returns a (possibly skewed) transformation with origin
        origin, the axis axisId towards xPoint, and other axes perpendicular.
        If normalize is false, all axes have length equal to the distance
        between the two origin and xPoint. The axes may be skewed.
        
        :param (input):
        origin The origin of coordinate system
        
        :param (input):
        xPoint The target point of axis axisId of coordinate system
        
        :param (input):
        axisId The axis that points from origin to xPoint
        
        :param (input):
        normalize true to have coordinate system normalized
        """
        ...
    
    def InitFromPlaneOf3Points(self: MSPyBentleyGeom.Transform, origin: MSPyBentleyGeom.DPoint3d, xPoint: MSPyBentleyGeom.DPoint3d, yPoint: MSPyBentleyGeom.DPoint3d) -> None:
        """
        Returns a transformation with origin at origin, x-axis
        from origin to xPoint, y-axis from origin to yPoint, and z-axis equal
        to the cross product of x and y axes. All axes are unnormalized. There
        is no effort to detect zero length axes or degenerate points that
        define only a line or plane but not a full coordinate system.
        
        :param (input):
        origin The origin of coordinate system
        
        :param (input):
        xPoint The 100 point of coordinate system
        
        :param (input):
        yPoint The 010 point of coordinate system
        """
        ...
    
    def InitFromPrincipleAxisRotations(self: MSPyBentleyGeom.Transform, inTransform: MSPyBentleyGeom.Transform, xRot: float, yRot: float, zRot: float) -> None:
        """
        Sets this instance to the transformation obtained by premultiplying
        inTransform by 3 matrix rotations about principle axes, given by the
        angles xrot, yrot and zrot. inTransform may be the same as this
        instance. Symbolically, given transform [M t] and rotation matrices
        X,Y,Z, the resulting transform is [X*Y*Z*M X*Y*Z*t]
        
        :param (input):
        inTransform The base transformation
        
        :param (input):
        xrot The x axis rotation, in radians
        
        :param (input):
        yrot The y axis rotation, in radians
        
        :param (input):
        zrot The z axis rotation, in radians
        """
        ...
    
    def InitFromProjectionToPlane(self: MSPyBentleyGeom.Transform, origin: MSPyBentleyGeom.DPoint3d, normal: MSPyBentleyGeom.DVec3d) -> bool:
        """
        Initialize a transform that projects to a plane.
        
        :param (input):
        origin any point on the target plane.
        
        :param (input):
        normal vector perpendicular to target plane
        """
        ...
    
    def InitFromScalePerpendicularToPlane(self: MSPyBentleyGeom.Transform, origin: MSPyBentleyGeom.DPoint3d, normal: MSPyBentleyGeom.DVec3d, scale: float) -> bool:
        """
        Initialize a transform that scales around a plane
        
        :param (input):
        origin any point on the target plane
        
        :param (input):
        normal vector perpendicular to target plane.
        
        :param (input):
        scale scale factor. (e.g. 0.0 to project onto the plane, -1 to
        mirror)
        """
        ...
    
    def InitIdentity(self: MSPyBentleyGeom.Transform) -> None:
        """
        returns an identity transformation, i.e. zero translation
        part and identity matrix part.
        """
        ...
    
    def InitNormalizedFrameFromOriginXPointYPoint(self: MSPyBentleyGeom.Transform, origin: MSPyBentleyGeom.DPoint3d, xPoint: MSPyBentleyGeom.DPoint3d, yPoint: MSPyBentleyGeom.DPoint3d) -> bool:
        """
        Attempt to set up a coordinate frame origin at origin,
        x-axis from origin to xPoint, y-axis in plane with yPoint, All axes
        are normalized. Return false with identity at origin if unable to do
        cross products.
        
        :param (input):
        origin The origin of coordinate system
        
        :param (input):
        xPoint The 100 point of coordinate system
        
        :param (input):
        yPoint The 010 point of coordinate system
        """
        ...
    
    def InitProduct(*args, **kwargs):
        """
        Overloaded function.
        
        1. InitProduct(self: MSPyBentleyGeom.Transform, transform1: MSPyBentleyGeom.Transform, transform2: MSPyBentleyGeom.Transform) -> None
        
        Returns the product of two transformations. Symbolically,
        given transforms [R t] and [S u], return the product transform [R t][S
        u] = [R*S t+R*u].
        
        :param (input):
        transform1 The first factor
        
        :param (input):
        transform2 The second factor
        
        2. InitProduct(self: MSPyBentleyGeom.Transform, matrix: RotMatrix, transform: MSPyBentleyGeom.Transform) -> None
        
        Returns the product of two transformations. Symbolically,
        given transforms [R t] and [S u], return the product transform [R t][S
        u] = [R*S t+R*u].
        
        :param (input):
        transform1 The first factor
        
        :param (input):
        transform2 The second factor
        
        3. InitProduct(self: MSPyBentleyGeom.Transform, transform: MSPyBentleyGeom.Transform, matrix: RotMatrix) -> None
        
        Returns the product of two transformations. Symbolically,
        given transforms [R t] and [S u], return the product transform [R t][S
        u] = [R*S t+R*u].
        
        :param (input):
        transform1 The first factor
        
        :param (input):
        transform2 The second factor
        """
        ...
    
    def InitUniformScaleApproximation(self: MSPyBentleyGeom.Transform, transform: MSPyBentleyGeom.Transform, primaryAxis: int, secondaryAxis: int) -> bool:
        """
        Construct a transform which preserves both a primary
        column directon and a secondary column plane. Scale all columns to
        length of primary axis.
        
        :param (input):
        transform original matrix.
        
        :param (input):
        primaryAxis axis to be retained.
        
        :param (input):
        secondaryAxis axis defining plane to be maintained.
        """
        ...
    
    def InverseOf(*args, **kwargs):
        """
        InverseOf(self: MSPyBentleyGeom.Transform, in: MSPyBentleyGeom.Transform) -> bool
        
        Sets this instance to the inverse transform of in. in may be the same
        as this instance. This is a modestly expensive floating point
        computation (33 multiplies, 14 adds). Symbolically, given transform [R
        t] return transform [Q Q*(-t)] where Q is the inverse of matrix R.
        
        :param (input):
        in The input transformation
        
        Remark:
        This is deprecated. Preferred call is{resutl =
        in.ValidatedInverse ();}
        
        :returns:
        true if transform is invertible
        """
        ...
    
    def InvertRigidBodyTransformation(*args, **kwargs):
        """
        InvertRigidBodyTransformation(self: MSPyBentleyGeom.Transform, in: MSPyBentleyGeom.Transform) -> None
        
        Sets this instance to a matrix which is the inverse of in (input) THE
        SPECIAL CASE WHERE in HAS ONLY PURE ROTATION OR MIRRORING (input) ITS
        ROTATIONAL PART. These special conditions allow the 'inversion' to be
        done by only a transposition and one matrix-times-point
        multiplication, rather than the full effort of inverting a general
        transformation. It is the caller's responsibility to be sure that
        these special conditions hold. This usually occurs when the caller has
        just constructed the transform by a sequence of translations and
        rotations. If the caller has received the matrix from nonverified
        external sources and therefore does not know if the special conditions
        apply, the <CODE>inverseOf</CODE> method should be used instead. in
        may be the same as this instance. The specific computations in this
        special-case inversion are (1) the output transform's translation is
        the input transform's matrix times the negative of the input
        transform's translation, and (2) the output transform's matrix part is
        the tranpose of the input transform's matrix part. Symbolically, given
        transform [R t] return transform [R^ (R^)*(-t)] where ^ indicates
        transposition.
        
        :param (input):
        in The input transformation (TransformCR)
        """
        ...
    
    def IsEqual(*args, **kwargs):
        """
        Overloaded function.
        
        1. IsEqual(self: MSPyBentleyGeom.Transform, transform2: MSPyBentleyGeom.Transform) -> bool
        
        Returns true if two transforms have exact (bitwise)
        equality.
        
        :param (input):
        transform2 The second transform
        
        :returns:
        true if the transforms are identical
        
        2. IsEqual(self: MSPyBentleyGeom.Transform, transform2: MSPyBentleyGeom.Transform, matrixTolerance: float, pointTolerance: float) -> bool
        
        Returns true if two transforms have exact (bitwise)
        equality.
        
        :param (input):
        transform2 The second transform
        
        :returns:
        true if the transforms are identical
        """
        ...
    
    def IsIdentity(self: MSPyBentleyGeom.Transform) -> bool:
        """
        Returns true if the transform is the identity transform.
        
        :returns:
        true if the transformation is within tolerance of the identity.
        """
        ...
    
    def IsMirrorAboutPlane(self: MSPyBentleyGeom.Transform, planePoint: MSPyBentleyGeom.DPoint3d, unitNormal: MSPyBentleyGeom.DVec3d) -> bool:
        """
        Returns true if the transform is a mirror with respect to
        a plane.
        
        :param (output):
        planePoint Some point on the plane.
        
        :param (output):
        unitNormal unit vector perpendicular to the plane.
        
        :returns:
        true if the transformation is a mirror.
        """
        ...
    
    def IsNearRigidScale(self: MSPyBentleyGeom.Transform, dest: MSPyBentleyGeom.Transform, primaryAxis: int = 0, tolerance: float = 1e-06) -> bool:
        """
        Clean up a transform that is close to a pure rotate and scale. If
        source is NOT near to a rigid scale, return false and copy to the
        dest. If near an identity return identity. If nearly perpendicular
        with scales other than 1, clean preserving the length and direction of
        the primary axis. This is intended to be used with a crude (e.g.
        1.0e-6) reltol to identify old DGN file matrices that are " dirty " by
        modern standards but were meant to be identity, rotation, or scaled
        rotations in the UOR era.
        
        :param (input):
        dest result
        
        :param (input):
        primaryAxis axis whose orientation and direction is preserved.
        
        :param (input):
        tolerance relative tolerance for recognizing near-perpendicular
        conditions.
        """
        ...
    
    def IsPlanar(self: MSPyBentleyGeom.Transform, normal: MSPyBentleyGeom.DVec3d) -> bool:
        """
        Returns true if transformation effects are entirely
        within the plane with given normal.
        
        :param (input):
        normal The plane normal
        
        :returns:
        true if the transform has no effects perpendicular to planes with
        the given normal.
        """
        ...
    
    def IsRigid(self: MSPyBentleyGeom.Transform) -> bool:
        """
        Returns true if the matrix part of a transform is a rigid
        body rotation, i.e. its transpose is its inverse and it has a positive
        determinant.
        
        :returns:
        true if the transformation is rigid (no scale or shear in the
        matrix part)
        """
        ...
    
    def IsRigidScale(self: MSPyBentleyGeom.Transform) -> tuple:
        """
        Returns true if the matrix part of a transform is a rigid
        body rotation, i.e. its transpose is its inverse and it has a positive
        determinant.
        
        :param (output):
        scale scale factor.
        
        :returns:
        true if the transformation is rigid (no scale or shear in the
        matrix part)
        """
        ...
    
    def IsRotateAroundLine(self: MSPyBentleyGeom.Transform, fixedPoint: MSPyBentleyGeom.DPoint3d, directionVector: MSPyBentleyGeom.DVec3d) -> tuple:
        """
        Returns true if the transform is a non-zero rotation
        around a line.
        
        :param (output):
        fixedPoint a point on the line.
        
        :param (output):
        directionVector vector in the line direction.
        
        :param (output):
        radians rotation angle in radians.
        
        :returns:
        true if the transformation is a non-zero rotation.
        """
        ...
    
    def IsTranslate(self: MSPyBentleyGeom.Transform, translation: MSPyBentleyGeom.DPoint3d) -> bool:
        """
        Returns true if the transform is a simple translation.
        
        :param (output):
        translation the translation vector. Zero of not a translation
        transform.
        
        :returns:
        true if the transformation is a pure translation.
        """
        ...
    
    def IsTranslateScaleRotateAroundZ(self: MSPyBentleyGeom.Transform, origin: MSPyBentleyGeom.DPoint3d, rigidAxes: RotMatrix) -> tuple:
        """
        Return true if the transform a combination of only 2 thing:(1) move
        origin, (2) rotate around Z
        
        :param (output):
        origin origin of frame.
        
        :param (output):
        rigidAxes unit-length axes.
        
        :param (output):
        scale scale factor on the original axes.
        
        :param (output):
        radians positive rotation around Z
        """
        ...
    
    def IsUniformScale(self: MSPyBentleyGeom.Transform, fixedPoint: MSPyBentleyGeom.DPoint3d) -> tuple:
        """
        Returns true if the transform is a uniform scale with
        scale factor other than 1.0.
        
        :param (output):
        fixedPoint (If function result is true) the (one) point which
        remains in place in the transformation.
        
        :param (output):
        scale The scale factor. If the transform is not a scale, this is
        returned as 1.0.
        
        :returns:
        true if the transformation is a uniform scale.
        """
        ...
    
    def IsUniformScaleAndRotateAroundLine(self: MSPyBentleyGeom.Transform, fixedPoint: MSPyBentleyGeom.DPoint3d, directionVector: MSPyBentleyGeom.DVec3d) -> tuple:
        """
        Returns true if the transform is a uniform scale combined
        with a rotation. One, but not both, of the two steps may be null (unit
        scale or no rotation)
        
        :param (output):
        fixedPoint fixed point of scaling. This is also a point on the
        line.
        
        :param (output):
        directionVector vector in the direction of the rotation.
        
        :param (output):
        radians rotation angle
        
        :param (output):
        scale scale factor.
        
        :returns:
        true if the transformation has at least one of the scale, rotate
        effects.
        """
        ...
    
    def Matrix(self: MSPyBentleyGeom.Transform) -> RotMatrix:
        """
        Return the matrix part
        """
        ...
    
    def MatrixColumnMagnitude(self: MSPyBentleyGeom.Transform, i: int) -> float:
        """
        return the magnitude of a column of the matrix.
        
        :param (input):
        i column index. Adjusted cyclically if outside 012
        """
        ...
    
    def MaxDiff(self: MSPyBentleyGeom.Transform, otherTransform: MSPyBentleyGeom.Transform) -> float:
        """
        Returns the largest absolute value difference between
        corresponding coefficients
        
        :param (input):
        otherTransform
        
        :returns:
        largest absolute difference between the two transforms
        """
        ...
    
    def Multiply(*args, **kwargs):
        """
        Overloaded function.
        
        1. Multiply(self: MSPyBentleyGeom.Transform, point: MSPyBentleyGeom.DPoint3d) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        :param [in,out]:
        point point to be updated
        
        2. Multiply(self: MSPyBentleyGeom.Transform, result: MSPyBentleyGeom.DPoint3d, point: MSPyBentleyGeom.DPoint3d) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        :param [in,out]:
        point point to be updated
        
        3. Multiply(self: MSPyBentleyGeom.Transform, point: MSPyBentleyGeom.DPoint3d, x: float, y: float, z: float) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        :param [in,out]:
        point point to be updated
        
        4. Multiply(self: MSPyBentleyGeom.Transform, points: MSPyBentleyGeom.DPoint3dArray) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        :param [in,out]:
        point point to be updated
        
        5. Multiply(self: MSPyBentleyGeom.Transform, points: list) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        :param [in,out]:
        point point to be updated
        
        6. Multiply(self: MSPyBentleyGeom.Transform, outPoints: MSPyBentleyGeom.DPoint3dArray, inPoints: MSPyBentleyGeom.DPoint3dArray) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        :param [in,out]:
        point point to be updated
        
        7. Multiply(self: MSPyBentleyGeom.Transform, outPoints: list, inPoints: list) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        :param [in,out]:
        point point to be updated
        
        8. Multiply(self: MSPyBentleyGeom.Transform, result: MSPyBentleyGeom.DPoint2d, point: MSPyBentleyGeom.DPoint2d) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        :param [in,out]:
        point point to be updated
        
        9. Multiply(self: MSPyBentleyGeom.Transform, outPoints: MSPyBentleyGeom.DPoint2dArray, inPoints: MSPyBentleyGeom.DPoint2dArray) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        :param [in,out]:
        point point to be updated
        
        10. Multiply(self: MSPyBentleyGeom.Transform, result: MSPyBentleyGeom.DPoint3d, point: MSPyBentleyGeom.DPoint2d) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        :param [in,out]:
        point point to be updated
        
        11. Multiply(self: MSPyBentleyGeom.Transform, outPoints: MSPyBentleyGeom.DPoint3dArray, inPoints: MSPyBentleyGeom.DPoint2dArray) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        :param [in,out]:
        point point to be updated
        
        12. Multiply(self: MSPyBentleyGeom.Transform, outPoints: list, inPoints: MSPyBentleyGeom.DPoint2dArray) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        :param [in,out]:
        point point to be updated
        
        13. Multiply(self: MSPyBentleyGeom.Transform, result: MSPyBentleyGeom.DPoint2d, point: MSPyBentleyGeom.DPoint3d) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        :param [in,out]:
        point point to be updated
        
        14. Multiply(self: MSPyBentleyGeom.Transform, outPoints: MSPyBentleyGeom.DPoint2dArray, inPoints: MSPyBentleyGeom.DPoint2dArray) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        :param [in,out]:
        point point to be updated
        
        15. Multiply(self: MSPyBentleyGeom.Transform, result: MSPyBentleyGeom.DPoint4d, point: MSPyBentleyGeom.DPoint4d) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        :param [in,out]:
        point point to be updated
        
        16. Multiply(self: MSPyBentleyGeom.Transform, outPoints: MSPyBentleyGeom.DPoint4dArray, inPoints: MSPyBentleyGeom.DPoint4dArray) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        :param [in,out]:
        point point to be updated
        
        17. Multiply(self: MSPyBentleyGeom.Transform, outRange: MSPyBentleyGeom.DRange3d, inRange: MSPyBentleyGeom.DRange3d) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        :param [in,out]:
        point point to be updated
        
        18. Multiply(self: MSPyBentleyGeom.Transform, inoutEllipse: MSPyBentleyGeom.DEllipse3d) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        :param [in,out]:
        point point to be updated
        
        19. Multiply(self: MSPyBentleyGeom.Transform, outEllipse: MSPyBentleyGeom.DEllipse3d, inEllipse: MSPyBentleyGeom.DEllipse3d) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        :param [in,out]:
        point point to be updated
        
        20. Multiply(self: MSPyBentleyGeom.Transform, inoutPlane: MSPyBentleyGeom.DPlane3d) -> bool
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        :param [in,out]:
        point point to be updated
        
        21. Multiply(self: MSPyBentleyGeom.Transform, outPlane: MSPyBentleyGeom.DPlane3d, inPlane: MSPyBentleyGeom.DPlane3d) -> bool
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        :param [in,out]:
        point point to be updated
        
        22. Multiply(self: MSPyBentleyGeom.Transform, inoutSegment: MSPyBentleyGeom.DSegment3d) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        :param [in,out]:
        point point to be updated
        
        23. Multiply(self: MSPyBentleyGeom.Transform, outSegment: MSPyBentleyGeom.DSegment3d, inSegment: MSPyBentleyGeom.DSegment3d) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        :param [in,out]:
        point point to be updated
        
        24. Multiply(self: MSPyBentleyGeom.Transform, inoutRay: MSPyBentleyGeom.DRay3d) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        :param [in,out]:
        point point to be updated
        
        25. Multiply(self: MSPyBentleyGeom.Transform, outRay: MSPyBentleyGeom.DRay3d, inRay: MSPyBentleyGeom.DRay3d) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        :param [in,out]:
        point point to be updated
        
        26. Multiply(self: MSPyBentleyGeom.Transform, xyzwOut: MSPyBentleyGeom.DPoint4dArray, xyzwIn: MSPyBentleyGeom.DPoint4dArray) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        :param [in,out]:
        point point to be updated
        
        27. Multiply(self: MSPyBentleyGeom.Transform, xyzOut: MSPyBentleyGeom.DPoint3dArray, xyzIn: MSPyBentleyGeom.DPoint3dArray) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        :param [in,out]:
        point point to be updated
        
        28. Multiply(self: MSPyBentleyGeom.Transform, outXYZ: list, inXYZ: list) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        :param [in,out]:
        point point to be updated
        
        29. Multiply(self: MSPyBentleyGeom.Transform, xyOut: MSPyBentleyGeom.DPoint2dArray, xyIn: MSPyBentleyGeom.DPoint2dArray) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        :param [in,out]:
        point point to be updated
        
        30. Multiply(self: MSPyBentleyGeom.Transform, xyzOut: MSPyBentleyGeom.DPoint3dArray, xyIn: MSPyBentleyGeom.DPoint2dArray) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        :param [in,out]:
        point point to be updated
        
        31. Multiply(self: MSPyBentleyGeom.Transform, outXYZ: list, inXY: MSPyBentleyGeom.DPoint2dArray) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        :param [in,out]:
        point point to be updated
        
        32. Multiply(self: MSPyBentleyGeom.Transform, xyOut: MSPyBentleyGeom.DPoint2dArray, xyzIn: MSPyBentleyGeom.DPoint3dArray) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        :param [in,out]:
        point point to be updated
        
        33. Multiply(self: MSPyBentleyGeom.Transform, outXY: MSPyBentleyGeom.DPoint2dArray, inXYZ: list) -> None
        
        Multiplies a point by a transform, returning the result
        in place of the input point.
        
        :param [in,out]:
        point point to be updated
        """
        ...
    
    def MultiplyMatrixOnly(*args, **kwargs):
        """
        Overloaded function.
        
        1. MultiplyMatrixOnly(self: MSPyBentleyGeom.Transform, point: MSPyBentleyGeom.DPoint3d, x: float, y: float, z: float) -> None
        
        Multiplies the matrix part of this instance times the column vector
        constructed from components x,y,z. Symbolically, given transform [R t]
        and column vector p, the returned point is R*p.
        
        :param (output):
        point result of matrix * point operation
        
        :param (input):
        x The x component of the point
        
        :param (input):
        y The y component of the point
        
        :param (input):
        z The z component of the point
        
        2. MultiplyMatrixOnly(self: MSPyBentleyGeom.Transform, outPoint: MSPyBentleyGeom.DPoint3d, inPoint: MSPyBentleyGeom.DPoint3d) -> None
        
        Multiplies the matrix part of this instance times the column vector
        constructed from components x,y,z. Symbolically, given transform [R t]
        and column vector p, the returned point is R*p.
        
        :param (output):
        point result of matrix * point operation
        
        :param (input):
        x The x component of the point
        
        :param (input):
        y The y component of the point
        
        :param (input):
        z The z component of the point
        
        3. MultiplyMatrixOnly(self: MSPyBentleyGeom.Transform, point: MSPyBentleyGeom.DPoint3d) -> None
        
        Multiplies the matrix part of this instance times the column vector
        constructed from components x,y,z. Symbolically, given transform [R t]
        and column vector p, the returned point is R*p.
        
        :param (output):
        point result of matrix * point operation
        
        :param (input):
        x The x component of the point
        
        :param (input):
        y The y component of the point
        
        :param (input):
        z The z component of the point
        """
        ...
    
    def MultiplyTransformTranslation(self: MSPyBentleyGeom.Transform, transform: MSPyBentleyGeom.Transform, translation: MSPyBentleyGeom.DVec3d, scaleFactor: float) -> None:
        """
        Multiply by a translation " from the left ":result = transformIn *
        (Identity, scaled translationIn)
        
        :param (input):
        transformIn full transform for right factor.
        
        :param (input):
        translationIn translation vector for right term
        
        :param (input):
        scaleFactor scale factor for translation
        """
        ...
    
    def MultiplyTranslationTransform(self: MSPyBentleyGeom.Transform, translation: MSPyBentleyGeom.DVec3d, scaleFactor: float, transform: MSPyBentleyGeom.Transform) -> None:
        """
        Multiply by a translation " from the left ":result = (Identity, scaled
        translationIn) * transformIn
        
        :param (input):
        translationIn translation vector for left term
        
        :param (input):
        scaleFactor factor for translation
        
        :param (input):
        transformIn full transform for right factor.
        """
        ...
    
    def MultiplyTranspose(*args, **kwargs):
        """
        Overloaded function.
        
        1. MultiplyTranspose(self: MSPyBentleyGeom.Transform, outPoints: MSPyBentleyGeom.DPoint3dArray, inPoints: MSPyBentleyGeom.DPoint3dArray) -> None
        
        Multiplies this instance times each column vector in inPoint, using
        the transpose of the matrix part of this instance in the
        multiplications, and places the resulting points in outPoint.
        Symbolically, given transform [R t], each returned point has the
        equivalent form p*R + t, where p is a row vector. inPoint and outPoint
        may be the same.
        
        :param (output):
        outPoint transformed points
        
        :param (input):
        inPoint The input points
        
        :param (input):
        numPoint The number of points
        
        2. MultiplyTranspose(self: MSPyBentleyGeom.Transform, outPoints: list, inPoints: list) -> None
        
        Multiplies this instance times each column vector in inPoint, using
        the transpose of the matrix part of this instance in the
        multiplications, and places the resulting points in outPoint.
        Symbolically, given transform [R t], each returned point has the
        equivalent form p*R + t, where p is a row vector. inPoint and outPoint
        may be the same.
        
        :param (output):
        outPoint transformed points
        
        :param (input):
        inPoint The input points
        
        :param (input):
        numPoint The number of points
        
        3. MultiplyTranspose(self: MSPyBentleyGeom.Transform, points: MSPyBentleyGeom.DPoint3dArray) -> None
        
        Multiplies this instance times each column vector in inPoint, using
        the transpose of the matrix part of this instance in the
        multiplications, and places the resulting points in outPoint.
        Symbolically, given transform [R t], each returned point has the
        equivalent form p*R + t, where p is a row vector. inPoint and outPoint
        may be the same.
        
        :param (output):
        outPoint transformed points
        
        :param (input):
        inPoint The input points
        
        :param (input):
        numPoint The number of points
        
        4. MultiplyTranspose(self: MSPyBentleyGeom.Transform, points: list) -> None
        
        Multiplies this instance times each column vector in inPoint, using
        the transpose of the matrix part of this instance in the
        multiplications, and places the resulting points in outPoint.
        Symbolically, given transform [R t], each returned point has the
        equivalent form p*R + t, where p is a row vector. inPoint and outPoint
        may be the same.
        
        :param (output):
        outPoint transformed points
        
        :param (input):
        inPoint The input points
        
        :param (input):
        numPoint The number of points
        """
        ...
    
    def MultiplyTransposeMatrixOnly(*args, **kwargs):
        """
        Overloaded function.
        
        1. MultiplyTransposeMatrixOnly(self: MSPyBentleyGeom.Transform, point: MSPyBentleyGeom.DPoint3d, x: float, y: float, z: float) -> None
        
        Multiplies the row vector constructed from components x,y,z times the
        matrix part of this instance. Symbolically, given transform [R t] and
        row vector p, the returned point is p*R.
        
        :param (output):
        point result of point * matrix operation
        
        :param (input):
        x The x component of the point
        
        :param (input):
        y The y component of the point
        
        :param (input):
        z The z component of the point
        
        2. MultiplyTransposeMatrixOnly(self: MSPyBentleyGeom.Transform, outPoint: MSPyBentleyGeom.DPoint3d, inPoint: MSPyBentleyGeom.DPoint3d) -> None
        
        Multiplies the row vector constructed from components x,y,z times the
        matrix part of this instance. Symbolically, given transform [R t] and
        row vector p, the returned point is p*R.
        
        :param (output):
        point result of point * matrix operation
        
        :param (input):
        x The x component of the point
        
        :param (input):
        y The y component of the point
        
        :param (input):
        z The z component of the point
        
        3. MultiplyTransposeMatrixOnly(self: MSPyBentleyGeom.Transform, point: MSPyBentleyGeom.DPoint3d) -> None
        
        Multiplies the row vector constructed from components x,y,z times the
        matrix part of this instance. Symbolically, given transform [R t] and
        row vector p, the returned point is p*R.
        
        :param (output):
        point result of point * matrix operation
        
        :param (input):
        x The x component of the point
        
        :param (input):
        y The y component of the point
        
        :param (input):
        z The z component of the point
        """
        ...
    
    def MultiplyWeighted(*args, **kwargs):
        """
        Overloaded function.
        
        1. MultiplyWeighted(self: MSPyBentleyGeom.Transform, point: MSPyBentleyGeom.DPoint3d, weight: float) -> None
        
        Multiplies a " weighted point " in place. That is, the point is input
        and output as (wx,wy,wz,w) where x,y,z are the cartesian image
        coordinates.
        
        :param [in,out]:
        point point to be updated
        
        :param (input):
        weight The weight
        
        2. MultiplyWeighted(self: MSPyBentleyGeom.Transform, weightedXYZOut: MSPyBentleyGeom.DPoint3dArray, weightedXYZIn: MSPyBentleyGeom.DPoint3dArray, weights: MSPyBentleyGeom.DoubleArray) -> None
        
        Multiplies a " weighted point " in place. That is, the point is input
        and output as (wx,wy,wz,w) where x,y,z are the cartesian image
        coordinates.
        
        :param [in,out]:
        point point to be updated
        
        :param (input):
        weight The weight
        
        3. MultiplyWeighted(self: MSPyBentleyGeom.Transform, weightedXYZOut: list, weightedXYZIn: list, weights: MSPyBentleyGeom.DoubleArray) -> None
        
        Multiplies a " weighted point " in place. That is, the point is input
        and output as (wx,wy,wz,w) where x,y,z are the cartesian image
        coordinates.
        
        :param [in,out]:
        point point to be updated
        
        :param (input):
        weight The weight
        """
        ...
    
    def OffsetPointByColumn(*args, **kwargs):
        """
        OffsetPointByColumn(self: MSPyBentleyGeom.Transform, out: MSPyBentleyGeom.DPoint3d, in: MSPyBentleyGeom.DPoint3d, i: int) -> None
        
        Adds column i of the matrix part of this instance to point in and
        places the result in out.
        
        :param (output):
        out sum of in and column i
        
        :param (input):
        in The base point for sum
        
        :param (input):
        i The column index of matrix
        """
        ...
    
    def Origin(self: MSPyBentleyGeom.Transform) -> MSPyBentleyGeom.DPoint3d:
        """
        Return the origin (aka translation) part as a DPoint3d.
        """
        ...
    
    def ScaleCompleteRows(self: MSPyBentleyGeom.Transform, transform: MSPyBentleyGeom.Transform, xscale: float, yscale: float, zscale: float) -> None:
        """
        Scale the complete rows by respective factors. (See also
        scaleMatrixColumns, scaleMatrixRows, which only act on the matrix
        part)
        
        :param (input):
        transform The input transform.
        
        :param (input):
        xscale The x column scale factor
        
        :param (input):
        yscale The y column scale factor
        
        :param (input):
        zscale The z column scale factor
        """
        ...
    
    def ScaleDoubleArrayByXColumnMagnitude(self: MSPyBentleyGeom.Transform, data: float, n: int) -> None:
        """
        scale all values in an array of doubles by the magnitude of a
        specified column of the matrix.
        
        :param (input):
        data array of doubles.
        
        :param (input):
        n number of values.
        """
        ...
    
    def ScaleMatrixColumns(*args, **kwargs):
        """
        Overloaded function.
        
        1. ScaleMatrixColumns(self: MSPyBentleyGeom.Transform, InTransform: MSPyBentleyGeom.Transform, xScale: float, yScale: float, zScale: float) -> None
        
        Scale the columns of the matrix part by respective factors.
        Translation part is unaffected. (See also scaleMatrixRows,
        scaleTransformRows)
        
        :param (input):
        transform The input transform.
        
        :param (input):
        xscale The x column scale factor
        
        :param (input):
        yscale The y column scale factor
        
        :param (input):
        zscale The z column scale factor
        
        2. ScaleMatrixColumns(self: MSPyBentleyGeom.Transform, xscale: float, yscale: float, zscale: float) -> None
        
        Scale the columns of the matrix part by respective factors.
        Translation part is unaffected. (See also scaleMatrixRows,
        scaleTransformRows)
        
        :param (input):
        transform The input transform.
        
        :param (input):
        xscale The x column scale factor
        
        :param (input):
        yscale The y column scale factor
        
        :param (input):
        zscale The z column scale factor
        """
        ...
    
    def ScaleMatrixRows(self: MSPyBentleyGeom.Transform, transform: MSPyBentleyGeom.Transform, xscale: float, yscale: float, zscale: float) -> None:
        """
        Scale the rows of the matrix part by respective factors. Translation
        part is unaffected. (See also scaleMatrixColumns, scaleTransformRows)
        
        :param (input):
        transform The input transform.
        
        :param (input):
        xscale The x column scale factor
        
        :param (input):
        yscale The y column scale factor
        
        :param (input):
        zscale The z column scale factor
        """
        ...
    
    def SetFixedPoint(*args, **kwargs):
        """
        Overloaded function.
        
        1. SetFixedPoint(self: MSPyBentleyGeom.Transform, point: MSPyBentleyGeom.DPoint2d) -> None
        
        Sets the translation part of this instance so that it leaves point
        point unchanged, i.e. so that this instance may be interpreted as
        applying its matrix part as a rotation or scaling about point.
        Symbolically, given transform [R t] and column vector p, the returned
        transform is [R p-R*p]. (The prior translation part is destroyed, and
        does not affect the result in any way.)
        
        :param (input):
        point The point that is to remain fixed when multiplied by the
        modified transformation
        
        2. SetFixedPoint(self: MSPyBentleyGeom.Transform, point: MSPyBentleyGeom.DPoint3d) -> None
        
        Sets the translation part of this instance so that it leaves point
        point unchanged, i.e. so that this instance may be interpreted as
        applying its matrix part as a rotation or scaling about point.
        Symbolically, given transform [R t] and column vector p, the returned
        transform is [R p-R*p]. (The prior translation part is destroyed, and
        does not affect the result in any way.)
        
        :param (input):
        point The point that is to remain fixed when multiplied by the
        modified transformation
        """
        ...
    
    def SetMatrix(self: MSPyBentleyGeom.Transform, matrix: RotMatrix) -> None:
        """
        Overwrites the matrix part of a preexisting
        transformation. The translation part is unchanged.
        
        :param (input):
        matrix The matrix to insert
        """
        ...
    
    def SetMatrixColumn(self: MSPyBentleyGeom.Transform, column: MSPyBentleyGeom.DVec3d, index: int) -> None:
        """
        Set a column of the matrix part.
        
        :param (output):
        column column data
        
        :param (input):
        index column index
        """
        ...
    
    def SetMatrixRow(self: MSPyBentleyGeom.Transform, row: MSPyBentleyGeom.DVec3d, index: int) -> None:
        """
        Set a column of the matrix part.
        
        :param (output):
        row row data
        
        :param (input):
        index column index
        """
        ...
    
    def SetTranslation(*args, **kwargs):
        """
        Overloaded function.
        
        1. SetTranslation(self: MSPyBentleyGeom.Transform, point: MSPyBentleyGeom.DPoint3d) -> None
        
        Sets the translation part of this instance to point. The prior
        translation part is overwritten, and the matrix part is unchanged.
        Symbolically, if point is u then this instance [R t] becomes the
        transformation [R u].
        
        :param (input):
        point The vector to insert
        
        2. SetTranslation(self: MSPyBentleyGeom.Transform, point: MSPyBentleyGeom.DPoint2d) -> None
        
        Sets the translation part of this instance to point. The prior
        translation part is overwritten, and the matrix part is unchanged.
        Symbolically, if point is u then this instance [R t] becomes the
        transformation [R u].
        
        :param (input):
        point The vector to insert
        """
        ...
    
    def Solve(self: MSPyBentleyGeom.Transform, outPoint: MSPyBentleyGeom.DPoint3d, inPoint: MSPyBentleyGeom.DPoint3d) -> bool:
        """
        Solves the linear system Tx=b, where T is this instance, b is the
        input point and x is the output point. No simplifying assumptions are
        made regarding the matrix part of T. Symbolically, if T = [M t], then
        x = Q (b - t), where Q is the inverse of M (i.e., the system is
        equivalent to Mx = b - t). inPoint and outPoint may have identical
        addresses.
        
        :param (output):
        outPoint solution to system
        
        :param (input):
        inPoint The constant point of the system
        
        :returns:
        false if the matrix part of this instance is singular.
        """
        ...
    
    def SolveArray(*args, **kwargs):
        """
        Overloaded function.
        
        1. SolveArray(self: MSPyBentleyGeom.Transform, xyzOut: MSPyBentleyGeom.DPoint3dArray, xyzIn: MSPyBentleyGeom.DPoint3dArray) -> bool
        
        Solves the linear systems TX=B, where T is this instance, B is the
        matrix of numPoints input points and X is the matrix of numPoints
        output points. No simplifying assumptions are made regarding the
        matrix part of T. Symbolically, if T = [M t], then for each
        input/output point i, X[i] = Q (B[i] - t), where Q is the inverse of M
        (i.e., the i_th system is equivalent to MX[i] = B[i] - t). inPoint and
        outPoint may have identical addresses.
        
        :param (output):
        outPoint column points of solution matrix to system
        
        :param (input):
        inPoint The column points of constant matrix of system
        
        :param (input):
        numPoints The number of input/output points
        
        :returns:
        false if the matrix part of this instance is singular.
        
        2. SolveArray(self: MSPyBentleyGeom.Transform, outXYZ: list, inXYZ: list) -> None
        
        Solves the linear systems TX=B, where T is this instance, B is the
        matrix of numPoints input points and X is the matrix of numPoints
        output points. No simplifying assumptions are made regarding the
        matrix part of T. Symbolically, if T = [M t], then for each
        input/output point i, X[i] = Q (B[i] - t), where Q is the inverse of M
        (i.e., the i_th system is equivalent to MX[i] = B[i] - t). inPoint and
        outPoint may have identical addresses.
        
        :param (output):
        outPoint column points of solution matrix to system
        
        :param (input):
        inPoint The column points of constant matrix of system
        
        :param (input):
        numPoints The number of input/output points
        
        :returns:
        false if the matrix part of this instance is singular.
        """
        ...
    
    def TransformImplicitPlane(self: MSPyBentleyGeom.Transform, a: float, b: float, c: float, d: float) -> tuple:
        """
        Transform the a,b,c,d components for an implicit plane. The plane
        equation format is ax+by+cz=d.
        
        :param (output):
        aOut x coefficient in transformed plane equation
        
        :param (output):
        bOut y coefficient in transformed plane equation
        
        :param (output):
        cOut z coefficient in transformed plane equation
        
        :param (output):
        dOut constant coefficient for equation.
        
        :param (input):
        a The x coefficient in plane equation
        
        :param (input):
        b The y coefficient in plane equation
        
        :param (input):
        c The z coefficient in plane equation
        
        :param (input):
        d The constant on right hand side of plane equation
        """
        ...
    
    def TranslateInLocalCoordinates(*args, **kwargs):
        """
        TranslateInLocalCoordinates(self: MSPyBentleyGeom.Transform, in: MSPyBentleyGeom.Transform, x: float, y: float, z: float) -> None
        
        Sets this instance to a transformation that has the same matrix part
        as transform in and a translation part that is the SUM of the
        translation part of in plus the product of the matrix part of in times
        the given point. If the translation part of in is interpreted as the
        origin of a coordinate system (whose axis directions and sizes are
        given by the columns of the matrix part), this instance becomes a
        coordinate frame with the same axis directions and sizes, but with the
        origin shifted to point x,y,z of the in system. That is, x,y,z are the
        local coordinates of the new origin, and the translation part of this
        instance becomes the global coordinates of the new origin. in may be
        identical to this instance. Symbolically, if in is the transform [R t]
        and the local origin coordinates x,y,z are in column vector p, the
        result is the transformation [R t+R*p].
        
        :param (input):
        in The input transformation
        
        :param (input):
        x The x-coordinate of the local origin
        
        :param (input):
        y The y-coordinate of the local origin
        
        :param (input):
        z The z-coordinate of the local origin
        """
        ...
    
    def Translation(self: MSPyBentleyGeom.Transform) -> MSPyBentleyGeom.DVec3d:
        """
        Return the translation (aka origin) part as a DVec3d.
        """
        ...
    
    @staticmethod
    def TryRangeMapping(sourceRange: MSPyBentleyGeom.DRange2d, destRange: MSPyBentleyGeom.DRange2d, transform: MSPyBentleyGeom.Transform) -> bool:
        """
        Returns a transformation that maps corners of the source
        range to corners of the destination range.
        
        :returns:
        false if either range is null or any direction of the sourceRange
        has zero length.
        """
        ...
    
    def ValidatedInverse(self: MSPyBentleyGeom.Transform) -> MSPyBentleyGeom.ValidatedTransform:
        """
        Return the inverse of the instance transform. This is a modestly
        expensive floating point computation (33 multiplies, 14 adds).
        Symbolically, given transform [R t] return transform [Q Q*(-t)] where
        Q is the inverse of matrix R.
        
        :returns:
        """
        ...
    
    def ZeroTranslation(self: MSPyBentleyGeom.Transform) -> None:
        """
        Sets the translation part of this instance to zero. The prior
        translation part is overwritten, and the matrix part is unchanged.
        Symbolically, this instance [R t] becomes the transformation [R 0].
        """
        ...
    
    def __init__(self: MSPyBentleyGeom.Transform) -> None:
        ...
    
    @property
    def form3d(arg0: MSPyBentleyGeom.Transform) -> numpy.typing.NDArray:
        ...
    @form3d.setter
    def form3d(arg0: RotMatrix, arg1: numpy.typing.NDArray) -> None:
        ...
    
class TransformArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.TransformArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.TransformArray, arg0: MSPyBentleyGeom.TransformArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.TransformArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.TransformArray, x: MSPyBentleyGeom.Transform) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.TransformArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.TransformArray, L: MSPyBentleyGeom.TransformArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.TransformArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.TransformArray, i: int, x: MSPyBentleyGeom.Transform) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.TransformArray) -> MSPyBentleyGeom.Transform
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.TransformArray, i: int) -> MSPyBentleyGeom.Transform
        
        Remove and return the item at index ``i``
        """
        ...
    
U0_EDGE: int

U1_EDGE: int

class UInt16Array:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.UInt16Array) -> None
        
        2. __init__(self: MSPyBentleyGeom.UInt16Array, arg0: MSPyBentleyGeom.UInt16Array) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.UInt16Array, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.UInt16Array, x: int) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.UInt16Array) -> None:
        """
        Clear the contents
        """
        ...
    
    def count(self: MSPyBentleyGeom.UInt16Array, x: int) -> int:
        """
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.UInt16Array, L: MSPyBentleyGeom.UInt16Array) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.UInt16Array, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.UInt16Array, i: int, x: int) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.UInt16Array) -> int
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.UInt16Array, i: int) -> int
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(self: MSPyBentleyGeom.UInt16Array, x: int) -> None:
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class UInt32Array:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.UInt32Array) -> None
        
        2. __init__(self: MSPyBentleyGeom.UInt32Array, arg0: MSPyBentleyGeom.UInt32Array) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.UInt32Array, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.UInt32Array, x: int) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.UInt32Array) -> None:
        """
        Clear the contents
        """
        ...
    
    def count(self: MSPyBentleyGeom.UInt32Array, x: int) -> int:
        """
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.UInt32Array, L: MSPyBentleyGeom.UInt32Array) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.UInt32Array, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.UInt32Array, i: int, x: int) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.UInt32Array) -> int
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.UInt32Array, i: int) -> int
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(self: MSPyBentleyGeom.UInt32Array, x: int) -> None:
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class UInt64Array:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.UInt64Array) -> None
        
        2. __init__(self: MSPyBentleyGeom.UInt64Array, arg0: MSPyBentleyGeom.UInt64Array) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.UInt64Array, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.UInt64Array, x: int) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.UInt64Array) -> None:
        """
        Clear the contents
        """
        ...
    
    def count(self: MSPyBentleyGeom.UInt64Array, x: int) -> int:
        """
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.UInt64Array, L: MSPyBentleyGeom.UInt64Array) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.UInt64Array, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.UInt64Array, i: int, x: int) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.UInt64Array) -> int
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.UInt64Array, i: int) -> int
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(self: MSPyBentleyGeom.UInt64Array, x: int) -> None:
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class UInt64VecArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.UInt64VecArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.UInt64VecArray, arg0: MSPyBentleyGeom.UInt64VecArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.UInt64VecArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.UInt64VecArray, x: MSPyBentleyGeom.UInt64Array) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.UInt64VecArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def count(self: MSPyBentleyGeom.UInt64VecArray, x: MSPyBentleyGeom.UInt64Array) -> int:
        """
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.UInt64VecArray, L: MSPyBentleyGeom.UInt64VecArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.UInt64VecArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.UInt64VecArray, i: int, x: MSPyBentleyGeom.UInt64Array) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.UInt64VecArray) -> MSPyBentleyGeom.UInt64Array
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.UInt64VecArray, i: int) -> MSPyBentleyGeom.UInt64Array
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(self: MSPyBentleyGeom.UInt64VecArray, x: MSPyBentleyGeom.UInt64Array) -> None:
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class UInt8Array:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.UInt8Array) -> None
        
        2. __init__(self: MSPyBentleyGeom.UInt8Array, arg0: MSPyBentleyGeom.UInt8Array) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.UInt8Array, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.UInt8Array, x: int) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.UInt8Array) -> None:
        """
        Clear the contents
        """
        ...
    
    def count(self: MSPyBentleyGeom.UInt8Array, x: int) -> int:
        """
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.UInt8Array, L: MSPyBentleyGeom.UInt8Array) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.UInt8Array, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.UInt8Array, i: int, x: int) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.UInt8Array) -> int
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.UInt8Array, i: int) -> int
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(self: MSPyBentleyGeom.UInt8Array, x: int) -> None:
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
class UpdateSequenceList:
    """
    None
    """

    def __init__(self: MSPyBentleyGeom.UpdateSequenceList) -> None:
        ...
    
    def append(self: MSPyBentleyGeom.UInt64Array, x: int) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.UInt64Array) -> None:
        """
        Clear the contents
        """
        ...
    
    def count(self: MSPyBentleyGeom.UInt64Array, x: int) -> int:
        """
        Return the number of times ``x`` appears in the list
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.UInt64Array, L: MSPyBentleyGeom.UInt64Array) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.UInt64Array, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.UInt64Array, i: int, x: int) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.UInt64Array) -> int
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.UInt64Array, i: int) -> int
        
        Remove and return the item at index ``i``
        """
        ...
    
    def remove(self: MSPyBentleyGeom.UInt64Array, x: int) -> None:
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
        ...
    
V0_EDGE: int

V1_EDGE: int

class ValidatedClipPlane:
    """
    None
    """

    def IsValid(*args, **kwargs):
        """
        Overloaded function.
        
        1. IsValid(self: MSPyBentleyGeom.ValidatedClipPlane) -> bool
        
        2. IsValid(self: MSPyBentleyGeom.ValidatedClipPlane, value: MSPyBentleyGeom.ClipPlane) -> bool
        """
        ...
    
    def SetIsValid(self: MSPyBentleyGeom.ValidatedClipPlane, value: bool) -> None:
        ...
    
    def Value(self: MSPyBentleyGeom.ValidatedClipPlane) -> MSPyBentleyGeom.ClipPlane:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ValidatedClipPlane) -> None
        
        2. __init__(self: MSPyBentleyGeom.ValidatedClipPlane, value: MSPyBentleyGeom.ClipPlane) -> None
        
        3. __init__(self: MSPyBentleyGeom.ValidatedClipPlane, value: MSPyBentleyGeom.ClipPlane, isValid: bool) -> None
        """
        ...
    
class ValidatedCurveLocationDetail:
    """
    None
    """

    def IsValid(*args, **kwargs):
        """
        Overloaded function.
        
        1. IsValid(self: MSPyBentleyGeom.ValidatedCurveLocationDetail) -> bool
        
        2. IsValid(self: MSPyBentleyGeom.ValidatedCurveLocationDetail, value: MSPyBentleyGeom.CurveLocationDetail) -> bool
        """
        ...
    
    def SetIsValid(self: MSPyBentleyGeom.ValidatedCurveLocationDetail, value: bool) -> None:
        ...
    
    def Value(self: MSPyBentleyGeom.ValidatedCurveLocationDetail) -> MSPyBentleyGeom.CurveLocationDetail:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ValidatedCurveLocationDetail) -> None
        
        2. __init__(self: MSPyBentleyGeom.ValidatedCurveLocationDetail, value: MSPyBentleyGeom.CurveLocationDetail) -> None
        
        3. __init__(self: MSPyBentleyGeom.ValidatedCurveLocationDetail, value: MSPyBentleyGeom.CurveLocationDetail, isValid: bool) -> None
        """
        ...
    
class ValidatedDEllipse3d:
    """
    None
    """

    def IsValid(*args, **kwargs):
        """
        Overloaded function.
        
        1. IsValid(self: MSPyBentleyGeom.ValidatedDEllipse3d) -> bool
        
        2. IsValid(self: MSPyBentleyGeom.ValidatedDEllipse3d, value: MSPyBentleyGeom.DEllipse3d) -> bool
        """
        ...
    
    def SetIsValid(self: MSPyBentleyGeom.ValidatedDEllipse3d, value: bool) -> None:
        ...
    
    def Value(self: MSPyBentleyGeom.ValidatedDEllipse3d) -> MSPyBentleyGeom.DEllipse3d:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ValidatedDEllipse3d) -> None
        
        2. __init__(self: MSPyBentleyGeom.ValidatedDEllipse3d, value: MSPyBentleyGeom.DEllipse3d) -> None
        
        3. __init__(self: MSPyBentleyGeom.ValidatedDEllipse3d, value: MSPyBentleyGeom.DEllipse3d, isValid: bool) -> None
        """
        ...
    
class ValidatedDPlane3d:
    """
    None
    """

    def IsValid(*args, **kwargs):
        """
        Overloaded function.
        
        1. IsValid(self: MSPyBentleyGeom.ValidatedDPlane3d) -> bool
        
        2. IsValid(self: MSPyBentleyGeom.ValidatedDPlane3d, value: MSPyBentleyGeom.DPlane3d) -> bool
        """
        ...
    
    def SetIsValid(self: MSPyBentleyGeom.ValidatedDPlane3d, value: bool) -> None:
        ...
    
    def Value(self: MSPyBentleyGeom.ValidatedDPlane3d) -> MSPyBentleyGeom.DPlane3d:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ValidatedDPlane3d) -> None
        
        2. __init__(self: MSPyBentleyGeom.ValidatedDPlane3d, value: MSPyBentleyGeom.DPlane3d) -> None
        
        3. __init__(self: MSPyBentleyGeom.ValidatedDPlane3d, value: MSPyBentleyGeom.DPlane3d, isValid: bool) -> None
        """
        ...
    
class ValidatedDPlane3dByVectors:
    """
    None
    """

    def IsValid(*args, **kwargs):
        """
        Overloaded function.
        
        1. IsValid(self: MSPyBentleyGeom.ValidatedDPlane3dByVectors) -> bool
        
        2. IsValid(self: MSPyBentleyGeom.ValidatedDPlane3dByVectors, value: MSPyBentleyGeom.DPlane3dByVectors) -> bool
        """
        ...
    
    def SetIsValid(self: MSPyBentleyGeom.ValidatedDPlane3dByVectors, value: bool) -> None:
        ...
    
    def Value(self: MSPyBentleyGeom.ValidatedDPlane3dByVectors) -> MSPyBentleyGeom.DPlane3dByVectors:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ValidatedDPlane3dByVectors) -> None
        
        2. __init__(self: MSPyBentleyGeom.ValidatedDPlane3dByVectors, value: MSPyBentleyGeom.DPlane3dByVectors) -> None
        
        3. __init__(self: MSPyBentleyGeom.ValidatedDPlane3dByVectors, value: MSPyBentleyGeom.DPlane3dByVectors, isValid: bool) -> None
        """
        ...
    
class ValidatedDPoint2d:
    """
    None
    """

    def IsValid(*args, **kwargs):
        """
        Overloaded function.
        
        1. IsValid(self: MSPyBentleyGeom.ValidatedDPoint2d) -> bool
        
        2. IsValid(self: MSPyBentleyGeom.ValidatedDPoint2d, value: MSPyBentleyGeom.DPoint2d) -> bool
        """
        ...
    
    def SetIsValid(self: MSPyBentleyGeom.ValidatedDPoint2d, value: bool) -> None:
        ...
    
    def Value(self: MSPyBentleyGeom.ValidatedDPoint2d) -> MSPyBentleyGeom.DPoint2d:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ValidatedDPoint2d) -> None
        
        2. __init__(self: MSPyBentleyGeom.ValidatedDPoint2d, value: MSPyBentleyGeom.DPoint2d) -> None
        
        3. __init__(self: MSPyBentleyGeom.ValidatedDPoint2d, value: MSPyBentleyGeom.DPoint2d, isValid: bool) -> None
        """
        ...
    
class ValidatedDPoint3d:
    """
    None
    """

    def IsValid(*args, **kwargs):
        """
        Overloaded function.
        
        1. IsValid(self: MSPyBentleyGeom.ValidatedDPoint3d) -> bool
        
        2. IsValid(self: MSPyBentleyGeom.ValidatedDPoint3d, value: MSPyBentleyGeom.DPoint3d) -> bool
        """
        ...
    
    def SetIsValid(self: MSPyBentleyGeom.ValidatedDPoint3d, value: bool) -> None:
        ...
    
    def Value(self: MSPyBentleyGeom.ValidatedDPoint3d) -> MSPyBentleyGeom.DPoint3d:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ValidatedDPoint3d) -> None
        
        2. __init__(self: MSPyBentleyGeom.ValidatedDPoint3d, value: MSPyBentleyGeom.DPoint3d) -> None
        
        3. __init__(self: MSPyBentleyGeom.ValidatedDPoint3d, value: MSPyBentleyGeom.DPoint3d, isValid: bool) -> None
        """
        ...
    
class ValidatedDPoint4d:
    """
    None
    """

    def IsValid(*args, **kwargs):
        """
        Overloaded function.
        
        1. IsValid(self: MSPyBentleyGeom.ValidatedDPoint4d) -> bool
        
        2. IsValid(self: MSPyBentleyGeom.ValidatedDPoint4d, value: MSPyBentleyGeom.DPoint4d) -> bool
        """
        ...
    
    def SetIsValid(self: MSPyBentleyGeom.ValidatedDPoint4d, value: bool) -> None:
        ...
    
    def Value(self: MSPyBentleyGeom.ValidatedDPoint4d) -> MSPyBentleyGeom.DPoint4d:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ValidatedDPoint4d) -> None
        
        2. __init__(self: MSPyBentleyGeom.ValidatedDPoint4d, value: MSPyBentleyGeom.DPoint4d) -> None
        
        3. __init__(self: MSPyBentleyGeom.ValidatedDPoint4d, value: MSPyBentleyGeom.DPoint4d, isValid: bool) -> None
        """
        ...
    
class ValidatedDRange3d:
    """
    None
    """

    def IsValid(*args, **kwargs):
        """
        Overloaded function.
        
        1. IsValid(self: MSPyBentleyGeom.ValidatedDRange3d) -> bool
        
        2. IsValid(self: MSPyBentleyGeom.ValidatedDRange3d, value: MSPyBentleyGeom.DRange3d) -> bool
        """
        ...
    
    def SetIsValid(self: MSPyBentleyGeom.ValidatedDRange3d, value: bool) -> None:
        ...
    
    def Value(self: MSPyBentleyGeom.ValidatedDRange3d) -> MSPyBentleyGeom.DRange3d:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ValidatedDRange3d) -> None
        
        2. __init__(self: MSPyBentleyGeom.ValidatedDRange3d, value: MSPyBentleyGeom.DRange3d) -> None
        
        3. __init__(self: MSPyBentleyGeom.ValidatedDRange3d, value: MSPyBentleyGeom.DRange3d, isValid: bool) -> None
        """
        ...
    
class ValidatedDRay3d:
    """
    None
    """

    def IsValid(*args, **kwargs):
        """
        Overloaded function.
        
        1. IsValid(self: MSPyBentleyGeom.ValidatedDRay3d) -> bool
        
        2. IsValid(self: MSPyBentleyGeom.ValidatedDRay3d, value: MSPyBentleyGeom.DRay3d) -> bool
        """
        ...
    
    def SetIsValid(self: MSPyBentleyGeom.ValidatedDRay3d, value: bool) -> None:
        ...
    
    def Value(self: MSPyBentleyGeom.ValidatedDRay3d) -> MSPyBentleyGeom.DRay3d:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ValidatedDRay3d) -> None
        
        2. __init__(self: MSPyBentleyGeom.ValidatedDRay3d, value: MSPyBentleyGeom.DRay3d) -> None
        
        3. __init__(self: MSPyBentleyGeom.ValidatedDRay3d, value: MSPyBentleyGeom.DRay3d, isValid: bool) -> None
        """
        ...
    
class ValidatedDSegment3d:
    """
    None
    """

    def IsValid(*args, **kwargs):
        """
        Overloaded function.
        
        1. IsValid(self: MSPyBentleyGeom.ValidatedDSegment3d) -> bool
        
        2. IsValid(self: MSPyBentleyGeom.ValidatedDSegment3d, value: MSPyBentleyGeom.DSegment3d) -> bool
        """
        ...
    
    def SetIsValid(self: MSPyBentleyGeom.ValidatedDSegment3d, value: bool) -> None:
        ...
    
    def Value(self: MSPyBentleyGeom.ValidatedDSegment3d) -> MSPyBentleyGeom.DSegment3d:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ValidatedDSegment3d) -> None
        
        2. __init__(self: MSPyBentleyGeom.ValidatedDSegment3d, value: MSPyBentleyGeom.DSegment3d) -> None
        
        3. __init__(self: MSPyBentleyGeom.ValidatedDSegment3d, value: MSPyBentleyGeom.DSegment3d, isValid: bool) -> None
        """
        ...
    
class ValidatedDVec2d:
    """
    None
    """

    def IsValid(*args, **kwargs):
        """
        Overloaded function.
        
        1. IsValid(self: MSPyBentleyGeom.ValidatedDVec2d) -> bool
        
        2. IsValid(self: MSPyBentleyGeom.ValidatedDVec2d, value: MSPyBentleyGeom.DVec2d) -> bool
        """
        ...
    
    def SetIsValid(self: MSPyBentleyGeom.ValidatedDVec2d, value: bool) -> None:
        ...
    
    def Value(self: MSPyBentleyGeom.ValidatedDVec2d) -> MSPyBentleyGeom.DVec2d:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ValidatedDVec2d) -> None
        
        2. __init__(self: MSPyBentleyGeom.ValidatedDVec2d, value: MSPyBentleyGeom.DVec2d) -> None
        
        3. __init__(self: MSPyBentleyGeom.ValidatedDVec2d, value: MSPyBentleyGeom.DVec2d, isValid: bool) -> None
        """
        ...
    
class ValidatedDVec3d:
    """
    None
    """

    def IsValid(*args, **kwargs):
        """
        Overloaded function.
        
        1. IsValid(self: MSPyBentleyGeom.ValidatedDVec3d) -> bool
        
        2. IsValid(self: MSPyBentleyGeom.ValidatedDVec3d, value: MSPyBentleyGeom.DVec3d) -> bool
        """
        ...
    
    def SetIsValid(self: MSPyBentleyGeom.ValidatedDVec3d, value: bool) -> None:
        ...
    
    def Value(self: MSPyBentleyGeom.ValidatedDVec3d) -> MSPyBentleyGeom.DVec3d:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ValidatedDVec3d) -> None
        
        2. __init__(self: MSPyBentleyGeom.ValidatedDVec3d, value: MSPyBentleyGeom.DVec3d) -> None
        
        3. __init__(self: MSPyBentleyGeom.ValidatedDVec3d, value: MSPyBentleyGeom.DVec3d, isValid: bool) -> None
        """
        ...
    
class ValidatedDouble:
    """
    None
    """

    def IsValid(*args, **kwargs):
        """
        Overloaded function.
        
        1. IsValid(self: MSPyBentleyGeom.ValidatedDouble) -> bool
        
        2. IsValid(self: MSPyBentleyGeom.ValidatedDouble, value: float) -> bool
        """
        ...
    
    def SetIsValid(self: MSPyBentleyGeom.ValidatedDouble, value: bool) -> None:
        ...
    
    def Value(self: MSPyBentleyGeom.ValidatedDouble) -> float:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ValidatedDouble) -> None
        
        2. __init__(self: MSPyBentleyGeom.ValidatedDouble, value: float) -> None
        
        3. __init__(self: MSPyBentleyGeom.ValidatedDouble, value: float, isValid: bool) -> None
        """
        ...
    
class ValidatedLocalRange:
    """
    None
    """

    def IsValid(*args, **kwargs):
        """
        Overloaded function.
        
        1. IsValid(self: MSPyBentleyGeom.ValidatedLocalRange) -> bool
        
        2. IsValid(self: MSPyBentleyGeom.ValidatedLocalRange, value: MSPyBentleyGeom.LocalRange) -> bool
        """
        ...
    
    def SetIsValid(self: MSPyBentleyGeom.ValidatedLocalRange, value: bool) -> None:
        ...
    
    def Value(self: MSPyBentleyGeom.ValidatedLocalRange) -> MSPyBentleyGeom.LocalRange:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ValidatedLocalRange) -> None
        
        2. __init__(self: MSPyBentleyGeom.ValidatedLocalRange, value: MSPyBentleyGeom.LocalRange) -> None
        
        3. __init__(self: MSPyBentleyGeom.ValidatedLocalRange, value: MSPyBentleyGeom.LocalRange, isValid: bool) -> None
        """
        ...
    
class ValidatedRotMatrix:
    """
    None
    """

    def IsValid(*args, **kwargs):
        """
        Overloaded function.
        
        1. IsValid(self: MSPyBentleyGeom.ValidatedRotMatrix) -> bool
        
        2. IsValid(self: MSPyBentleyGeom.ValidatedRotMatrix, value: MSPyBentleyGeom.RotMatrix) -> bool
        """
        ...
    
    def SetIsValid(self: MSPyBentleyGeom.ValidatedRotMatrix, value: bool) -> None:
        ...
    
    def Value(self: MSPyBentleyGeom.ValidatedRotMatrix) -> MSPyBentleyGeom.RotMatrix:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ValidatedRotMatrix) -> None
        
        2. __init__(self: MSPyBentleyGeom.ValidatedRotMatrix, value: MSPyBentleyGeom.RotMatrix) -> None
        
        3. __init__(self: MSPyBentleyGeom.ValidatedRotMatrix, value: MSPyBentleyGeom.RotMatrix, isValid: bool) -> None
        """
        ...
    
class ValidatedSize:
    """
    None
    """

    def IsValid(*args, **kwargs):
        """
        Overloaded function.
        
        1. IsValid(self: MSPyBentleyGeom.ValidatedSize) -> bool
        
        2. IsValid(self: MSPyBentleyGeom.ValidatedSize, value: int) -> bool
        """
        ...
    
    def SetIsValid(self: MSPyBentleyGeom.ValidatedSize, value: bool) -> None:
        ...
    
    def Value(self: MSPyBentleyGeom.ValidatedSize) -> int:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ValidatedSize) -> None
        
        2. __init__(self: MSPyBentleyGeom.ValidatedSize, value: int) -> None
        
        3. __init__(self: MSPyBentleyGeom.ValidatedSize, value: int, isValid: bool) -> None
        """
        ...
    
class ValidatedTransform:
    """
    None
    """

    def IsValid(*args, **kwargs):
        """
        Overloaded function.
        
        1. IsValid(self: MSPyBentleyGeom.ValidatedTransform) -> bool
        
        2. IsValid(self: MSPyBentleyGeom.ValidatedTransform, value: MSPyBentleyGeom.Transform) -> bool
        """
        ...
    
    def SetIsValid(self: MSPyBentleyGeom.ValidatedTransform, value: bool) -> None:
        ...
    
    def Value(self: MSPyBentleyGeom.ValidatedTransform) -> MSPyBentleyGeom.Transform:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.ValidatedTransform) -> None
        
        2. __init__(self: MSPyBentleyGeom.ValidatedTransform, value: MSPyBentleyGeom.Transform) -> None
        
        3. __init__(self: MSPyBentleyGeom.ValidatedTransform, value: MSPyBentleyGeom.Transform, isValid: bool) -> None
        """
        ...
    
class ValuesView[BeExtendedDataGeometryMap]:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    
class VertexId:
    """
    None
    """

    def GetFaces(self: MSPyBentleyGeom.VertexId) -> tuple:
        ...
    
    def SetFaces(self: MSPyBentleyGeom.VertexId, f1: MSPyBentleyGeom.FaceId, f2: MSPyBentleyGeom.FaceId, f3: MSPyBentleyGeom.FaceId) -> None:
        ...
    
    def __init__(self: MSPyBentleyGeom.VertexId) -> None:
        ...
    
class VertexIdArray:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.VertexIdArray) -> None
        
        2. __init__(self: MSPyBentleyGeom.VertexIdArray, arg0: MSPyBentleyGeom.VertexIdArray) -> None
        
        Copy constructor
        
        3. __init__(self: MSPyBentleyGeom.VertexIdArray, arg0: Iterable) -> None
        """
        ...
    
    def append(self: MSPyBentleyGeom.VertexIdArray, x: MSPyBentleyGeom.VertexId) -> None:
        """
        Add an item to the end of the list
        """
        ...
    
    def clear(self: MSPyBentleyGeom.VertexIdArray) -> None:
        """
        Clear the contents
        """
        ...
    
    def extend(*args, **kwargs):
        """
        Overloaded function.
        
        1. extend(self: MSPyBentleyGeom.VertexIdArray, L: MSPyBentleyGeom.VertexIdArray) -> None
        
        Extend the list by appending all the items in the given list
        
        2. extend(self: MSPyBentleyGeom.VertexIdArray, L: Iterable) -> None
        
        Extend the list by appending all the items in the given list
        """
        ...
    
    def insert(self: MSPyBentleyGeom.VertexIdArray, i: int, x: MSPyBentleyGeom.VertexId) -> None:
        """
        Insert an item at a given position.
        """
        ...
    
    def pop(*args, **kwargs):
        """
        Overloaded function.
        
        1. pop(self: MSPyBentleyGeom.VertexIdArray) -> MSPyBentleyGeom.VertexId
        
        Remove and return the last item
        
        2. pop(self: MSPyBentleyGeom.VertexIdArray, i: int) -> MSPyBentleyGeom.VertexId
        
        Remove and return the item at index ``i``
        """
        ...
    
class YawPitchRollAngles:
    """
    None
    """

    @staticmethod
    def FromDegrees(yawDegrees: float, pitchDegrees: float, rollDegrees: float) -> MSPyBentleyGeom.YawPitchRollAngles:
        """
        constructor from all angles in degrees
        """
        ...
    
    @staticmethod
    def FromRadians(yawRadians: float, pitchRadians: float, rollRadians: float) -> MSPyBentleyGeom.YawPitchRollAngles:
        """
        constructor from all angles in radians
        """
        ...
    
    def GetPitch(self: MSPyBentleyGeom.YawPitchRollAngles) -> MSPyBentleyGeom.AngleInDegrees:
        ...
    
    def GetRoll(self: MSPyBentleyGeom.YawPitchRollAngles) -> MSPyBentleyGeom.AngleInDegrees:
        ...
    
    def GetYaw(self: MSPyBentleyGeom.YawPitchRollAngles) -> MSPyBentleyGeom.AngleInDegrees:
        ...
    
    def IsIdentity(self: MSPyBentleyGeom.YawPitchRollAngles) -> bool:
        """
        test for near-zero angles.
        """
        ...
    
    def MaxAbsDegrees(self: MSPyBentleyGeom.YawPitchRollAngles) -> float:
        """
        return the maximum absolute radians among the angles.
        """
        ...
    
    def MaxAbsRadians(self: MSPyBentleyGeom.YawPitchRollAngles) -> float:
        """
        return the maximum absolute radians among the angles.
        """
        ...
    
    def MaxDiffDegrees(self: MSPyBentleyGeom.YawPitchRollAngles, other: MSPyBentleyGeom.YawPitchRollAngles) -> float:
        """
        return the maximum absolute difference among radians among the angles.
        """
        ...
    
    def MaxDiffRadians(self: MSPyBentleyGeom.YawPitchRollAngles, other: MSPyBentleyGeom.YawPitchRollAngles) -> float:
        """
        return the maximum absolute difference among radians among the angles.
        """
        ...
    
    @property
    def Pitch(arg0: MSPyBentleyGeom.YawPitchRollAngles) -> MSPyBentleyGeom.AngleInDegrees:
        ...
    
    @property
    def Roll(arg0: MSPyBentleyGeom.YawPitchRollAngles) -> MSPyBentleyGeom.AngleInDegrees:
        ...
    
    def ToRotMatrix(self: MSPyBentleyGeom.YawPitchRollAngles) -> RotMatrix:
        """
        Convert the angles to a RotMatrix
        """
        ...
    
    def ToTransform(self: MSPyBentleyGeom.YawPitchRollAngles, origin: DPoint3d) -> Transform:
        """
        Convert the angles and an origin to a Transform.
        """
        ...
    
    @staticmethod
    def TryFromRotMatrix(angles: MSPyBentleyGeom.YawPitchRollAngles, matrix: RotMatrix) -> bool:
        """
        Try to extract angles from a RotMatrix
        """
        ...
    
    @property
    def Yaw(arg0: MSPyBentleyGeom.YawPitchRollAngles) -> MSPyBentleyGeom.AngleInDegrees:
        ...
    
    def __init__(*args, **kwargs):
        """
        Overloaded function.
        
        1. __init__(self: MSPyBentleyGeom.YawPitchRollAngles) -> None
        
        2. __init__(self: MSPyBentleyGeom.YawPitchRollAngles, yaw: MSPyBentleyGeom.AngleInDegrees, pitch: MSPyBentleyGeom.AngleInDegrees, roll: MSPyBentleyGeom.AngleInDegrees) -> None
        
        3. __init__(self: MSPyBentleyGeom.YawPitchRollAngles, yaw: MSPyBentleyGeom.Angle, pitch: MSPyBentleyGeom.Angle, roll: MSPyBentleyGeom.Angle) -> None
        """
        ...
    
eAreaSelect_CCWNegativeWindingNumber: AreaSelect

eAreaSelect_CCWNonzeroWindingNumber: AreaSelect

eAreaSelect_CCWPositiveWindingNumber: AreaSelect

eAreaSelect_Parity: AreaSelect

eBoolSelect_FromStructure: BoolSelect

eBoolSelect_Parity: BoolSelect

eBoolSelect_Summed_Negative: BoolSelect

eBoolSelect_Summed_NonZero: BoolSelect

eBoolSelect_Summed_Parity: BoolSelect

eBoolSelect_Summed_Positive: BoolSelect

eBoolSelect_Union: BoolSelect

eCURVE_CURVE_BLEND_BisectorParabola: BlendType

eCURVE_CURVE_BLEND_VerticalAxisParabola: BlendType

eCURVE_PARAMETER_MAPPING_BezierFraction: CurveParameterMapping

eCURVE_PARAMETER_MAPPING_CurveFraction: CurveParameterMapping

eCURVE_PARAMETER_MAPPING_CurveKnot: CurveParameterMapping

eClipPlaneContainment_Ambiguous: ClipPlaneContainment

eClipPlaneContainment_StronglyInside: ClipPlaneContainment

eClipPlaneContainment_StronglyOutside: ClipPlaneContainment

eCoincident: PlanePolygonSSICode

eFACET_PARAM_01BothAxes: FacetParamMode

eFACET_PARAM_01LargerAxis: FacetParamMode

eFACET_PARAM_Distance: FacetParamMode

eLOCAL_COORDINATE_SCALE_01RangeBothAxes: LocalCoordinateSelect

eLOCAL_COORDINATE_SCALE_01RangeLargerAxis: LocalCoordinateSelect

eLOCAL_COORDINATE_SCALE_UnitAxesAtLowerLeft: LocalCoordinateSelect

eLOCAL_COORDINATE_SCALE_UnitAxesAtStart: LocalCoordinateSelect

eREPROJECT_BadArgument: ReprojectStatus

eREPROJECT_CSMAPERR_DatumConverterNotSet: ReprojectStatus

eREPROJECT_CSMAPERR_Error: ReprojectStatus

eREPROJECT_CSMAPERR_OutOfMathematicalDomain: ReprojectStatus

eREPROJECT_CSMAPERR_OutOfUsefulRange: ReprojectStatus

eREPROJECT_CSMAPERR_VerticalDatumConversionError: ReprojectStatus

eREPROJECT_DataError: ReprojectStatus

eREPROJECT_DontValidateRange: ReprojectStatus

eREPROJECT_GeoCoordNotInitialized: ReprojectStatus

eREPROJECT_InvalidCoordSys: ReprojectStatus

eREPROJECT_NoChange: ReprojectStatus

eREPROJECT_StrokeError: ReprojectStatus

eREPROJECT_Success: ReprojectStatus

eSolidPrimitiveType_DgnBox: SolidPrimitiveType

eSolidPrimitiveType_DgnCone: SolidPrimitiveType

eSolidPrimitiveType_DgnExtrusion: SolidPrimitiveType

eSolidPrimitiveType_DgnRotationalSweep: SolidPrimitiveType

eSolidPrimitiveType_DgnRuledSweep: SolidPrimitiveType

eSolidPrimitiveType_DgnSphere: SolidPrimitiveType

eSolidPrimitiveType_DgnTorusPipe: SolidPrimitiveType

eSolidPrimitiveType_None: SolidPrimitiveType

eTransverse: PlanePolygonSSICode

eUnknown: PlanePolygonSSICode

class interpolationParam:
    """
    None
    """

    def __init__(*args, **kwargs):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    
    @property
    def isChordLenKnots(self: MSPyBentleyGeom.interpolationParam) -> int:
        ...
    @isChordLenKnots.setter
    def isChordLenKnots(self: MSPyBentleyGeom.interpolationParam, arg0: int) -> None:
        ...
    
    @property
    def isChordLenTangents(self: MSPyBentleyGeom.interpolationParam) -> int:
        ...
    @isChordLenTangents.setter
    def isChordLenTangents(self: MSPyBentleyGeom.interpolationParam, arg0: int) -> None:
        ...
    
    @property
    def isColinearTangents(self: MSPyBentleyGeom.interpolationParam) -> int:
        ...
    @isColinearTangents.setter
    def isColinearTangents(self: MSPyBentleyGeom.interpolationParam, arg0: int) -> None:
        ...
    
    @property
    def isNaturalTangents(self: MSPyBentleyGeom.interpolationParam) -> int:
        ...
    @isNaturalTangents.setter
    def isNaturalTangents(self: MSPyBentleyGeom.interpolationParam, arg0: int) -> None:
        ...
    
    @property
    def isPeriodic(self: MSPyBentleyGeom.interpolationParam) -> int:
        ...
    @isPeriodic.setter
    def isPeriodic(self: MSPyBentleyGeom.interpolationParam, arg0: int) -> None:
        ...
    
    @property
    def numKnots(self: MSPyBentleyGeom.interpolationParam) -> int:
        ...
    @numKnots.setter
    def numKnots(self: MSPyBentleyGeom.interpolationParam, arg0: int) -> None:
        ...
    
    @property
    def numPoints(self: MSPyBentleyGeom.interpolationParam) -> int:
        ...
    @numPoints.setter
    def numPoints(self: MSPyBentleyGeom.interpolationParam, arg0: int) -> None:
        ...
    
    @property
    def order(self: MSPyBentleyGeom.interpolationParam) -> int:
        ...
    @order.setter
    def order(self: MSPyBentleyGeom.interpolationParam, arg0: int) -> None:
        ...
    
mgds_fc_condition: float

mgds_fc_epsilon: float

mgds_fc_iang_to_rad: float

mgds_fc_miang_to_rad: float

mgds_fc_nearZero: float

mgds_fc_rad_to_iang: float

msGeomConst_2pi: float

msGeomConst_degreesPerRadian: float

msGeomConst_pi: float

msGeomConst_piOver12: float

msGeomConst_piOver2: float

msGeomConst_piOver4: float

msGeomConst_radiansPerDegree: float

